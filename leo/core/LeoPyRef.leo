<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20090620052003.8505"><vh>@@button add-test</vh></v>
<v t="ekr.20100210214809.5767"><vh>@@button compare old/new</vh></v>
<v t="ekr.20090514093345.6054"><vh>Disabled buttons</vh>
<v t="ekr.20100205152016.14055"><vh>@@button find-node-by-gnx</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20100205162207.5844"><vh>@@button print gnx</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
</v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20100223133351.5996"><vh>@@button clean all blank lines</vh></v>
<v t="ekr.20100223133351.5999"><vh>@@button find long line</vh></v>
<v t="ekr.20100225053729.5761"><vh>@@button strip diff</vh></v>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20100407063358.5748"><vh>inspect modules</vh></v>
<v t="ekr.20100515063611.5801"><vh>max N</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20100902154544.5872"><vh>@bool enable-abbreviations = True</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20090105132011.6"><vh>Regex notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
</v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh>
<v t="ekr.20090202064534.4"><vh> Your mission, should you choose to accept it</vh>
<v t="ekr.20100223100750.5843"><vh>Original post by Robin Dunn</vh></v>
<v t="ekr.20100223100750.5842"><vh>Post to pyxides, 2010/02/23</vh></v>
</v>
<v t="ekr.20061116060847"><vh>@url http://www.jhorman.org/wikidPad/</vh></v>
<v t="ekr.20091218120633.6299"><vh>Bzr</vh>
<v t="ekr.20080917153158.10"><vh>Bzr notes</vh></v>
<v t="ekr.20090713080429.6042"><vh>Bzr workflow notes</vh></v>
<v t="ekr.20081113095540.1"><vh>Bzr/ubuntu notes</vh></v>
</v>
<v t="ekr.20090502071837.103"><vh>Cool projects</vh></v>
<v t="ekr.20101024062147.6004"><vh>Documentation notes</vh>
<v t="ekr.20060306194040"><vh>The curse of knowledge</vh></v>
<v t="ekr.20100828074347.5828"><vh>Slide show resources</vh></v>
<v t="ekr.20100904134301.8336"><vh>Generate pdf on Linux</vh></v>
</v>
<v t="ekr.20091218120633.6300"><vh>Other notes</vh>
<v t="ekr.20090601083544.6066"><vh>Cool plugins &amp; Leo code</vh>
<v t="ekr.20090601083544.6068"><vh>@g.command decorator</vh></v>
</v>
<v t="ekr.20070614094933"><vh>EasyInstall installation notes--XP</vh></v>
<v t="ekr.20071104222805"><vh>Emacs/Pymacs notes</vh>
<v t="ekr.20071102191642.1"><vh>xemacs/pymacs install notes</vh></v>
<v t="ekr.20071103090504"><vh>Pymacs docs</vh>
<v t="ekr.20071103090504.1"><vh>Emacs Lisp structures and Python objects</vh>
<v t="ekr.20071103090504.2"><vh>Emacs lisp structures and Python</vh></v>
<v t="ekr.20071103090504.3"><vh>Simple objects</vh></v>
<v t="ekr.20071103090504.4"><vh>Sequences</vh></v>
</v>
<v t="ekr.20071103090504.5"><vh>Opaque objects</vh>
<v t="ekr.20071103090504.6"><vh>Emacs lisp handles</vh></v>
<v t="ekr.20071103090504.7"><vh>Python handles</vh></v>
</v>
<v t="ekr.20071103090504.8"><vh>Usages on the Emacs lisp side</vh>
<v t="ekr.20071103090504.9"><vh>pymacs-eval/apply</vh></v>
<v t="ekr.20071103090504.10"><vh>pymacs-load</vh></v>
</v>
<v t="ekr.20071103091052"><vh>Usage on the Python side</vh>
<v t="ekr.20071103091052.1"><vh>Python setup</vh></v>
<v t="ekr.20071103091052.2"><vh>Response mode</vh></v>
<v t="ekr.20071103091052.3"><vh>Emacs lisp symbols</vh></v>
<v t="ekr.20071103091052.4"><vh>Dynamic bindings (The let class)</vh></v>
<v t="ekr.20071103091052.5"><vh>Raw Emacs lisp expression</vh></v>
<v t="ekr.20071103091052.6"><vh>User interaction</vh></v>
<v t="ekr.20071103091052.7"><vh>Key bindings</vh></v>
</v>
<v t="ekr.20071103092153"><vh>Debugging</vh>
<v t="ekr.20071103092153.1"><vh>The *pymacs* buffer</vh></v>
<v t="ekr.20071103092153.2"><vh>Usual Emacs debugging</vh></v>
<v t="ekr.20071103092153.3"><vh>Auto-reloading on save</vh></v>
</v>
<v t="ekr.20071103092153.4"><vh>Example 1: defining an Emacs command in Python</vh></v>
<v t="ekr.20071103093725"><vh>Example 3: defining a rebox tool</vh>
<v t="ekr.20071103094355"><vh>The python side</vh></v>
<v t="ekr.20071103094355.1"><vh>The emacs side</vh></v>
<v t="ekr.20071103093725.1"><vh>rebox.py</vh>
<v t="ekr.20071103093725.2"><vh>rebox declarations</vh></v>
<v t="ekr.20071103093725.3"><vh>main</vh></v>
<v t="ekr.20071103093725.4"><vh>pymacs_load_hook</vh></v>
<v t="ekr.20071103093725.5"><vh>class Emacs_Rebox</vh>
<v t="ekr.20071103093725.6"><vh>__init__</vh></v>
<v t="ekr.20071103093725.7"><vh>set_default_style</vh></v>
<v t="ekr.20071103093725.8"><vh>region</vh></v>
<v t="ekr.20071103093725.9"><vh>comment</vh></v>
<v t="ekr.20071103093725.10"><vh>emacs_engine</vh></v>
<v t="ekr.20071103093725.11"><vh>ask_for_style</vh></v>
<v t="ekr.20071103093725.12"><vh>find_region</vh></v>
<v t="ekr.20071103093725.13"><vh>find_comment</vh></v>
<v t="ekr.20071103093725.14"><vh>remainder_of_line</vh></v>
<v t="ekr.20071103093725.15"><vh>clean_undo_after_old</vh></v>
<v t="ekr.20071103093725.16"><vh>clean_undo_after</vh></v>
</v>
<v t="ekr.20071103093725.17"><vh>engine</vh></v>
<v t="ekr.20071103093725.18"><vh>guess_language</vh></v>
<v t="ekr.20071103093725.19"><vh>guess_template</vh></v>
<v t="ekr.20071103093725.20"><vh>left_margin_size</vh></v>
<v t="ekr.20071103093725.21"><vh>merge_styles</vh></v>
<v t="ekr.20071103093725.22"><vh>refill_lines</vh></v>
<v t="ekr.20071103093725.23"><vh>class Marker</vh>
<v t="ekr.20071103093725.24"><vh>save_position</vh></v>
<v t="ekr.20071103093725.25"><vh>get_position</vh></v>
</v>
<v t="ekr.20071103093725.26"><vh>class Template</vh>
<v t="ekr.20071103093725.27"><vh>__init__</vh></v>
<v t="ekr.20071103093725.28"><vh>__cmp__</vh></v>
<v t="ekr.20071103093725.29"><vh>characters</vh></v>
<v t="ekr.20071103093725.30"><vh>match</vh></v>
<v t="ekr.20071103093725.31"><vh>unbuild</vh></v>
<v t="ekr.20071103093725.32"><vh>build</vh></v>
</v>
<v t="ekr.20071103093725.33"><vh>regexp_quote</vh></v>
<v t="ekr.20071103093725.34"><vh>regexp_ruler</vh></v>
<v t="ekr.20071103093725.35"><vh>unbuild_clean</vh></v>
<v t="ekr.20071103093725.36"><vh>make_generic</vh></v>
<v t="ekr.20071103093725.37"><vh>&lt;&lt; templates &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050123161408"><vh>ExamDiff files &amp; scripts</vh>
<v t="ekr.20050123160215.1"><vh>Put all files in alpha order in ExamDiff</vh></v>
</v>
<v t="ekr.20031218072017.365"><vh>How to...</vh>
<v t="ekr.20060208112908"><vh>BZR stuff...</vh>
<v t="ekr.20060331094112"><vh>How to generate keys using putty</vh></v>
<v t="ekr.20060208112908.1"><vh>How to check out leo from SourceForge</vh></v>
<v t="ekr.20031218072017.366"><vh>How to add and remove files from CVS repository</vh></v>
<v t="ekr.20031218072017.391"><vh>How to use CVS branches</vh></v>
</v>
<v t="ekr.20031218072017.367"><vh>How to add support for a new language</vh></v>
<v t="ekr.20080814134319.1"><vh>How to create and push to a private bzr branch</vh></v>
<v t="ekr.20051203084725"><vh>How to expand java .jar files</vh></v>
<v t="ekr.20031218072017.384"><vh>How to export syntax colored code preserving colors</vh></v>
<v t="ekr.20031218072017.385"><vh>How to Increase environment space</vh></v>
<v t="ekr.20051203084725.1"><vh>How to install and run jythonShell</vh></v>
<v t="ekr.20050316092232"><vh>How to install jyLeo</vh>
<v t="ekr.20050716104357"><vh>Old instructions</vh></v>
<v t="ekr.20050317153447"><vh>jy-Leo install instructions by Paul Paterson</vh></v>
</v>
<v t="ekr.20051129084430"><vh>How to install jython</vh>
<v t="ekr.20051129084430.1"><vh>@url http://www.jython.org/install.html</vh></v>
</v>
<v t="ekr.20070623150151"><vh>How to make Leo commands undoable</vh></v>
<v t="ekr.20091217112515.6070"><vh>How to make the codewise completer work</vh>
<v t="ekr.20091217112515.6069"><vh>Others posts</vh></v>
<v t="ekr.20091217112515.6071"><vh>plugin docs</vh></v>
</v>
<v t="ekr.20031218072017.386"><vh>How to remove cursed newlines: use binary mode</vh>
<v t="ekr.20031218072017.387"><vh>The solution</vh></v>
<v t="ekr.20031218072017.388"><vh>cursed newline answer</vh></v>
<v t="ekr.20031218072017.389"><vh>cursed newline answer 2</vh></v>
</v>
<v t="ekr.20061023153133"><vh>How to run patch</vh></v>
<v t="ekr.20050510071834"><vh>How to use a temp file with pdb</vh></v>
<v t="ekr.20041214135556"><vh>How to use Tile</vh></v>
</v>
<v t="ekr.20070215183046"><vh>IronPython notes</vh></v>
<v t="ekr.20080114142724"><vh>leoGtkNotes</vh>
<v t="ekr.20080112175736"><vh> gtk: to do</vh></v>
<v t="ekr.20080113061130"><vh> gtk: what I did</vh></v>
</v>
<v t="ekr.20050214055018"><vh>Mac Notes</vh>
<v t="ekr.20050221054932"><vh>How to make monolithic Leo app on MacOS X</vh></v>
<v t="ekr.20050214055018.4"><vh>@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)</vh></v>
<v t="ekr.20050214055018.5"><vh>@url http://www.wordtech-software.com/leo.html  (Mac Bundle)</vh></v>
<v t="ekr.20050513164506"><vh>Problems with run script command on Mac x11</vh></v>
<v t="ekr.20040104162835.8"><vh>Linux/Mac notes: Dan Winkler</vh>
<v t="ekr.20040104162835.13"><vh>Fink &amp; aqua</vh></v>
<v t="ekr.20040104162835.14"><vh>Mac, Fink, etc.</vh></v>
<v t="ekr.20040104162835.15"><vh>Double clicking on Linux</vh></v>
</v>
</v>
<v t="ekr.20060111112513.1"><vh>New jyLeo notes</vh></v>
<v t="ekr.20031218072017.392"><vh>Python Notes...</vh>
<v t="ekr.20031218072017.398"><vh>How to call any Python method from the C API</vh></v>
<v t="ekr.20031218072017.399"><vh>How to run Python programs easily on NT,2K,XP</vh>
<v t="ekr.20031218072017.400"><vh>setting the PATHEXT env var</vh></v>
<v t="ekr.20031218072017.401"><vh>Yet another Python .bat wrapper</vh></v>
</v>
</v>
<v t="ekr.20070308062440"><vh>Thread notes</vh>
<v t="ekr.20070308062440.1"><vh>Posting 2</vh></v>
</v>
<v t="ekr.20050306070535"><vh>Tk Notes</vh>
<v t="ekr.20050306070535.3"><vh>How to detect changes in text</vh></v>
</v>
</v>
<v t="ekr.20031218072017.434"><vh>Unused code</vh>
<v t="ekr.20050920084036.207"><vh>queryReplaceCommandsClass (limited to single node)</vh>
<v t="ekr.20050920084036.208"><vh> ctor &amp; init</vh></v>
<v t="ekr.20050920084036.209"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.210"><vh>Entry points</vh></v>
<v t="ekr.20051005151838"><vh>Helpers</vh>
<v t="ekr.20050920084036.212"><vh>doOneReplace</vh></v>
<v t="ekr.20050920084036.219"><vh>findNextMatch (query-replace)</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt; (tag_add &amp; tag_config) LATER</vh></v>
</v>
<v t="ekr.20050920084036.211"><vh>getUserResponse</vh></v>
<v t="ekr.20050920084036.220"><vh>quitSearch</vh></v>
<v t="ekr.20050920084036.215"><vh>stateHandler</vh></v>
</v>
</v>
<v t="ekr.20071117060958"><vh>getFileName (no longer used)</vh></v>
<v t="ekr.20101021041958.6005"><vh>From readSettingsFile</vh>
<v t="ekr.20061028082834"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
</v>
<v t="ekr.20101022124309.6127"><vh>OLDg.setDefaultDirectory &amp; helpers</vh>
<v t="ekr.20081001062423.10"><vh>g.getAbsPathFromNode (strict helper)</vh></v>
<v t="ekr.20081001062423.11"><vh>g.getPathFromDirectives (strict helper)</vh></v>
<v t="ekr.20081001062423.12"><vh>g.findDefaultDirectory (strict helper)</vh></v>
</v>
<v t="ekr.20101023095329.6115"><vh>from at.initCommonIvars</vh>
<v t="ekr.20041005105605.11"><vh>&lt;&lt; set defaults for arguments and options &gt;&gt;</vh></v>
<v t="ekr.20041005105605.12"><vh>&lt;&lt; init common ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20101023095329.6116"><vh>from at.initReadIvars</vh>
<v t="ekr.20041005105605.14"><vh>&lt;&lt; init ivars for reading &gt;&gt;</vh></v>
</v>
<v t="ekr.20101023095329.6118"><vh>from at.initWriteIvars</vh>
<v t="ekr.20041005105605.16"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
<v t="ekr.20080211085914"><vh>ic.scanDefaultDirectory</vh></v>
<v t="ekr.20041005105605.236"><vh>at.scanDefaultDirectory</vh></v>
</v>
</v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file leoProjects.txt</vh>
<v t="ekr.20100709113505.6291"><vh>Leo 4.8 a1</vh>
<v t="ekr.20101024235225.5864"><vh>Code notes</vh>
<v t="ekr.20101024235225.5863"><vh>Can we put up the LeoID dialog later?</vh></v>
<v t="ekr.20101024235225.5866"><vh>Be more clever in putting up the Leo id dialog</vh></v>
<v t="ekr.20101024235225.5894"><vh>Simplified leoPlugins code</vh></v>
<v t="ekr.20101024235225.5925"><vh>Added support for slideshow plugin</vh></v>
<v t="ekr.20101024235225.5957"><vh>Fixed @test logic</vh>
<v t="ekr.20101024235225.5956"><vh>patch</vh></v>
</v>
<v t="ekr.20101024235225.5959"><vh>Investigated at-auto-rst bug</vh></v>
<v t="ekr.20101024235225.5962"><vh>Investigated bug 524890: Incomplete derived file</vh>
<v t="ekr.20101024235225.5963"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20101027055033.5968"><vh>Added support for .nsi files</vh>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; (leoApp.py)</vh></v>
<v t="ekr.20090225080846.3"><vh>at.readOneAtEditNode</vh></v>
<v t="ekr.20080811174246.1"><vh>languageForExtension</vh></v>
<v t="ekr.20031218072017.3210"><vh>createOutline (leoImport)</vh></v>
<v t="ekr.20080825131124.3"><vh>createImportDispatchDict</vh></v>
<v t="ekr.20101027055033.5967"><vh>scanNSIText</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh>
<v t="ekr.20100109214940.6225"><vh>4.8 to do</vh>
<v t="ekr.20101026125532.5968"><vh>Installation problems with Qt</vh></v>
<v t="ekr.20101024062147.6011"><vh>Before b1</vh>
<v t="ekr.20101025100847.5852"><vh>@url ready to work on codewise</vh></v>
<v t="ekr.20101024062147.6025"><vh>Somewhat hard bugs</vh>
<v t="ekr.20100804095820.5812"><vh>bug 613153: unable to describe root directory on thumb drive</vh>
<v t="ekr.20031218072017.2151"><vh>os_path_isabs</vh></v>
</v>
<v t="ekr.20100223123910.5835"><vh>bug 611413: The import logic for python code doesn't work as expected in some cases</vh></v>
<v t="ekr.20100827114047.5892"><vh>bug 581031: Fix toggle-split-direction</vh></v>
<v t="ekr.20101024062147.5991"><vh>bug 583955: Key bindings in Find Panel need some love</vh></v>
<v t="ekr.20101024062147.6024"><vh>bug 622819: Ctrl-Shift movement is incorrect</vh></v>
</v>
</v>
<v t="ekr.20101024062147.6012"><vh>Before rc1</vh></v>
<v t="ekr.20101024062147.6014"><vh>For 4.8.1</vh>
<v t="ekr.20100206074650.5843"><vh>Autocompletion</vh>
<v t="ekr.20090131200406.14"><vh>Notes</vh>
<v t="ekr.20080113165010"><vh>About auto completion</vh></v>
<v t="ekr.20101004092958.6008"><vh>codewise stuff</vh>
<v t="ekr.20101004092958.5964"><vh>codewise crash</vh></v>
<v t="ekr.20101004092958.6009"><vh>codewise.py</vh>
<v t="ekr.20101004092958.6010"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20101004092958.6011"><vh>&lt;&lt; usage &gt;&gt;</vh></v>
<v t="ekr.20101004092958.6012"><vh>&lt;&lt; decls &gt;&gt;</vh></v>
<v t="ekr.20101004092958.6013"><vh>Top level</vh>
<v t="ekr.20101004092958.6014"><vh>Commands</vh>
<v t="ekr.20101004092958.6015"><vh>cmd_functions</vh></v>
<v t="ekr.20101004092958.6016"><vh>cmd_init</vh></v>
<v t="ekr.20101004092958.6017"><vh>cmd_members</vh></v>
<v t="ekr.20101004092958.6018"><vh>cmd_parse</vh></v>
<v t="ekr.20101004092958.6019"><vh>cmd_parseall</vh></v>
<v t="ekr.20101004092958.6020"><vh>cmd_scintilla</vh></v>
<v t="ekr.20101004092958.6021"><vh>cmd_setup</vh></v>
<v t="ekr.20101004092958.6022"><vh>cmd_tags</vh></v>
</v>
<v t="ekr.20101004092958.6023"><vh>main</vh></v>
<v t="ekr.20101004092958.6024"><vh>printlines</vh></v>
<v t="ekr.20101004092958.6025"><vh>run_ctags</vh></v>
</v>
<v t="ekr.20101004092958.6026"><vh>class CodeWise</vh>
<v t="ekr.20101004092958.6027"><vh>__init__</vh></v>
<v t="ekr.20101004092958.6028"><vh>createdb</vh></v>
<v t="ekr.20101004092958.6029"><vh>create_caches</vh></v>
<v t="ekr.20101004092958.6030"><vh>reset_caches</vh></v>
<v t="ekr.20101004092958.6031"><vh>cursor</vh></v>
<v t="ekr.20101004092958.6032"><vh>class_id</vh></v>
<v t="ekr.20101004092958.6033"><vh>get_members</vh></v>
<v t="ekr.20101004092958.6034"><vh>get_functions</vh></v>
<v t="ekr.20101004092958.6035"><vh>file_id</vh></v>
<v t="ekr.20101004092958.6036"><vh>feed_function</vh></v>
<v t="ekr.20101004092958.6037"><vh>feed_scintilla</vh></v>
<v t="ekr.20101004092958.6038"><vh>feed_ctags</vh></v>
<v t="ekr.20101004092958.6039"><vh>add_source</vh></v>
<v t="ekr.20101004092958.6040"><vh>sources</vh></v>
<v t="ekr.20101004092958.6041"><vh>zap_symbols</vh></v>
<v t="ekr.20101004092958.6042"><vh>parseall</vh></v>
<v t="ekr.20101004092958.6043"><vh>parse</vh></v>
</v>
<v t="ekr.20101004092958.6044"><vh>class ContextSniffer</vh>
<v t="ekr.20101004092958.6045"><vh>__init__</vh></v>
<v t="ekr.20101004092958.6046"><vh>declare</vh></v>
<v t="ekr.20101004092958.6047"><vh>push_declarations</vh></v>
<v t="ekr.20101004092958.6048"><vh>set_small_context</vh></v>
</v>
</v>
<v t="ekr.20101004092958.6049"><vh>codewise experiments</vh></v>
<v t="ekr.20101004092958.6050"><vh>How to make codewise work</vh></v>
</v>
<v t="ekr.20081005065934.12"><vh>Links from Ville re Scintilla</vh></v>
<v t="ekr.20060927173836.1"><vh>Make calltips and autocompleter 'stateless'</vh></v>
<v t="ekr.20080110082845"><vh>pyxides: code completion</vh></v>
<v t="ekr.20071106083149"><vh>Recent post</vh></v>
<v t="ekr.20100506062734.5756"><vh>Ville post re autocompleter</vh></v>
</v>
<v t="ekr.20101002192824.5989"><vh>Changed</vh>
<v t="ekr.20101002192824.5916"><vh> ctor (autocompleter)</vh></v>
<v t="ekr.20101002192824.5997"><vh>calltip</vh></v>
<v t="ekr.20101002192824.5988"><vh>chain</vh></v>
<v t="ekr.20101002192824.5941"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20101002192824.5948"><vh>getLeadinWord &amp; helper</vh>
<v t="ekr.20101002192824.5945"><vh>findAnchor</vh></v>
</v>
<v t="ekr.20101002192824.5951"><vh>insertNormalChar</vh></v>
<v t="ekr.20101002192824.5953"><vh>setMembersList &amp; helpers</vh>
<v t="ekr.20101002192824.5954"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20101002192824.5956"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20101002192824.5925"><vh>showCalltips (TO DO)</vh></v>
<v t="ekr.20101002192824.5958"><vh>start</vh></v>
</v>
<v t="ekr.20101024062147.5999"><vh>Testing</vh>
<v t="ekr.20101002144536.5831"><vh>Test auto scanner</vh></v>
<v t="ekr.20101002192824.5843"><vh>test-new-ac</vh>
<v t="ekr.20101002192824.6019"><vh>class AutoCompleterScanner</vh>
<v t="ekr.20101002192824.6020"><vh> ctor &amp; helper (AutoCompleterScanner)</vh>
<v t="ekr.20101002192824.6021"><vh>definePatterns</vh></v>
</v>
<v t="ekr.20101002192824.6022"><vh>scan &amp; dumps</vh>
<v t="ekr.20101002192824.6023"><vh>dumpTips</vh></v>
<v t="ekr.20101002192824.6024"><vh>dumpWords</vh></v>
<v t="ekr.20101002192824.6025"><vh>printSummary</vh></v>
</v>
<v t="ekr.20101002192824.6026"><vh>scanForAutoCompleter &amp; helper</vh>
<v t="ekr.20101002192824.6027"><vh>makeAutocompletionList</vh></v>
</v>
<v t="ekr.20101002192824.6028"><vh>scanForCallTip &amp; helper</vh>
<v t="ekr.20101002192824.6029"><vh>cleanPythonTip</vh></v>
</v>
</v>
<v t="ekr.20101002192824.5915"><vh>class NewAutoCompleter (New)</vh>
<v t="ekr.20101002192824.5916"></v>
<v t="ekr.20101002192824.5919"><vh>Top level</vh>
<v t="ekr.20101002192824.5920"><vh>autoComplete</vh></v>
<v t="ekr.20101002192824.5921"><vh>autoCompleteForce</vh></v>
<v t="ekr.20101002192824.5922"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20101002192824.5924"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20101002192824.5925"></v>
<v t="ekr.20101002192824.5926"><vh>showCalltipsForce</vh></v>
<v t="ekr.20101002192824.5927"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20101002192824.5928"><vh>Helpers</vh>
<v t="ekr.20101002192824.5929"><vh>.abort &amp; exit (autocompleter)</vh></v>
<v t="ekr.20101002192824.5930"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20101002192824.5931"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20101002192824.5997"></v>
<v t="ekr.20101002192824.5988"></v>
<v t="ekr.20101002192824.5940"><vh>computeCompletionList</vh></v>
<v t="ekr.20101002192824.5941"></v>
<v t="ekr.20101002192824.5942"><vh>doTabCompletion (autocompleter)</vh></v>
<v t="ekr.20101002192824.5943"><vh>extendSelection</vh></v>
<v t="ekr.20101002192824.5944"><vh>findCalltipWord</vh></v>
<v t="ekr.20101002192824.5946"><vh>finish</vh></v>
<v t="ekr.20101002192824.5948"></v>
<v t="ekr.20101002192824.5949"><vh>getMembersList</vh></v>
<v t="ekr.20101002192824.6005"><vh>info (rewrite)</vh></v>
<v t="ekr.20101002192824.5951"></v>
<v t="ekr.20101002192824.5952"><vh>push, pop, clear, stackNames (To be deleted)</vh></v>
<v t="ekr.20101002192824.5953"></v>
<v t="ekr.20101002192824.5957"><vh>setSelection</vh></v>
<v t="ekr.20101002192824.5958"></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20080603052650.466"><vh>4.9 Vim stuff</vh>
<v t="ekr.20100827114047.5895"><vh>Bugs</vh>
<v t="ekr.20101024062147.5994"><vh>Minor</vh>
<v t="ekr.20101021101942.6011"><vh>Window size not honored when opened from menu</vh></v>
<v t="ekr.20100522090453.5912"><vh>Fix bugs with @verbatim, @raw and @end_raw</vh></v>
<v t="ekr.20100223133351.5998"><vh>show-invisibles doesn't work for blank lines</vh></v>
<v t="ekr.20081208102356.1"><vh>Threading colorizer doesn't handle multiple body editors</vh></v>
<v t="ekr.20100521090440.5885"><vh>Fix mac unicode crasher</vh>
<v t="ekr.20100521090440.5886"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20101024062147.5995"><vh>Rst problems</vh>
<v t="ekr.20101021160326.5948"><vh>Fix rst3 unbounded recursion</vh></v>
<v t="ekr.20100827114047.5893"><vh>Fix rst file problems</vh>
<v t="ekr.20100220190251.5616"><vh>Fix rst bug?</vh>
<v t="ekr.20100220190251.5617"><vh>report</vh></v>
<v t="ekr.20090502071837.72"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20090502071837.73"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20090502071837.74"><vh>rstripList</vh></v>
<v t="ekr.20090502071837.75"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20100220204150.5627"><vh>@@rst hello.html</vh>
<v t="ekr.20100220204150.5628"><vh>Greet the world</vh></v>
</v>
</v>
</v>
<v t="ekr.20100826110728.5840"><vh>rst with show-comments-as-paragraph</vh></v>
</v>
<v t="ekr.20101024062147.5996"><vh>Wishlist</vh>
<v t="ekr.20080922115725.1"><vh>Finish @shadow</vh>
<v t="ekr.20081004102201.2"><vh>Log file for @shadow</vh></v>
<v t="ekr.20081001062423.1"><vh>Can @shadow mark externally changed nodes?</vh>
<v t="ekr.20080708094444.38"><vh>x.propagate_changed_lines</vh>
<v t="ekr.20080708094444.40"><vh>&lt;&lt; init vars &gt;&gt;</vh></v>
<v t="ekr.20080708094444.39"><vh>&lt;&lt; define print_tags &gt;&gt;</vh></v>
<v t="ekr.20080708192807.2"><vh>&lt;&lt; about this loop &gt;&gt;</vh></v>
<v t="ekr.20080708192807.5"><vh>&lt;&lt; Handle the opcode &gt;&gt;</vh></v>
<v t="ekr.20080708094444.45"><vh>&lt;&lt; do final correctness check &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090402072059.13"><vh>Create a general mechanism for aux (shadow, _db) files</vh></v>
</v>
<v t="ekr.20100131161507.6303"><vh>Unit tests that all commands have docstrings</vh></v>
<v t="ekr.20100826110728.5839"><vh>Relocating .leo_shadow directories</vh></v>
<v t="ekr.20100830120622.5829"><vh>Fix python import problems</vh></v>
</v>
</v>
<v t="ekr.20100828074347.5827"><vh>Vim bindings</vh>
<v t="ekr.20100521090440.5887"><vh>Generalize minibuffer code</vh></v>
<v t="ekr.20100210102224.5744"><vh>Notes for key bindings</vh></v>
<v t="ekr.20060927173836.6"><vh>Don't abort mode if there are problems with bindings</vh></v>
<v t="ekr.20100113075303.6270"><vh>Easiest vim problems</vh>
<v t="ekr.20100112051224.6229"><vh>(vim) Binding Arrow keys (fixed?)</vh></v>
<v t="ekr.20100112051224.6239"><vh>Displaying mode help</vh></v>
<v t="ekr.20100112051224.6225"><vh>Repeat last cursor movement command</vh></v>
<v t="ekr.20090629183608.8445"><vh>Cursors (easiest)</vh></v>
<v t="ekr.20100112051224.6231"><vh>Undo command (fixed?)</vh></v>
</v>
<v t="ekr.20100113075303.6271"><vh>Mode-oriented bindings</vh>
<v t="ekr.20100112051224.6228"><vh>Binding numeric keys (modes-oriented bindings)</vh></v>
<v t="ekr.20100112051224.6230"><vh>Binding 'bksp' key (mode-oriented bindings)</vh></v>
</v>
<v t="ekr.20080616110054.2"><vh>Support vim dot command</vh></v>
<v t="ekr.20100113075303.6272"><vh>Argument handling</vh>
<v t="ekr.20100112051224.6222"><vh>Commands requesting user input (hard?)</vh></v>
<v t="ekr.20100112051224.6226"><vh>Range prefix to commands (k.getArgs)</vh></v>
<v t="ekr.20100112051224.6227"><vh>Range prefix to objects (k.getArgs)</vh></v>
</v>
<v t="ekr.20100112051224.6223"><vh>Editing node headlines using @mode nodes</vh></v>
<v t="ekr.20100112051224.6246"><vh>Missing commands</vh>
<v t="ekr.20100112051224.6232"><vh>Toggle case command</vh></v>
<v t="ekr.20100112051224.6233"><vh>Replace current character command</vh></v>
<v t="ekr.20100112051224.6234"><vh>Move current line</vh></v>
<v t="ekr.20100112051224.6235"><vh>Move buffer up/down</vh></v>
<v t="ekr.20100112051224.6236"><vh>Word-related commands</vh></v>
<v t="ekr.20100112051224.6237"><vh>Forward and backward by sentences</vh></v>
<v t="ekr.20100112051224.6238"><vh>Focus to body pane</vh></v>
<v t="ekr.20090629183608.8446"><vh>Notes about commands</vh></v>
</v>
</v>
<v t="ekr.20100521090440.5890"><vh>Cleanups: first</vh>
<v t="ekr.20100223123910.5930"><vh>recentFilesController</vh></v>
<v t="ekr.20100219083854.5615"><vh>Improve caching</vh>
<v t="ekr.20100209160132.5770"><vh>cache notes</vh>
<v t="ekr.20100209114432.5751"><vh>Cache expansion bits</vh></v>
</v>
<v t="ekr.20100211095442.6201"><vh>cache notes 2</vh></v>
<v t="ekr.20100223075705.5635"><vh>Don't write expansion bits</vh></v>
<v t="ekr.20100210163813.5748"><vh>Caching buglets?</vh></v>
<v t="ekr.20100225102636.5627"><vh>Use the string returned by cacher</vh></v>
</v>
<v t="ekr.20100211072044.5754"><vh>Dubious usages of .unitTesting</vh>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20051022043608.1"><vh>createOpenWithMenuItemsFromTable</vh>
<v t="ekr.20051022043713.1"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1725"></v>
<v t="ekr.20061031131434.49"><vh>scan</vh></v>
<v t="ekr.20060127052111.1"><vh>cutStack</vh></v>
<v t="ekr.20061024075542.1"><vh>open</vh></v>
<v t="ekr.20040715155607"><vh>g.scanForAtIgnore</vh></v>
<v t="tbrown.20090219095555.61"><vh>g.handleUrlInUrlNode</vh>
<v t="tbrown.20090219095555.62"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="tbrown.20090219095555.63"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.229"><vh>yankRectangle</vh></v>
<v t="ekr.20050920084036.232"><vh>stringRectangle</vh></v>
<v t="ekr.20051218133207"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20090103070824.11"><vh>c.checkFileTimeStamp</vh></v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
<v t="ekr.20090712050729.6017"><vh>promptForDangerousWrite</vh></v>
<v t="ekr.20070529083836"><vh>cleanLines</vh></v>
<v t="ekr.20080711093251.5"><vh>at.writeOneAtShadowNode &amp; helpers</vh>
<v t="ekr.20080819075811.13"><vh>adjustTargetLanguage</vh></v>
</v>
<v t="bwmulder.20050101094804"><vh>at.openForWrite</vh></v>
<v t="ekr.20031218072017.2609"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20041113113140"><vh>loadOnePlugin</vh></v>
<v t="ekr.20031218072017.2829"><vh>c.openTempFileInExternalEditor</vh></v>
<v t="ekr.20031218072017.1151"><vh>tangle.put_all_roots</vh>
<v t="ekr.20031218072017.1152"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="ekr.20031218072017.1153"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="ekr.20031218072017.1154"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="ekr.20031218072017.1155"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
<v t="sps.20100608083657.20937"><vh>&lt;&lt; unit testing fake files&gt;&gt;</vh></v>
<v t="sps.20100608083657.20938"><vh>&lt;&lt; unit testing set result and continue &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.15"><vh>at.initWriteIvars</vh></v>
</v>
<v t="ekr.20090131200406.11"><vh>Remove remaining tk-isms from Leo's core</vh></v>
</v>
<v t="ekr.20100206074650.5844"><vh>Features</vh>
<v t="ekr.20090811141250.5955"><vh> Most important features</vh>
<v t="ekr.20100521130114.5904"><vh>Document plugins automatically</vh></v>
<v t="ekr.20090801103907.6018"><vh>Add entries to global dicts for more languages</vh>
<v t="ekr.20090816125009.5993"><vh>@url http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780</vh></v>
<v t="ekr.20090814190307.5983"><vh>print all modes/*.py files</vh></v>
</v>
<v t="ekr.20090601083544.6051"><vh>Add expand_noweb_references for rst3 plugin</vh>
<v t="ekr.20090601083544.6052"><vh>post</vh></v>
</v>
<v t="ekr.20080918164844.12"><vh>Improve headline navigation</vh></v>
<v t="ekr.20080730212711.7"><vh>Improve plugins handling</vh>
<v t="ekr.20090804105939.5993"><vh>Possibly redo how plugins are loaded</vh></v>
<v t="ekr.20080313032655.2"><vh>Once a plugin is enabled, it is always enabled</vh></v>
<v t="ekr.20080923200153.1"><vh>Support scan-directives hook again?</vh></v>
<v t="ekr.20080421140032.1"><vh>Fix multiple controllers problem in all plugins</vh></v>
</v>
<v t="ekr.20090724081340.5987"><vh>Improve recursive import script and @auto</vh></v>
<v t="ekr.20090907080624.6081"><vh>Spell checker should check headlines</vh></v>
<v t="ekr.20071001052501"><vh>Versioning for nodes</vh></v>
<v t="ekr.20101004092958.5914"><vh>Write treepad scanner</vh>
<v t="ekr.20101004092958.5939"><vh>treepad.py</vh>
<v t="ekr.20101004092958.5940"><vh>treepad declarations</vh></v>
<v t="ekr.20101004092958.5941"><vh>class Node</vh>
<v t="ekr.20101004092958.5942"><vh>__init__</vh></v>
<v t="ekr.20101004092958.5943"><vh>__str__</vh></v>
<v t="ekr.20101004092958.5944"><vh>addchild</vh></v>
<v t="ekr.20101004092958.5945"><vh>findparent</vh></v>
<v t="ekr.20101004092958.5946"><vh>writenode</vh></v>
<v t="ekr.20101004092958.5947"><vh>writetree</vh></v>
</v>
<v t="ekr.20101004092958.5948"><vh>class NodeReader</vh>
<v t="ekr.20101004092958.5949"><vh>__init__</vh></v>
<v t="ekr.20101004092958.5950"><vh>expect</vh></v>
<v t="ekr.20101004092958.5951"><vh>readstart</vh></v>
<v t="ekr.20101004092958.5952"><vh>readnode</vh></v>
</v>
<v t="ekr.20101004092958.5953"><vh>class TreeReader</vh>
<v t="ekr.20101004092958.5954"><vh>__init__</vh></v>
<v t="ekr.20101004092958.5955"><vh>add</vh></v>
<v t="ekr.20101004092958.5956"><vh>read</vh></v>
</v>
<v t="ekr.20101004092958.5957"><vh>class TreeWriter</vh>
<v t="ekr.20101004092958.5958"><vh>__init__</vh></v>
<v t="ekr.20101004092958.5959"><vh>write</vh></v>
</v>
<v t="ekr.20101004092958.5960"><vh>class Main</vh>
<v t="ekr.20101004092958.5961"><vh>__init__</vh></v>
<v t="ekr.20101004092958.5962"><vh>Run</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20090714085914.5994"><vh>New commands</vh>
<v t="ekr.20071004120359.2"><vh>Do expand-region-abbrevs from</vh></v>
<v t="ekr.20090402072059.2"><vh>clone-find-all-once</vh>
<v t="ekr.20090402072059.4"><vh>@@@button my clone find all</vh>
<v t="ekr.20090402072059.5"><vh>&lt;&lt; do some initial stuff &gt;&gt;</vh></v>
<v t="ekr.20090402072059.6"><vh>&lt;&lt; create the found node &gt;&gt;</vh></v>
<v t="ekr.20090402072059.7"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
<v t="ekr.20090402072059.8"><vh>&lt;&lt; Skip node if it's a child of a previously found node &gt;&gt;</vh>
<v t="ekr.20090402072059.9"><vh>&lt;&lt; def: is a child of b &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20100108101415.6196"><vh>insert-tab commands</vh></v>
<v t="ekr.20090601083544.6067"><vh>Make all commands available to all commanders</vh></v>
</v>
<v t="ekr.20090131200406.15"><vh>Optional file features</vh>
<v t="ekr.20100827095120.5861"><vh>Improve format of .leo files?</vh></v>
<v t="ekr.20090622020908.6058"><vh>Add lite sentinels</vh></v>
<v t="ekr.20080311135649.2"><vh>Allow different .leo formats</vh></v>
<v t="ekr.20061002093442"><vh>Add opml support to new,open, save commands</vh></v>
<v t="ekr.20071003104917"><vh>Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace</vh></v>
<v t="ekr.20090218115025.3"><vh>Why are attributes pickled by default?</vh></v>
<v t="ekr.20080626081829.2"><vh>Allow headline comments for @nosent files</vh></v>
<v t="ekr.20080919085541.3"><vh>Use sqlite data base as an alternative representation for .leo files</vh></v>
</v>
<v t="ekr.20090210093316.1"><vh>Optional features</vh>
<v t="ekr.20081119132758.2"><vh>Support @ifgui in settings trees</vh></v>
<v t="ekr.20080727122007.1"><vh>Allow user to set background colors of nodes</vh></v>
<v t="ekr.20080813064908.8"><vh>Find a way to limit length of lines in indented nodes</vh></v>
<v t="ekr.20080802070659.11"><vh>Make node attributes visible, and supported by Leo's core</vh></v>
<v t="ekr.20080806054207.3"><vh>Auto scroll outline pane if headline would become invisible</vh></v>
<v t="ekr.20070521105645"><vh>Improve api docs with epydoc?</vh></v>
<v t="ekr.20061116054917.6"><vh>Remove blanks in calltips</vh></v>
<v t="ekr.20080628095358.1"><vh>Make each Leo command a class</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060207133601"><vh>@file ../doc/leoToDoLater.txt</vh>
<v t="ekr.20060824110846"><vh>Colorizing</vh>
<v t="ekr.20060813121814"><vh>Add colorizer files for cweb, rapidq</vh>
<v t="ekr.20060824103837"><vh>Notes</vh></v>
</v>
</v>
<v t="ekr.20060227142119"><vh>Drawing, printing and rendering</vh>
<v t="ekr.20060822162521"><vh>Make headlines scroll</vh></v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20060227123536"><vh>Tiddlywiki and related comments about rendering body text</vh></v>
<v t="ekr.20050127110221"><vh>Printing &amp; flash</vh></v>
<v t="EKR.20040512082621"><vh>HTML widgets</vh>
<v t="EKR.20040512082621.1"><vh>htmllib.tcl</vh></v>
<v t="ekr.20031218072017.729"><vh>HTML rendering in Leo's body pane</vh>
<v t="ekr.20031218072017.731"><vh>HTML plugin: opml</vh></v>
</v>
</v>
<v t="ekr.20041228092223"><vh>Play with wiki markup</vh></v>
<v t="ekr.20041201084142"><vh>Add convenience methods to change individual headlines color directly</vh></v>
</v>
<v t="ekr.20041228091154"><vh>Commands</vh>
<v t="ekr.20061021131443"><vh>Emacs support</vh>
<v t="ekr.20060628103226.3"><vh>Make sure repeat counts work on basic editing commands</vh></v>
<v t="ekr.20060628094329.2"><vh>Test/Fix macros</vh></v>
<v t="ekr.20060628103226.2"><vh>Alt-x handlers should add to lossage</vh></v>
<v t="ekr.20060123091352"><vh>Incremental search in switch-to-buffer</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20051110155735.1"><vh>Improve Spell tab</vh></v>
<v t="ekr.20061006165447"><vh>Let import commands decide what kind of import to do</vh></v>
<v t="ekr.20041022083833.1"><vh>Easy</vh>
<v t="ekr.20040315060557"><vh>Declone command</vh></v>
<v t="ekr.20041219162724"><vh>Add dialog to insert recent directories</vh></v>
<v t="ekr.20031218072017.800"><vh>Improve extract section command</vh></v>
<v t="ekr.20041130123243"><vh>Clear Undo command</vh></v>
<v t="ekr.20031218072017.790"><vh>Import dialog improvements</vh></v>
<v t="ekr.20031218072017.807"><vh>Put up file dialog on empty @url, etc.</vh></v>
<v t="ekr.20040217153407"><vh>User customizeable tangling and untangling</vh></v>
</v>
<v t="ekr.20040329094003"><vh>Apply patch command</vh></v>
<v t="ekr.20031218072017.748"><vh>Import/Export to yaml</vh></v>
<v t="ekr.20041016134312.2"><vh>Standard Weave command</vh></v>
<v t="ekr.20060227124411"><vh>Import/export from wiki's</vh></v>
<v t="ekr.20060227131611"><vh>Two ideas from Kent</vh></v>
<v t="ekr.20061011111007"><vh>@bool autoload_most_recent_leo_file</vh></v>
</v>
<v t="ekr.20041022083226"><vh>Directives</vh>
<v t="ekr.20031218072017.833"><vh>Use @file extension by default if no @language</vh></v>
<v t="ekr.20041016134312.1"><vh>Allow multiple @language directives in a single node</vh></v>
<v t="ekr.20031218072017.805"><vh>Allow other section delims besides &lt;&lt; and &gt;&gt;</vh></v>
<v t="ekr.20031218072017.745"><vh>@@first &lt;n&gt;</vh></v>
<v t="ekr.20031218072017.795"><vh>Metatags</vh></v>
<v t="ekr.20041130104552"><vh>(Support bird-track programs/comments?)</vh></v>
<v t="ekr.20031218072017.797"><vh>Allow @file http &amp; @file ftp</vh>
<v t="ekr.20031218072017.810"><vh>Remote access Scott Powell</vh></v>
</v>
</v>
<v t="ekr.20060527184335"><vh>Gui</vh>
<v t="ekr.20031218072017.793"><vh>Keep right panes constant when tiling horizontally (Tix)</vh></v>
<v t="ekr.20060213151918"><vh>Add baloons</vh>
<v t="ekr.20060212125650"><vh>createBalloon</vh></v>
</v>
<v t="ekr.20060116083043.1"><vh>Add context-menus on nodes or text</vh></v>
<v t="ekr.20051207130144"><vh>Investigate Tk DnD</vh>
<v t="ekr.20051207130144.1"><vh>@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html</vh></v>
</v>
</v>
<v t="ekr.20050509085713"><vh>Installer</vh>
<v t="ekr.20050328093147.1"><vh>Report: improving installer</vh></v>
<v t="ekr.20070929125944"><vh>Emulate Orange's download philosophy</vh></v>
</v>
<v t="ekr.20041228085245"><vh>Options &amp; settings</vh>
<v t="ekr.20031218072017.740"><vh>Disallow writes outside a "top-level" folder</vh></v>
<v t="ekr.20040311022923"><vh>Make sentinel name in @-node optional</vh></v>
</v>
<v t="ekr.20080807111553.1"><vh>Scripting</vh>
<v t="ekr.20031218072017.753"><vh>Emacs comint-mode:  The improved Execute Script command does most of this</vh></v>
<v t="ekr.20070627151457"><vh>--runCommand option</vh></v>
</v>
<v t="ekr.20041228092223.4"><vh>Windows</vh>
<v t="ekr.20050108051818"><vh>Add hyperlinks for url's</vh></v>
<v t="ekr.20041022083005.2"><vh>add a Stop button for find/change</vh></v>
<v t="ekr.20040908104644"><vh>Leo splash screen</vh>
<v t="ekr.20040908221501"><vh>@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/120687</vh></v>
</v>
</v>
<v t="ekr.20041228084143"><vh>Maybe never</vh>
<v t="ekr.20070426092031"><vh>Consider another way to compute home directory</vh></v>
<v t="ekr.20060930110925"><vh>Fix arrow keys (if possible)</vh></v>
<v t="ekr.20041022070154"><vh>(options for setting working directory during startup)</vh>
<v t="ekr.20041022070154.1"><vh>Request &amp; response</vh></v>
</v>
<v t="ekr.20051104051733"><vh>Make Focus-in in minibuffer widget equivalent to Alt-x</vh></v>
</v>
<v t="ekr.20040123102724"><vh>Can't or won't</vh>
<v t="ekr.20100128094926.6222"><vh> port pmw to py3k</vh></v>
<v t="ekr.20080822065427.3"><vh>Create desktop icon or start menu item</vh></v>
<v t="ekr.20080815174457.5"><vh>Consider deleting private shadow files</vh></v>
<v t="ekr.20060329102951"><vh>@ref</vh>
<v t="ekr.20060329102951.1"><vh>My summary post</vh></v>
<v t="ekr.20060329102951.2"><vh>Reply</vh></v>
</v>
<v t="ekr.20040220110030"><vh>Change cursor when caps lock is down</vh></v>
<v t="ekr.20031218072017.743"><vh>Note window for each node</vh></v>
<v t="ekr.20060610193837"><vh>open python window does not appear to work on Solaris</vh></v>
<v t="ekr.20040216054459"><vh>@h @f @endh and @endf directives</vh></v>
<v t="ekr.20040329185649"><vh>Known Bugs: can't be fixed or can wait</vh>
<v t="ekr.20031218072017.663"><vh>Bug: can't be fixed</vh>
<v t="ekr.20031218072017.664"><vh>Cut/paste bug on X windows (waiting for help)</vh>
<v t="ekr.20031218072017.665"><vh>(Cut &amp; Paste ) (Middle-button bug reported by Timo)</vh>
<v t="ekr.20031218072017.666"><vh> Paste bug report</vh></v>
<v t="ekr.20031218072017.667"><vh> Test</vh></v>
</v>
<v t="ekr.20031218072017.668"><vh>Automatic select &amp; Paste bug (Linux?)</vh></v>
</v>
<v t="ekr.20050514171429"><vh>Glitch pasting into headlines</vh></v>
<v t="ekr.20031218072017.669"><vh>Linux-only Bugs</vh>
<v t="ekr.20031218072017.670"><vh>Possible webbrowser bug</vh></v>
<v t="ekr.20031218072017.671"><vh>Fix horiz scrollbar bug when tiling horizontally</vh></v>
<v t="ekr.20031218072017.672"><vh>Control-V doesn't work on Linux</vh></v>
</v>
<v t="ekr.20050202073944"><vh>Mac bugs</vh>
<v t="ekr.20050201175325.2"><vh>Can't delete script buttons</vh></v>
<v t="ekr.20050201175325.1"><vh>Icon buttons are not colored, nor do they have square borders, etc.</vh></v>
<v t="ekr.20050202052911.1"><vh>Find Text in Find Panel gets focus only if it contains text</vh></v>
</v>
<v t="ekr.20031218072017.673"><vh>Tk bugs</vh>
<v t="ekr.20041201071145"><vh>Tk Freezes on debean when libtk is compiled with thread support</vh></v>
<v t="EKR.20040523192553"><vh>(Crash when pasting large text into headlines)</vh>
<v t="EKR.20040606104355"><vh>Report</vh></v>
</v>
<v t="ekr.20031218072017.674"><vh>Caps lock affects keyboard shortcuts on Windows</vh></v>
<v t="ekr.20031218072017.675"><vh>Tree problems</vh></v>
<v t="ekr.20031218072017.676"><vh>Control-T can't be overridden in canvas text.</vh></v>
<v t="ekr.20031218072017.677"><vh>(Alt-ctrl = Alt)</vh></v>
<v t="ekr.20031218072017.718"><vh>(tab bug)</vh>
<v t="ekr.20040117092727"><vh>This is definitely a Tk bug</vh></v>
<v t="ekr.20040118090055"><vh>Patch and bug report</vh></v>
<v t="ekr.20031218072017.719"><vh>Report</vh></v>
<v t="ekr.20040105070023.5"><vh>Report 2</vh></v>
<v t="ekr.20031218072017.720"><vh>Minimal test</vh></v>
<v t="ekr.20031218072017.721"><vh>Test File for Non Expanding Tabs</vh></v>
</v>
</v>
<v t="ekr.20040129133809.8"><vh>top node not saved</vh></v>
</v>
<v t="ekr.20040105064959"><vh>Bugs: can wait</vh>
<v t="ekr.20040115165036"><vh>bug in xml doc parts (hard to fix?)</vh>
<v t="ekr.20040115165036.1"><vh>Demo XML comment bug</vh></v>
<v t="ekr.20040115165036.3"><vh>@file xmlcommentbug.xml</vh></v>
<v t="ekr.20040115165036.4"><vh>xmlcommentbug.xml</vh></v>
</v>
<v t="ekr.20040125114453"><vh>Import bug?control-alt-f of python code misalloctes code (waiting for answer)</vh></v>
<v t="ekr.20040129133809.5"><vh>Expand/contract may not work after drag (works for me)</vh></v>
</v>
</v>
<v t="ekr.20040217153407.1"><vh>Unify @root and @file</vh></v>
<v t="ekr.20060228072202"><vh>New undoer</vh>
<v t="ekr.20060201161901.2"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3332355</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20100907092144.5901"><vh>Unit tests</vh>
<v t="ekr.20100907115157.5905"><vh>@ignore</vh>
<v t="ekr.20100208095423.5940"><vh>@test leoCache</vh></v>
<v t="ekr.20100906165118.5915"><vh>@test leoInkCommands</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20100120092047.6087"><vh>@file ../external/ipy_leo.py</vh>
<v t="ekr.20100120092047.6088"><vh>ipy_leo declarations</vh></v>
<v t="ekr.20100120092047.6089"><vh>init_ipython</vh></v>
<v t="ekr.20100120092047.6090"><vh>update_commander</vh></v>
<v t="ekr.20100120092047.6091"><vh>es</vh></v>
<v t="ekr.20100120092047.6092"><vh>format_for_leo</vh></v>
<v t="ekr.20100120092047.6093"><vh>valid_attribute</vh></v>
<v t="ekr.20100120092047.6094"><vh>rootnode</vh></v>
<v t="ekr.20100120092047.6095"><vh>all_cells</vh></v>
<v t="ekr.20100120092047.6096"><vh>eval_node</vh></v>
<v t="ekr.20100120092047.6097"><vh>class LeoNode</vh>
<v t="ekr.20100120092047.6098"><vh>__init__</vh></v>
<v t="ekr.20100120092047.6099"><vh>__str__</vh></v>
<v t="ekr.20100120092047.6101"><vh>__get_h and _set_h</vh></v>
<v t="ekr.20100120092047.6103"><vh>_get_b and __set_b</vh></v>
<v t="ekr.20100120092047.6104"><vh>__set_val</vh></v>
<v t="ekr.20100120092047.6105"><vh>__set_l</vh></v>
<v t="ekr.20100120092047.6106"><vh>__iter__</vh></v>
<v t="ekr.20100120092047.6107"><vh>__children</vh></v>
<v t="ekr.20100120092047.6108"><vh>keys</vh></v>
<v t="ekr.20100120092047.6109"><vh>__getitem__</vh></v>
<v t="ekr.20100120092047.6110"><vh>__setitem__</vh></v>
<v t="ekr.20100120092047.6111"><vh>__delitem__</vh></v>
<v t="ekr.20100120092047.6112"><vh>ipush</vh></v>
<v t="ekr.20100120092047.6113"><vh>go</vh></v>
<v t="ekr.20100120092047.6114"><vh>append</vh></v>
<v t="ekr.20100120092047.6115"><vh>script</vh></v>
<v t="ekr.20100120092047.6116"><vh>__get_uA</vh></v>
</v>
<v t="ekr.20100120092047.6117"><vh>class LeoWorkbook</vh>
<v t="ekr.20100120092047.6118"><vh>__getattr__</vh></v>
<v t="ekr.20100120092047.6119"><vh>__str__</vh></v>
<v t="ekr.20100120092047.6120"><vh>__setattr__</vh></v>
<v t="ekr.20100120092047.6121"><vh>__iter__</vh></v>
<v t="ekr.20100120092047.6152"><vh>current</vh></v>
<v t="ekr.20100120092047.6122"><vh>match_h</vh></v>
<v t="ekr.20100120092047.6123"><vh>require</vh></v>
</v>
<v t="ekr.20100120092047.6124"><vh>class PosList</vh></v>
<v t="ekr.20100120092047.6126"><vh>workbook_complete</vh></v>
<v t="ekr.20100120092047.6127"><vh>add_var</vh></v>
<v t="ekr.20100120092047.6128"><vh>add_file</vh></v>
<v t="ekr.20100120092047.6129"><vh>expose_ileo_push</vh></v>
<v t="ekr.20100120092047.6130"><vh>push_ipython_script</vh></v>
<v t="ekr.20100120092047.6131"><vh>eval_body</vh></v>
<v t="ekr.20100120092047.6132"><vh>push_plain_python</vh></v>
<v t="ekr.20100120092047.6133"><vh>push_cl_node</vh></v>
<v t="ekr.20100120092047.6134"><vh>push_ev_node</vh></v>
<v t="ekr.20100120092047.6136"><vh>push_position_from_leo</vh></v>
<v t="ekr.20100120092047.6135"><vh>push_mark_req</vh></v>
<v t="ekr.20100120092047.6137"><vh>edit_object_in_leo</vh></v>
<v t="ekr.20100120092047.6138"><vh>edit_macro</vh></v>
<v t="ekr.20100120092047.6139"><vh>get_history</vh></v>
<v t="ekr.20100120092047.6140"><vh>lee_f</vh></v>
<v t="ekr.20100120092047.6141"><vh>leoref_f</vh></v>
<v t="ekr.20100120092047.6142"><vh>mb_f</vh></v>
<v t="ekr.20100120092047.6143"><vh>mb_completer</vh></v>
<v t="ekr.20100120092047.6144"><vh>ileo_pre_prompt_hook</vh></v>
<v t="ekr.20100120092047.6145"><vh>show_welcome</vh></v>
<v t="ekr.20100120092047.6146"><vh>run_leo_startup_node</vh></v>
<v t="ekr.20100120092047.6147"><vh>lleo_f</vh></v>
<v t="ekr.20100120092047.6148"><vh>lno_f</vh></v>
<v t="ekr.20100120092047.6149"><vh>lshadow_f</vh></v>
<v t="ekr.20100120092047.6150"><vh>shadow_walk</vh></v>
<v t="ekr.20100120092047.6151"><vh>mkbutton</vh></v>
</v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh>
<v t="ville.20091010205847.1364"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ville.20091009234538.1373"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ville.20091010205847.1363"><vh>sending</vh></v>
<v t="ville.20091010205847.1362"><vh>class LProtoBuf</vh></v>
<v t="ville.20091009234538.1374"><vh>class LProtoServer</vh>
<v t="ville.20091009234538.1380"><vh>methods</vh></v>
</v>
<v t="ville.20091010205847.1360"><vh>(ignore) class LProtoObsoleteClient</vh>
<v t="ville.20091010205847.1361"><vh>initialization</vh></v>
</v>
<v t="ville.20091010233144.10051"><vh>class LProtoClient</vh></v>
</v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh>
<v t="ekr.20080921091311.1"><vh>&lt;&lt; imports and inits &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2607"><vh>profile_leo</vh></v>
<v t="ekr.20031218072017.1934"><vh>run &amp; helpers</vh>
<v t="ekr.20090519143741.5915"><vh>doPrePluginsInit &amp; helpers</vh>
<v t="ekr.20100914142850.5892"><vh>createGui &amp; helper</vh></v>
<v t="ekr.20080921060401.4"><vh>createSpecialGui</vh></v>
<v t="ekr.20070306085724"><vh>adjustSysPath</vh></v>
<v t="ekr.20041124083125"><vh>completeFileName</vh></v>
<v t="ekr.20101021101942.6010"><vh>getDefaultFile</vh></v>
<v t="ekr.20101020125657.5976"><vh>getFiles</vh></v>
<v t="ekr.20080921091311.2"><vh>initApp</vh></v>
<v t="ekr.20041130093254"><vh>reportDirectories</vh></v>
<v t="ekr.20091007103358.6061"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20090519143741.5917"><vh>doPostPluginsInit &amp; helpers</vh>
<v t="ekr.20031218072017.1624"><vh>createFrame &amp; helpers (runLeo.py)</vh>
<v t="ekr.20100913171604.5888"><vh>doSelect</vh></v>
<v t="ekr.20100913171604.5885"><vh>doWindowSize</vh></v>
<v t="ekr.20100913171604.5889"><vh>findNode</vh></v>
</v>
<v t="ekr.20080921060401.5"><vh>finishInitApp (runLeo.py)</vh></v>
<v t="ekr.20080921060401.6"><vh>initFocusAndDraw</vh></v>
<v t="ekr.20100914142850.5894"><vh>make_screen_shot</vh></v>
<v t="ekr.20040411081633"><vh>startPsyco</vh></v>
</v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh>
<v t="ekr.20080822065427.8"><vh>&lt;&lt; define emergency dialog class &gt;&gt;</vh>
<v t="ekr.20080822065427.9"><vh>__init__ (emergencyDialog)</vh></v>
<v t="ekr.20080822065427.12"><vh>createButtons</vh></v>
<v t="ekr.20080822065427.14"><vh>createTopFrame</vh></v>
<v t="ekr.20080822065427.10"><vh>okButton</vh></v>
<v t="ekr.20080822065427.21"><vh>onKey</vh></v>
<v t="ekr.20080822065427.16"><vh>run</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"></v>
</v>
<v t="ekr.20031218072017.2609"></v>
<v t="ekr.20100831090251.5838"><vh>app.createXGui</vh>
<v t="ekr.20100831090251.5840"><vh>app.createCursesGui</vh></v>
<v t="ekr.20090619065122.8593"><vh>app.createDefaultGui</vh></v>
<v t="ekr.20090202191501.5"><vh>app.createNullGui</vh></v>
<v t="ekr.20031218072017.1938"><vh>app.createNullGuiWithScript</vh></v>
<v t="ekr.20090202191501.1"><vh>app.createQtGui</vh></v>
<v t="ekr.20031218072017.2610"><vh>app.createTkGui</vh></v>
<v t="ekr.20090126063121.3"><vh>app.createWxGui</vh></v>
</v>
<v t="ekr.20031218072017.2612"><vh>app.destroyAllOpenWithFiles</vh></v>
<v t="ekr.20031218072017.2613"><vh>app.destroyOpenWithFilesForFrame</vh></v>
<v t="ekr.20031218072017.2614"><vh>app.destroyOpenWithFileWithDict</vh></v>
<v t="ekr.20031218072017.2615"><vh>app.destroyWindow</vh></v>
<v t="ekr.20031218072017.1732"><vh>app.finishQuit</vh></v>
<v t="ekr.20031218072017.2616"><vh>app.forceShutdown</vh></v>
<v t="ekr.20031218072017.2188"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20031218072017.2189"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2617"><vh>app.onQuit</vh></v>
<v t="ekr.20031218072017.1978"><vh>app.setLeoID</vh>
<v t="ekr.20031218072017.1979"><vh>&lt;&lt; return if we can set leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20031218072017.1980"><vh>&lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20060211140947.1"><vh>&lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1981"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1982"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt; (changed)</vh></v>
</v>
<v t="ville.20090620122043.6275"><vh>app.setGlobalDb</vh></v>
<v t="ekr.20031218072017.1847"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="ekr.20090717112235.6007"><vh>app.computeSignon</vh></v>
<v t="ekr.20031218072017.2619"><vh>app.writeWaitingLog</vh></v>
<v t="ville.20090602181814.6219"><vh>app.commanders</vh></v>
</v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh>
<v t="ekr.20041005105605.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041005105605.5"><vh>&lt;&lt; define class constants &gt;&gt;</vh></v>
<v t="ekr.20041005105605.6"><vh>&lt;&lt; define sentinelDict &gt;&gt;</vh></v>
<v t="ekr.20041005105605.7"><vh>at.Birth &amp; init</vh>
<v t="ekr.20041005105605.8"><vh>atFile.__init__</vh>
<v t="ekr.20041005105605.9"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.10"><vh>at.initCommonIvars</vh></v>
<v t="ekr.20041005105605.13"><vh>at.initReadIvars</vh></v>
<v t="ekr.20041005105605.15"></v>
</v>
<v t="ekr.20041005105605.17"><vh>at.Reading</vh>
<v t="ekr.20100619222623.5918"><vh>&lt;&lt; about new sentinels &gt;&gt;</vh></v>
<v t="ekr.20041005105605.18"><vh>Reading (top level)</vh>
<v t="ekr.20070919133659"><vh>at.checkDerivedFile</vh></v>
<v t="ekr.20041005105605.19"><vh>at.openFileForReading</vh></v>
<v t="ekr.20041005105605.21"><vh>at.read &amp; helpers</vh>
<v t="ekr.20041005105605.25"><vh>at.deleteAllTempBodyStrings</vh></v>
<v t="ekr.20100122130101.6174"><vh>at.deleteTnodeList</vh></v>
<v t="ekr.20071105164407"><vh>at.deleteUnvisitedNodes &amp; helpers</vh>
<v t="ekr.20100803073751.5817"><vh>createResurrectedNodesNode</vh></v>
<v t="ekr.20100803073751.5818"><vh>defineResurrectedNodeCallback</vh></v>
</v>
<v t="ekr.20041005105605.22"><vh>at.initFileName</vh></v>
<v t="ekr.20100224050618.11547"><vh>at.isFileLike</vh></v>
</v>
<v t="ekr.20041005105605.26"><vh>at.readAll</vh></v>
<v t="ekr.20080801071227.7"><vh>at.readAtShadowNodes</vh></v>
<v t="ekr.20070909100252"><vh>at.readOneAtAutoNode</vh></v>
<v t="ekr.20090225080846.3"></v>
<v t="ekr.20080711093251.7"><vh>at.readOneAtShadowNode</vh>
<v t="ekr.20080712080505.1"><vh>at.importAtShadowNode</vh></v>
</v>
<v t="ekr.20041005105605.27"><vh>at.readOpenFile &amp; helpers</vh>
<v t="ekr.20041005105605.28"><vh>&lt;&lt; handle first and last lines &gt;&gt; (at.readOpenFile)</vh></v>
<v t="ekr.20100122130101.6175"><vh>at.shouldDeleteChildren</vh></v>
<v t="ekr.20041005105605.117"><vh>at.completeFirstDirective</vh></v>
<v t="ekr.20041005105605.118"><vh>at.completeLastDirectives</vh></v>
</v>
</v>
<v t="ekr.20041005105605.71"><vh>Reading (4.x)</vh>
<v t="ekr.20041005105605.72"><vh>at.createThinChild4</vh></v>
<v t="ekr.20041005105605.73"><vh>at.findChild4</vh></v>
<v t="ekr.20041005105605.74"><vh>at.scanText4 &amp; allies</vh>
<v t="ekr.20041005105605.75"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20041005105605.76"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20041005105605.77"><vh>at.readNormalLine &amp; appendToDocPart</vh>
<v t="ekr.20100624082003.5942"><vh>at.appendToDocPart</vh></v>
</v>
<v t="ekr.20041005105605.80"><vh>start sentinels</vh>
<v t="ekr.20041005105605.81"><vh>at.readStartAll</vh></v>
<v t="ekr.20041005105605.85"><vh>at.readStartNode &amp; helpers</vh>
<v t="ekr.20100630144047.5783"><vh>at.changeLevel</vh></v>
<v t="ekr.20100625085138.5957"><vh>at.createNewThinNode</vh></v>
<v t="ekr.20100625184546.5979"><vh>at.parseNodeSentinel &amp; helpers</vh>
<v t="ekr.20100625085138.5955"><vh>at.getNodeHeadline</vh></v>
<v t="ekr.20100625085138.5953"><vh>at.parseThinNodeSentinel</vh></v>
</v>
</v>
<v t="ekr.20041005105605.111"><vh>at.readRef (paired using new sentinels)</vh></v>
<v t="ekr.20041005105605.82"><vh>at.readStartAt/Doc &amp; helpers</vh>
<v t="ekr.20100624082003.5938"><vh>readStartAt</vh></v>
<v t="ekr.20100624082003.5939"><vh>readStartDoc</vh></v>
<v t="ekr.20100624082003.5940"><vh>skipToEndSentinel</vh></v>
</v>
<v t="ekr.20041005105605.83"><vh>at.readStartLeo</vh></v>
<v t="ekr.20041005105605.84"><vh>at.readStartMiddle</vh></v>
<v t="ekr.20041005105605.89"><vh>at.readStartOthers</vh></v>
</v>
<v t="ekr.20041005105605.90"><vh>end sentinels</vh>
<v t="ekr.20041005105605.91"><vh>at.readEndAll</vh></v>
<v t="ekr.20041005105605.92"><vh>at.readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20041005105605.93"><vh>at.readEndLeo</vh></v>
<v t="ekr.20041005105605.94"><vh>at.readEndMiddle</vh></v>
<v t="ekr.20041005105605.95"><vh>at.readEndNode</vh></v>
<v t="ekr.20041005105605.98"><vh>at.readEndOthers</vh></v>
<v t="ekr.20100625140824.5968"><vh>at.readEndRef</vh></v>
<v t="ekr.20041005105605.99"><vh>at.readLastDocLine (old sentinels only)</vh></v>
</v>
<v t="ekr.20041005105605.100"><vh>Unpaired sentinels</vh>
<v t="ekr.20041005105605.101"><vh>at.ignoreOldSentinel</vh></v>
<v t="ekr.20041005105605.102"><vh>at.readAfterRef</vh></v>
<v t="ekr.20041005105605.103"><vh>at.readClone</vh></v>
<v t="ekr.20041005105605.104"><vh>at.readComment</vh></v>
<v t="ekr.20041005105605.105"><vh>at.readDelims</vh></v>
<v t="ekr.20041005105605.106"><vh>at.readDirective (@@)</vh>
<v t="ekr.20041005105605.107"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20041005105605.108"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.109"><vh>at.readNl</vh></v>
<v t="ekr.20041005105605.110"><vh>at.readNonl</vh></v>
<v t="ekr.20041005105605.112"><vh>at.readVerbatim</vh></v>
</v>
<v t="ekr.20041005105605.113"><vh>at.badEndSentinel, popSentinelStack</vh></v>
</v>
<v t="ekr.20041005105605.114"><vh>at.sentinelKind4 &amp; helper (read logic)</vh>
<v t="ekr.20100518083515.5896"><vh>sentinelKind4_helper</vh></v>
</v>
<v t="ekr.20041005105605.115"><vh>at.skipSentinelStart4</vh></v>
</v>
<v t="ekr.20041005105605.116"><vh>Reading utils...</vh>
<v t="ekr.20100625092449.5963"><vh>at.appendToOut</vh></v>
<v t="ekr.20050301105854"><vh>at.copyAllTempBodyStringsToVnodes</vh></v>
<v t="ekr.20041005105605.119"><vh>at.createImportedNode</vh></v>
<v t="ekr.20041005105605.120"><vh>at.parseLeoSentinel</vh>
<v t="ekr.20041005105605.121"><vh>&lt;&lt; set the opening comment delim &gt;&gt;</vh></v>
<v t="ekr.20041005105605.122"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="ekr.20041005105605.123"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20041005105605.124"><vh>&lt;&lt; read optional thin param &gt;&gt;</vh></v>
<v t="ekr.20041005105605.125"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="ekr.20041005105605.126"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.127"><vh>at.readError</vh></v>
<v t="ekr.20041005105605.128"><vh>at.readLine</vh></v>
<v t="ekr.20041005105605.129"><vh>at.scanHeader</vh>
<v t="ekr.20041005105605.130"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050103163224"><vh>at.scanHeaderForThin (used by import code)</vh></v>
<v t="ekr.20041005105605.131"><vh>at.skipIndent</vh></v>
<v t="ekr.20100628072537.5814"><vh>at.terminateNode &amp; helpers</vh>
<v t="ekr.20100628124907.5816"><vh>at.indicateNodeChanged</vh></v>
<v t="ekr.20100628124907.5818"><vh>at.reportCorrection</vh></v>
<v t="ekr.20100702062857.5824"><vh>at.terminateBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20041005105605.132"><vh>at.Writing</vh>
<v t="ekr.20041005105605.133"><vh>Writing (top level)</vh>
<v t="ekr.20041005105605.154"><vh>at.asisWrite</vh>
<v t="ekr.20041005105605.155"><vh>&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="ekr.20041005105605.156"><vh>&lt;&lt; Write p's body &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.142"><vh>at.openFileForWriting &amp; helper</vh>
<v t="ekr.20041005105605.143"><vh>at.openFileForWritingHelper &amp; helper</vh>
<v t="bwmulder.20050101094804"></v>
</v>
</v>
<v t="ekr.20041005105605.144"><vh>at.write &amp; helper</vh>
<v t="ekr.20041005105605.145"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20041005105605.146"><vh>&lt;&lt; set dirty and orphan bits &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.147"><vh>at.writeAll &amp; helper</vh>
<v t="ekr.20041005105605.150"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
<v t="ekr.20041005105605.148"><vh>at.clearAllOrphanBits</vh></v>
<v t="ekr.20041005105605.149"><vh>at.writeAllHelper</vh></v>
</v>
<v t="ekr.20070806105859"><vh>at.writeAtAutoNodes &amp; writeDirtyAtAutoNodes &amp; helpers</vh>
<v t="ekr.20070806140208"><vh>at.writeAtAutoNodesHelper</vh></v>
<v t="ekr.20070806141607"><vh>at.writeOneAtAutoNode &amp; helpers</vh></v>
</v>
<v t="ekr.20080711093251.3"><vh>at.writeAtShadowNodes &amp; writeDirtyAtShadowNodes &amp; helpers</vh>
<v t="ekr.20080711093251.4"><vh>at.writeAtShadowNodesHelper</vh></v>
<v t="ekr.20080711093251.5"></v>
</v>
<v t="ekr.20050506084734"><vh>at.writeFromString</vh></v>
<v t="ekr.20041005105605.151"><vh>at.writeMissing</vh>
<v t="ekr.20041005105605.152"><vh>&lt;&lt; write the @file node &gt;&gt; (writeMissing)</vh></v>
</v>
<v t="ekr.20090225080846.5"><vh>at.writeOneAtEditNode</vh></v>
<v t="ekr.20041005105605.157"><vh>at.writeOpenFile</vh></v>
</v>
<v t="ekr.20041005105605.160"><vh>Writing 4.x</vh>
<v t="ekr.20041005105605.161"><vh>at.putBody</vh>
<v t="ekr.20041005105605.162"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20041005105605.163"><vh>&lt;&lt; handle line at s[i] &gt;&gt; (putBody)</vh></v>
</v>
<v t="ekr.20041005105605.164"><vh>writing code lines...</vh>
<v t="ekr.20041005105605.165"><vh>@all</vh>
<v t="ekr.20041005105605.166"><vh>putAtAllLine</vh></v>
<v t="ekr.20041005105605.167"><vh>putatAllBody</vh>
<v t="ekr.20041005105605.168"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.169"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20041005105605.170"><vh>@others</vh>
<v t="ekr.20041005105605.171"><vh>inAtOthers</vh></v>
<v t="ekr.20041005105605.172"><vh>putAtOthersChild</vh></v>
<v t="ekr.20041005105605.173"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20041005105605.174"><vh>putCodeLine (leoAtFile)</vh></v>
<v t="ekr.20041005105605.175"><vh>putRefLine &amp; allies</vh>
<v t="ekr.20041005105605.176"><vh>putRefLine</vh></v>
<v t="ekr.20041005105605.177"><vh>putRefAt</vh></v>
<v t="ekr.20041005105605.178"><vh>putAfterLastRef</vh></v>
<v t="ekr.20041005105605.179"><vh>putAfterMiddleRef</vh></v>
</v>
</v>
<v t="ekr.20041005105605.180"><vh>writing doc lines...</vh>
<v t="ekr.20041005105605.181"><vh>putBlankDocLine</vh></v>
<v t="ekr.20041005105605.183"><vh>putDocLine</vh>
<v t="ekr.20100629190353.5831"><vh>&lt;&lt; write the line as is &gt;&gt;</vh></v>
<v t="ekr.20041005105605.184"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.185"><vh>putEndDocLine</vh></v>
<v t="ekr.20041005105605.186"><vh>putPending (old only)</vh></v>
<v t="ekr.20041005105605.182"><vh>putStartDocLine</vh></v>
</v>
</v>
<v t="ekr.20041005105605.187"><vh>Writing 4,x sentinels...</vh>
<v t="ekr.20041005105605.188"><vh>nodeSentinelText 4.x</vh>
<v t="ekr.20041005105605.189"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.190"><vh>putLeadInSentinel 4.x</vh></v>
<v t="ekr.20041005105605.191"><vh>putCloseNodeSentinel 4.x</vh></v>
<v t="ekr.20041005105605.192"><vh>putOpenLeoSentinel 4.x</vh></v>
<v t="ekr.20041005105605.193"><vh>putOpenNodeSentinel</vh></v>
<v t="ekr.20041005105605.194"><vh>putSentinel (applies cweb hack) 4.x</vh>
<v t="ekr.20041005105605.195"><vh>&lt;&lt; apply the cweb hack to s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041005105605.196"><vh>Writing 4.x utils...</vh>
<v t="ekr.20090514111518.5661"><vh>checkPythonCode (leoAtFile) &amp; helpers</vh>
<v t="ekr.20090514111518.5663"><vh>checkPythonSyntax (leoAtFile)</vh>
<v t="ekr.20090514111518.5666"><vh>syntaxError (leoAtFile)</vh></v>
</v>
<v t="ekr.20090514111518.5665"><vh>tabNannyNode (leoAtFile)</vh></v>
</v>
<v t="ekr.20080712150045.3"><vh>closeStringFile</vh></v>
<v t="ekr.20041005105605.135"><vh>closeWriteFile</vh></v>
<v t="ekr.20041005105605.197"><vh>compareFiles</vh></v>
<v t="ekr.20041005105605.198"><vh>directiveKind4 (write logic)</vh></v>
<v t="ekr.20041005105605.199"><vh>hasSectionName</vh></v>
<v t="ekr.20041005105605.200"><vh>isSectionName</vh></v>
<v t="ekr.20070909103844"><vh>isSignificantTree</vh></v>
<v t="ekr.20080712150045.2"><vh>openStringFile</vh></v>
<v t="ekr.20041005105605.201"><vh>os and allies</vh>
<v t="ekr.20041005105605.202"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="ekr.20041005105605.203"><vh>onl &amp; onl_sent</vh></v>
<v t="ekr.20041005105605.204"><vh>os</vh></v>
</v>
<v t="ekr.20041005105605.205"><vh>outputStringWithLineEndings</vh></v>
<v t="ekr.20050506090446.1"><vh>putAtFirstLines</vh></v>
<v t="ekr.20050506090955"><vh>putAtLastLines</vh></v>
<v t="ekr.20071117152308"><vh>putBuffered</vh></v>
<v t="ekr.20041005105605.206"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20041005105605.207"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="ekr.20041005105605.208"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20041005105605.209"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.210"><vh>putIndent</vh></v>
<v t="ekr.20041005105605.211"><vh>putInitialComment</vh></v>
<v t="ekr.20080712150045.1"><vh>replaceFileWithString (atFile)</vh></v>
<v t="ekr.20041005105605.212"><vh>replaceTargetFileIfDifferent (atFile)</vh>
<v t="ekr.20041019090322"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.216"><vh>warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20041005105605.217"><vh>writeError</vh></v>
<v t="ekr.20041005105605.218"><vh>writeException</vh></v>
</v>
</v>
<v t="ekr.20041005105605.219"><vh>at.Utilites</vh>
<v t="ekr.20041005105605.220"><vh>atFile.error &amp; printError</vh></v>
<v t="ekr.20080923070954.4"><vh>at.scanAllDirectives</vh>
<v t="ekr.20080923070954.14"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20080923070954.13"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20070529083836"></v>
<v t="ekr.20041005105605.221"><vh>exception</vh></v>
<v t="ekr.20050104131929"><vh>file operations...</vh>
<v t="ekr.20050104131820"><vh>chmod</vh></v>
<v t="ekr.20050104131929.1"><vh>atFile.rename</vh>
<v t="ekr.20050104131929.2"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
</v>
<v t="ekr.20050104132018"><vh>atFile.remove</vh></v>
<v t="ekr.20050104132026"><vh>stat</vh></v>
</v>
<v t="ekr.20090530055015.6050"><vh>at.fullPath</vh></v>
<v t="ekr.20090530055015.6023"><vh>get/setPathUa (leoAtFile)</vh></v>
<v t="ekr.20081216090156.4"><vh>parseUnderindentTag</vh></v>
<v t="ekr.20090712050729.6017"></v>
<v t="ekr.20041005105605.242"><vh>scanForClonedSibs (reading &amp; writing)</vh></v>
<v t="ekr.20041005105605.243"><vh>sentinelName</vh></v>
<v t="ekr.20041005105605.20"><vh>warnOnReadOnlyFile</vh></v>
</v>
</v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh>
<v t="ekr.20070227091955.2"><vh>&lt;&lt; about the leoBridge module &gt;&gt;</vh></v>
<v t="ekr.20070227092442"><vh>controller</vh></v>
<v t="ekr.20070227092442.2"><vh>class bridgeController</vh>
<v t="ekr.20070227092442.3"><vh>ctor (bridgeController)</vh></v>
<v t="ekr.20070227092442.4"><vh>globals</vh></v>
<v t="ekr.20070227093530"><vh>initLeo &amp; helpers</vh>
<v t="ekr.20070227093629.1"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070227093629.2"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070302061713"><vh>adjustSysPath</vh></v>
<v t="ekr.20070227095743"><vh>createGui</vh></v>
<v t="ekr.20070227093629.4"><vh>isValidPython</vh></v>
<v t="ekr.20070227094232"><vh>getLeoID</vh>
<v t="ekr.20070227094232.1"><vh>&lt;&lt; try to get leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20070227094232.2"><vh>&lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20070227094232.3"><vh>&lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;</vh></v>
</v>
<v t="ekr.20070227093629.9"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20070227093918"><vh>isOpen</vh></v>
<v t="ekr.20070227092442.5"><vh>openLeoFile &amp; helpers</vh>
<v t="ekr.20070227093629.5"><vh>completeFileName (leoBridge)</vh></v>
<v t="ekr.20070227093629.6"><vh>createFrame (leoBridge)</vh></v>
</v>
</v>
</v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh>
<v t="ekr.20100208223942.10436"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20100208062523.5885"><vh>class cacher</vh>
<v t="ekr.20100208082353.5919"><vh> Birth</vh>
<v t="ekr.20100208062523.5886"><vh> ctor (cacher)</vh></v>
<v t="ekr.20100208082353.5918"><vh>initFileDB</vh></v>
<v t="ekr.20100208082353.5920"><vh>initGlobalDb</vh></v>
<v t="ekr.20100210163813.5747"><vh>save (cacher)</vh></v>
</v>
<v t="ekr.20100209160132.5759"><vh>clear/AllCache(s) (cacher)</vh></v>
<v t="ekr.20100208071151.5907"><vh>fileKey</vh></v>
<v t="ekr.20100208082353.5925"><vh>Reading</vh>
<v t="ekr.20100208071151.5910"><vh>cacher.createOutlineFromCacheList &amp; helpers</vh>
<v t="ekr.20100208071151.5911"><vh>fastAddLastChild</vh></v>
<v t="ekr.20100705083838.5740"><vh>reportChangedClone</vh></v>
</v>
<v t="ekr.20100208082353.5923"><vh>getCachedGlobalFileRatios</vh></v>
<v t="ekr.20100208082353.5924"><vh>getCachedStringPosition</vh></v>
<v t="ekr.20100208082353.5922"><vh>getCachedWindowPositionDict</vh></v>
<v t="ekr.20100208071151.5905"><vh>readFile (cacher)</vh></v>
</v>
<v t="ekr.20100208082353.5927"><vh>Writing</vh>
<v t="ekr.20100208071151.5901"><vh>makeCacheList</vh></v>
<v t="ekr.20100208082353.5929"><vh>setCachedGlobalsElement</vh></v>
<v t="ekr.20100208082353.5928"><vh>setCachedStringPosition</vh></v>
<v t="ekr.20100208071151.5903"><vh>writeFile (cacher)</vh></v>
</v>
<v t="ekr.20100208065621.5890"><vh>test (cacher)</vh></v>
</v>
<v t="ekr.20100208223942.5967"><vh>class PickleShareDB</vh>
<v t="ekr.20100208223942.5968"><vh> Birth &amp; special methods</vh>
<v t="ekr.20100208223942.5969"><vh> __init__</vh></v>
<v t="ekr.20100208223942.5970"><vh>__contains__</vh></v>
<v t="ekr.20100208223942.5971"><vh>__delitem__</vh></v>
<v t="ekr.20100208223942.5972"><vh>__getitem__</vh></v>
<v t="ekr.20100208223942.5973"><vh>__iter__</vh></v>
<v t="ekr.20100208223942.5974"><vh>__repr__</vh></v>
<v t="ekr.20100208223942.5975"><vh>__setitem__</vh></v>
</v>
<v t="ekr.20100208223942.10452"><vh>_makedirs</vh></v>
<v t="ekr.20100208223942.10458"><vh>_openFile</vh></v>
<v t="ekr.20100208223942.10454"><vh>_walkfiles &amp; helpers</vh>
<v t="ekr.20100208223942.10456"><vh>_listdir</vh></v>
<v t="ekr.20100208223942.10464"><vh>_fn_match</vh></v>
</v>
<v t="ekr.20100208223942.5978"><vh>clear</vh></v>
<v t="ekr.20100208223942.5979"><vh>get</vh></v>
<v t="ekr.20100208223942.5980"><vh>has_key</vh></v>
<v t="ekr.20100208223942.5981"><vh>items</vh></v>
<v t="ekr.20100208223942.5982"><vh>keys &amp; helpers</vh>
<v t="ekr.20100208223942.5976"><vh>_normalized</vh></v>
<v t="ekr.20100208223942.10460"><vh>_relpathto</vh></v>
<v t="ekr.20100208223942.10462"><vh>_splitall</vh></v>
</v>
<v t="ekr.20100208223942.5989"><vh>uncache</vh></v>
</v>
</v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh>
<v t="ekr.20070317085437"><vh>class chapterController</vh>
<v t="ekr.20070530075604"><vh>Birth</vh>
<v t="ekr.20070317085437.2"><vh> ctor: chapterController</vh></v>
<v t="ekr.20070325104904"><vh>cc.finishCreate</vh></v>
</v>
<v t="ekr.20070317085437.30"><vh>Commands (chapters)</vh>
<v t="ekr.20070317085437.50"><vh>cc.cloneNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.1"><vh>cc.cloneToChapterHelper</vh></v>
</v>
<v t="ekr.20070608072116"><vh>cc.convertNodeToChapter</vh></v>
<v t="ekr.20070317085437.51"><vh>cc.copyNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.2"><vh>cc.copyNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070317085437.31"><vh>cc.createChapter</vh></v>
<v t="ekr.20070603190617"><vh>cc.createChapterByName</vh></v>
<v t="ekr.20070607092909"><vh>cc.createChapterFromNode</vh></v>
<v t="ekr.20070604155815.3"><vh>cc.moveNodeToChapter &amp; helper</vh>
<v t="ekr.20070317085437.52"><vh>cc.moveNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070317085437.40"><vh>cc.removeChapter</vh></v>
<v t="ekr.20070606075434"><vh>cc.removeChapterByName</vh></v>
<v t="ekr.20070317085437.41"><vh>cc.renameChapter</vh></v>
<v t="ekr.20070604165126"><vh>cc.selectChapter</vh></v>
<v t="ekr.20070317130250"><vh>cc.selectChapterByName &amp; helper</vh>
<v t="ekr.20090306060344.2"><vh>selectChapterHelper</vh></v>
</v>
</v>
<v t="ekr.20070511081405"><vh>Creating/deleting nodes (chapterController)</vh>
<v t="ekr.20070325101652"><vh>cc.createChaptersNode</vh></v>
<v t="ekr.20070325063303.2"><vh>cc.createChapterNode</vh></v>
<v t="ekr.20070509081915.1"><vh>cc.createChild</vh></v>
<v t="ekr.20070325063303.4"><vh>cc.deleteChapterNode</vh></v>
</v>
<v t="ekr.20070317130648"><vh>Utils</vh>
<v t="ekr.20070320085610"><vh>cc.error</vh></v>
<v t="ekr.20070325093617"><vh>cc.findChapterNode</vh></v>
<v t="ekr.20070325094401"><vh>cc.findChaptersNode</vh></v>
<v t="ekr.20070605124356"><vh>cc.inChapter</vh></v>
<v t="ekr.20070325115102"><vh>cc.getChapterNode</vh></v>
<v t="ekr.20070318124004"><vh>cc.getChapter</vh></v>
<v t="ekr.20070318122708"><vh>cc.getSelectedChapter</vh></v>
<v t="ekr.20070510064813"><vh>cc.printChaptersTree</vh></v>
<v t="ekr.20070615075643"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20071028091719"><vh>cc.findChapterNameForPosition</vh></v>
</v>
<v t="ekr.20070610100031"><vh>Undo</vh>
<v t="ekr.20070606075125"><vh>afterCreateChapter</vh></v>
<v t="ekr.20070610091608"><vh>afterRemoveChapter</vh></v>
<v t="ekr.20070606082729"><vh>beforeCreateChapter</vh></v>
<v t="ekr.20070610091608.1"><vh>beforeRemoveChapter</vh></v>
<v t="ekr.20070606081341"><vh>redoInsertChapter</vh></v>
<v t="ekr.20070610100555"><vh>redoRemoveChapter</vh></v>
<v t="ekr.20070606074705"><vh>undoInsertChapter</vh></v>
<v t="ekr.20070610100555.1"><vh>undoRemoveChapter</vh></v>
</v>
</v>
<v t="ekr.20070317085708"><vh>class chapter</vh>
<v t="ekr.20070317085708.1"><vh> ctor: chapter</vh></v>
<v t="ekr.20070317085708.2"><vh>__str__ and __repr__(chapter)</vh></v>
<v t="ekr.20070325155208.1"><vh>chapter.error</vh></v>
<v t="ekr.20070317131205.1"><vh>chapter.select &amp; helpers</vh>
<v t="ekr.20070423102603.1"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070317131708"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070425175522"><vh>chapter.findEditorInChapter</vh></v>
<v t="ekr.20070615065222"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070529171934.1"><vh>chapter.rename (not used)</vh></v>
</v>
<v t="ekr.20070320091806.1"><vh>chapter.unselect</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh>
<v t="bob.20080115083029"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="bob.20080115090639"><vh>&lt;&lt; changelog &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2795"><vh>&lt;&lt; define colorizer constants &gt;&gt;</vh></v>
<v t="EKR.20040623090054"><vh>&lt;&lt; define global colorizer data &gt;&gt;</vh></v>
<v t="bob.20080115070511.2"><vh>&lt;&lt; define leo_color_database &gt;&gt;</vh></v>
<v t="bob.20080115070511.3"><vh>color database functions</vh>
<v t="bob.20071231111744.2"><vh>get / getColor</vh></v>
<v t="bob.20080115070511.4"><vh>getRGB / getColorRGB</vh></v>
<v t="bob.20080115072302"><vh>getCairo / getColorCairo</vh></v>
</v>
<v t="ekr.20031218072017.2796"><vh>class colorizer</vh>
<v t="ekr.20031218072017.1605"><vh>color.__init__ &amp; helper</vh>
<v t="ekr.20031218072017.371"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh>
<v t="ekr.20031218072017.372"><vh>actionscript keywords</vh></v>
<v t="bwmulder.20041023131509"><vh>ada keywords</vh></v>
<v t="ekr.20040206072057"><vh>c# keywords</vh></v>
<v t="ekr.20031218072017.373"><vh>c/c++/cweb keywords</vh></v>
<v t="ekr.20040401103539"><vh>css keywords</vh></v>
<v t="ekr.20031218072017.374"><vh>elisp keywords</vh></v>
<v t="ekr.20031218072017.375"><vh>html keywords</vh></v>
<v t="ekr.20031218072017.376"><vh>java keywords</vh></v>
<v t="ekr.20031218072017.377"><vh>latex keywords</vh></v>
<v t="ekr.20060328110802"><vh>lua keywords</vh></v>
<v t="ekr.20031218072017.378"><vh>pascal keywords</vh></v>
<v t="ekr.20031218072017.379"><vh>perl/perlpod keywords</vh></v>
<v t="ekr.20031218072017.380"><vh>php keywords</vh></v>
<v t="ekr.20050618052653"><vh>plsql keywords</vh></v>
<v t="ekr.20031218072017.381"><vh>python keywords</vh></v>
<v t="ekr.20040331145826"><vh>rapidq keywords</vh></v>
<v t="sps.20081213155951.1"><vh>ruby keywords</vh></v>
<v t="ekr.20031218072017.382"><vh>rebol keywords</vh></v>
<v t="ekr.20040401111125"><vh>shell keywords</vh></v>
<v t="ekr.20031218072017.383"><vh>tcl/tk keywords</vh></v>
</v>
<v t="ekr.20031218072017.1606"><vh>&lt;&lt; ivars for communication between colorizeAnyLanguage and its allies &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1607"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20080704085627.3"><vh>splitList</vh></v>
</v>
<v t="ekr.20031218072017.2801"><vh>colorize &amp; recolor_range</vh></v>
<v t="ekr.20031218072017.1880"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="ekr.20031218072017.1602"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="ekr.20060829084924"><vh>&lt;&lt; configure fonts &gt;&gt; (revise,maybe)</vh></v>
<v t="ekr.20031218072017.1603"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
</v>
<v t="ekr.20031218072017.1881"><vh>&lt;&lt; all state ivars match &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1882"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="ekr.20031218072017.1883"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1884"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1885"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1886"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1887"><vh>&lt;&lt; non-incrementally color the text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1888"><vh>&lt;&lt; update state ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1889"><vh>&lt;&lt; set state ivars to "unknown" &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1892"><vh>colorizeLine &amp; allies</vh>
<v t="ekr.20031218072017.1618"><vh>continueBlockComment</vh></v>
<v t="ekr.20031218072017.1893"><vh>continueSingle/DoubleString</vh></v>
<v t="ekr.20031218072017.1614"><vh>continueDocPart</vh>
<v t="ekr.20031218072017.1615"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1616"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1894"><vh>continueNocolor</vh></v>
<v t="ekr.20031218072017.1613"><vh>continueSingle/DoublePythonString</vh></v>
<v t="ekr.20031218072017.1620"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="ekr.20031218072017.1895"><vh>doLatexLine</vh></v>
<v t="ekr.20031218072017.1896"><vh>doNormalState</vh>
<v t="ekr.20031218072017.1897"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20031218072017.1898"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1899"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1900"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1901"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1902"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20031218072017.1904"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1903"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1617"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1619"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1905"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1906"><vh>Vaid only in latex mode</vh>
<v t="ekr.20031218072017.1907"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1908"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20031218072017.1612"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1909"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1910"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1911"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1912"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1913"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1914"><vh>doNowebSecRef (colorizer)</vh>
<v t="ekr.20031218072017.1915"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1604"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
<v t="ekr.20050420083821"><vh>disable &amp; enable</vh></v>
<v t="ekr.20031218072017.2803"><vh>getCwebWord</vh></v>
<v t="ekr.20071009094150"><vh>isSameColorState</vh></v>
<v t="ekr.20031218072017.1944"><vh>removeAllImages (leoColor)</vh></v>
<v t="ekr.20080828103146.8"><vh>scanColorDirectives (leoColor)</vh></v>
<v t="ekr.20041217041016"><vh>setFontFromConfig (colorizer)</vh></v>
<v t="ekr.20031218072017.2804"><vh>updateSyntaxColorer</vh></v>
<v t="ekr.20031218072017.2805"><vh>useSyntaxColoring</vh></v>
<v t="ekr.20031218072017.2806"><vh>Utils</vh>
<v t="ekr.20031218072017.1609"><vh>index &amp; tag (leoColor)</vh></v>
<v t="ekr.20031218072017.2807"><vh>setFirstLineState</vh></v>
<v t="ekr.20031218072017.2808"><vh>skip_id</vh></v>
<v t="ekr.20031218072017.1610"><vh>skip_python_string</vh></v>
<v t="ekr.20031218072017.2809"><vh>skip_string</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2218"><vh>class nullColorizer</vh>
<v t="ekr.20031218072017.2219"><vh>__init__</vh></v>
<v t="ekr.20031218072017.2220"><vh>entry points</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh>
<v t="ekr.20040712045933"><vh>&lt;&lt; imports  &gt;&gt; (leoCommands)</vh></v>
<v t="ekr.20041118104831"><vh>class commands</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20081005065934.1"><vh>c.initAfterLoad</vh></v>
<v t="ekr.20090213065933.6"><vh>c.initConfigSettings</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20090213065933.7"><vh>c.setWindowPosition</vh></v>
</v>
<v t="ekr.20031218072017.2817"></v>
<v t="ekr.20080901124540.1"><vh>c.Directive scanning</vh>
<v t="ekr.20080827175609.39"><vh>c.scanAllDirectives</vh></v>
<v t="ekr.20080828103146.15"><vh>c.scanAtPathDirectives</vh></v>
<v t="ekr.20080828103146.12"><vh>c.scanAtRootDirectives</vh></v>
<v t="ekr.20080922124033.5"><vh>c.os_path_finalize and c.os_path_finalize_join</vh></v>
<v t="ekr.20081006100835.1"><vh>c.getNodePath &amp; c.getNodeFileName</vh></v>
</v>
<v t="ekr.20091211111443.6265"><vh>c.doBatchOperations &amp; helpers</vh>
<v t="ekr.20091211111443.6266"><vh>checkBatchOperationsList</vh></v>
</v>
<v t="ekr.20051106040126"><vh>c.executeMinibufferCommand</vh></v>
<v t="ekr.20091002083910.6106"><vh>c.find...</vh>
<v t="ville.20090311190405.70"><vh>c.find_h</vh></v>
<v t="ville.20090311200059.1"><vh>c.find_b</vh></v>
</v>
<v t="ekr.20091001141621.6061"><vh>c.generators</vh>
<v t="ekr.20091001141621.6043"><vh>c.all_nodes &amp; all_unique_nodes</vh></v>
<v t="ekr.20091001141621.6062"><vh>c.all_unique_positions</vh></v>
<v t="ekr.20091001141621.6044"><vh>c.all_positions</vh></v>
</v>
<v t="ekr.20090130135126.1"><vh>c.Properties</vh></v>
<v t="bobjack.20080509080123.2"><vh>c.universalCallback</vh></v>
<v t="ekr.20031218072017.2818"><vh>Command handlers...</vh>
<v t="ekr.20031218072017.2819"><vh>File Menu</vh>
<v t="ekr.20031218072017.2820"><vh>top level (file menu)</vh>
<v t="ekr.20031218072017.1623"><vh>c.new</vh></v>
<v t="ekr.20031218072017.2821"><vh>c.open &amp; helper</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
<v t="ekr.20090212054250.9"><vh>c.createNodeFromExternalFile</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>c.openWith and helpers</vh>
<v t="ekr.20031218072017.2824"><vh>c.getOpenWithExt</vh></v>
<v t="ekr.20031218072017.2829"></v>
<v t="ekr.20100203050306.5797"><vh>c.openWithHelper</vh>
<v t="ekr.20031218072017.2827"><vh>c.createOrRecreateTempFileAsNeeded</vh></v>
<v t="ekr.20100203050306.5937"><vh>c.createOpenWithTempFile</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath (may be over-ridden)</vh></v>
</v>
<v t="ekr.20031218072017.2833"><vh>c.close</vh></v>
<v t="ekr.20031218072017.2834"><vh>c.save</vh></v>
<v t="ekr.20031218072017.2835"><vh>c.saveAs</vh></v>
<v t="ekr.20070413045221"><vh>saveAsUnzipped &amp; saveAsZipped</vh></v>
<v t="ekr.20031218072017.2836"><vh>c.saveTo</vh></v>
<v t="ekr.20031218072017.2837"><vh>revert</vh></v>
</v>
<v t="ekr.20031218072017.2079"><vh>Recent Files submenu &amp; allies</vh>
<v t="ekr.20031218072017.2080"><vh>clearRecentFiles</vh></v>
<v t="ekr.20031218072017.2081"><vh>c.openRecentFile</vh>
<v t="ekr.20031218072017.2082"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2083"><vh>c.updateRecentFiles</vh></v>
<v t="tbrown.20080509212202.6"><vh>cleanRecentFiles</vh></v>
<v t="tbrown.20080509212202.8"><vh>sortRecentFiles</vh></v>
</v>
<v t="ekr.20031218072017.2838"><vh>Read/Write submenu</vh>
<v t="ekr.20031218072017.2839"><vh>readOutlineOnly</vh></v>
<v t="ekr.20070915134101"><vh>readFileIntoNode</vh></v>
<v t="ekr.20070806105721.1"><vh>readAtAutoNodes (commands)</vh></v>
<v t="ekr.20031218072017.1839"><vh>readAtFileNodes (commands)</vh></v>
<v t="ekr.20080801071227.4"><vh>readAtShadowNodes (commands)</vh></v>
<v t="ekr.20031218072017.1809"><vh>importDerivedFile</vh></v>
<v t="ekr.20070915142635"><vh>writeFileFromNode (changed)</vh></v>
</v>
<v t="ekr.20031218072017.2841"><vh>Tangle submenu</vh>
<v t="ekr.20031218072017.2842"><vh>tangleAll</vh></v>
<v t="ekr.20031218072017.2843"><vh>tangleMarked</vh></v>
<v t="ekr.20031218072017.2844"><vh>tangle</vh></v>
</v>
<v t="ekr.20031218072017.2845"><vh>Untangle submenu</vh>
<v t="ekr.20031218072017.2846"><vh>untangleAll</vh></v>
<v t="ekr.20031218072017.2847"><vh>untangleMarked</vh></v>
<v t="ekr.20031218072017.2848"><vh>untangle</vh></v>
</v>
<v t="ekr.20031218072017.2849"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20031218072017.2850"><vh>exportHeadlines</vh></v>
<v t="ekr.20031218072017.2851"><vh>flattenOutline</vh></v>
<v t="ekr.20031218072017.2852"><vh>importAtRoot</vh></v>
<v t="ekr.20031218072017.2853"><vh>importAtFile</vh></v>
<v t="ekr.20031218072017.2854"><vh>importCWEBFiles</vh></v>
<v t="ekr.20031218072017.2855"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20031218072017.2856"><vh>importNowebFiles</vh></v>
<v t="ekr.20031218072017.2857"><vh>outlineToCWEB</vh></v>
<v t="ekr.20031218072017.2858"><vh>outlineToNoweb</vh></v>
<v t="ekr.20031218072017.2859"><vh>removeSentinels</vh></v>
<v t="ekr.20031218072017.2860"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2861"><vh>Edit Menu...</vh>
<v t="ekr.20031218072017.2862"><vh>Edit top level</vh>
<v t="ekr.20031218072017.2140"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20031218072017.2143"><vh>redirectScriptOutput</vh></v>
<v t="EKR.20040627100424"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20070115135502"><vh>writeScriptFile (changed)</vh></v>
</v>
<v t="ekr.20100216141722.5620"><vh>class gotoLineNumber and helpers (commands)</vh>
<v t="ekr.20100216141722.5621"><vh> __init__ (gotoLineNumber)</vh></v>
<v t="ekr.20100216141722.5622"><vh>go</vh></v>
<v t="ekr.20100216141722.5623"><vh>countLines &amp; helpers</vh>
<v t="ekr.20100216141722.5624"><vh>countLinesHelper</vh></v>
<v t="ekr.20100216141722.5625"><vh>countLinesInChildren</vh></v>
</v>
<v t="ekr.20100216141722.5626"><vh>findGnx</vh></v>
<v t="ekr.20100216141722.5627"><vh>findRoot</vh></v>
<v t="ekr.20100216141722.5628"><vh>findVnode &amp; helpers</vh>
<v t="ekr.20100216141722.5629"><vh>findNodeSentinel &amp; helper</vh>
<v t="ekr.20100216141722.5630"><vh>handleDelim</vh></v>
</v>
<v t="ekr.20100216141722.5631"><vh>getNodeLineInfo &amp; helper</vh>
<v t="ekr.20100728074713.5843"><vh>removeLevelStars</vh></v>
</v>
<v t="ekr.20100216141722.5632"><vh>setDelimFromLines</vh></v>
<v t="ekr.20100216141722.5633"><vh>skipToMatchingNodeSentinel (no longer used)</vh></v>
</v>
<v t="ekr.20100216141722.5634"><vh>getFileLines (leoEditCommands)</vh></v>
<v t="ekr.20100216141722.5635"><vh>openFile (gotoLineNumber)</vh></v>
<v t="ekr.20100216141722.5636"><vh>setup_file</vh></v>
<v t="ekr.20100216141722.5637"><vh>setup_script</vh></v>
<v t="ekr.20100216141722.5638"><vh>showResults</vh></v>
</v>
<v t="EKR.20040612232221"><vh>c.goToScriptLineNumber</vh></v>
<v t="ekr.20031218072017.2088"><vh>fontPanel</vh></v>
<v t="ekr.20031218072017.2090"><vh>colorPanel</vh></v>
<v t="ekr.20031218072017.2883"><vh>show/hide/toggleInvisibles</vh></v>
<v t="ekr.20031218072017.2086"><vh>preferences</vh></v>
</v>
<v t="ekr.20031218072017.2884"><vh>Edit Body submenu</vh>
<v t="ekr.20031218072017.1704"><vh>convertAllBlanks</vh></v>
<v t="ekr.20031218072017.1705"><vh>convertAllTabs</vh></v>
<v t="ekr.20031218072017.1821"><vh>convertBlanks</vh></v>
<v t="ekr.20031218072017.1822"><vh>convertTabs</vh></v>
<v t="ekr.20031218072017.1823"><vh>createLastChildNode</vh></v>
<v t="ekr.20031218072017.1824"><vh>dedentBody</vh></v>
<v t="ekr.20031218072017.1706"><vh>extract (test)</vh></v>
<v t="ekr.20031218072017.1708"><vh>extractSection</vh>
<v t="ekr.20031218072017.1709"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1710"><vh>extractSectionNames</vh>
<v t="ekr.20031218072017.1711"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1825"><vh>c.findBoundParagraph</vh>
<v t="ekr.20031218072017.1826"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1827"><vh>c.findMatchingBracket, helper and test</vh>
<v t="ekr.20061113221414"><vh>findMatchingBracketHelper</vh></v>
</v>
<v t="ekr.20031218072017.1829"><vh>getBodyLines</vh></v>
<v t="ekr.20031218072017.1830"><vh>indentBody (indent-region)</vh></v>
<v t="ekr.20031218072017.1831"><vh>insertBodyTime, helpers and tests</vh>
<v t="ekr.20031218072017.1832"><vh>getTime</vh></v>
</v>
<v t="ekr.20050312114529"><vh>insert/removeComments</vh>
<v t="ekr.20050312114529.1"><vh>addComments</vh></v>
<v t="ekr.20050312114529.2"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20031218072017.1833"><vh>reformatParagraph</vh>
<v t="ekr.20031218072017.1834"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1835"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1836"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1837"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1838"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20031218072017.2885"><vh>Edit Headline submenu</vh>
<v t="ekr.20031218072017.2886"><vh>c.editHeadline</vh></v>
<v t="ekr.20031218072017.2290"><vh>toggleAngleBrackets</vh></v>
</v>
<v t="ekr.20031218072017.2887"><vh>Find submenu (frame methods)</vh>
<v t="ekr.20051013084200"><vh>dismissFindPanel</vh></v>
<v t="ekr.20031218072017.2888"><vh>showFindPanel</vh></v>
<v t="ekr.20031218072017.2889"><vh>findNext</vh></v>
<v t="ekr.20031218072017.2890"><vh>findPrevious</vh></v>
<v t="ekr.20031218072017.2891"><vh>replace</vh></v>
<v t="ekr.20031218072017.2892"><vh>replaceThenFind</vh></v>
<v t="ekr.20051013083241"><vh>replaceAll</vh></v>
</v>
<v t="ekr.20031218072017.2893"><vh>notValidInBatchMode</vh></v>
</v>
<v t="ekr.20031218072017.2894"><vh>Outline menu...</vh>
<v t="ekr.20031218072017.2895"><vh> Top Level... (Commands)</vh>
<v t="ekr.20031218072017.1548"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20031218072017.1549"><vh>cutOutline</vh></v>
<v t="ekr.20031218072017.1550"><vh>copyOutline</vh></v>
<v t="ekr.20031218072017.1551"><vh>pasteOutline</vh>
<v t="ekr.20050418084539"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050418084539.2"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="EKR.20040610130943"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20031218072017.2028"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20031218072017.1759"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20031218072017.1760"><vh>c.checkMoveWithParentWithWarning &amp; c.checkDrag</vh>
<v t="ekr.20070910105044"><vh>checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070910105044.1"><vh>checkDrag</vh></v>
</v>
<v t="ekr.20031218072017.1193"><vh>c.deleteOutline</vh></v>
<v t="ekr.20031218072017.1761"><vh>c.insertHeadline</vh></v>
<v t="ekr.20071005173203.1"><vh>c.insertChild</vh></v>
<v t="ekr.20031218072017.1762"><vh>c.clone</vh></v>
<v t="ekr.20031218072017.1765"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20080425060424.1"><vh>Sort...</vh>
<v t="ekr.20080503055349.1"><vh>c.setPositionAfterSort</vh></v>
<v t="ekr.20050415134809"><vh>c.sortChildren</vh></v>
<v t="ekr.20050415134809.1"><vh>c.sortSiblings</vh></v>
</v>
</v>
<v t="ekr.20040711135959.2"><vh>Check Outline submenu...</vh>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20080426051658.1"><vh>assert consistency of parent and children arrays</vh></v>
</v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040723094220.1"><vh>c.checkAllPythonCode</vh>
<v t="ekr.20040723094220.2"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.3"><vh>c.checkPythonCode</vh>
<v t="ekr.20040723094220.4"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.5"><vh>c.checkPythonNode</vh></v>
<v t="ekr.20040723094220.6"><vh>c.tabNannyNode</vh></v>
</v>
<v t="ekr.20040412060927"><vh>c.dumpOutline</vh></v>
<v t="ekr.20040711135959.1"><vh>Pretty Print commands</vh>
<v t="ekr.20040712053025"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20040712053025.1"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20050729211526"><vh>prettyPrintPythonNode</vh></v>
<v t="ekr.20071001075704"><vh>prettyPrintPythonTree</vh></v>
<v t="ekr.20040711135244.5"><vh>class prettyPrinter</vh>
<v t="ekr.20040711135244.6"><vh>__init__</vh>
<v t="ekr.20041021100850"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713093048"><vh>clear</vh></v>
<v t="ekr.20040713064323"><vh>dumpLines</vh></v>
<v t="ekr.20040711135244.7"><vh>dumpToken</vh></v>
<v t="ekr.20040713091855"><vh>endUndo</vh></v>
<v t="ekr.20040711135244.8"><vh>get</vh></v>
<v t="ekr.20040711135244.4"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040711135244.9"><vh>put</vh></v>
<v t="ekr.20041021104237"><vh>putArray</vh></v>
<v t="ekr.20040711135244.10"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20041021102938"><vh>doEndMarker</vh></v>
<v t="ekr.20041021102340.1"><vh>doErrorToken</vh></v>
<v t="ekr.20041021102340.2"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20041021102340"><vh>doMultiLine (strings, etc).</vh></v>
<v t="ekr.20041021101911.5"><vh>doName</vh></v>
<v t="ekr.20041021101911.3"><vh>doNewline</vh></v>
<v t="ekr.20041021101911.6"><vh>doNumber</vh></v>
<v t="ekr.20040711135244.11"><vh>doOp</vh></v>
<v t="ekr.20041021112219"><vh>doStartLine</vh></v>
<v t="ekr.20041021101911.1"><vh>oops</vh></v>
<v t="ekr.20041021101911.2"><vh>trace</vh></v>
</v>
<v t="ekr.20040711135244.12"><vh>putToken</vh></v>
<v t="ekr.20040713070356"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2898"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20031218072017.2899"><vh>Commands (outline menu)</vh>
<v t="ekr.20031218072017.2900"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20080819075811.3"><vh>contractAllOtherNodes &amp; helper</vh>
<v t="ekr.20080819075811.7"><vh>contractIfNotCurrent</vh></v>
</v>
<v t="ekr.20031218072017.2901"><vh>contractNode</vh></v>
<v t="ekr.20040930064232"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20031218072017.2902"><vh>contractParent</vh></v>
<v t="ekr.20031218072017.2903"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20031218072017.2904"><vh>expandAllSubheads</vh></v>
<v t="ekr.20031218072017.2905"><vh>expandLevel1..9</vh></v>
<v t="ekr.20031218072017.2906"><vh>expandNextLevel</vh></v>
<v t="ekr.20031218072017.2907"><vh>expandNode</vh></v>
<v t="ekr.20040930064232.1"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20060928062431"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20031218072017.2908"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20031218072017.2909"><vh>Utilities</vh>
<v t="ekr.20031218072017.2910"><vh>contractSubtree</vh></v>
<v t="ekr.20031218072017.2911"><vh>expandSubtree</vh></v>
<v t="ekr.20031218072017.2912"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2922"><vh>Mark...</vh>
<v t="ekr.20090905110447.6098"><vh>c.cloneMarked</vh></v>
<v t="ekr.20031218072017.2923"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20031218072017.2924"><vh>markChangedRoots</vh></v>
<v t="ekr.20031218072017.2925"><vh>markAllAtFileNodesDirty</vh></v>
<v t="ekr.20031218072017.2926"><vh>markAtFileNodesDirty</vh></v>
<v t="ekr.20031218072017.2928"><vh>markHeadline</vh></v>
<v t="ekr.20031218072017.2929"><vh>markSubheads</vh></v>
<v t="ekr.20031218072017.2930"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20031218072017.1766"><vh>Move... (Commands)</vh>
<v t="ekr.20070420092425"><vh>cantMoveMessage</vh></v>
<v t="ekr.20031218072017.1767"><vh>demote</vh></v>
<v t="ekr.20031218072017.1768"><vh>moveOutlineDown</vh>
<v t="ekr.20031218072017.1769"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1770"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
<v t="ekr.20031218072017.1772"><vh>moveOutlineUp</vh>
<v t="ekr.20031218072017.1773"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1774"><vh>promote</vh></v>
<v t="ekr.20071213185710"><vh>c.toggleSparseMove</vh></v>
</v>
<v t="ekr.20031218072017.2913"><vh>Goto (Commands)</vh>
<v t="ekr.20031218072017.1628"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20031218072017.1627"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20031218072017.2914"><vh>goToFirstNode</vh></v>
<v t="ekr.20051012092453"><vh>goToFirstSibling</vh></v>
<v t="ekr.20070615070925"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20031218072017.2915"><vh>goToLastNode</vh></v>
<v t="ekr.20051012092847.1"><vh>goToLastSibling</vh></v>
<v t="ekr.20050711153537"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20031218072017.2916"><vh>goToNextClone</vh></v>
<v t="ekr.20071213123942"><vh>findNextClone</vh></v>
<v t="ekr.20031218072017.2917"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20031218072017.2918"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20031218072017.2919"><vh>goToNextSibling</vh></v>
<v t="ekr.20031218072017.2920"><vh>goToParent</vh></v>
<v t="ekr.20031218072017.2921"><vh>goToPrevSibling</vh></v>
<v t="ekr.20031218072017.2993"><vh>selectThreadBack</vh></v>
<v t="ekr.20031218072017.2994"><vh>selectThreadNext</vh></v>
<v t="ekr.20031218072017.2995"><vh>selectVisBack</vh></v>
<v t="ekr.20031218072017.2996"><vh>selectVisNext</vh></v>
<v t="ekr.20070417112650"><vh>utils</vh>
<v t="ekr.20070226121510"><vh> treeFocusHelper</vh></v>
<v t="ekr.20070226113916"><vh> treeSelectHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2931"><vh>Window Menu</vh>
<v t="ekr.20031218072017.2092"><vh>openCompareWindow</vh></v>
<v t="ekr.20031218072017.2932"><vh>openPythonWindow</vh></v>
</v>
<v t="ekr.20031218072017.2938"><vh>Help Menu</vh>
<v t="ekr.20031218072017.2939"><vh>about (version number &amp; date)</vh></v>
<v t="ekr.20031218072017.2943"><vh>openLeoSettings and openMyLeoSettings</vh></v>
<v t="ekr.20061018094539"><vh>openLeoScripts</vh></v>
<v t="ekr.20031218072017.2940"><vh>leoDocumentation</vh></v>
<v t="ekr.20031218072017.2941"><vh>leoHome</vh></v>
<v t="ekr.20050130152008"><vh>openLeoPlugins</vh></v>
<v t="ekr.20090628075121.5994"><vh>leoQuickStart</vh></v>
<v t="ekr.20031218072017.2942"><vh>leoTutorial (version number)</vh></v>
<v t="ekr.20060613082924"><vh>leoUsersGuide</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2945"><vh>Dragging (commands)</vh>
<v t="ekr.20031218072017.2353"><vh>c.dragAfter</vh></v>
<v t="ekr.20031218072017.2947"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20031218072017.2946"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20031218072017.2948"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="ekr.20031218072017.2949"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20080515053412.1"><vh>c.add_command, c.bind, c.bind2 &amp; c.tag_bind</vh>
<v t="ekr.20080610085158.2"><vh>c.add_command</vh></v>
<v t="ekr.20080610085158.3"><vh>c.bind and c.bind2</vh></v>
<v t="ekr.20080610085158.4"><vh>c.tag_bind</vh></v>
</v>
<v t="ekr.20080514131122.7"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20080514131122.8"><vh>c.bringToFront</vh></v>
<v t="ekr.20040803072955.143"><vh>c.expandAllAncestors</vh></v>
<v t="ekr.20080514131122.9"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20080514131122.10"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20080514131122.20"><vh>c.outerUpdate</vh></v>
<v t="ekr.20080514131122.12"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20080514131122.14"><vh>c.redrawing...</vh>
<v t="ekr.20090110073010.1"><vh>c.redraw</vh></v>
<v t="ekr.20090110131802.2"><vh>c.redraw_after_contract</vh></v>
<v t="ekr.20090112065525.1"><vh>c.redraw_after_expand</vh></v>
<v t="ekr.20090110073010.2"><vh>c.redraw_after_head_changed</vh></v>
<v t="ekr.20090110073010.3"><vh>c.redraw_afer_icons_changed</vh></v>
<v t="ekr.20090110073010.4"><vh>c.redraw_after_select</vh></v>
</v>
<v t="ekr.20080514131122.13"><vh>c.recolor_now</vh></v>
<v t="ekr.20080514131122.16"><vh>c.traceFocus</vh></v>
<v t="ekr.20080514131122.17"><vh>c.widget_name</vh></v>
<v t="ekr.20080514131122.18"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20080514131122.19"><vh>c.xWantsFocusNow</vh></v>
</v>
<v t="ekr.20031218072017.2955"><vh>Enabling Menu Items</vh>
<v t="ekr.20040323172420"><vh>Slow routines: no longer used</vh>
<v t="ekr.20031218072017.2966"><vh>canGoToNextDirtyHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2967"><vh>canGoToNextMarkedHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2968"><vh>canMarkChangedHeadline (slow)</vh></v>
<v t="ekr.20031218072017.2969"><vh>canMarkChangedRoots (slow)</vh></v>
</v>
<v t="ekr.20040131170659"><vh>canClone (new for hoist)</vh></v>
<v t="ekr.20031218072017.2956"><vh>canContractAllHeadlines</vh></v>
<v t="ekr.20031218072017.2957"><vh>canContractAllSubheads</vh></v>
<v t="ekr.20031218072017.2958"><vh>canContractParent</vh></v>
<v t="ekr.20031218072017.2959"><vh>canContractSubheads</vh></v>
<v t="ekr.20031218072017.2960"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="ekr.20031218072017.2961"><vh>canDemote</vh></v>
<v t="ekr.20031218072017.2962"><vh>canExpandAllHeadlines</vh></v>
<v t="ekr.20031218072017.2963"><vh>canExpandAllSubheads</vh></v>
<v t="ekr.20031218072017.2964"><vh>canExpandSubheads</vh></v>
<v t="ekr.20031218072017.2287"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="ekr.20031218072017.2965"><vh>canFindMatchingBracket</vh></v>
<v t="ekr.20040303165342"><vh>canHoist &amp; canDehoist</vh></v>
<v t="ekr.20070608165544"><vh>hoistLevel</vh></v>
<v t="ekr.20031218072017.2970"><vh>canMoveOutlineDown</vh></v>
<v t="ekr.20031218072017.2971"><vh>canMoveOutlineLeft</vh></v>
<v t="ekr.20031218072017.2972"><vh>canMoveOutlineRight</vh></v>
<v t="ekr.20031218072017.2973"><vh>canMoveOutlineUp</vh></v>
<v t="ekr.20031218072017.2974"><vh>canPasteOutline</vh></v>
<v t="ekr.20031218072017.2975"><vh>canPromote</vh></v>
<v t="ekr.20031218072017.2976"><vh>canRevert</vh></v>
<v t="ekr.20031218072017.2977"><vh>canSelect....</vh></v>
<v t="ekr.20031218072017.2978"><vh>canShiftBodyLeft/Right</vh></v>
<v t="ekr.20031218072017.2979"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="ekr.20031218072017.2980"><vh>canUndo &amp; canRedo</vh></v>
<v t="ekr.20031218072017.2981"><vh>canUnmarkAll</vh></v>
</v>
<v t="ekr.20031218072017.2982"><vh>Getters &amp; Setters</vh>
<v t="ekr.20060906211747"><vh>Getters</vh>
<v t="ekr.20040803140033"><vh>c.currentPosition</vh></v>
<v t="ekr.20040306220230.1"><vh>c.edit_widget</vh></v>
<v t="ekr.20031218072017.2986"><vh>c.fileName &amp; relativeFileName &amp; shortFileName</vh></v>
<v t="ekr.20060906134053"><vh>c.findRootPosition New in 4.4.2</vh></v>
<v t="ekr.20070615070925.1"><vh>c.firstVisible</vh></v>
<v t="ekr.20040803112200"><vh>c.is...Position</vh>
<v t="ekr.20040803155551"><vh>c.currentPositionIsRootPosition</vh></v>
<v t="ekr.20040803160656"><vh>c.currentPositionHasNext</vh></v>
<v t="ekr.20040803112450"><vh>c.isCurrentPosition</vh></v>
<v t="ekr.20040803112450.1"><vh>c.isRootPosition</vh></v>
</v>
<v t="ekr.20031218072017.2987"><vh>c.isChanged</vh></v>
<v t="ekr.20031218072017.4146"><vh>c.lastVisible</vh></v>
<v t="ekr.20040311094927"><vh>c.nullPosition</vh></v>
<v t="ekr.20040307104131.3"><vh>c.positionExists</vh></v>
<v t="ekr.20040803140033.2"><vh>c.rootPosition</vh></v>
<v t="ekr.20070609122713"><vh>c.visLimit</vh></v>
<v t="ekr.20090107113956.1"><vh>c.vnode2position</vh></v>
<v t="tbrown.20091206142842.10296"><vh>c.vnode2allPositions</vh></v>
</v>
<v t="ekr.20060906211747.1"><vh>Setters</vh>
<v t="ekr.20040315032503"><vh>c.appendStringToBody</vh></v>
<v t="ekr.20031218072017.2984"><vh>c.clearAllMarked</vh></v>
<v t="ekr.20031218072017.2985"><vh>c.clearAllVisited</vh></v>
<v t="ekr.20060906211138"><vh>c.clearMarked</vh></v>
<v t="ekr.20040305223522"><vh>c.setBodyString</vh></v>
<v t="ekr.20031218072017.2989"><vh>c.setChanged</vh></v>
<v t="ekr.20040803140033.1"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20040305223225"><vh>c.setHeadString</vh></v>
<v t="ekr.20060109164136"><vh>c.setLog</vh></v>
<v t="ekr.20060906211138.1"><vh>c.setMarked</vh></v>
<v t="ekr.20040803140033.3"><vh>c.setRootPosition</vh></v>
<v t="ekr.20060906131836"><vh>c.setRootVnode New in 4.4.2</vh></v>
<v t="ekr.20040311173238"><vh>c.topPosition &amp; c.setTopPosition</vh></v>
<v t="ekr.20031218072017.3404"><vh>c.trimTrailingLines</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2990"><vh>Selecting &amp; Updating (commands)</vh>
<v t="ekr.20031218072017.2991"><vh>c.redrawAndEdit</vh></v>
<v t="ekr.20031218072017.2992"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20031218072017.2997"><vh>c.selectPosition</vh></v>
<v t="ekr.20060923202156"><vh>c.onCanvasKey</vh>
<v t="ekr.20061002095711.1"><vh>c.navQuickKey</vh></v>
<v t="ekr.20061002095711"><vh>c.navHelper</vh></v>
</v>
<v t="ville.20090525205736.12325"><vh>c.getSelectedPositions</vh></v>
</v>
<v t="ekr.20031218072017.2999"><vh>Syntax coloring interface</vh>
<v t="ekr.20031218072017.3000"><vh>updateSyntaxColorer</vh></v>
</v>
<v t="ekr.20090103070824.12"><vh>Time stamps</vh>
<v t="ekr.20090103070824.11"></v>
<v t="ekr.20090103070824.9"><vh>c.setFileTimeStamp</vh></v>
</v>
</v>
<v t="ekr.20041118104831.1"><vh>class configSettings (leoCommands)</vh>
<v t="ekr.20041118104831.2"><vh>configSettings.__init__ (c.configSettings)</vh></v>
<v t="ekr.20041118104240"><vh>initIvar (c.configSettings)</vh></v>
<v t="ekr.20041118104414"><vh>initEncoding</vh></v>
<v t="ekr.20041118053731"><vh>Getters (c.configSettings)</vh></v>
<v t="ekr.20041118195812"><vh>Setters... (c.configSettings)</vh></v>
</v>
<v t="ekr.20070615131604"><vh>class nodeHistory</vh>
<v t="ekr.20070615131604.1"><vh> ctor (nodeHistory)</vh></v>
<v t="ekr.20070615131604.3"><vh>canGoToNext/Prev</vh></v>
<v t="ekr.20070615132939"><vh>clear</vh></v>
<v t="ekr.20070615134813"><vh>goNext/Prev</vh></v>
<v t="ekr.20070615132939.1"><vh>remove</vh></v>
<v t="ekr.20070615140032"><vh>selectChapter</vh></v>
<v t="ville.20090724234020.14676"><vh>update</vh></v>
<v t="ekr.20070615140655"><vh>visitedPositions</vh></v>
</v>
</v>
<v t="ekr.20041117062700"><vh>@file leoConfig.py</vh>
<v t="ekr.20041227063801"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041119203941.2"><vh>&lt;&lt; class parserBaseClass &gt;&gt;</vh>
<v t="ekr.20041121130043"><vh>&lt;&lt; parserBaseClass data &gt;&gt;</vh></v>
<v t="ekr.20041119204700"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20080514084054.4"><vh>computeModeName (parserBaseClass)</vh></v>
<v t="ekr.20060102103625"><vh>createModeCommand (parserBaseClass)</vh></v>
<v t="ekr.20041120103012"><vh>error</vh></v>
<v t="ekr.20041120094940"><vh>kind handlers (parserBaseClass)</vh>
<v t="ekr.20060608221203"><vh>doAbbrev</vh></v>
<v t="ekr.20041120094940.1"><vh>doBool</vh></v>
<v t="ekr.20070925144337"><vh>doButtons</vh></v>
<v t="ekr.20080312071248.6"><vh>doCommands</vh></v>
<v t="ekr.20041120094940.2"><vh>doColor</vh></v>
<v t="ekr.20071214140900"><vh>doData</vh></v>
<v t="ekr.20041120094940.3"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20070224075914"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20041120094940.6"><vh>doFloat</vh></v>
<v t="ekr.20041120094940.4"><vh>doFont</vh></v>
<v t="ekr.20041120103933"><vh>doIf</vh></v>
<v t="ekr.20041121125416"><vh>doIfGui (can never work)</vh></v>
<v t="dan.20080410121257.2"><vh>doIfHostname</vh></v>
<v t="ekr.20041120104215"><vh>doIfPlatform</vh></v>
<v t="ekr.20041120104215.1"><vh>doIgnore</vh></v>
<v t="ekr.20041120094940.5"><vh>doInt</vh></v>
<v t="ekr.20041217132253"><vh>doInts</vh></v>
<v t="ekr.20070925144337.2"><vh>doMenus &amp; helpers (ParserBaseClass)</vh>
<v t="ekr.20070926141716"><vh>doItems</vh></v>
<v t="ekr.20070926142312"><vh>dumpMenuList</vh></v>
</v>
<v t="ekr.20060102103625.1"><vh>doMode (ParserBaseClass)</vh></v>
<v t="ekr.20070411101643.1"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20041120104215.2"><vh>doPage</vh></v>
<v t="ekr.20041121125741"><vh>doRatio</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts (ParserBaseClass)</vh></v>
<v t="ekr.20041217132028"><vh>doString</vh></v>
<v t="ekr.20041120094940.8"><vh>doStrings</vh></v>
<v t="bobjack.20080324141020.4"><vh>doPopup &amp; helper</vh>
<v t="bobjack.20080324141020.5"><vh>doPopupItems</vh></v>
</v>
<v t="tbrown.20080514112857.124"><vh>doMenuat</vh>
<v t="tbrown.20080514180046.9"><vh>getName</vh></v>
<v t="tbrown.20080514180046.2"><vh>dumpMenuTree</vh></v>
<v t="tbrown.20080514180046.8"><vh>patchMenuTree</vh></v>
</v>
</v>
<v t="ekr.20041124063257"><vh>munge</vh></v>
<v t="ekr.20041119204700.2"><vh>oops</vh></v>
<v t="ekr.20041213082558"><vh>parsers</vh>
<v t="ekr.20041213083651"><vh>fontSettingNameToFontKind</vh></v>
<v t="ekr.20041213082558.1"><vh>parseFont &amp; helper</vh>
<v t="ekr.20041213082558.2"><vh>parseFontLine</vh></v>
</v>
<v t="ekr.20041119205148"><vh>parseHeadline</vh></v>
<v t="ekr.20070411101643.2"><vh>parseOpenWith &amp; helper</vh>
<v t="ekr.20070411101643.4"><vh>parseOpenWithLine</vh></v>
</v>
<v t="ekr.20041120112043"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060608222828"><vh>parseAbbrevLine (g.app.config)</vh></v>
</v>
<v t="ekr.20041120094940.9"><vh>set (parserBaseClass)</vh></v>
<v t="ekr.20041227071423"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20041119204700.1"><vh>traverse (parserBaseClass)</vh></v>
<v t="ekr.20041120094940.10"><vh>valueError</vh></v>
<v t="ekr.20041119204700.3"><vh>visitNode (must be overwritten in subclasses)</vh></v>
</v>
<v t="ekr.20041119203941"><vh>class configClass</vh>
<v t="ekr.20041122094813"><vh>&lt;&lt;  class data &gt;&gt; (g.app.config)</vh>
<v t="ekr.20041117062717.1"><vh>defaultsDict</vh></v>
<v t="ekr.20041118062709"><vh>define encodingIvarsDict</vh></v>
<v t="ekr.20041117072055"><vh>ivarsDict</vh></v>
</v>
<v t="ekr.20041117083202"><vh>Birth... (g.app.config)</vh>
<v t="ekr.20041117062717.2"><vh>ctor (configClass)</vh></v>
<v t="ekr.20041227063801.2"><vh>initDicts</vh></v>
<v t="ekr.20041117065611.2"><vh>initIvarsFromSettings &amp; helpers</vh>
<v t="ekr.20041117065611.1"><vh>initEncoding</vh></v>
<v t="ekr.20041117065611"><vh>initIvar</vh></v>
</v>
<v t="ekr.20041117083202.2"><vh>initRecentFiles</vh></v>
<v t="ekr.20041117083857"><vh>initSettingsFiles</vh></v>
</v>
<v t="ekr.20041117081009"><vh>Getters... (g.app.config)</vh>
<v t="ekr.20041123070429"><vh>canonicalizeSettingName (munge)</vh></v>
<v t="ekr.20041123092357"><vh>config.findSettingsPosition</vh></v>
<v t="ekr.20051011105014"><vh>exists (g.app.config)</vh></v>
<v t="ekr.20041117083141"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20041121143823"><vh>getValFromDict</vh></v>
<v t="ekr.20051015093141"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20060608224112"><vh>getAbbrevDict</vh></v>
<v t="ekr.20041117081009.3"><vh>getBool</vh></v>
<v t="ekr.20070926082018"><vh>getButtons</vh></v>
<v t="ekr.20041122070339"><vh>getColor</vh></v>
<v t="ekr.20080312071248.7"><vh>getCommonCommands</vh></v>
<v t="ekr.20071214140900.1"><vh>getData</vh></v>
<v t="ekr.20041117093009.1"><vh>getDirectory</vh></v>
<v t="ekr.20070224075914.1"><vh>getEnabledPlugins</vh></v>
<v t="ekr.20041117082135"><vh>getFloat</vh></v>
<v t="ekr.20041117062717.13"><vh>getFontFromParams (config)</vh></v>
<v t="ekr.20041117081513"><vh>getInt</vh></v>
<v t="ekr.20041117093009.2"><vh>getLanguage</vh></v>
<v t="ekr.20070926070412"><vh>getMenusList (c.config)</vh></v>
<v t="ekr.20070411101643"><vh>getOpenWith</vh></v>
<v t="ekr.20041122070752"><vh>getRatio</vh></v>
<v t="ekr.20041117062717.11"><vh>getRecentFiles</vh></v>
<v t="ekr.20080917061525.3"><vh>getSettingSource (g.app.config)</vh></v>
<v t="ekr.20041117062717.14"><vh>getShortcut (config)</vh></v>
<v t="ekr.20041117081009.4"><vh>getString</vh></v>
<v t="ekr.20041120074536"><vh>settingsRoot</vh></v>
</v>
<v t="ekr.20100616083554.5922"><vh>Iterators... (g.app.config)</vh>
<v t="ekr.20100616083554.5923"><vh>config_iter_helper</vh></v>
</v>
<v t="ekr.20041118084146"><vh>Setters (g.app.config)</vh>
<v t="ekr.20041118084146.1"><vh>set (g.app.config)</vh></v>
<v t="ekr.20041118084241"><vh>setString</vh></v>
<v t="ekr.20041228042224"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20041201080436"><vh>appendToRecentFiles (g.app.config)</vh></v>
</v>
<v t="ekr.20041117093246"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20041120064303"><vh>readSettingsFiles &amp; helpers (g.app.config)</vh>
<v t="ekr.20101021041958.6008"><vh>getLocalConfigFile</vh></v>
<v t="ekr.20101021041958.6004"><vh>defineSettingsTable</vh></v>
<v t="ekr.20041117085625"><vh>openSettingsFile</vh></v>
<v t="ekr.20051013161232"><vh>updateSettings</vh></v>
</v>
<v t="ekr.20041117083857.1"><vh>g.app.config.readSettings</vh></v>
</v>
<v t="ekr.20050424114937.1"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20070224115832"><vh>readRecentFiles &amp; helpers</vh>
<v t="ekr.20061010121944"><vh>createRecentFiles</vh></v>
<v t="ekr.20050424115658"><vh>readRecentFilesFile</vh></v>
</v>
<v t="ekr.20050424114937.2"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20050424131051"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20070418073400"><vh>g.app.config.printSettings</vh></v>
</v>
<v t="ekr.20041119203941.3"><vh>class settingsTreeParser (parserBaseClass)</vh>
<v t="ekr.20041119204103"><vh>ctor</vh></v>
<v t="ekr.20041119204714"><vh>visitNode (settingsTreeParser)</vh></v>
</v>
</v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh>
<v t="ekr.20050710151017"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050920084036.1"><vh>&lt;&lt; define class baseEditCommandsClass &gt;&gt;</vh>
<v t="ekr.20050920084036.2"><vh> ctor, finishCreate, init (baseEditCommandsClass)</vh></v>
<v t="ekr.20051214132256"><vh>begin/endCommand (baseEditCommands)</vh>
<v t="ekr.20051214133130"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20051215102349"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20051214133130.1"><vh>endCommand</vh></v>
</v>
<v t="ekr.20061007105001"><vh>editWidget (baseEditCommandsClass)</vh></v>
<v t="ekr.20050920084036.5"><vh>getPublicCommands &amp; getStateCommands</vh></v>
<v t="ekr.20050920084036.6"><vh>getWSString</vh></v>
<v t="ekr.20050920084036.7"><vh>oops</vh></v>
<v t="ekr.20050929161635"><vh>Helpers</vh>
<v t="ekr.20050920084036.249"><vh>_chckSel</vh></v>
<v t="ekr.20050920084036.250"><vh>_checkIfRectangle</vh></v>
<v t="ekr.20050920084036.233"><vh>getRectanglePoints</vh></v>
<v t="ekr.20051002090441"><vh>keyboardQuit</vh></v>
</v>
</v>
<v t="ekr.20050924100713"><vh> Module level... (leoEditCommands)</vh>
<v t="ekr.20050920084720"><vh>createEditCommanders (leoEditCommands module)</vh></v>
<v t="ekr.20050922104731"><vh>finishCreateEditCommanders (leoEditCommands module)</vh></v>
<v t="ekr.20050924100713.1"><vh>initAllEditCommanders</vh></v>
</v>
<v t="ekr.20050920084036.13"><vh>abbrevCommandsClass</vh>
<v t="ekr.20100901080826.6002"><vh> Birth</vh>
<v t="ekr.20100901080826.6003"><vh>ctor</vh></v>
<v t="ekr.20100901080826.6004"><vh>finishCreate (abbrevClass)</vh></v>
<v t="ekr.20050920084036.15"><vh>getPublicCommands &amp; getStateCommands</vh></v>
</v>
<v t="ekr.20100901080826.6155"><vh> Entry point</vh>
<v t="ekr.20050920084036.27"><vh>expandAbbrev</vh></v>
</v>
<v t="ekr.20100901080826.5850"><vh>aproposAbbreviations</vh></v>
<v t="ekr.20050920084036.58"><vh>dynamic abbreviation...</vh>
<v t="ekr.20050920084036.60"><vh>dynamicCompletion</vh></v>
<v t="ekr.20050920084036.59"><vh>dynamicExpansion</vh>
<v t="ekr.20070605110441"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20050920084036.61"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20070531103114"><vh>static abbrevs</vh>
<v t="ekr.20100901080826.6001"><vh>addAbbrevHelper</vh></v>
<v t="ekr.20050920084036.25"><vh>addAbbreviation</vh></v>
<v t="ekr.20051004080550"><vh>addInverseAbbreviation</vh></v>
<v t="ekr.20050920084036.18"><vh>killAllAbbrevs</vh></v>
<v t="ekr.20050920084036.19"><vh>listAbbrevs</vh></v>
<v t="ekr.20050920084036.20"><vh>readAbbreviations &amp; helper</vh>
<v t="ekr.20100901080826.6156"><vh>readAbbreviationsFromFile</vh></v>
</v>
<v t="ekr.20050920084036.23"><vh>toggleAbbrevMode</vh></v>
<v t="ekr.20050920084036.24"><vh>writeAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20050920084036.31"><vh>bufferCommandsClass</vh>
<v t="ekr.20050920084036.32"><vh> ctor (bufferCommandsClass)</vh></v>
<v t="ekr.20050920084036.33"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.34"><vh>Entry points</vh>
<v t="ekr.20050920084036.35"><vh>appendToBuffer</vh></v>
<v t="ekr.20050920084036.36"><vh>copyToBuffer</vh></v>
<v t="ekr.20050920084036.37"><vh>insertToBuffer</vh></v>
<v t="ekr.20050920084036.38"><vh>killBuffer</vh></v>
<v t="ekr.20050920084036.42"><vh>listBuffers &amp; listBuffersAlphabetically</vh></v>
<v t="ekr.20050920084036.39"><vh>prependToBuffer</vh></v>
<v t="ekr.20050920084036.43"><vh>renameBuffer</vh></v>
<v t="ekr.20050920084036.40"><vh>switchToBuffer</vh></v>
</v>
<v t="ekr.20050927102133.1"><vh>Utils</vh>
<v t="ekr.20051215121416"><vh>computeData</vh></v>
<v t="ekr.20051215164823"><vh>findBuffer</vh></v>
<v t="ekr.20050927093851"><vh>getBufferName</vh></v>
</v>
</v>
<v t="ekr.20070522085324"><vh>chapterCommandsClass</vh>
<v t="ekr.20070522085340"><vh> ctor</vh></v>
<v t="ekr.20070522085429"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
<v t="ekr.20050920084036.150"><vh>controlCommandsClass</vh>
<v t="ekr.20050920084036.151"><vh> ctor</vh></v>
<v t="ekr.20050920084036.152"><vh> getPublicCommands</vh></v>
<v t="ekr.20050922110030"><vh>advertizedUndo</vh></v>
<v t="ekr.20050920084036.160"><vh>executeSubprocess</vh></v>
<v t="ekr.20070429090859"><vh>print plugins info...</vh></v>
<v t="ekr.20060603161041"><vh>setSilentMode</vh></v>
<v t="ekr.20050920084036.158"><vh>shellCommand</vh></v>
<v t="ekr.20050930112126"><vh>shellCommandOnRegion</vh></v>
<v t="ville.20090222184600.2"><vh>actOnNode</vh></v>
<v t="ekr.20050920084036.155"><vh>shutdown, saveBuffersKillEmacs &amp; setShutdownHook</vh></v>
<v t="ekr.20050920084036.153"><vh>suspend &amp; iconifyFrame</vh></v>
</v>
<v t="ekr.20060127162818.1"><vh>debugCommandsClass</vh>
<v t="ekr.20060127162921"><vh> ctor</vh></v>
<v t="ekr.20060127163325"><vh> getPublicCommands</vh></v>
<v t="ekr.20060205050659"><vh>collectGarbage</vh></v>
<v t="ekr.20060519003651"><vh>debug &amp; helper</vh>
<v t="ekr.20060521140213"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20060202160523"><vh>dumpAll/New/VerboseObjects</vh></v>
<v t="ekr.20060127163325.1"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20060202154734"><vh>freeTreeWidgets</vh></v>
<v t="ekr.20090226080753.8"><vh>pdb</vh></v>
<v t="ekr.20060210100432"><vh>printFocus</vh></v>
<v t="ekr.20060205043324.3"><vh>printGcSummary</vh></v>
<v t="ekr.20060202133313"><vh>printStats</vh></v>
<v t="ekr.20060328121145"><vh>runUnitTest commands</vh></v>
</v>
<v t="ekr.20050920084036.53"><vh>editCommandsClass</vh>
<v t="ekr.20050929155208"><vh> birth</vh>
<v t="ekr.20050920084036.54"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20050920084036.55"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20061012113455"><vh>doNothing</vh></v>
</v>
<v t="ekr.20100209160132.5763"><vh>cache (leoEditCommands)</vh></v>
<v t="ekr.20050920084036.57"><vh>capitalization &amp; case</vh>
<v t="ekr.20051015114221"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20050920084036.145"><vh>changePreviousWord (not used)</vh></v>
<v t="ekr.20051015114221.1"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20051022142249"><vh>clicks and focus (editCommandsClass)</vh>
<v t="ekr.20060211100905"><vh>activate-x-menu &amp; activateMenu (editCommandsClass)</vh></v>
<v t="ekr.20051022144825.1"><vh>cycleFocus</vh></v>
<v t="ekr.20060613090701"><vh>cycleAllFocus</vh></v>
<v t="ekr.20051022144825"><vh>focusTo...</vh></v>
<v t="ekr.20060211063744.1"><vh>clicks in the headline</vh></v>
<v t="ekr.20060211055455"><vh>clicks in the icon box</vh></v>
<v t="ekr.20060211062025"><vh>clickClickBox</vh></v>
<v t="ekr.20060211063744.2"><vh>simulate...Drag</vh></v>
</v>
<v t="ekr.20051019183105"><vh>color &amp; font</vh>
<v t="ekr.20051019183105.1"><vh>show-colors</vh></v>
<v t="ekr.20051019201809"><vh>editCommands.show-fonts &amp; helpers</vh></v>
</v>
<v t="ekr.20050920084036.132"><vh>comment column...</vh>
<v t="ekr.20050920084036.133"><vh>setCommentColumn</vh></v>
<v t="ekr.20050920084036.134"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20050920084036.62"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20050920084036.63"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20050920084036.64"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20050920084036.65"><vh>evalExpression</vh></v>
<v t="ekr.20050920084036.66"><vh>fill column and centering</vh>
<v t="ekr.20050920084036.67"><vh>centerLine</vh></v>
<v t="ekr.20050920084036.68"><vh>setFillColumn</vh></v>
<v t="ekr.20050920084036.69"><vh>centerRegion</vh></v>
<v t="ekr.20050920084036.70"><vh>setFillPrefix</vh></v>
<v t="ekr.20050920084036.71"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060417194232"><vh>find (quick)</vh>
<v t="ekr.20060925151926"><vh>backward/findCharacter &amp; helper</vh>
<v t="ekr.20060417194232.1"><vh>findCharacterHelper</vh></v>
</v>
<v t="ekr.20060417194232.2"><vh>findWord and FindWordOnLine &amp; helper</vh>
<v t="ekr.20080408060320.1"><vh>findWordHelper</vh></v>
</v>
</v>
<v t="ekr.20050920084036.72"><vh>goto...</vh>
<v t="ekr.20050929115226"><vh>gotoCharacter</vh></v>
<v t="ekr.20060417181052"><vh>gotoGlobalLine</vh></v>
<v t="ekr.20050929124234"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20071114081313"><vh>icons...</vh>
<v t="ekr.20080108092811"><vh> Helpers</vh>
<v t="ekr.20080108091349"><vh>appendImageDictToList</vh></v>
<v t="ekr.20090701125429.6013"><vh>dHash</vh></v>
<v t="tbrown.20080119085249"><vh>getIconList</vh></v>
<v t="tbrown.20080119085249.1"><vh>setIconList &amp; helpers</vh>
<v t="ekr.20090701125429.6012"><vh>_setIconListHelper</vh></v>
</v>
</v>
<v t="ekr.20071114082418"><vh>deleteFirstIcon</vh></v>
<v t="ekr.20071114092622"><vh>deleteIconByName</vh></v>
<v t="ekr.20071114085054"><vh>deleteLastIcon</vh></v>
<v t="ekr.20071114082418.1"><vh>deleteNodeIcons</vh></v>
<v t="ekr.20071114081313.1"><vh>insertIcon</vh></v>
<v t="ekr.20080108090719"><vh>insertIconFromFile</vh></v>
</v>
<v t="ekr.20050920084036.74"><vh>indent...</vh>
<v t="ekr.20050920084036.76"><vh>deleteIndentation</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20050920084036.85"><vh>insert &amp; delete...</vh>
<v t="ekr.20060417171125"><vh>addSpace/TabToLines &amp; removeSpace/TabFromLines &amp; helper</vh>
<v t="ekr.20060417172056"><vh>addRemoveHelper</vh></v>
</v>
<v t="ekr.20051026092433.1"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20070325094935"><vh>cleanAllLines</vh></v>
<v t="ekr.20060415112257"><vh>cleanLines</vh></v>
<v t="ekr.20060414085834"><vh>clearSelectedText</vh></v>
<v t="ekr.20100817125519.5833"><vh>delete-word &amp; backward-delete-word</vh></v>
<v t="ekr.20050920084036.87"><vh>deleteNextChar</vh></v>
<v t="ekr.20050920084036.135"><vh>deleteSpaces</vh></v>
<v t="ekr.20050920084036.138"><vh>insertNewLine</vh></v>
<v t="ekr.20050920084036.86"><vh>insertNewLineAndTab (changed)</vh></v>
<v t="ekr.20050920084036.139"><vh>insertParentheses</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand, helpers</vh>
<v t="ekr.20061103114242"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20090213065933.14"><vh>doPlainTab</vh></v>
<v t="ekr.20060627091557"><vh>flashCharacter</vh></v>
<v t="ekr.20060627083506"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20060804095512"><vh>initBracketMatcher</vh></v>
<v t="ekr.20051026171121"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20051026171121.1"><vh>updateAutoIndent (leoEditCommands)</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20050920084036.79"><vh>info...</vh>
<v t="ekr.20050920084036.80"><vh>howMany</vh></v>
<v t="ekr.20050920084036.81"><vh>lineNumber</vh></v>
<v t="ekr.20050920084036.83"><vh>viewLossage</vh></v>
<v t="ekr.20050920084036.84"><vh>whatLine</vh></v>
</v>
<v t="ekr.20050920084036.88"><vh>line...</vh>
<v t="ekr.20050920084036.90"><vh>flushLines</vh></v>
<v t="ekr.20051002095724"><vh>keepLines</vh></v>
<v t="ekr.20050920084036.92"><vh>linesHelper</vh></v>
<v t="ekr.20050920084036.77"><vh>splitLine</vh></v>
</v>
<v t="ekr.20050929114218"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20051218170358"><vh> general helpers</vh>
<v t="ekr.20060113130510"><vh>extendHelper</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
<v t="ekr.20060209095101"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20081123102100.1"><vh>backToHome</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20051218141237"><vh>between lines &amp; helper</vh>
<v t="ekr.20060113105246.1"><vh>moveUpOrDownHelper</vh></v>
</v>
<v t="ekr.20050920084036.148"><vh>buffers &amp; helper</vh>
<v t="ekr.20100109094541.6227"><vh>moveToBufferHelper</vh></v>
</v>
<v t="ekr.20051213080533"><vh>characters &amp; helper</vh>
<v t="ekr.20100109094541.6228"><vh>moveToCharacterHelper</vh></v>
</v>
<v t="ekr.20051218174113"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20050920084036.136"><vh>exchangePointMark</vh></v>
<v t="ekr.20061007082956"><vh>extend-to-line</vh></v>
<v t="ekr.20061007214835.4"><vh>extend-to-sentence</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word</vh></v>
<v t="ekr.20050920084036.140"><vh>movePastClose &amp; helper</vh>
<v t="ekr.20051218171457"><vh>movePastCloseHelper</vh></v>
</v>
<v t="ekr.20100109094541.6231"><vh>moveWithinLineHelper</vh></v>
<v t="ekr.20090530181848.6034"><vh>pages &amp; helper</vh>
<v t="ekr.20090530181848.6035"><vh>movePageHelper</vh></v>
</v>
<v t="ekr.20050920084036.102"><vh>paragraphs &amp; helpers</vh>
<v t="ekr.20051218133207"></v>
<v t="ekr.20051218133207.1"><vh>forwardParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.131"><vh>sentences &amp; helpers</vh>
<v t="ekr.20051213094517"><vh>backSentenceHelper</vh></v>
<v t="ekr.20050920084036.137"><vh>forwardSentenceHelper</vh></v>
</v>
<v t="ekr.20100109094541.6232"><vh>within lines</vh></v>
<v t="ekr.20050920084036.149"><vh>words &amp; helper</vh>
<v t="ekr.20051218121447"><vh>moveWordHelper</vh></v>
</v>
</v>
<v t="ekr.20050920084036.95"><vh>paragraph...</vh>
<v t="ekr.20050920084036.99"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20050920084036.100"><vh>fillRegion</vh></v>
<v t="ekr.20050920084036.104"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20050920084036.103"><vh>fillParagraph</vh></v>
<v t="ekr.20050920084036.98"><vh>killParagraph</vh></v>
<v t="ekr.20050920084036.96"><vh>extend-to-paragraph &amp; helper</vh>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20050920084036.105"><vh>region...</vh>
<v t="ekr.20050920084036.108"><vh>tabIndentRegion (indent-rigidly)</vh></v>
<v t="ekr.20050920084036.109"><vh>countRegion</vh></v>
<v t="ekr.20060417183606"><vh>moveLinesDown</vh></v>
<v t="ekr.20060417183606.1"><vh>moveLinesUp</vh></v>
<v t="ekr.20050920084036.110"><vh>reverseRegion</vh></v>
<v t="ekr.20050920084036.111"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060309060654"><vh>scrolling...</vh>
<v t="ekr.20050920084036.147"><vh>measure</vh></v>
<v t="ekr.20050920084036.116"><vh>scrollUp/Down &amp; helper</vh>
<v t="ekr.20060113082917"><vh>scrollHelper</vh></v>
</v>
<v t="ekr.20060309060654.1"><vh>scrollOutlineUp/Down/Line/Page</vh></v>
<v t="ekr.20060726154531"><vh>scrollOutlineLeftRight</vh></v>
</v>
<v t="ekr.20050920084036.117"><vh>sort...</vh>
<v t="ekr.20050920084036.118"><vh>sortLines commands</vh></v>
<v t="ekr.20050920084036.119"><vh>sortColumns</vh></v>
<v t="ekr.20050920084036.120"><vh>sortFields</vh></v>
</v>
<v t="ekr.20050920084036.121"><vh>swap/transpose...</vh>
<v t="ekr.20060529184652"><vh>swapHelper</vh></v>
<v t="ekr.20050920084036.122"><vh>transposeLines</vh></v>
<v t="ekr.20050920084036.123"><vh>swapWords</vh></v>
<v t="ekr.20060529184652.1"><vh>transposeWords (doesn't work)</vh></v>
<v t="ekr.20050920084036.124"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20050920084036.126"><vh>tabify &amp; untabify</vh></v>
<v t="ekr.20061111223516"><vh>selectAllText (leoEditCommands)</vh></v>
</v>
<v t="ekr.20050920084036.161"><vh>editFileCommandsClass</vh>
<v t="ekr.20050920084036.162"><vh> ctor</vh></v>
<v t="ekr.20050920084036.163"><vh> getPublicCommands (editFileCommandsClass)</vh></v>
<v t="ekr.20070920104110"><vh>compareLeoFiles</vh>
<v t="ekr.20070921072608"><vh>computeChangeDicts</vh></v>
<v t="ekr.20070921072910"><vh>createAllCompareClones &amp; helper</vh>
<v t="ekr.20070921074410"><vh>createCompareClones</vh></v>
</v>
<v t="ekr.20070921070101"><vh>createHiddenCommander</vh></v>
<v t="ekr.20070921070101.1"><vh>createFileDict</vh></v>
<v t="ekr.20070921072608.1"><vh>dumpCompareNodes</vh></v>
</v>
<v t="ekr.20050920084036.164"><vh>deleteFile</vh></v>
<v t="ekr.20050920084036.165"><vh>diff (revise)</vh></v>
<v t="ekr.20050920084036.166"><vh>getReadableTextFile</vh></v>
<v t="ekr.20050920084036.167"><vh>insertFile</vh></v>
<v t="ekr.20050920084036.168"><vh>makeDirectory</vh></v>
<v t="ekr.20060419123128"><vh>open-outline-by-name</vh></v>
<v t="ekr.20050920084036.169"><vh>removeDirectory</vh></v>
<v t="ekr.20050920084036.170"><vh>saveFile (changed)</vh></v>
</v>
<v t="ekr.20060205164707"><vh>helpCommandsClass</vh>
<v t="ekr.20060205165501"><vh>getPublicCommands (helpCommands)</vh></v>
<v t="ekr.20051014170754"><vh>helpForMinibuffer</vh></v>
<v t="ekr.20060417203717"><vh>helpForCommand</vh></v>
<v t="ekr.20060226131603.1"><vh>aproposAutocompletion</vh></v>
<v t="ekr.20060205170335"><vh>aproposBindings</vh></v>
<v t="ekr.20070501092655"><vh>aproposDebuggingCommands</vh>
<v t="ekr.20070501092655.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060205170335.1"><vh>aproposFindCommands</vh>
<v t="ekr.20060209082023.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060602154458"><vh>pythonHelp</vh></v>
<v t="ekr.20070418074444"><vh>printSettings</vh></v>
</v>
<v t="ekr.20050920084036.171"><vh>keyHandlerCommandsClass (add docstrings)</vh>
<v t="ekr.20050920084036.172"><vh> ctor</vh></v>
<v t="ekr.20050920084036.173"><vh>getPublicCommands (keyHandler)</vh></v>
</v>
<v t="ekr.20050920084036.174"><vh>killBufferCommandsClass</vh>
<v t="ekr.20050920084036.175"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20050920084036.176"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.183"><vh>addToKillBuffer</vh></v>
<v t="ekr.20050920084036.181"><vh>backwardKillSentence</vh></v>
<v t="ekr.20050920084036.180"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20051216151811"><vh>clearKillRing</vh></v>
<v t="ekr.20050920084036.185"><vh>getClipboard</vh></v>
<v t="ekr.20050920084036.184"><vh>iterateKillBuffer</vh>
<v t="ekr.20071003160252.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20071003160252.2"><vh>next</vh></v>
</v>
<v t="ekr.20050920084036.178"><vh>kill</vh></v>
<v t="ekr.20071003183657"><vh>KillLine</vh></v>
<v t="ekr.20050920084036.182"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20050930095323.1"><vh>killSentence</vh></v>
<v t="ekr.20050930100733"><vh>killWs</vh></v>
<v t="ekr.20050930091642.1"><vh>yank</vh></v>
<v t="ekr.20050930091642.2"><vh>yankPop</vh></v>
<v t="ekr.20050920084036.128"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20050920084036.186"><vh>leoCommandsClass (add docstrings)</vh>
<v t="ekr.20050920084036.187"><vh> ctor</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050920084036.190"><vh>macroCommandsClass</vh>
<v t="ekr.20050920084036.191"><vh> ctor</vh></v>
<v t="ekr.20050920084036.192"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920085536.15"><vh>addToDoAltX (common helper)</vh></v>
<v t="ekr.20050920084036.202"><vh>callLastKeyboardMacro</vh></v>
<v t="ekr.20050920084036.194"><vh>callNamedMacro</vh></v>
<v t="ekr.20050920084036.206"><vh>endKbdMacro</vh></v>
<v t="ekr.20050920084036.203"><vh>executeMacro</vh></v>
<v t="ekr.20050920084036.196"><vh>loadFile &amp; helper</vh>
<v t="ekr.20050920084036.197"><vh>loadMacros</vh></v>
</v>
<v t="ekr.20050920084036.198"><vh>nameLastKbdMacro</vh></v>
<v t="ekr.20090201152408.1"><vh>printMacros</vh></v>
<v t="ekr.20050920084036.199"><vh>saveMacros &amp; helpers</vh>
<v t="ekr.20050920084036.200"><vh>saveMacrosHelper</vh></v>
</v>
<v t="ekr.20050920084036.204"><vh>startKbdMacro</vh></v>
</v>
<v t="ekr.20050920084036.221"><vh>rectangleCommandsClass</vh>
<v t="ekr.20050920084036.222"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20051004112630"><vh>check</vh></v>
<v t="ekr.20050920084036.223"><vh>getPublicCommands</vh></v>
<v t="ekr.20051215103053"><vh>beginCommand &amp; beginCommandWithEvent (rectangle)</vh></v>
<v t="ekr.20050920084036.224"><vh>Entries (rectangleCommandsClass)</vh>
<v t="ekr.20050920084036.225"><vh>clearRectangle</vh></v>
<v t="ekr.20050920084036.226"><vh>closeRectangle</vh></v>
<v t="ekr.20050920084036.227"><vh>deleteRectangle</vh></v>
<v t="ekr.20050920084036.228"><vh>killRectangle</vh></v>
<v t="ekr.20050920084036.230"><vh>openRectangle</vh></v>
<v t="ekr.20050920084036.232"></v>
<v t="ekr.20050920084036.229"></v>
</v>
</v>
<v t="ekr.20050920084036.234"><vh>registerCommandsClass</vh>
<v t="ekr.20051004095209"><vh>Birth</vh>
<v t="ekr.20050920084036.235"><vh> ctor, finishCreate &amp; init</vh></v>
<v t="ekr.20050920084036.247"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.252"><vh>addRegisterItems</vh></v>
</v>
<v t="ekr.20051004123217"><vh>checkBodySelection</vh></v>
<v t="ekr.20050920084036.236"><vh>Entries... (register commands)</vh>
<v t="ekr.20050920084036.238"><vh>appendToRegister</vh></v>
<v t="ekr.20050920084036.237"><vh>prependToRegister</vh></v>
<v t="ekr.20050920084036.239"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20050920084036.240"><vh>copyToRegister</vh></v>
<v t="ekr.20050920084036.241"><vh>incrementRegister</vh></v>
<v t="ekr.20050920084036.242"><vh>insertRegister</vh></v>
<v t="ekr.20050920084036.243"><vh>jumpToRegister</vh></v>
<v t="ekr.20050920084036.244"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20050920084036.245"><vh>pointToRegister</vh></v>
<v t="ekr.20050920084036.246"><vh>viewRegister</vh></v>
</v>
</v>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20060123125256"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060123125317.2"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20090126063121.1"><vh>editWidget (minibufferFind)</vh></v>
<v t="ekr.20060124140114"><vh> Options (minibufferFind)</vh>
<v t="ekr.20060124123133"><vh>setFindScope</vh></v>
<v t="ekr.20060124122844"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20060125074939"><vh>showFindOptions</vh></v>
<v t="ekr.20060205105950"><vh>setupChangePattern</vh></v>
<v t="ekr.20060125091234"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060210180352"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20060210164421"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20070105123800"><vh>changeAll (minibufferFind)</vh></v>
<v t="ekr.20060128080201"><vh>cloneFindAll</vh></v>
<v t="ekr.20060204120158"><vh>findAgain</vh></v>
<v t="ekr.20060209064140"><vh>findAll</vh></v>
<v t="ekr.20060205105950.1"><vh>generalChangeHelper (minibufferFind)</vh></v>
<v t="ekr.20060124181213.4"><vh>generalSearchHelper</vh></v>
<v t="ekr.20060210174441"><vh>lastStateHelper</vh></v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh></v>
<v t="ekr.20060124140224.3"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060124140224.1"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060125093807"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060124134356"><vh>setupArgs</vh></v>
<v t="ekr.20060210173041"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060224171851"><vh>updateChange/FindList</vh></v>
<v t="ekr.20060124140224.2"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor (searchCommandsClass)</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060123131421"><vh>Top-level methods</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>Find Tab commands</vh></v>
<v t="ekr.20060124115801"><vh>getHandler</vh></v>
<v t="ekr.20060123115459"><vh>Find options wrappers</vh></v>
<v t="ekr.20060124093828"><vh>Find wrappers</vh></v>
<v t="ekr.20060204120158.2"><vh>findAgain</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20090204084607.1"><vh>abortSearch</vh></v>
<v t="ekr.20060203072636"><vh>endSearch</vh></v>
<v t="ekr.20090204084607.2"><vh>iSearch</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20090204084607.4"><vh>iSearchBackspace</vh></v>
<v t="ekr.20090204084607.6"><vh>getStrokes</vh></v>
<v t="ekr.20090204084607.5"><vh>push &amp; pop</vh></v>
<v t="ekr.20090205085858.1"><vh>setWidget</vh></v>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
</v>
</v>
</v>
<v t="ekr.20051025071455"><vh>Spell classes</vh>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...(spellCommandsClass)</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTabHandler.__init__</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add (spellTab)</vh></v>
<v t="ekr.20051025071455.38"><vh>change (spellTab)</vh></v>
<v t="ekr.20051025071455.40"><vh>find &amp; helpers</vh>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh></v>
<v t="ekr.20051025071455.47"><vh>findNextWord (spellTab)</vh></v>
</v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20100904095239.5914"><vh>class EnchantClass</vh>
<v t="ekr.20100904095239.5916"><vh> __init__ (EnchantClass)</vh></v>
<v t="ekr.20100904095239.5927"><vh>add</vh></v>
<v t="ekr.20100904095239.5928"><vh>ignore</vh></v>
<v t="ekr.20100904095239.5920"><vh>processWord</vh></v>
</v>
</v>
<v t="ekr.20050922104213"><vh>&lt;&lt; define classesList &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh>
<v t="ekr.20050405141130"><vh>&lt;&lt; imports &gt;&gt; (leoFileCommands)</vh></v>
<v t="ekr.20060918164811"><vh>&lt;&lt; define exception classes &gt;&gt;</vh></v>
<v t="ekr.20060919145406"><vh>&lt;&lt; define sax classes &gt;&gt;</vh>
<v t="ekr.20060919110638.19"><vh>class saxContentHandler (XMLGenerator)</vh>
<v t="ekr.20060919110638.20"><vh> __init__ &amp; helpers</vh>
<v t="ekr.20060919110638.21"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20060919110638.29"><vh> Do nothing</vh></v>
<v t="ekr.20060919134313"><vh> Utils</vh>
<v t="ekr.20060919110638.23"><vh>attrsToList</vh></v>
<v t="ekr.20060919110638.26"><vh>error</vh></v>
<v t="ekr.20060919110638.27"><vh>inElement</vh></v>
<v t="ekr.20060919110638.28"><vh>printStartElement</vh>
<v t="ekr.20060919110638.24"><vh>attrsToString</vh></v>
<v t="ekr.20060919110638.25"><vh>clean</vh></v>
</v>
</v>
<v t="ekr.20060919110638.30"><vh>characters</vh></v>
<v t="ekr.20060919110638.31"><vh>endElement &amp; helpers</vh>
<v t="ekr.20060919110638.32"><vh>endTnode</vh></v>
<v t="ekr.20060919110638.33"><vh>endVnode</vh></v>
<v t="ekr.20060919110638.34"><vh>endVH</vh></v>
</v>
<v t="ekr.20060919110638.45"><vh>getRootNode</vh></v>
<v t="ekr.20061004054323"><vh>processingInstruction (stylesheet)</vh></v>
<v t="ekr.20060919110638.35"><vh>startElement &amp; helpers</vh>
<v t="ekr.20060919110638.36"><vh>getWindowPositionAttributes</vh></v>
<v t="ekr.20060919110638.37"><vh>startGlobals (sax read)</vh></v>
<v t="ekr.20060919110638.38"><vh>startWinPos</vh></v>
<v t="ekr.20060919110638.39"><vh>startLeoHeader</vh></v>
<v t="ekr.20060919110638.40"><vh>startVH</vh></v>
<v t="ekr.20060919112118"><vh>startVnodes</vh></v>
<v t="ekr.20060919110638.41"><vh>startTnode</vh>
<v t="ekr.20060919110638.42"><vh>tnodeAttributes</vh></v>
</v>
<v t="ekr.20060919110638.43"><vh>startVnode</vh>
<v t="ekr.20060919110638.44"><vh>vnodeAttributes</vh></v>
</v>
</v>
</v>
<v t="ekr.20060919110638.15"><vh>class saxNodeClass</vh>
<v t="ekr.20060919110638.16"><vh> node.__init__</vh></v>
<v t="ekr.20060919110638.17"><vh> node.__str__ &amp; __repr__</vh></v>
<v t="ekr.20060919110638.18"><vh>node.dump</vh></v>
</v>
</v>
<v t="ekr.20090218115025.4"><vh>Birth</vh>
<v t="ekr.20031218072017.3019"><vh>leoFileCommands._init_</vh></v>
<v t="ekr.20090218115025.5"><vh>initIvars</vh></v>
</v>
<v t="ekr.20031218072017.3020"><vh>Reading</vh>
<v t="ekr.20060919104836"><vh> Top-level</vh>
<v t="ekr.20070919133659.1"><vh>checkLeoFile (fileCommands)</vh></v>
<v t="ekr.20031218072017.1559"><vh>getLeoOutlineFromClipboard &amp; helpers</vh>
<v t="ekr.20080410115129.1"><vh>checkPaste</vh></v>
</v>
<v t="ekr.20031218072017.1553"><vh>fc.getLeoFile &amp; helpers</vh>
<v t="ekr.20090526081836.5841"><vh>fc.getLeoFileHelper</vh></v>
<v t="ekr.20100205060712.8314"><vh>fc.handleNodeConflicts &amp; helper</vh>
<v t="ekr.20100701112151.5959"><vh>getDiff</vh></v>
</v>
<v t="ekr.20100124110832.6212"><vh>fc.propegateDirtyNodes</vh></v>
<v t="ekr.20031218072017.1554"><vh>fc.warnOnReadOnlyFiles</vh></v>
</v>
<v t="ekr.20031218072017.3029"><vh>readAtFileNodes (fileCommands)</vh></v>
<v t="ekr.20031218072017.2297"><vh>open (leoFileCommands)</vh></v>
<v t="ekr.20031218072017.3030"><vh>readOutlineOnly</vh>
<v t="ekr.20071211134300"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060919133249"><vh>Common</vh>
<v t="ekr.20031218072017.2004"><vh>canonicalTnodeIndex</vh></v>
<v t="ekr.20040701065235.1"><vh>getDescendentAttributes</vh></v>
<v t="EKR.20040627114602"><vh>getDescendentUnknownAttributes</vh></v>
<v t="ekr.20060919142200.1"><vh>initReadIvars</vh></v>
<v t="EKR.20040627120120"><vh>restoreDescendentAttributes</vh></v>
</v>
<v t="ekr.20060919104530"><vh>Sax (reading)</vh>
<v t="ekr.20090525144314.6526"><vh>cleanSaxInputString</vh></v>
<v t="ekr.20060919110638.5"><vh>fc.createSaxChildren &amp; helpers</vh>
<v t="ekr.20060919110638.7"><vh>fc.createSaxVnode &amp; helpers</vh>
<v t="ekr.20060919110638.8"><vh>handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>handleVnodeSaxAttributes</vh></v>
</v>
</v>
<v t="ekr.20060919110638.2"><vh>dumpSaxTree</vh></v>
<v t="ekr.20061003093021"><vh>getSaxUa</vh></v>
<v t="ekr.20060919110638.14"><vh>parse_leo_file</vh></v>
<v t="ekr.20060919110638.3"><vh>readSaxFile</vh></v>
<v t="ekr.20060919110638.11"><vh>resolveTnodeLists</vh></v>
<v t="ekr.20080805132422.3"><vh>resolveArchivedPosition  (New in Leo 4.5)</vh></v>
<v t="ekr.20060919110638.13"><vh>setPositionsFromVnodes &amp; helper (sax read)</vh>
<v t="ekr.20061006104837.1"><vh>archivedPositionToPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3032"><vh>Writing</vh>
<v t="ekr.20070413045221.2"><vh> Top-level  (leoFileCommands)</vh>
<v t="ekr.20031218072017.1720"><vh>save (fileCommands)</vh></v>
<v t="ekr.20031218072017.3043"><vh>saveAs (leoFileCommands)</vh></v>
<v t="ekr.20031218072017.3044"><vh>saveTo (leoFileCommands)</vh></v>
<v t="ekr.20070413061552"><vh>putSavedMessage</vh></v>
</v>
<v t="ekr.20050404190914.2"><vh>deleteFileWithMessage (leoFileCommands)</vh></v>
<v t="ekr.20031218072017.1470"><vh>put (leoFileCommands)</vh></v>
<v t="ekr.20031218072017.1971"><vh>putClipboardHeader</vh></v>
<v t="ekr.20040324080819.1"><vh>putLeoFile &amp; helpers</vh>
<v t="ekr.20031218072017.3035"><vh>putFindSettings</vh></v>
<v t="ekr.20031218072017.3037"><vh>putGlobals</vh>
<v t="ekr.20031218072017.3038"><vh>&lt;&lt; put the body/outline ratios &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3039"><vh>&lt;&lt; put the position of this frame &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3040"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3041"><vh>putHeader</vh></v>
<v t="ekr.20031218072017.3042"><vh>putPostlog</vh></v>
<v t="ekr.20031218072017.2066"><vh>putPrefs</vh></v>
<v t="ekr.20031218072017.1246"><vh>putProlog</vh></v>
<v t="ekr.20031218072017.1248"><vh>putStyleSheetLine</vh></v>
<v t="ekr.20031218072017.1577"><vh>putTnode</vh></v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Set gnx = vnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Append unKnownAttributes to attrs&gt;&gt; fc.put</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1579"><vh>putVnodes</vh></v>
<v t="ekr.20031218072017.1247"><vh>putXMLLine</vh></v>
</v>
<v t="ekr.20031218072017.1573"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="ekr.20060919064401"><vh>putToOPML</vh></v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file &amp; helpers</vh>
<v t="ekr.20100119145629.6109"><vh>checkOutline</vh></v>
<v t="ekr.20040324080359.1"><vh>isReadOnly</vh></v>
<v t="ekr.20100119145629.6114"><vh>writeAllAtFileNodesHelper</vh></v>
<v t="ekr.20100119145629.6111"><vh>writeToFileHelper &amp; helpers</vh>
<v t="ekr.20100119145629.6106"><vh>createActualFile</vh></v>
<v t="ekr.20031218072017.3047"><vh>createBackupFile</vh></v>
<v t="ekr.20100119145629.6108"><vh>handleWriteLeoFileException</vh></v>
</v>
<v t="ekr.20100119145629.6110"><vh>writeToStringHelper</vh></v>
<v t="ekr.20070412095520"><vh>writeZipFile</vh></v>
</v>
<v t="ekr.20031218072017.2012"><vh>writeAtFileNodes (fileCommands)</vh></v>
<v t="ekr.20080801071227.5"><vh>writeAtShadowNodes (fileCommands)</vh></v>
<v t="ekr.20031218072017.1666"><vh>writeDirtyAtFileNodes (fileCommands)</vh></v>
<v t="ekr.20080801071227.6"><vh>writeDirtyAtShadowNodes (fileCommands)</vh></v>
<v t="ekr.20031218072017.2013"><vh>writeMissingAtFileNodes</vh></v>
<v t="ekr.20031218072017.3050"><vh>writeOutlineOnly</vh></v>
</v>
<v t="ekr.20080805114146.2"><vh>Utils</vh>
<v t="ekr.20031218072017.1570"><vh>assignFileIndices &amp; compactFileIndices</vh></v>
<v t="ekr.20080805085257.1"><vh>createUaList</vh></v>
<v t="ekr.20080805085257.2"><vh>pickle</vh></v>
<v t="ekr.20040701065235.2"><vh>putDescendentAttributes</vh></v>
<v t="ekr.20080805071954.2"><vh>putDescendentVnodeUas</vh></v>
<v t="ekr.20050418161620.2"><vh>putUaHelper</vh></v>
<v t="EKR.20040526202501"><vh>putUnknownAttributes</vh></v>
<v t="ekr.20031218072017.3045"><vh>setDefaultDirectoryForNewFiles (fileCommands)</vh></v>
<v t="ekr.20080412172151.2"><vh>updateFixedStatus</vh></v>
</v>
</v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh>
<v t="ekr.20031218072017.2414"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="ekr.20070105092022.1"><vh>class searchWidget</vh>
<v t="ekr.20070105092438"><vh>ctor</vh></v>
<v t="ekr.20070105093138"><vh>getters</vh></v>
<v t="ekr.20070105102419"><vh>setters</vh></v>
<v t="ekr.20070105092022.4"><vh>toPythonIndex</vh></v>
</v>
<v t="ekr.20061212084717"><vh>class leoFind</vh>
<v t="ekr.20031218072017.3053"><vh>leoFind.__init__ &amp; helpers</vh>
<v t="ekr.20041121145452"><vh>&lt;&lt; compute self.title &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3054"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20050123164539"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060123065756.1"><vh>Top Level Buttons</vh>
<v t="ekr.20031218072017.3057"><vh>changeAllButton</vh></v>
<v t="ekr.20031218072017.3056"><vh>changeButton</vh></v>
<v t="ekr.20031218072017.3058"><vh>changeThenFindButton</vh></v>
<v t="ekr.20031218072017.3060"><vh>findAllButton</vh></v>
<v t="ekr.20031218072017.3059"><vh>findButton</vh></v>
<v t="ekr.20031218072017.3065"><vh>setup_button</vh></v>
</v>
<v t="ekr.20031218072017.3055"><vh>Top Level Commands</vh>
<v t="ekr.20031218072017.3061"><vh>changeCommand</vh></v>
<v t="ekr.20031218072017.3062"><vh>changeThenFindCommand</vh></v>
<v t="ekr.20051013084200.1"><vh>dismiss: defined in subclass class</vh></v>
<v t="ekr.20031218072017.3063"><vh>findNextCommand</vh></v>
<v t="ekr.20031218072017.3064"><vh>findPreviousCommand</vh></v>
<v t="EKR.20040503070514"><vh>handleUserClick</vh></v>
<v t="ekr.20031218072017.3066"><vh>setup_command</vh></v>
</v>
<v t="ekr.20031218072017.3067"><vh>Find/change utils</vh>
<v t="ekr.20031218072017.2293"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20031218072017.2294"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2295"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3068"><vh>change</vh></v>
<v t="ekr.20031218072017.3069"><vh>changeAll (leoFind)</vh></v>
<v t="ekr.20031218072017.3070"><vh>changeSelection</vh>
<v t="ekr.20060526201951"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20031218072017.3071"><vh>changeThenFind</vh></v>
<v t="ekr.20031218072017.2417"><vh>doChange...Script</vh></v>
<v t="ekr.20031218072017.3072"><vh>doFind...Script</vh></v>
<v t="ekr.20031218072017.3073"><vh>findAll</vh>
<v t="ekr.20051113110735"><vh>&lt;&lt; create the found node &gt;&gt;</vh></v>
<v t="ekr.20051113110851"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3074"><vh>findNext</vh></v>
<v t="ekr.20031218072017.3075"><vh>findNextMatch</vh></v>
<v t="ekr.20031218072017.3076"><vh>resetWrap</vh></v>
<v t="ekr.20031218072017.3077"><vh>search &amp; helpers</vh>
<v t="ekr.20060526140328"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20060526081931"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20060526092203"><vh>regexHelper</vh></v>
<v t="ekr.20060526140744"><vh>backwardsHelper</vh></v>
<v t="ekr.20060526093531"><vh>plainHelper</vh></v>
<v t="ekr.20060526140744.1"><vh>matchWord</vh></v>
<v t="ekr.20070105165924"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3081"><vh>selectNextPosition</vh></v>
</v>
<v t="ekr.20061212095134.1"><vh>General utils</vh>
<v t="ekr.20051020120306.26"><vh>bringToFront (leoFind)</vh></v>
<v t="ekr.20061111084423.1"><vh>oops (leoFind)</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText (leoFind)</vh></v>
</v>
<v t="ekr.20031218072017.3082"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20031218072017.3083"><vh>checkArgs</vh></v>
<v t="ekr.20031218072017.3084"><vh>initBatchCommands</vh></v>
<v t="ekr.20031218072017.3085"><vh>initBatchText, initNextText &amp; init_s_ctrl</vh></v>
<v t="ekr.20031218072017.3086"><vh>initInHeadline</vh></v>
<v t="ekr.20031218072017.3087"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20031218072017.3088"><vh>printLine</vh></v>
<v t="ekr.20031218072017.3089"><vh>restore</vh></v>
<v t="ekr.20031218072017.3090"><vh>save (leoFind)</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess (leoFind)</vh></v>
<v t="ekr.20031218072017.1460"><vh>update_ivars (leoFind)</vh></v>
</v>
</v>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind)</vh>
<v t="ekr.20051020120306.11"><vh>__init__ &amp; initGui</vh></v>
<v t="ekr.20060221074900"><vh>Callbacks</vh>
<v t="ekr.20060221074900.1"><vh>findButtonCallback</vh></v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
</v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070105123638"><vh>changeAllCommand</vh></v>
<v t="ekr.20060128075225"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20060204120158.1"><vh>findAgainCommand</vh></v>
<v t="ekr.20060209064832"><vh>findAllCommand</vh></v>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
</v>
<v t="ekr.20061212092124"><vh>Defined in subclasses</vh></v>
</v>
<v t="ekr.20070302090616"><vh>class nullFindTab class (findTab)</vh>
<v t="ekr.20070302090616.1"><vh>Birth (nullFindTab)</vh>
<v t="ekr.20070302090616.2"><vh> ctor (nullFindTab)</vh></v>
<v t="ekr.20070302090616.3"><vh>initGui</vh></v>
<v t="ekr.20070302090616.4"><vh>init</vh>
<v t="ekr.20070302090616.5"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20070302090616.6"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
<v t="ekr.20070302090616.7"><vh>&lt;&lt; set checkboxes from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070302090616.15"><vh>createBindings</vh></v>
<v t="ekr.20070302090616.9"><vh>createFrame</vh>
<v t="ekr.20070302090616.10"><vh>createFindChangeAreas</vh></v>
<v t="ekr.20070302090616.12"><vh>createBoxes</vh></v>
<v t="ekr.20070302090616.14"><vh>createButtons (not used)</vh></v>
</v>
</v>
<v t="ekr.20070302090616.8"><vh>class svar (nullFindTab)</vh></v>
<v t="ekr.20070302092907"><vh>class buttonWidget (nullFindTab)</vh></v>
<v t="ekr.20070302090616.16"><vh>Options</vh>
<v t="ekr.20070302090616.17"><vh>getOption</vh></v>
<v t="ekr.20070302090616.18"><vh>setOption</vh></v>
<v t="ekr.20070302090616.19"><vh>toggleOption</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3093"><vh>@file leoGlobals.py</vh>
<v t="ekr.20050208101229"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="EKR.20040610094819"><vh>&lt;&lt; define globalDirectiveList &gt;&gt;</vh></v>
<v t="ekr.20090521175848.5881"><vh>&lt;&lt; define the nullObject class &gt;&gt;</vh></v>
<v t="ekr.20050328133058"><vh>g.createStandAloneTkApp</vh></v>
<v t="ekr.20031218072017.3095"><vh>Checking Leo Files...</vh>
<v t="ekr.20031218072017.822"><vh>createTopologyList</vh></v>
</v>
<v t="ekr.20031218072017.3099"><vh>Commands &amp; Directives</vh>
<v t="ekr.20050304072744"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20050328133444"><vh>g.computeStandardDirectories &amp; helpers</vh>
<v t="ekr.20041117155521"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20041117151301"><vh>computeHomeDir</vh></v>
<v t="ekr.20060416113431"><vh>computeLeoDir</vh></v>
<v t="ekr.20031218072017.1937"><vh>computeLoadDir</vh>
<v t="ville.20090703102253.6160"><vh>&lt;&lt; resolve symlinks &gt;&gt;</vh></v>
</v>
<v t="dan.20080410121257.1"><vh>computeMachineName</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1380"><vh>g.Directive utils...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20090214075058.8"><vh>g.findAtTabWidthDirectives (must be fast)</vh></v>
<v t="ekr.20090214075058.6"><vh>g.findLanguageDirectives (must be fast)</vh></v>
<v t="ekr.20031218072017.1385"><vh>g.findReference</vh></v>
<v t="ekr.20090214075058.9"><vh>g.get_directives_dict (must be fast)</vh>
<v t="ekr.20090214075058.10"><vh>compute_directives_re</vh></v>
</v>
<v t="ekr.20080827175609.1"><vh>g.get_directives_dict_list (must be fast)</vh></v>
<v t="ekr.20031218072017.1386"><vh>g.getOutputNewline</vh></v>
<v t="ekr.20080827175609.52"><vh>g.scanAtCommentAndLanguageDirectives</vh></v>
<v t="ekr.20080827175609.32"><vh>g.scanAtEncodingDirectives</vh></v>
<v t="ekr.20080827175609.53"><vh>g.scanAtHeaderDirectives</vh></v>
<v t="ekr.20080827175609.33"><vh>g.scanAtLineendingDirectives</vh></v>
<v t="ekr.20080827175609.34"><vh>g.scanAtPagewidthDirectives</vh></v>
<v t="ekr.20101022172109.6108"><vh>g.scanAtPathDirectives scanAllAtPathDirectives</vh></v>
<v t="ekr.20100507084415.5760"><vh>g.scanAtRootDirectives</vh></v>
<v t="ekr.20031218072017.3154"><vh>g.scanAtRootOptions</vh>
<v t="ekr.20031218072017.3155"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20080827175609.37"><vh>g.scanAtTabwidthDirectives &amp; scanAllTabWidthDirectives</vh></v>
<v t="ekr.20080831084419.4"><vh>g.scanAtWrapDirectives &amp; scanAllAtWrapDirectives</vh></v>
<v t="ekr.20080901195858.4"><vh>g.scanDirectives  (for compatibility only)</vh></v>
<v t="ekr.20040715155607"></v>
<v t="ekr.20040712084911.1"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20041123094807"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20031218072017.1382"><vh>g.set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>g.set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>g.set_language</vh></v>
<v t="ekr.20081001062423.9"><vh>g.setDefaultDirectory &amp; helper</vh>
<v t="ekr.20101022124309.6132"><vh>g.checkOpenDirectory</vh></v>
</v>
<v t="ekr.20071109165315"><vh>g.stripPathCruft</vh></v>
</v>
<v t="ekr.20031218072017.3100"><vh>wrap_lines</vh>
<v t="ekr.20031218072017.3101"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3102"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3104"><vh>Debugging, Dumping, Timing, Tracing &amp; Sherlock</vh>
<v t="ekr.20031218072017.3105"><vh>alert</vh></v>
<v t="ekr.20051023083258"><vh>callers &amp; _callerName</vh>
<v t="ekr.20031218072017.3107"><vh>_callerName</vh></v>
</v>
<v t="ekr.20041105091148"><vh>g.pdb</vh></v>
<v t="ekr.20031218072017.3108"><vh>Dumps</vh>
<v t="ekr.20031218072017.3109"><vh>dump</vh></v>
<v t="ekr.20060917120951"><vh>es_dump</vh></v>
<v t="ekr.20031218072017.3110"><vh>es_error &amp; es_print_error</vh></v>
<v t="ekr.20031218072017.3111"><vh>es_event_exception</vh></v>
<v t="ekr.20031218072017.3112"><vh>es_exception</vh></v>
<v t="ekr.20061015090538"><vh>es_exception_type</vh></v>
<v t="ekr.20040731204831"><vh>getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20031218072017.3113"><vh>printBindings</vh></v>
<v t="ekr.20031218072017.3114"><vh>printGlobals</vh></v>
<v t="ekr.20070510074941"><vh>g.printEntireTree</vh></v>
<v t="ekr.20031218072017.3115"><vh>printLeoModules</vh></v>
</v>
<v t="ekr.20031218072017.1317"><vh>file/module/plugin_date</vh></v>
<v t="ekr.20031218072017.3121"><vh>redirecting stderr and stdout to Leo's log pane</vh>
<v t="ekr.20031218072017.1656"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh>
<v t="ekr.20041012082437"><vh>redirectClass.__init__</vh></v>
<v t="ekr.20041012082437.1"><vh>isRedirected</vh></v>
<v t="ekr.20041012082437.2"><vh>flush</vh></v>
<v t="ekr.20041012091252"><vh>rawPrint</vh></v>
<v t="ekr.20041012082437.3"><vh>redirect</vh></v>
<v t="ekr.20041012082437.4"><vh>undirect</vh></v>
<v t="ekr.20041012082437.5"><vh>write</vh></v>
</v>
<v t="ekr.20031218072017.3122"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh>
<v t="ekr.20041012090942"><vh>redirectStderr &amp; redirectStdout</vh></v>
<v t="ekr.20041012090942.1"><vh>restoreStderr &amp; restoreStdout</vh></v>
<v t="ekr.20041012090942.2"><vh>stdErrIsRedirected &amp; stdOutIsRedirected</vh></v>
<v t="ekr.20041012090942.3"><vh>rawPrint</vh></v>
</v>
<v t="ekr.20031218072017.3123"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
<v t="ekr.20080729142651.1"><vh>g.getIvarsDict and checkUnchangedIvars</vh></v>
<v t="ekr.20031218072017.3127"><vh>g.get_line &amp; get_line__after</vh></v>
<v t="ekr.20031218072017.3128"><vh>pause</vh></v>
<v t="ekr.20050819064157"><vh>print_obj &amp; toString</vh></v>
<v t="ekr.20041224080039"><vh>print_dict &amp; dictToString</vh></v>
<v t="ekr.20041126060136"><vh>print_list &amp; listToString</vh></v>
<v t="ekr.20041122153823"><vh>print_stack (printStack)</vh></v>
<v t="ekr.20031218072017.3129"><vh>Sherlock... (trace)</vh>
<v t="ekr.20031218072017.3130"><vh>init_sherlock</vh></v>
<v t="ekr.20031218072017.3131"><vh>get_Sherlock_args</vh></v>
<v t="ekr.20031218072017.3132"><vh>init_trace</vh></v>
<v t="ekr.20031218072017.2317"><vh>g.trace (revised)</vh></v>
<v t="ekr.20031218072017.2318"><vh>trace_tag</vh></v>
</v>
<v t="ekr.20031218072017.3133"><vh>Statistics</vh>
<v t="ekr.20031218072017.3134"><vh>clear_stats</vh></v>
<v t="ekr.20031218072017.3135"><vh>print_stats</vh></v>
<v t="ekr.20031218072017.3136"><vh>stat</vh></v>
</v>
<v t="ekr.20031218072017.3137"><vh>Timing</vh></v>
<v t="ekr.20080531075119.1"><vh>class Tracer &amp; g.startTracer</vh>
<v t="ekr.20080531075119.2"><vh> __init__</vh></v>
<v t="ekr.20080531075119.3"><vh>computeName</vh></v>
<v t="ekr.20080531075119.4"><vh>report</vh></v>
<v t="ekr.20080531075119.5"><vh>stop</vh></v>
<v t="ekr.20080531075119.6"><vh>tracer</vh></v>
<v t="ekr.20080531075119.7"><vh>updateStats</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3116"><vh>Files &amp; Directories...</vh>
<v t="ekr.20080606074139.2"><vh>g.chdir</vh></v>
<v t="ekr.20031218072017.3117"><vh>g.create_temp_file</vh></v>
<v t="ekr.20031218072017.3118"><vh>g.ensure_extension</vh></v>
<v t="ekr.20031218072017.1264"><vh>g.getBaseDirectory</vh></v>
<v t="ville.20090701144325.14942"><vh>g.guessExternalEditor</vh></v>
<v t="tbrown.20090219095555.61"></v>
<v t="ekr.20100329071036.5744"><vh>g.is_binary_file</vh></v>
<v t="EKR.20040504154039"><vh>g.is_sentinel</vh>
<v t="ekr.20040719161756"><vh>&lt;&lt; is_sentinel doc tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3119"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20071114113736"><vh>g.makePathRelativeTo</vh></v>
<v t="ekr.20070412082527"><vh>g.openLeoOrZipFile</vh></v>
<v t="ekr.20090520055433.5945"><vh>g.openWithFileName &amp; helpers</vh>
<v t="ekr.20090520055433.5951"><vh>g.createMenu</vh></v>
<v t="ekr.20090520055433.5948"><vh>g.findOpenFile</vh></v>
<v t="ekr.20090520055433.5952"><vh>g.finishOpen</vh></v>
<v t="ekr.20090520055433.5950"><vh>g.handleOpenHooks</vh></v>
<v t="ekr.20090520055433.5954"><vh>g.mungeFileName</vh></v>
<v t="ekr.20090520055433.5946"><vh>g.openWithFileNameHelper</vh>
<v t="ekr.20090520055433.5949"><vh>preRead</vh></v>
</v>
<v t="ekr.20080921154026.1"><vh>g.openWrapperLeoFile</vh></v>
</v>
<v t="ekr.20100125073206.8710"><vh>g.readFileIntoString (Leo 4.7)</vh></v>
<v t="ekr.20031218072017.3120"><vh>g.readlineForceUnixNewline</vh></v>
<v t="ekr.20031218072017.3124"><vh>g.sanitize_filename</vh></v>
<v t="ekr.20060328150113"><vh>g.setGlobalOpenDir</vh></v>
<v t="ekr.20031218072017.3125"><vh>g.shortFileName &amp; shortFilename</vh></v>
<v t="ekr.20050104135720"><vh>Used by tangle code &amp; leoFileCommands</vh>
<v t="ekr.20031218072017.1241"><vh>g.update_file_if_changed</vh></v>
<v t="ekr.20050104123726.3"><vh>g.utils_remove</vh></v>
<v t="ekr.20031218072017.1263"><vh>g.utils_rename</vh></v>
<v t="ekr.20050104124903"><vh>g.utils_chmod</vh></v>
<v t="ekr.20050104123726.4"><vh>g.utils_stat</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1588"><vh>Garbage Collection</vh>
<v t="ekr.20031218072017.1589"><vh>clearAllIvars</vh></v>
<v t="ekr.20031218072017.1590"><vh>collectGarbage</vh></v>
<v t="ekr.20060127162818"><vh>enable_gc_debug</vh></v>
<v t="ekr.20031218072017.1592"><vh>printGc</vh>
<v t="ekr.20031218072017.1593"><vh>printGcRefs</vh></v>
</v>
<v t="ekr.20060202161935"><vh>printGcAll</vh></v>
<v t="ekr.20060127164729.1"><vh>printGcObjects   (printNewObjects=pno)</vh>
<v t="ekr.20040703054646"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
<v t="ekr.20040703065638"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20060205043324.1"><vh>printGcSummary</vh></v>
<v t="ekr.20060127165509"><vh>printGcVerbose</vh></v>
</v>
<v t="ekr.20031218072017.3139"><vh>Hooks &amp; plugins (leoGlobals)</vh>
<v t="ekr.20031218072017.1315"><vh>idle time functions (leoGlobals)</vh>
<v t="EKR.20040602125018"><vh>enableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.1"><vh>disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20031218072017.1596"><vh>g.doHook</vh></v>
<v t="ville.20090521164644.5924"><vh>g.command (decorator for creating global commands)</vh></v>
<v t="ekr.20100910075900.5950"><vh>Wrappers for g.app.pluginController methods</vh>
<v t="ekr.20100910075900.5951"><vh>Loading &amp; registration</vh></v>
<v t="ekr.20100910075900.5952"><vh>Information</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3145"><vh>Most common functions...</vh>
<v t="ekr.20031218072017.3147"><vh>g.choose</vh></v>
<v t="ekr.20080821073134.2"><vh>g.doKeywordArgs</vh></v>
<v t="ekr.20031218072017.1474"><vh>g.enl, ecnl &amp; ecnls</vh></v>
<v t="ekr.20100914094836.5892"><vh>g.error, g.note &amp; g.warning</vh></v>
<v t="ekr.20070626132332"><vh>g.es &amp; minitest</vh>
<v t="ekr.20071024101611"><vh>mini test of es</vh></v>
</v>
<v t="ekr.20050707064040"><vh>g.es_print</vh></v>
<v t="ekr.20050707065530"><vh>g.es_trace</vh></v>
<v t="ekr.20100126062623.6240"><vh>g.internalError</vh></v>
<v t="ekr.20090128083459.82"><vh>g.posList</vh>
<v t="ekr.20090130114732.2"><vh>&lt;&lt; docstring for posList &gt;&gt;</vh></v>
</v>
<v t="ekr.20080710101653.1"><vh>g.pr</vh></v>
<v t="ekr.20080220111323"><vh>g.translateArgs</vh></v>
<v t="ekr.20060810095921"><vh>g.translateString &amp; tr</vh></v>
<v t="ekr.20031218072017.3150"><vh>g.windows</vh></v>
</v>
<v t="ekr.20031218072017.2145"><vh>os.path wrappers (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2146"><vh>os_path_abspath</vh></v>
<v t="ekr.20031218072017.2147"><vh>os_path_basename</vh></v>
<v t="ekr.20031218072017.2148"><vh>os_path_dirname</vh></v>
<v t="ekr.20031218072017.2149"><vh>os_path_exists</vh></v>
<v t="ekr.20080922124033.6"><vh>os_path_expandExpression</vh></v>
<v t="ekr.20080921060401.13"><vh>os_path_expanduser</vh></v>
<v t="ekr.20080921060401.14"><vh>g.os_path_finalize &amp; os_path_finalize_join</vh></v>
<v t="ekr.20031218072017.2150"><vh>os_path_getmtime</vh></v>
<v t="ekr.20080729142651.2"><vh>os_path_getsize</vh></v>
<v t="ekr.20031218072017.2151"></v>
<v t="ekr.20031218072017.2152"><vh>os_path_isdir</vh></v>
<v t="ekr.20031218072017.2153"><vh>os_path_isfile</vh></v>
<v t="ekr.20031218072017.2154"><vh>os_path_join</vh></v>
<v t="ekr.20031218072017.2156"><vh>os_path_normcase</vh></v>
<v t="ekr.20031218072017.2157"><vh>os_path_normpath</vh></v>
<v t="ekr.20080605064555.2"><vh>os_path_realpath</vh></v>
<v t="ekr.20031218072017.2158"><vh>os_path_split</vh></v>
<v t="ekr.20031218072017.2159"><vh>os_path_splitext</vh></v>
<v t="ekr.20090829140232.6036"><vh>os_startfile</vh></v>
<v t="ekr.20031218072017.2160"><vh>toUnicodeFileEncoding</vh></v>
</v>
<v t="ekr.20031218072017.3151"><vh>Scanning... (leoGlobals.py)</vh>
<v t="ekr.20031218072017.3156"><vh>scanError</vh></v>
<v t="ekr.20031218072017.3157"><vh>scanf</vh></v>
<v t="ekr.20031218072017.3158"><vh>Scanners: calling scanError</vh>
<v t="ekr.20031218072017.3159"><vh>skip_block_comment</vh></v>
<v t="ekr.20031218072017.3160"><vh>skip_braces</vh></v>
<v t="ekr.20031218072017.3161"><vh>skip_php_braces (no longer used)</vh></v>
<v t="ekr.20031218072017.3162"><vh>skip_parens</vh></v>
<v t="ekr.20031218072017.3163"><vh>skip_pascal_begin_end</vh></v>
<v t="ekr.20031218072017.3164"><vh>skip_pascal_block_comment</vh></v>
<v t="ekr.20031218072017.3165"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="ekr.20031218072017.3166"><vh>skip_heredoc_string : called by php import (Dave Hein)</vh></v>
<v t="ekr.20031218072017.3167"><vh>skip_pp_directive</vh></v>
<v t="ekr.20031218072017.3168"><vh>skip_pp_if</vh></v>
<v t="ekr.20031218072017.3169"><vh>skip_pp_part</vh></v>
<v t="ekr.20031218072017.3170"><vh>skip_python_string</vh></v>
<v t="ekr.20031218072017.2369"><vh>skip_string</vh></v>
<v t="ekr.20031218072017.3171"><vh>skip_to_semicolon</vh></v>
<v t="ekr.20031218072017.3172"><vh>skip_typedef</vh></v>
</v>
<v t="ekr.20031218072017.3173"><vh>Scanners: no error messages</vh>
<v t="ekr.20031218072017.3174"><vh>escaped</vh></v>
<v t="ekr.20031218072017.3175"><vh>find_line_start</vh></v>
<v t="ekr.20031218072017.3176"><vh>find_on_line</vh></v>
<v t="ekr.20031218072017.3177"><vh>is_c_id</vh></v>
<v t="ekr.20031218072017.3178"><vh>is_nl</vh></v>
<v t="ekr.20031218072017.3179"><vh>is_special</vh></v>
<v t="ekr.20031218072017.3180"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20031218072017.3181"><vh>match</vh></v>
<v t="ekr.20031218072017.3182"><vh>match_c_word</vh></v>
<v t="ekr.20031218072017.3183"><vh>match_ignoring_case</vh></v>
<v t="ekr.20031218072017.3184"><vh>match_word</vh></v>
<v t="ekr.20031218072017.3185"><vh>skip_blank_lines</vh></v>
<v t="ekr.20031218072017.3186"><vh>skip_c_id</vh></v>
<v t="ekr.20040705195048"><vh>skip_id</vh></v>
<v t="ekr.20031218072017.3187"><vh>skip_line, skip_to_start/end_of_line</vh></v>
<v t="ekr.20031218072017.3188"><vh>skip_long</vh></v>
<v t="ekr.20031218072017.3189"><vh>skip_matching_python_delims</vh></v>
<v t="ekr.20060627080947"><vh>skip_matching_python_parens</vh></v>
<v t="ekr.20031218072017.3190"><vh>skip_nl</vh></v>
<v t="ekr.20031218072017.3191"><vh>skip_non_ws</vh></v>
<v t="ekr.20031218072017.3192"><vh>skip_pascal_braces</vh></v>
<v t="ekr.20031218072017.3193"><vh>skip_to_char</vh></v>
<v t="ekr.20031218072017.3194"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="ekr.20031218072017.3195"><vh>splitLines &amp; joinLines</vh></v>
</v>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20050503112513.7"><vh>g.executeFile</vh>
<v t="ekr.20050503112513.8"><vh>&lt;&lt; define subprocess_wrapper &gt;&gt;</vh></v>
</v>
<v t="ekr.20040321065415"><vh>g.findNode... &amp;,findTopLevelNode</vh></v>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh></v>
<v t="ekr.20060624085200"><vh>g.handleScriptException</vh>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
</v>
<v t="ekr.20031218072017.1498"><vh>Unicode utils...</vh>
<v t="ekr.20100125073206.8709"><vh>g.getPythonEncodingFromString</vh></v>
<v t="ekr.20080816125725.2"><vh>g.isBytes, isCallable, isChar, isString &amp; isUnicode</vh></v>
<v t="ekr.20031218072017.1500"><vh>g.isValidEncoding</vh></v>
<v t="ekr.20061006152327"><vh>g.isWordChar &amp; g.isWordChar1</vh></v>
<v t="ekr.20031218072017.1501"><vh>g.reportBadChars</vh></v>
<v t="ekr.20050208093800"><vh>g.toEncodedString</vh></v>
<v t="ekr.20050208093800.1"><vh>g.toUnicode</vh></v>
<v t="ekr.20091206161352.6232"><vh>g.u &amp; g.ue</vh></v>
<v t="ekr.20080919065433.2"><vh>toEncodedStringWithErrorCode (for unit testing)</vh></v>
<v t="ekr.20080919065433.1"><vh>toUnicodeWithErrorCode (for unit testing)</vh></v>
</v>
<v t="ekr.20070524083513"><vh>Unit testing (leoGlobals.py)</vh>
<v t="ekr.20070619173330"><vh>g.getTestVars</vh></v>
<v t="ekr.20100812172650.5909"><vh>g.findTestScript</vh></v>
</v>
<v t="EKR.20040612114220"><vh>Utility classes, functions &amp; objects...</vh>
<v t="ekr.20050315073003"><vh> Index utilities... (leoGlobals)</vh>
<v t="ekr.20050314140957"><vh>g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20050315071727"><vh>g.convertRowColToPythonIndex</vh></v>
</v>
<v t="ekr.20031218072017.3140"><vh> List utilities...</vh>
<v t="ekr.20031218072017.3141"><vh>appendToList</vh></v>
<v t="ekr.20031218072017.3142"><vh>flattenList</vh></v>
<v t="ekr.20060221081328"><vh>maxStringListLength</vh></v>
</v>
<v t="ekr.20031218072017.3106"><vh>angleBrackets &amp; virtual_event_name</vh></v>
<v t="ekr.20031218072017.3097"><vh>CheckVersion</vh>
<v t="ekr.20060921100435"><vh>CheckVersion, helper</vh>
<v t="ekr.20070120123930"><vh>CheckVersionToInt</vh></v>
</v>
<v t="ekr.20060921100435.1"><vh>oldCheckVersion (Dave Hein)</vh></v>
</v>
<v t="ekr.20031218072017.3098"><vh>class Bunch (object)</vh></v>
<v t="ekr.20031219074948.1"><vh>class nullObject</vh></v>
<v t="ekr.20031218072017.3103"><vh>g.computeWindowTitle</vh></v>
<v t="ekr.20090516135452.5777"><vh>g.ensureLeading/TrailingNewlines</vh></v>
<v t="ekr.20031218072017.3138"><vh>g.executeScript</vh></v>
<v t="ekr.20040331083824.1"><vh>g.fileLikeObject</vh>
<v t="ekr.20050404151753"><vh> ctor</vh></v>
<v t="ekr.20050404151753.1"><vh>clear</vh></v>
<v t="ekr.20050404151753.2"><vh>close</vh></v>
<v t="ekr.20050404151753.3"><vh>flush</vh></v>
<v t="ekr.20050404151753.4"><vh>get &amp; getvalue &amp; read</vh></v>
<v t="ekr.20050404151753.5"><vh>readline</vh></v>
<v t="ekr.20050404151753.6"><vh>write</vh></v>
</v>
<v t="ekr.20031218072017.3126"><vh>g.funcToMethod</vh></v>
<v t="ekr.20050920084036.4"><vh>g.longestCommonPrefix &amp; g.itemsMatchingPrefixInList</vh></v>
<v t="ekr.20031218072017.3144"><vh>g.makeDict</vh></v>
<v t="ekr.20060221083356"><vh>g.prettyPrintType</vh></v>
<v t="ekr.20090516135452.5776"><vh>g.removeLeading/Trailing</vh></v>
<v t="ekr.20060410112600"><vh>g.stripBrackets</vh></v>
<v t="ekr.20061031102333.2"><vh>g.getWord &amp; getLine</vh></v>
<v t="ekr.20041219095213"><vh>import wrappers</vh>
<v t="ekr.20040917061619"><vh>g.cantImport</vh></v>
<v t="ekr.20041219095213.1"><vh>g.importModule</vh></v>
<v t="ekr.20041219071407"><vh>g.importExtension &amp; helpers</vh>
<v t="ekr.20060329083657"><vh>cantImportDialog &amp; helpers</vh>
<v t="ekr.20060329083310.1"><vh>createDialogFrame</vh></v>
<v t="ekr.20060329083310.2"><vh>createDialogButtons</vh></v>
<v t="ekr.20060329085417.1"><vh>center</vh></v>
<v t="ekr.20060329085612"><vh>get_window_info</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2278"><vh>g.importFromPath</vh></v>
</v>
<v t="ekr.20040629162023"><vh>readLines class and generator</vh>
<v t="EKR.20040612114220.3"><vh>g.readLinesGenerator</vh></v>
<v t="EKR.20040612114220.4"><vh>class readLinesClass</vh></v>
</v>
<v t="ville.20090827174345.9963"><vh>g.assertui</vh></v>
</v>
<v t="ekr.20031218072017.3197"><vh>Whitespace...</vh>
<v t="ekr.20031218072017.3198"><vh>computeLeadingWhitespace</vh></v>
<v t="ekr.20031218072017.3199"><vh>computeWidth</vh></v>
<v t="ekr.20051014175117"><vh>g.adjustTripleString</vh></v>
<v t="ekr.20050211120242.2"><vh>g.removeExtraLws</vh></v>
<v t="ekr.20031218072017.3200"><vh>get_leading_ws</vh></v>
<v t="ekr.20031218072017.3201"><vh>optimizeLeadingWhitespace</vh></v>
<v t="ekr.20040723093558"><vh>regularizeTrailingNewlines</vh></v>
<v t="ekr.20091229090857.11698"><vh>removeBlankLines</vh></v>
<v t="ekr.20091229075924.6235"><vh>removeLeadingBlankLines</vh></v>
<v t="ekr.20031218072017.3202"><vh>removeLeadingWhitespace</vh></v>
<v t="ekr.20031218072017.3203"><vh>removeTrailingWs</vh></v>
<v t="ekr.20031218072017.3204"><vh>skip_leading_ws</vh></v>
<v t="ekr.20031218072017.3205"><vh>skip_leading_ws_with_indent</vh></v>
<v t="ekr.20040723093558.1"><vh>stripBlankLines</vh></v>
</v>
<v t="ekr.20060913091602"><vh>ZODB support</vh>
<v t="ekr.20060913090832.1"><vh>g.init_zodb</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh>
<v t="ekr.20100728074713.5840"><vh>&lt;&lt; how to write a new importer &gt;&gt;</vh></v>
<v t="ekr.20091224155043.6539"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="sps.20081112093624.1"><vh>&lt;&lt; class scanUtility &gt;&gt;</vh>
<v t="sps.20081111154528.5"><vh>escapeFalseSectionReferences</vh></v>
</v>
<v t="ekr.20071127175948"><vh>&lt;&lt; class leoImportCommands &gt;&gt;</vh>
<v t="ekr.20031218072017.3207"><vh>import.__init__ &amp; helper</vh>
<v t="ekr.20080825131124.3"></v>
</v>
<v t="ekr.20031218072017.3289"><vh>Export</vh>
<v t="ekr.20031218072017.3290"><vh>convertCodePartToWeb</vh>
<v t="ekr.20031218072017.3291"><vh>&lt;&lt; put v's headline ref in head_ref&gt;&gt;</vh></v>
<v t="ekr.20031218072017.3292"><vh>&lt;&lt; put name following @root or @file in file_name &gt;&gt;</vh>
<v t="ekr.20031218072017.3293"><vh>&lt;&lt; Set file_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3294"><vh>&lt;&lt; append ref to file_name &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3295"><vh>&lt;&lt; append head_ref &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3296"><vh>convertDocPartToWeb (handle @ %def)</vh></v>
<v t="ekr.20031218072017.3297"><vh>convertVnodeToWeb</vh>
<v t="ekr.20031218072017.3298"><vh>&lt;&lt; Supply a missing doc part &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3299"><vh>copyPart</vh></v>
<v t="ekr.20031218072017.1462"><vh>exportHeadlines (changed)</vh></v>
<v t="ekr.20031218072017.1147"><vh>flattenOutline (changed)</vh></v>
<v t="ekr.20031218072017.1148"><vh>outlineToWeb (changed)</vh></v>
<v t="ekr.20031218072017.3300"><vh>removeSentinelsCommand</vh>
<v t="ekr.20031218072017.3302"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1149"><vh>&lt;&lt; Write s into newFileName &gt;&gt; (remove-sentinels) (changed)</vh></v>
</v>
<v t="ekr.20031218072017.3303"><vh>removeSentinelLines</vh></v>
<v t="ekr.20031218072017.1464"><vh>weave (changed)</vh>
<v t="ekr.20031218072017.1150"><vh>&lt;&lt; open filename to f, or return &gt;&gt; (weave)</vh></v>
<v t="ekr.20031218072017.1465"><vh>&lt;&lt; write the context of p to f &gt;&gt; (weave)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3305"><vh>Utilities</vh>
<v t="ekr.20090122201952.4"><vh>appendStringToBody &amp; setBodyString (leoImport)</vh></v>
<v t="ekr.20031218072017.3306"><vh>createHeadline (leoImport)</vh></v>
<v t="ekr.20031218072017.3307"><vh>error</vh></v>
<v t="ekr.20041126042730"><vh>getTabWidth</vh></v>
<v t="ekr.20031218072017.3309"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20031218072017.3312"><vh>massageWebBody</vh>
<v t="ekr.20031218072017.3313"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3314"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1463"><vh>setEncoding (leoImport)</vh></v>
</v>
<v t="ekr.20031218072017.3209"><vh>Import</vh>
<v t="ekr.20031218072017.3210"></v>
<v t="ekr.20070806111212"><vh>readAtAutoNodes (importCommands) &amp; helper</vh>
<v t="ekr.20070807084545"><vh>readOneAtAutoNode (leoImport)</vh></v>
</v>
<v t="ekr.20031218072017.1810"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3212"><vh>importFilesCommand</vh>
<v t="ekr.20031218072017.3213"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3214"><vh>importFlattenedOutline &amp; allies</vh>
<v t="ekr.20031218072017.3215"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="ekr.20031218072017.3216"><vh>&lt;&lt; Link a new position p into the outline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3217"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3218"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3219"><vh>&lt;&lt; Add the lines to the body text of p &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3220"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20031218072017.3222"><vh>moreHeadlineLevel</vh></v>
<v t="ekr.20031218072017.3223"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="ekr.20031218072017.3224"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20031218072017.3225"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20031218072017.3226"><vh>importWebCommand</vh></v>
<v t="ekr.20031218072017.3227"><vh>findFunctionDef</vh></v>
<v t="ekr.20031218072017.3228"><vh>scanBodyForHeadline</vh>
<v t="ekr.20031218072017.3229"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3230"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3231"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20031218072017.3232"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3233"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3234"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20031218072017.3235"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3236"><vh>Symbol table</vh>
<v t="ekr.20031218072017.3237"><vh>cstCanonicalize</vh></v>
<v t="ekr.20031218072017.3238"><vh>cstDump</vh></v>
<v t="ekr.20031218072017.3239"><vh>cstEnter</vh></v>
<v t="ekr.20031218072017.3240"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20070713075450"><vh>Unit tests</vh>
<v t="ekr.20070713082220"><vh>scannerUnitTest</vh></v>
</v>
</v>
<v t="ekr.20071127175948.1"><vh>Import scanners</vh>
<v t="edreamleo.20070710110153"><vh>scanCText</vh></v>
<v t="ekr.20071008130845.1"><vh>scanCSharpText</vh></v>
<v t="ekr.20070711060107.1"><vh>scanElispText</vh></v>
<v t="ekr.20100803231223.5808"><vh>scanIniText</vh></v>
<v t="edreamleo.20070710110114.2"><vh>scanJavaText</vh></v>
<v t="ekr.20071027111225.1"><vh>scanJavaScriptText</vh></v>
<v t="ekr.20101027055033.5967"></v>
<v t="ekr.20070711104241.2"><vh>scanPascalText</vh></v>
<v t="ekr.20070711090122"><vh>scanPHPText</vh></v>
<v t="ekr.20070703122141.99"><vh>scanPythonText</vh></v>
<v t="ekr.20090501095634.48"><vh>scanRstText</vh></v>
<v t="ekr.20071214072145"><vh>scanXmlText</vh></v>
<v t="ekr.20070713075352"><vh>scanUnknownFileType (default scanner) &amp; helper</vh>
<v t="ekr.20080811174246.1"></v>
</v>
</v>
</v>
<v t="ekr.20070703122141.65"><vh>&lt;&lt; class baseScannerClass &gt;&gt;</vh>
<v t="ekr.20070703122141.66"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20070808115837"><vh>Checking</vh>
<v t="ekr.20070703122141.102"><vh>check</vh></v>
<v t="ekr.20070703122141.104"><vh>checkTrialWrite (baseScannerClass)</vh></v>
<v t="ekr.20070730093735"><vh>compareHelper &amp; helpers</vh>
<v t="ekr.20091227115606.6468"><vh>adjustRstLines</vh></v>
<v t="ekr.20090513073632.5735"><vh>compareRstUnderlines</vh></v>
</v>
<v t="ekr.20071110144948"><vh>checkLeadingWhitespace</vh></v>
<v t="ekr.20070911110507"><vh>reportMismatch</vh></v>
</v>
<v t="ekr.20070706084535"><vh>Code generation</vh>
<v t="ekr.20090512080015.5800"><vh>adjustParent</vh></v>
<v t="ekr.20070707073044.1"><vh>addRef</vh></v>
<v t="ekr.20090122201952.6"><vh>appendStringToBody &amp; setBodyString (baseScannerClass)</vh></v>
<v t="ekr.20090512153903.5806"><vh>computeBody (baseScannerClass)</vh></v>
<v t="ekr.20090513073632.5737"><vh>createDeclsNode</vh></v>
<v t="ekr.20070707085612"><vh>createFunctionNode</vh></v>
<v t="ekr.20070703122141.77"><vh>createHeadline (baseScannerClass)</vh></v>
<v t="ekr.20090502071837.1"><vh>endGen</vh></v>
<v t="ekr.20070703122141.79"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070709094002"><vh>indentBody</vh></v>
<v t="ekr.20070705085335"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20070707113832.1"><vh>putClass &amp; helpers</vh>
<v t="ekr.20070707190351"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20070703122141.105"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20070703122141.106"><vh>getClassNodeRef</vh></v>
<v t="ekr.20070707171329"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20070707082432"><vh>putFunction (baseScannerClass)</vh></v>
<v t="ekr.20070705094630"><vh>putRootText</vh></v>
<v t="ekr.20090122201952.5"><vh>setBodyString</vh></v>
<v t="ekr.20070703122141.88"><vh>undentBody</vh></v>
<v t="ekr.20081216090156.1"><vh>undentBy</vh></v>
<v t="ekr.20070801074524"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20070703122141.78"><vh>error, oops, report and warning</vh></v>
<v t="ekr.20070706084535.1"><vh>Parsing</vh>
<v t="ekr.20071201072917"><vh>adjustDefStart</vh></v>
<v t="ekr.20070707150022"><vh>extendSignature</vh></v>
<v t="ekr.20071017132056"><vh>getIndent</vh></v>
<v t="ekr.20070706101600"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071018084830"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20070712075148"><vh>skipArgs</vh></v>
<v t="ekr.20070707073859"><vh>skipBlock</vh></v>
<v t="ekr.20070712091019"><vh>skipCodeBlock</vh></v>
<v t="ekr.20070711104014"><vh>skipComment &amp; helper</vh>
<v t="ekr.20070707074541"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20070707080042"><vh>skipDecls</vh></v>
<v t="ekr.20070707094858.1"><vh>skipId</vh></v>
<v t="ekr.20070730134936"><vh>skipNewline</vh></v>
<v t="ekr.20070712081451"><vh>skipParens</vh></v>
<v t="ekr.20070707073627.2"><vh>skipString</vh></v>
<v t="ekr.20070711132314"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20070711134534"><vh>getSigId</vh></v>
<v t="ekr.20070711140703"><vh>skipSigStart</vh></v>
<v t="ekr.20070712082913"><vh>skipSigTail</vh></v>
<v t="ekr.20070712112008"><vh>startsHelper</vh></v>
</v>
<v t="ekr.20070711104014.1"><vh>startsComment</vh></v>
<v t="ekr.20070707094858.2"><vh>startsId</vh></v>
<v t="ekr.20070707172732.1"><vh>startsString</vh></v>
</v>
<v t="ekr.20070707072749"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071110105107"><vh>checkBlanksAndTabs</vh></v>
<v t="ekr.20070808115837.1"><vh>regularizeWhitespace</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3241"><vh>&lt;&lt; scanner classes &gt;&gt;</vh>
<v t="edreamleo.20070710093042"><vh>class cScanner</vh></v>
<v t="ekr.20071008130845.2"><vh>class cSharpScanner</vh></v>
<v t="ekr.20070711060113"><vh>class elispScanner</vh>
<v t="ekr.20070711060113.1"><vh> __init__ (elispScanner)</vh></v>
<v t="ekr.20070711060113.2"><vh>Overrides (elispScanner)</vh>
<v t="ekr.20070711060113.3"><vh>startsClass/Function &amp; skipSignature</vh></v>
<v t="ekr.20070711063339"><vh>startsString</vh></v>
<v t="ekr.20100929121021.13743"><vh>skipBlock</vh></v>
<v t="ekr.20100929121021.13745"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20100803231223.5807"><vh>class iniScanner</vh>
<v t="ekr.20100803231223.5810"><vh>startsHelper</vh></v>
<v t="ekr.20100803231223.5815"><vh>isSectionLine</vh></v>
</v>
<v t="edreamleo.20070710085115"><vh>class javaScanner</vh>
<v t="ekr.20071019171430"><vh>javaScanner.__init__</vh></v>
<v t="ekr.20071019170943"><vh>javaScanner.getSigId</vh></v>
</v>
<v t="ekr.20071027111225.2"><vh>class javaScriptScanner</vh>
<v t="ekr.20071027111225.3"><vh>javaScriptScanner.__init__</vh></v>
<v t="ekr.20071102150937"><vh>startsString</vh></v>
<v t="ekr.20071102161115"><vh>skipString</vh></v>
</v>
<v t="ekr.20070711104241.3"><vh>class pascalScanner</vh>
<v t="ekr.20080211065754"><vh>skipArgs</vh></v>
<v t="ekr.20080211065906"><vh>ctor</vh></v>
<v t="ekr.20080211070816"><vh>skipCodeBlock</vh></v>
<v t="ekr.20080211070945"><vh>skipInterface</vh></v>
<v t="ekr.20080211070056"><vh>skipSigTail</vh></v>
<v t="ekr.20080211071959"><vh>putClass &amp; helpers</vh></v>
</v>
<v t="ekr.20100219075946.5742"><vh>class phpScanner</vh>
<v t="ekr.20100219075946.5743"><vh> __init__</vh></v>
<v t="ekr.20100219075946.5744"><vh>isPurePHP</vh></v>
<v t="ekr.20100219075946.5745"><vh>Overrides</vh>
<v t="ekr.20100219075946.5746"><vh>startsString skipString</vh></v>
<v t="ekr.20100219075946.5747"><vh>getSigId</vh></v>
</v>
</v>
<v t="ekr.20070703122141.100"><vh>class pythonScanner</vh>
<v t="ekr.20070703122141.101"><vh> __init__</vh></v>
<v t="ekr.20071201073102.1"><vh>adjustDefStart (python)</vh></v>
<v t="ekr.20070707113839"><vh>extendSignature</vh></v>
<v t="ekr.20070707073627.4"><vh>skipString</vh></v>
<v t="ekr.20070712090019.1"><vh>skipCodeBlock (python) &amp; helpers</vh>
<v t="ekr.20070801080447"><vh>pythonNewlineHelper</vh></v>
<v t="ekr.20100223094350.5834"><vh>skipToTheNextClassOrFunction (New in 4.8)</vh></v>
</v>
<v t="ekr.20070803101619"><vh>skipSigTail</vh></v>
</v>
<v t="ekr.20090501095634.41"><vh>class rstScanner</vh>
<v t="ekr.20090501095634.42"><vh> __init__</vh></v>
<v t="ekr.20090512080015.5798"><vh>adjustParent</vh></v>
<v t="ekr.20091229090857.11694"><vh>computeBody (rst)</vh></v>
<v t="ekr.20090512080015.5797"><vh>computeSectionLevel</vh></v>
<v t="ekr.20090512153903.5810"><vh>createDeclsNode</vh></v>
<v t="ekr.20090502071837.2"><vh>endGen</vh></v>
<v t="ekr.20090501095634.46"><vh>isUnderLine</vh></v>
<v t="ekr.20090501095634.50"><vh>startsComment/ID/String</vh></v>
<v t="ekr.20090501095634.45"><vh>startsHelper</vh></v>
<v t="ekr.20090501095634.47"><vh>startsSection &amp; helper</vh>
<v t="ekr.20091229075924.6234"><vh>getLine</vh></v>
</v>
</v>
<v t="ekr.20071214072145.1"><vh>class xmlScanner</vh>
<v t="ekr.20071214072451"><vh> __init__ (xmlScanner)</vh></v>
<v t="ekr.20071214131818"><vh>addTags</vh></v>
<v t="ekr.20091230062012.6238"><vh>skipId (override base class) &amp; helper</vh>
<v t="ekr.20091230062012.6239"><vh>isWordChar</vh></v>
</v>
<v t="ekr.20071214072924.4"><vh>startsHelper &amp; helpers</vh>
<v t="ekr.20071214072924.3"><vh>skipToEndOfTag</vh></v>
<v t="ekr.20071214075117"><vh>skipToMatchingTag</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh>
<v t="ekr.20061031131434.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20061031131434.2"><vh>&lt;&lt; about 'internal' bindings &gt;&gt;</vh></v>
<v t="ekr.20061031131434.3"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20061031131434.4"><vh>class autoCompleterClass</vh>
<v t="ekr.20061031131434.5"><vh> ctor (autocompleter)</vh>
<v t="ekr.20061031131434.6"><vh>defineClassesDict</vh></v>
<v t="ekr.20061031131434.7"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20061031131434.8"><vh>Top level</vh>
<v t="ekr.20061031131434.9"><vh>autoComplete</vh></v>
<v t="ekr.20061031131434.10"><vh>autoCompleteForce</vh></v>
<v t="ekr.20061031131434.11"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20080924032842.3"><vh>getExternalCompletions</vh></v>
<v t="ekr.20061031131434.12"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20061031131434.13"><vh>showCalltips</vh></v>
<v t="ekr.20061031131434.14"><vh>showCalltipsForce</vh></v>
<v t="ekr.20061031131434.15"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20061031131434.16"><vh>Helpers</vh>
<v t="ekr.20061031131434.17"><vh>.abort &amp; exit (autocompleter) (test)</vh></v>
<v t="ekr.20061031131434.18"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20061031131434.19"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20061031131434.20"><vh>calltip</vh>
<v t="ekr.20061031131434.21"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20061031131434.22"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20061031131434.23"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20061031131434.24"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20061031131434.25"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20061031131434.26"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.27"><vh>chain</vh></v>
<v t="ekr.20061031131434.28"><vh>computeCompletionList</vh></v>
<v t="ekr.20061031131434.29"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20061031131434.30"><vh>doTabCompletion (autocompleter)</vh></v>
<v t="ekr.20061031131434.31"><vh>extendSelection</vh></v>
<v t="ekr.20061031131434.33"><vh>findCalltipWord</vh></v>
<v t="ekr.20080924032842.5"><vh>findAnchor</vh></v>
<v t="ekr.20061031131434.34"><vh>finish</vh></v>
<v t="ekr.20061031131434.35"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20061031131434.36"><vh>getLeadinWord</vh></v>
<v t="ekr.20061031131434.37"><vh>getMembersList</vh></v>
<v t="ekr.20061031131434.38"><vh>info</vh></v>
<v t="ekr.20061031131434.39"><vh>insertNormalChar</vh></v>
<v t="ekr.20061031131434.40"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20061031131434.41"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20061031131434.42"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20061031131434.43"><vh>completeSelf (not used yet)</vh></v>
<v t="ekr.20061031131434.44"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20061031131434.45"><vh>setSelection</vh></v>
<v t="ekr.20061031131434.46"><vh>start</vh></v>
</v>
<v t="ekr.20061031131434.57"><vh>Proxy classes and objects</vh>
<v t="ekr.20061031131434.58"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20061031131434.59"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20061031131434.60"><vh>class forgivingParserClass</vh>
<v t="ekr.20061031131434.61"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20061031131434.62"><vh>parse</vh></v>
<v t="ekr.20061031131434.63"><vh>forgivingParser (leoKeys)</vh></v>
<v t="ekr.20061031131434.64"><vh>computeErrorNode (leoKeys)</vh></v>
<v t="ekr.20061031131434.65"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20061031131434.66"><vh>class classScannerClass</vh>
<v t="ekr.20061031131434.67"><vh>ctor</vh></v>
<v t="ekr.20061031131434.68"><vh>scan</vh></v>
<v t="ekr.20061031131434.69"><vh>findParentClass</vh></v>
<v t="ekr.20061031131434.70"><vh>findClass &amp; helpers</vh>
<v t="ekr.20061031131434.71"><vh>endsDoc</vh></v>
<v t="ekr.20061031131434.72"><vh>startsClass</vh></v>
<v t="ekr.20061031131434.73"><vh>startsDoc</vh></v>
</v>
</v>
</v>
<v t="ekr.20061031131434.74"><vh>class keyHandlerClass</vh>
<v t="ekr.20061031131434.75"><vh> Birth (keyHandler)</vh>
<v t="ekr.20061031131434.76"><vh> ctor (keyHandler)</vh>
<v t="ekr.20061031131434.78"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.79"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.80"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20061031131434.81"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20061031131434.82"><vh>setDefaultUnboundKeyAction</vh></v>
<v t="ekr.20070123143428"><vh>k.defineTkNames</vh></v>
<v t="ekr.20080509064108.6"><vh>k.defineSingleLineCommands</vh></v>
<v t="ekr.20080509064108.7"><vh>k.defineMultiLineCommands</vh></v>
<v t="ekr.20070123085931"><vh>k.defineSpecialKeys</vh></v>
<v t="ekr.20061101071425"><vh>oops</vh></v>
</v>
<v t="ekr.20061031131434.88"><vh>Binding (keyHandler)</vh>
<v t="ekr.20061031131434.89"><vh>bindKey</vh>
<v t="ekr.20061031131434.90"><vh>&lt;&lt; give warning and return if we try to bind to Enter or Leave &gt;&gt;</vh></v>
<v t="ekr.20061031131434.92"><vh>&lt;&lt; remove previous conflicting definitions from bunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.93"><vh>bindKeyToDict</vh></v>
<v t="ekr.20061031131434.94"><vh>bindOpenWith</vh></v>
<v t="ekr.20061031131434.95"><vh>checkBindings</vh></v>
<v t="ekr.20070218130238"><vh>dumpMasterBindingsDict</vh></v>
<v t="ekr.20061031131434.96"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20061031131434.97"><vh>k.completeAllBindings</vh></v>
<v t="ekr.20061031131434.98"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20061031131434.99"><vh>k.initAbbrev</vh></v>
<v t="ekr.20061031131434.100"><vh>addModeCommands (enterModeCallback)</vh></v>
<v t="ekr.20061031131434.101"><vh>initSpecialIvars</vh></v>
<v t="ekr.20061031131434.102"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20061031131434.103"><vh>k.makeMasterGuiBinding</vh></v>
</v>
<v t="ekr.20061031131434.104"><vh>Dispatching (keyHandler)</vh>
<v t="ekr.20061031131434.105"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20061031131434.106"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20061031131434.107"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20061031131434.109"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20061031131434.110"><vh>k.handleDefaultChar</vh></v>
</v>
<v t="ekr.20061031131434.111"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20061031131434.112"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20061031131434.113"><vh>k.endCommand</vh></v>
</v>
<v t="ekr.20061031131434.114"><vh>Externally visible commands</vh>
<v t="ekr.20061031131434.115"><vh>digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20061031131434.116"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20070613133500"><vh>k.menuCommandKey</vh></v>
<v t="ekr.20070613190936"><vh>k.propagateKeyEvent</vh></v>
<v t="ekr.20061031131434.117"><vh>negativeArgument (redo?)</vh></v>
<v t="ekr.20061031131434.118"><vh>numberCommand</vh></v>
<v t="ekr.20061031131434.119"><vh>printBindings &amp; helper</vh>
<v t="ekr.20061031131434.120"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20061031131434.121"><vh>printCommands</vh></v>
<v t="ekr.20061031131434.122"><vh>repeatComplexCommand &amp; helper</vh></v>
<v t="ekr.20061031131434.123"><vh>set-xxx-State</vh></v>
<v t="ekr.20061031131434.124"><vh>toggle-input-state</vh></v>
</v>
<v t="ekr.20061031131434.125"><vh>Externally visible helpers</vh>
<v t="ekr.20061031131434.126"><vh>manufactureKeyPressForCommandName</vh></v>
<v t="ekr.20061031131434.127"><vh>simulateCommand</vh></v>
<v t="ekr.20061031131434.128"><vh>getArg</vh>
<v t="ekr.20061031131434.129"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.130"><vh>keyboardQuit</vh></v>
<v t="ekr.20061031131434.131"><vh>k.registerCommand</vh></v>
<v t="ekr.20071212104050"><vh>k.overrideCommand</vh></v>
</v>
<v t="ekr.20061031131434.145"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20061031131434.146"><vh>masterKeyHandler &amp; helpers</vh>
<v t="ekr.20061031131434.147"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.108"><vh>callStateFunction</vh></v>
<v t="ekr.20091230094319.6244"><vh>doMode</vh></v>
<v t="ekr.20091230094319.6242"><vh>doPlainKey</vh></v>
<v t="ekr.20091230094319.6240"><vh>getPaneBinding</vh></v>
<v t="ekr.20061031131434.152"><vh>handleMiniBindings</vh></v>
<v t="ekr.20080510095819.1"><vh>k.handleUnboudKeys</vh></v>
</v>
<v t="ekr.20061031131434.153"><vh>masterClickHandler</vh></v>
<v t="ekr.20061031131434.154"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20061031131434.155"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20061031170011.3"><vh>Minibuffer (keyHandler)</vh>
<v t="ekr.20061031131434.135"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20061031170011.5"><vh>getLabel</vh></v>
<v t="ekr.20080408060320.791"><vh>k.killLine</vh></v>
<v t="ekr.20061031170011.6"><vh>protectLabel</vh></v>
<v t="ekr.20061031170011.7"><vh>resetLabel</vh></v>
<v t="ekr.20061031170011.8"><vh>setLabel</vh></v>
<v t="ekr.20061031170011.9"><vh>extendLabel</vh></v>
<v t="ekr.20080408060320.790"><vh>selectAll</vh></v>
<v t="ekr.20061031170011.10"><vh>setLabelBlue</vh></v>
<v t="ekr.20061031170011.11"><vh>setLabelGrey</vh></v>
<v t="ekr.20080510153327.2"><vh>setLabelRed</vh></v>
<v t="ekr.20061031170011.12"><vh>updateLabel</vh></v>
<v t="ekr.20061031170011.13"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20061031131434.156"><vh>Modes</vh>
<v t="ekr.20061031131434.157"><vh>badMode</vh></v>
<v t="ekr.20061031131434.158"><vh>createModeBindings</vh></v>
<v t="ekr.20061031131434.159"><vh>endMode</vh></v>
<v t="ekr.20061031131434.160"><vh>enterNamedMode</vh></v>
<v t="ekr.20061031131434.161"><vh>exitNamedMode</vh></v>
<v t="ekr.20061031131434.162"><vh>generalModeHandler</vh></v>
<v t="ekr.20061031131434.163"><vh>initMode</vh></v>
<v t="ekr.20061031131434.164"><vh>reinitMode</vh></v>
<v t="ekr.20061031131434.165"><vh>modeHelp &amp; helper</vh>
<v t="ekr.20061031131434.166"><vh>modeHelpHelper</vh></v>
</v>
</v>
<v t="ekr.20061031131434.167"><vh>Shared helpers</vh>
<v t="ekr.20061031131434.175"><vh>k.computeCompletionList</vh></v>
<v t="ekr.20061031131434.176"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20061031131434.168"><vh>getFileName &amp; helpers</vh>
<v t="ekr.20061031131434.169"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.170"><vh>k.doFileNameBackSpace</vh></v>
<v t="ekr.20061031131434.171"><vh>k.doFileNameChar</vh></v>
<v t="ekr.20061031131434.172"><vh>k.doFileNameTab</vh></v>
<v t="ekr.20061031131434.173"><vh>k.computeFileNameCompletionList</vh></v>
<v t="ekr.20061031131434.174"><vh>k.showFileNameTabList</vh></v>
</v>
<v t="ekr.20061031131434.179"><vh>getShortcutForCommand/Name (should return lists)</vh></v>
<v t="ekr.20061031131434.177"><vh>k.doBackSpace (minibuffer)</vh></v>
<v t="ekr.20061031131434.178"><vh>k.doTabCompletion</vh></v>
<v t="ekr.20061031131434.180"><vh>traceBinding</vh></v>
</v>
<v t="ekr.20061031131434.181"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20090518072506.8494"><vh>isFKey</vh></v>
<v t="ekr.20061031131434.182"><vh>isPlainKey</vh></v>
<v t="ekr.20061031131434.184"><vh>shortcutFromSetting (uses k.guiBindNamesDict)</vh>
<v t="ekr.20061031131434.185"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20061031131434.186"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20061031131434.187"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20061031131434.188"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20061031131434.189"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.190"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20061031131434.191"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20061031131434.193"><vh>States</vh>
<v t="ekr.20061031131434.194"><vh>clearState</vh></v>
<v t="ekr.20061031131434.196"><vh>getState</vh></v>
<v t="ekr.20061031131434.195"><vh>getStateHandler</vh></v>
<v t="ekr.20061031131434.197"><vh>getStateKind</vh></v>
<v t="ekr.20061031131434.198"><vh>inState</vh></v>
<v t="ekr.20080511122507.4"><vh>setDefaultInputState</vh></v>
<v t="ekr.20061031131434.133"><vh>setInputState</vh></v>
<v t="ekr.20061031131434.199"><vh>setState</vh></v>
<v t="ekr.20061031131434.192"><vh>showStateAndMode</vh></v>
<v t="ekr.20080512115455.1"><vh>showStateColors</vh></v>
</v>
<v t="ekr.20061031131434.200"><vh>universalDispatcher &amp; helpers</vh>
<v t="ekr.20061031131434.201"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061031131434.202"><vh>executeNTimes</vh></v>
<v t="ekr.20061031131434.203"><vh>doControlU</vh></v>
</v>
</v>
<v t="ekr.20101002134934.5848"><vh>class AutoCompleterScanner (New)</vh>
<v t="ekr.20101002113936.5842"><vh> ctor &amp; helper (AutoCompleterScanner)</vh>
<v t="ekr.20101002113936.5833"><vh>definePatterns</vh></v>
</v>
<v t="ekr.20101002113936.5834"><vh>scan &amp; dumps</vh>
<v t="ekr.20101002120446.5842"><vh>dumpTips</vh></v>
<v t="ekr.20101002120446.5841"><vh>dumpWords</vh></v>
<v t="ekr.20101002134934.5847"><vh>printSummary</vh></v>
</v>
<v t="ekr.20101002113936.5836"><vh>scanForAutoCompleter &amp; helper</vh>
<v t="ekr.20101002113936.5837"><vh>makeAutocompletionList</vh></v>
</v>
<v t="ekr.20101002113936.5835"><vh>scanForCallTip &amp; helper</vh>
<v t="ekr.20101002133920.5845"><vh>cleanPythonTip</vh></v>
</v>
</v>
<v t="ekr.20101002192824.5915"></v>
</v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh>
<v t="ekr.20060904165452.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1991"><vh>class nodeIndices</vh>
<v t="ekr.20031218072017.1992"><vh>nodeIndices.__init__</vh></v>
<v t="ekr.20031218072017.1993"><vh>areEqual (no longer used)</vh></v>
<v t="ekr.20031218072017.1994"><vh>get/setDefaultId</vh></v>
<v t="ekr.20031218072017.1995"><vh>getNewIndex</vh></v>
<v t="ekr.20031218072017.1996"><vh>isGnx (not used)</vh></v>
<v t="ekr.20031218072017.1997"><vh>scanGnx</vh></v>
<v t="ekr.20031218072017.1998"><vh>setTimeStamp</vh></v>
<v t="ekr.20031218072017.1999"><vh>toString</vh></v>
</v>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> p.ctor &amp; other special methods...</vh>
<v t="ekr.20080416161551.190"><vh> p.__init__</vh></v>
<v t="ekr.20080920052058.3"><vh>p.__eq__ &amp; __ne__</vh></v>
<v t="ekr.20091210082012.6230"><vh>p.__ge__ &amp; __le__&amp; __lt__</vh></v>
<v t="ekr.20091210082012.6233"><vh>p.__gt__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__ (no longer used)</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__ &amp; __bool__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20061006092649"><vh>p.archivedPosition</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump</vh></v>
<v t="ekr.20080416161551.191"><vh>p.key</vh></v>
</v>
<v t="ekr.20090128083459.74"><vh>p.Properties</vh>
<v t="ekr.20090128083459.75"><vh>p.b property</vh></v>
<v t="ekr.20090128083459.76"><vh>p.h property</vh></v>
<v t="ekr.20090215165030.3"><vh>p.gnx property</vh></v>
</v>
<v t="ekr.20040306212636"><vh>p.Getters</vh>
<v t="ekr.20040306210951"><vh>p.vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>p.children &amp; parents</vh>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040306214240.3"><vh>p.hasChildren &amp; p.numberOfChildren</vh></v>
</v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20080416161551.192"><vh>p.hasX</vh>
<v t="ekr.20080416161551.193"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20060920203352"><vh>p.findRootPosition</vh></v>
<v t="ekr.20080416161551.194"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20080416161551.196"><vh>p.isVisible</vh></v>
<v t="ekr.20080416161551.197"><vh>p.level &amp; simpleLevel</vh></v>
<v t="shadow.20080825171547.2"><vh>p.textOffset</vh></v>
</v>
<v t="ekr.20040305222924"><vh>p.Setters</vh>
<v t="ekr.20040306220634"><vh>p.Vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20100303074003.5637"><vh>p.restore/saveCursorAndScroll</vh></v>
</v>
<v t="ekr.20040315034158"><vh>p.setBodyString &amp; setHeadString</vh></v>
<v t="ekr.20040312015908"><vh>p.Visited bits</vh>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>p.File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>p.convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>p.moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>p.moreBody</vh></v>
</v>
<v t="ekr.20091001141621.6060"><vh>p.generators</vh>
<v t="ekr.20091001141621.6055"><vh>p.children</vh></v>
<v t="ekr.20091002083910.6102"><vh>p.following_siblings</vh></v>
<v t="ekr.20091002083910.6104"><vh>p.nodes</vh></v>
<v t="ekr.20091001141621.6058"><vh>p.parents</vh></v>
<v t="ekr.20091002083910.6099"><vh>p.self_and_parents</vh></v>
<v t="ekr.20091001141621.6057"><vh>p.self_and_siblings</vh></v>
<v t="ekr.20091001141621.6066"><vh>p.self_and_subtree</vh></v>
<v t="ekr.20091001141621.6056"><vh>p.subtree</vh></v>
<v t="ekr.20091002083910.6105"><vh>p.unique_nodes</vh></v>
<v t="ekr.20091002083910.6103"><vh>p.unique_subtree</vh></v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting</vh>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20100802121531.5804"><vh>p.deletePositionsInList</vh></v>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToFirst/LastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20080416161551.199"><vh>p.moveToX</vh>
<v t="ekr.20080416161551.200"><vh>p.moveToBack</vh></v>
<v t="ekr.20080416161551.201"><vh>p.moveToFirstChild</vh></v>
<v t="ekr.20080416161551.202"><vh>p.moveToLastChild</vh></v>
<v t="ekr.20080416161551.203"><vh>p.moveToLastNode</vh></v>
<v t="ekr.20080416161551.204"><vh>p.moveToNext</vh></v>
<v t="ekr.20080416161551.205"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20080416161551.206"><vh>p.moveToNthChild</vh></v>
<v t="ekr.20080416161551.207"><vh>p.moveToParent</vh></v>
<v t="ekr.20080416161551.208"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20080416161551.209"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20080416161551.210"><vh>p.moveToVisBack</vh>
<v t="ekr.20090715145956.6166"><vh>checkVisBackLimit</vh></v>
</v>
<v t="ekr.20080416161551.211"><vh>p.moveToVisNext</vh>
<v t="ekr.20090715145956.6167"><vh>checkVisNextLimit</vh></v>
</v>
</v>
<v t="ekr.20080423062035.1"><vh>p.Low level methods</vh>
<v t="ekr.20080427062528.4"><vh>p._adjustPositionBeforeUnlink</vh></v>
<v t="ekr.20080416161551.214"><vh>p._linkAfter</vh></v>
<v t="ekr.20080416161551.215"><vh>p._linkAsNthChild</vh></v>
<v t="ekr.20080416161551.212"><vh>p._parentVnode</vh></v>
<v t="ekr.20080416161551.216"><vh>p._linkAsRoot</vh></v>
<v t="ekr.20080416161551.217"><vh>p._unlink</vh>
<v t="ekr.20090706171333.6226"><vh>p.badUnlink</vh></v>
</v>
</v>
</v>
<v t="ville.20090311190405.68"><vh>class poslist</vh>
<v t="ville.20090311190405.69"><vh>select_h</vh></v>
<v t="ville.20090311195550.1"><vh>select_b</vh></v>
</v>
<v t="ekr.20031218072017.3341"><vh>class vnode</vh>
<v t="ekr.20031218072017.951"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3342"><vh>v.Birth &amp; death</vh>
<v t="ekr.20031218072017.3344"><vh>v.__init</vh></v>
<v t="ekr.20031218072017.3345"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="ekr.20040312145256"><vh>v.dump</vh></v>
<v t="ekr.20060910100316"><vh>v.__hash__ (only for zodb)</vh></v>
</v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>v.findAtFileName</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode (vnode)</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20031218072017.3359"><vh>v.Getters</vh>
<v t="ekr.20031218072017.3378"><vh>v.bodyString</vh></v>
<v t="ekr.20031218072017.3360"><vh>v.Children</vh>
<v t="ekr.20031218072017.3362"><vh>v.firstChild</vh></v>
<v t="ekr.20040307085922"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="ekr.20031218072017.3364"><vh>v.lastChild</vh></v>
<v t="ekr.20031218072017.3365"><vh>v.nthChild</vh></v>
<v t="ekr.20031218072017.3366"><vh>v.numberOfChildren</vh></v>
</v>
<v t="ekr.20040323100443"><vh>v.directParents</vh></v>
<v t="ekr.20080429053831.6"><vh>v.hasBody</vh></v>
<v t="ekr.20031218072017.1581"><vh>v.headString &amp; v.cleanHeadString</vh></v>
<v t="ekr.20031218072017.3367"><vh>v.Status Bits</vh>
<v t="ekr.20031218072017.3368"><vh>v.isCloned</vh></v>
<v t="ekr.20031218072017.3369"><vh>v.isDirty</vh></v>
<v t="ekr.20031218072017.3370"><vh>v.isExpanded</vh></v>
<v t="ekr.20031218072017.3371"><vh>v.isMarked</vh></v>
<v t="ekr.20031218072017.3372"><vh>v.isOrphan</vh></v>
<v t="ekr.20031218072017.3373"><vh>v.isSelected</vh></v>
<v t="ekr.20031218072017.3374"><vh>v.isTopBitSet</vh></v>
<v t="ekr.20031218072017.3376"><vh>v.isVisited</vh></v>
<v t="ekr.20080429053831.10"><vh>v.isWriteBit</vh></v>
<v t="ekr.20031218072017.3377"><vh>v.status</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3384"><vh>v.Setters</vh>
<v t="ekr.20090830051712.6151"><vh> v.Dirty bits</vh>
<v t="ekr.20031218072017.3390"><vh>v.clearDirty</vh></v>
<v t="ekr.20090830051712.6153"><vh>v.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20090830051712.6157"><vh>v.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20080429053831.12"><vh>v.setDirty</vh></v>
</v>
<v t="ekr.20031218072017.3386"><vh> v.Status bits</vh>
<v t="ekr.20031218072017.3389"><vh>v.clearClonedBit</vh></v>
<v t="ekr.20031218072017.3391"><vh>v.clearMarked</vh></v>
<v t="ekr.20080429053831.8"><vh>v.clearWriteBit</vh></v>
<v t="ekr.20031218072017.3392"><vh>v.clearOrphan</vh></v>
<v t="ekr.20031218072017.3393"><vh>v.clearVisited</vh></v>
<v t="ekr.20031218072017.3395"><vh>v.contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20031218072017.3396"><vh>v.initStatus</vh></v>
<v t="ekr.20031218072017.3397"><vh>v.setClonedBit &amp; initClonedBit</vh></v>
<v t="ekr.20031218072017.3398"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20031218072017.3399"><vh>v.setOrphan</vh></v>
<v t="ekr.20031218072017.3400"><vh>v.setSelected</vh></v>
<v t="ekr.20031218072017.3401"><vh>v.setVisited</vh></v>
<v t="ekr.20080429053831.9"><vh>v.setWriteBit</vh></v>
</v>
<v t="ekr.20031218072017.3385"><vh>v.computeIcon &amp; setIcon</vh></v>
<v t="ekr.20100303074003.5636"><vh>v.restoreCursorAndScroll</vh></v>
<v t="ekr.20100303074003.5638"><vh>v.saveCursorAndScroll(w)</vh></v>
<v t="ekr.20040315032144"><vh>v.setBodyString &amp; v.setHeadString</vh></v>
<v t="ekr.20080429053831.13"><vh>v.setFileIndex</vh></v>
<v t="ekr.20031218072017.3402"><vh>v.setSelection</vh></v>
</v>
<v t="ekr.20080427062528.9"><vh>v.Low level methods</vh>
<v t="ekr.20090706110836.6135"><vh>v._addLink &amp; helper</vh>
<v t="ekr.20090804184658.6129"><vh>v._addParentLinks</vh></v>
</v>
<v t="ekr.20090804184658.6128"><vh>v._cutLink</vh>
<v t="ekr.20090804190529.6133"><vh>v._cutParentLinks</vh></v>
</v>
<v t="ekr.20031218072017.3425"><vh>v._linkAsNthChild (used by 4.x read logic)</vh></v>
</v>
<v t="ekr.20090130065000.1"><vh>v.Properties</vh>
<v t="ekr.20090130114732.5"><vh>v.b Property</vh></v>
<v t="ekr.20090130125002.1"><vh>v.h property</vh></v>
<v t="ekr.20090130114732.6"><vh>v.u Property</vh></v>
<v t="ekr.20090215165030.1"><vh>v.gnx Property</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh>
<v t="ekr.20100908125007.6041"><vh>Top-level functions</vh></v>
<v t="ville.20090222141717.2"><vh>TryNext (exception)</vh></v>
<v t="ekr.20100908125007.6033"><vh>class CommandChainDispatcher</vh></v>
<v t="ekr.20100908125007.6009"><vh>class baseLeoPlugin</vh>
<v t="ekr.20100908125007.6010"><vh>&lt;&lt;docstring&gt;&gt;</vh></v>
<v t="ekr.20100908125007.6012"><vh>__init__</vh></v>
<v t="ekr.20100908125007.6013"><vh>setCommand</vh></v>
<v t="ekr.20100908125007.6014"><vh>setMenuItem</vh></v>
<v t="ekr.20100908125007.6015"><vh>setButton</vh></v>
</v>
<v t="ekr.20100908125007.6007"><vh>class LeoPluginsController</vh>
<v t="ekr.20100909065501.5954"><vh>Birth</vh>
<v t="ekr.20100908125007.6034"><vh>pc.ctor</vh></v>
<v t="ekr.20100909065501.5974"><vh>pc.finishCreate</vh></v>
</v>
<v t="ekr.20100909065501.5952"><vh>Event handlers</vh>
<v t="ekr.20100908125007.6016"><vh>callTagHandler</vh></v>
<v t="ekr.20100908125007.6017"><vh>doHandlersForTag</vh></v>
<v t="ekr.20100908125007.6018"><vh>doPlugins</vh></v>
</v>
<v t="ekr.20100909065501.5950"><vh>Information</vh>
<v t="ekr.20100908125007.6019"><vh>getHandlersForTag</vh></v>
<v t="ekr.20100910075900.10204"><vh>getLoadedPlugins</vh></v>
<v t="ekr.20100908125007.6020"><vh>getPluginModule</vh></v>
<v t="ekr.20100908125007.6021"><vh>isLoaded</vh></v>
<v t="ekr.20100908125007.6025"><vh>printHandlers</vh></v>
<v t="ekr.20100908125007.6026"><vh>printPlugins</vh></v>
<v t="ekr.20100908125007.6027"><vh>printPluginsInfo</vh></v>
<v t="ekr.20100909065501.5949"><vh>regularizeName</vh></v>
<v t="ekr.20100909104341.5979"><vh>setLoaded</vh></v>
</v>
<v t="ekr.20100909065501.5953"><vh>Load &amp; unload</vh>
<v t="ekr.20100908125007.6022"><vh>loadHandlers</vh></v>
<v t="ekr.20100908125007.6024"><vh>loadOnePlugin</vh></v>
<v t="ekr.20031218072017.1318"><vh>plugin_signon</vh></v>
<v t="ekr.20100908125007.6030"><vh>unloadOnePlugin</vh></v>
</v>
<v t="ekr.20100909065501.5951"><vh>Registration</vh>
<v t="ekr.20100908125007.6028"><vh>registerExclusiveHandler</vh></v>
<v t="ekr.20100908125007.6029"><vh>registerHandler</vh></v>
<v t="ekr.20100908125007.6031"><vh>unregisterHandler</vh></v>
</v>
</v>
</v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh>
<v t="ekr.20061024060248.2"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20061024131236"><vh>dump</vh></v>
<v t="ekr.20061024130957"><vh>getters</vh></v>
<v t="ekr.20061024060248.3"><vh>hello</vh></v>
<v t="ekr.20061024075542"><vh>init</vh></v>
<v t="ekr.20061024075542.1"></v>
<v t="ekr.20061024084200"><vh>run-script (pymacs)</vh></v>
</v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh>
<v t="ekr.20090502071837.4"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20100908120927.5971"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20090502071837.12"><vh>code_block</vh></v>
<v t="ekr.20090502071837.33"><vh>class rstCommands</vh>
<v t="ekr.20090502071837.34"><vh> Birth &amp; init</vh>
<v t="ekr.20090502071837.35"><vh> ctor (rstClass)</vh>
<v t="ekr.20090502071837.36"><vh>&lt;&lt; init ivars &gt;&gt; (leoRst)</vh></v>
</v>
<v t="ekr.20090502071837.102"><vh> getPublicCommands</vh></v>
<v t="ekr.20090511055302.5792"><vh>finishCreate</vh></v>
<v t="ekr.20090502071837.38"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20090502071837.39"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20090502071837.40"><vh>munge</vh></v>
</v>
<v t="ekr.20100813041139.5920"><vh>Entry points</vh>
<v t="ekr.20100812082517.5945"><vh>code_to_rst_command &amp; helpers</vh>
<v t="ekr.20100812082517.5963"><vh>write_code_body &amp; helpers</vh>
<v t="ekr.20100812082517.5964"><vh>split_parts</vh></v>
<v t="ekr.20100812082517.5965"><vh>write_code_block</vh></v>
</v>
<v t="ekr.20100812082517.5966"><vh>write_code_headline &amp; helper</vh>
<v t="ekr.20100812082517.5967"><vh>write_code_headline_helper</vh></v>
</v>
<v t="ekr.20100812082517.5968"><vh>write_code_node</vh></v>
<v t="ekr.20100812082517.5939"><vh>write_code_tree</vh></v>
</v>
<v t="ekr.20090511055302.5793"><vh>rst3 command &amp; helpers</vh>
<v t="ekr.20090502071837.62"><vh>processTopTree</vh></v>
<v t="ekr.20090502071837.63"><vh>processTree</vh></v>
<v t="ekr.20090502071837.64"><vh>write_rst_tree</vh></v>
<v t="ekr.20100822092546.5835"><vh>write_slides &amp; helper</vh>
<v t="ekr.20100822174725.5836"><vh>writeSlideTitle</vh></v>
</v>
<v t="ekr.20090502071837.58"><vh>write methods (rst3 command)</vh>
<v t="ekr.20090502071837.68"><vh>getDocPart</vh>
<v t="ekr.20090502071837.69"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20090502071837.72"></v>
<v t="ekr.20090502071837.76"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20090502071837.81"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20090502071837.77"><vh>isAnyDocPart</vh></v>
<v t="ekr.20090502071837.79"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20090502071837.78"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20090502071837.80"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20090502071837.82"><vh>replaceCodeBlockDirectives</vh></v>
<v t="ekr.20090502071837.70"><vh>skip_literal_block</vh></v>
<v t="ekr.20090502071837.71"><vh>writeBody</vh></v>
<v t="ekr.20090502071837.83"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20090502071837.84"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20090502071837.85"><vh>writeNode (leoRst)</vh></v>
<v t="ekr.20090502071837.86"><vh>writePreformat</vh></v>
<v t="ekr.20090502071837.87"><vh>writeTree</vh></v>
</v>
</v>
<v t="ekr.20090502071837.67"><vh>writeNodeToString</vh></v>
<v t="ekr.20090512153903.5803"><vh>writeAtAutoFile</vh>
<v t="ekr.20090513073632.5733"><vh>initAtAutoWrite (rstCommands)</vh></v>
<v t="ekr.20091228080620.6499"><vh>isSafeWrite</vh></v>
</v>
</v>
<v t="ekr.20090502071837.41"><vh>Options</vh>
<v t="ekr.20090502071837.42"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20090502071837.43"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20090502071837.44"><vh>getOption &amp; setOption</vh></v>
<v t="ekr.20090502071837.45"><vh>initCodeBlockString</vh></v>
<v t="ekr.20090502071837.46"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20090502071837.47"><vh>preprocessNode</vh></v>
<v t="ekr.20090502071837.48"><vh>parseOptionLine</vh></v>
<v t="ekr.20090502071837.49"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20090502071837.50"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20090502071837.51"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20090502071837.52"><vh>scanOption</vh></v>
<v t="ekr.20090502071837.53"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20090502071837.54"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20090502071837.55"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20090502071837.56"><vh>handleSingleNodeOptions</vh></v>
</v>
</v>
<v t="ekr.20090502071837.59"><vh>Shared write code</vh>
<v t="ekr.20090502071837.96"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20090502071837.97"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20090502071837.98"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20090502071837.100"><vh>relocate_references</vh></v>
<v t="ekr.20090502071837.99"><vh>find_anchors</vh></v>
<v t="ekr.20090502071837.101"><vh>http_attribute_iter</vh></v>
</v>
<v t="ekr.20090502071837.60"><vh>init_write (rstCommands)</vh></v>
<v t="ekr.20090502071837.94"><vh>write (leoRst)</vh></v>
<v t="ekr.20100813041139.5919"><vh>write_files &amp; helpers</vh>
<v t="ekr.20100813041139.5913"><vh>addTitleToHtml</vh></v>
<v t="ekr.20100813041139.5914"><vh>createDirectoryForFile</vh></v>
<v t="ekr.20100813041139.5912"><vh>createIntermediateFile (changed)</vh></v>
<v t="ekr.20090502071837.65"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090502071837.66"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
</v>
</v>
<v t="ekr.20090502071837.88"><vh>Utils</vh>
<v t="ekr.20090502071837.89"><vh>computeOutputFileName</vh></v>
<v t="ekr.20090502071837.90"><vh>encode</vh></v>
<v t="ekr.20090502071837.91"><vh>report</vh></v>
<v t="ekr.20090502071837.92"><vh>rstComment</vh></v>
<v t="ekr.20090502071837.93"><vh>underline (leoRst)</vh></v>
</v>
</v>
</v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh>
<v t="ekr.20080708094444.78"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080708094444.52"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20080708094444.80"><vh>class shadowController</vh>
<v t="ekr.20080708094444.79"><vh> x.ctor</vh></v>
<v t="ekr.20080711063656.1"><vh>x.File utils</vh>
<v t="ekr.20080711063656.7"><vh>x.baseDirName</vh></v>
<v t="ekr.20080711063656.4"><vh>x.dirName and pathName</vh></v>
<v t="ekr.20080712080505.3"><vh>x.isSignificantPublicFile</vh></v>
<v t="ekr.20080710082231.19"><vh>x.makeShadowDirectory</vh></v>
<v t="ekr.20080713091247.1"><vh>x.replaceFileWithString (@shadow)</vh></v>
<v t="ekr.20080711063656.6"><vh>x.shadowDirName and shadowPathName</vh></v>
<v t="ekr.20080711063656.3"><vh>x.unlink</vh></v>
</v>
<v t="ekr.20080708192807.1"><vh>x.Propagation</vh>
<v t="ekr.20080708094444.35"><vh>x.check_the_final_output</vh></v>
<v t="ekr.20080708094444.37"><vh>x.copy_sentinels</vh></v>
<v t="ekr.20080708094444.38"></v>
<v t="ekr.20080708094444.36"><vh>x.propagate_changes</vh></v>
<v t="ekr.20080708094444.34"><vh>x.strip_sentinels_with_map</vh></v>
<v t="bwmulder.20041231170726"><vh>x.updatePublicAndPrivateFiles</vh></v>
</v>
<v t="ekr.20080708094444.89"><vh>x.Utils...</vh>
<v t="ekr.20080708094444.85"><vh>x.error &amp; message &amp; verbatim_error</vh></v>
<v t="ekr.20090529125512.6122"><vh>x.markerFromFileLines &amp; helper</vh>
<v t="ekr.20090529125512.6125"><vh>x.findLeoLine</vh></v>
</v>
<v t="ekr.20080708094444.9"><vh>x.markerFromFileName</vh></v>
<v t="ekr.20080708094444.30"><vh>x.push_filter_mapping</vh></v>
<v t="ekr.20080708094444.29"><vh>x.separate_sentinels</vh></v>
<v t="ekr.20080708094444.33"><vh>x.show_error &amp; helper</vh>
<v t="ekr.20080822065427.4"><vh>show_error_lines</vh></v>
</v>
</v>
<v t="ekr.20080709062932.2"><vh>atShadowTestCase</vh>
<v t="ekr.20080709062932.6"><vh>__init__</vh></v>
<v t="ekr.20080709062932.7"><vh> fail</vh></v>
<v t="ekr.20080709062932.8"><vh>setUp &amp; helpers</vh>
<v t="ekr.20080709062932.19"><vh>findNode</vh></v>
<v t="ekr.20080709062932.20"><vh>createSentinelNode</vh></v>
<v t="ekr.20080709062932.21"><vh>makePrivateLines</vh></v>
<v t="ekr.20080709062932.22"><vh>makePublicLines</vh></v>
<v t="ekr.20080709062932.23"><vh>mungePrivateLines</vh></v>
</v>
<v t="ekr.20080709062932.9"><vh>tearDown</vh></v>
<v t="ekr.20080709062932.10"><vh>runTest (atShadowTestCase)</vh></v>
<v t="ekr.20080709062932.11"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20090529061522.5727"><vh>class marker</vh>
<v t="ekr.20090529061522.6257"><vh>markerClass.ctor &amp; repr</vh></v>
<v t="ekr.20090529061522.6258"><vh>getDelims</vh></v>
<v t="ekr.20090529061522.6259"><vh>isSentinel</vh></v>
<v t="ekr.20090529061522.6260"><vh>isVerbatimSentinel</vh></v>
</v>
<v t="ekr.20080708094444.12"><vh>class sourcereader</vh>
<v t="ekr.20080708094444.13"><vh>__init__</vh></v>
<v t="ekr.20080708094444.14"><vh>index</vh></v>
<v t="ekr.20080708094444.15"><vh>get</vh></v>
<v t="ekr.20080708094444.16"><vh>sync</vh></v>
<v t="ekr.20080708094444.17"><vh>size</vh></v>
<v t="ekr.20080708094444.18"><vh>atEnd</vh></v>
<v t="ekr.20080708094444.19"><vh>clone (not used)</vh></v>
<v t="ekr.20080708094444.20"><vh>dump</vh></v>
</v>
<v t="ekr.20080708094444.21"><vh>class sourcewriter</vh>
<v t="ekr.20080708094444.22"><vh>__init__</vh></v>
<v t="ekr.20080708094444.23"><vh>put</vh></v>
<v t="ekr.20080708094444.24"><vh>index</vh></v>
<v t="ekr.20080708094444.25"><vh>getlines</vh></v>
<v t="ekr.20080708094444.26"><vh>dump</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh>
<v t="ekr.20031218072017.2411"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3447"><vh>&lt;&lt; constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3448"><vh>node classes</vh>
<v t="ekr.20031218072017.3449"><vh>class tst_node</vh>
<v t="ekr.20031218072017.3450"><vh>tst_node.__init__</vh></v>
<v t="ekr.20031218072017.3451"><vh>tst_node.__repr__</vh></v>
<v t="sps.20100624231018.12083"><vh>tst_node.dump</vh></v>
</v>
<v t="ekr.20031218072017.3452"><vh>class part_node</vh>
<v t="ekr.20031218072017.3453"><vh>part_node.__init__</vh></v>
<v t="ekr.20031218072017.3454"><vh>part_node.__repr__</vh></v>
<v t="sps.20100622084732.16656"><vh>part_node.reflist</vh></v>
</v>
<v t="ekr.20031218072017.3455"><vh>class ust_node</vh>
<v t="ekr.20031218072017.3456"><vh>ust_node.__init__</vh></v>
<v t="ekr.20031218072017.3457"><vh>ust_node.__repr__</vh></v>
<v t="sps.20100624231018.12084"><vh>ust_node.dump</vh></v>
</v>
<v t="ekr.20031218072017.3458"><vh>class def_node</vh>
<v t="ekr.20031218072017.3459"><vh>def_node.__init__</vh></v>
<v t="ekr.20031218072017.3460"><vh>def_node.__repr__</vh></v>
</v>
<v t="ekr.20031218072017.3461"><vh>class root_attributes (Stephen P. Schaefer)</vh>
<v t="ekr.20031218072017.3462"><vh>root_attributes.__init__</vh>
<v t="ekr.20031218072017.3463"><vh>&lt;&lt; trace the state &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3464"><vh>root_attributes.__repr__</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3465"><vh>class tangleCommands methods</vh>
<v t="sps.20100629094515.20943"><vh>class RegexpForLanguageOrComment</vh></v>
<v t="ekr.20031218072017.3466"><vh>tangle.__init__</vh></v>
<v t="ekr.20031218072017.1356"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="ekr.20031218072017.1357"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1358"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1359"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="ekr.20031218072017.3467"><vh>top level</vh>
<v t="ekr.20031218072017.3468"><vh>cleanup</vh>
<v t="ekr.20031218072017.3469"><vh>&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3470"><vh>initTangleCommand</vh></v>
<v t="ekr.20031218072017.3471"><vh>initUntangleCommand</vh></v>
<v t="ekr.20031218072017.3472"><vh>tangle</vh></v>
<v t="ekr.20031218072017.3473"><vh>tangleAll</vh></v>
<v t="ekr.20031218072017.3474"><vh>tangleMarked</vh></v>
<v t="sps.20100618004337.20865"><vh>tanglePass1</vh></v>
<v t="ekr.20031218072017.3476"><vh>tanglePass2</vh></v>
<v t="ekr.20031218072017.3477"><vh>tangleTree (calls cleanup)</vh></v>
<v t="ekr.20031218072017.3478"><vh>untangle</vh>
<v t="sps.20100618004337.16262"><vh>&lt;&lt; read fake files for unit testing &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3479"><vh>untangleAll</vh></v>
<v t="ekr.20031218072017.3480"><vh>untangleMarked</vh></v>
<v t="ekr.20031218072017.3481"><vh>untangleRoot (calls cleanup)</vh>
<v t="ekr.20031218072017.3482"><vh>&lt;&lt; return if @silent &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3483"><vh>&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</vh></v>
<v t="sps.20100608083657.20939"><vh>&lt;&lt; fake the file access &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3485"><vh>&lt;&lt; Pass 3:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3486"><vh>untangleTree</vh>
<v t="ekr.20031218072017.3487"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3488"><vh>tangle</vh>
<v t="ekr.20031218072017.3489"><vh>Pass 1</vh>
<v t="sps.20100618004337.20969"><vh>handle_newline</vh></v>
<v t="sps.20100618004337.20951"><vh>skip_body</vh>
<v t="sps.20100618004337.20952"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="sps.20100618004337.20953"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="sps.20100618004337.20954"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh>
<v t="sps.20100716120121.12132"><vh>&lt;&lt;process normal section&gt;&gt;</vh></v>
</v>
<v t="sps.20100618004337.20955"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh>
<v t="sps.20100716120121.12132"></v>
</v>
<v t="sps.20100618004337.20956"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
<v t="sps.20100618004337.20957"><vh>The interface between tangle and untangle</vh></v>
</v>
<v t="sps.20100618004337.20965"><vh>skip_code</vh>
<v t="sps.20100618004337.20966"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="sps.20100618004337.20967"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3503"><vh>skip_doc</vh></v>
<v t="ekr.20031218072017.3504"><vh>skip_headline</vh></v>
</v>
<v t="ekr.20031218072017.3505"><vh>Pass 2</vh>
<v t="ekr.20031218072017.1488"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
<v t="ekr.20031218072017.1151"></v>
<v t="ekr.20031218072017.3506"><vh>put_code</vh>
<v t="ekr.20031218072017.3507"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3509"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
<v t="sps.20100624113712.16401"><vh>&lt;&lt; elide @comment or @language &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3510"><vh>put_doc</vh>
<v t="ekr.20031218072017.3511"><vh>&lt;&lt;put the doc part&gt;&gt;</vh>
<v t="ekr.20031218072017.3512"><vh>&lt;&lt;output or skip whitespace or newlines&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3515"><vh>put_leading_ws</vh></v>
<v t="ekr.20031218072017.3516"><vh>put_newline</vh>
<v t="ekr.20031218072017.3517"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3518"><vh>put_part_node</vh></v>
<v t="ekr.20031218072017.3519"><vh>put_section</vh>
<v t="ekr.20031218072017.3520"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3521"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3522"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="ekr.20031218072017.3523"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="ekr.20031218072017.3524"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3525"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="sps.20100621105534.16896"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3527"><vh>section_check</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3528"><vh>tst</vh>
<v t="ekr.20031218072017.3529"><vh>st_check</vh></v>
<v t="ekr.20031218072017.3530"><vh>st_dump</vh></v>
<v t="ekr.20031218072017.3531"><vh>st_dump_node</vh></v>
<v t="ekr.20031218072017.3532"><vh>st_enter</vh>
<v t="ekr.20031218072017.3533"><vh>&lt;&lt;check for duplicate code definitions &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3534"><vh>&lt;&lt;remember root node attributes&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3535"><vh>st_enter_root_name</vh></v>
<v t="ekr.20031218072017.3536"><vh>st_enter_section_name</vh></v>
<v t="ekr.20031218072017.3537"><vh>st_lookup</vh></v>
</v>
<v t="ekr.20031218072017.3538"><vh>ust</vh>
<v t="ekr.20031218072017.3539"><vh>ust_dump</vh></v>
<v t="ekr.20031218072017.3540"><vh>ust_enter</vh>
<v t="ekr.20031218072017.3541"><vh>&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3542"><vh>ust_lookup</vh></v>
<v t="ekr.20031218072017.3543"><vh>ust_warn_about_orphans</vh></v>
</v>
<v t="ekr.20031218072017.3544"><vh>untangle</vh>
<v t="ekr.20031218072017.3545"><vh>compare_comments</vh>
<v t="ekr.20031218072017.3546"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3547"><vh>massage_block_comment (no longer used)</vh></v>
<v t="ekr.20031218072017.3548"><vh>forgiving_compare</vh>
<v t="ekr.20031218072017.3549"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3546"></v>
<v t="ekr.20031218072017.3550"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3551"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3555"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="ekr.20031218072017.3557"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3556"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3553"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3552"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="ekr.20031218072017.3554"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3553"></v>
</v>
<v t="ekr.20031218072017.3558"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="sps.20100629094515.16518"><vh>&lt;&lt; Skip @language or @comment in outline &gt;&gt;</vh>
<v t="ekr.20031218072017.3553"></v>
</v>
<v t="ekr.20031218072017.3559"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="ekr.20031218072017.3553"></v>
</v>
<v t="ekr.20031218072017.3560"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3561"><vh>&lt;&lt; Trace the mismatch &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3562"><vh>mismatch</vh></v>
<v t="ekr.20031218072017.3563"><vh>scan_derived_file (pass 2)</vh>
<v t="ekr.20031218072017.2368"><vh>&lt;&lt; set the private global matching vars &gt;&gt;</vh></v>
<v t="sps.20100622084732.12299"><vh>&lt;&lt; Skip the header line output by tangle &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3565"><vh>&lt;&lt; handle the start of a new line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3566"><vh>&lt;&lt; handle a sentinel line &gt;&gt;</vh>
<v t="ekr.20031218072017.3567"><vh>&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3568"><vh>&lt;&lt; copy the entire line &gt;&gt;</vh></v>
<v t="sps.20100622084732.12308"><vh>&lt;&lt; copy a multi-line comment &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3569"><vh>&lt;&lt; copy a string &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3572"><vh>&lt;&lt; end all open sections &gt;&gt;</vh></v>
</v>
<v t="sps.20100623125751.16367"><vh>select_next_sentinel</vh>
<v t="sps.20100623125751.16368"><vh>&lt;&lt; push each part for each reference expected &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3573"><vh>update_def (pass 2)</vh>
<v t="ekr.20031218072017.3574"><vh>&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</vh></v>
<v t="sps.20100629094515.20939"><vh>&lt;&lt; Add the trailing whitespace of code to ucode. &gt;&gt;</vh></v>
<v t="sps.20100629094515.20940"><vh>&lt;&lt; Move any @language or @comment from code to ucode &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3575"><vh>update_current_vnode</vh></v>
</v>
<v t="ekr.20031218072017.3576"><vh>utility methods</vh>
<v t="sps.20100623164631.12028"><vh>refpart_stack_dump</vh></v>
<v t="ekr.20031218072017.3577"><vh>compare_section_names</vh></v>
<v t="ekr.20031218072017.3578"><vh>copy</vh></v>
<v t="ekr.20031218072017.3579"><vh>error, pathError, warning</vh></v>
<v t="ekr.20031218072017.3580"><vh>is_end_of_directive</vh></v>
<v t="ekr.20031218072017.3581"><vh>is_end_of_string</vh></v>
<v t="ekr.20031218072017.3582"><vh>is_escaped</vh></v>
<v t="ekr.20031218072017.3583"><vh>is_section_name</vh></v>
<v t="ekr.20031218072017.3584"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="ekr.20031218072017.3585"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3586"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3587"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3588"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3589"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3590"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3591"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="sps.20100625103124.16437"><vh>parent_language_comment_settings</vh></v>
<v t="ekr.20031218072017.3592"><vh>push_new_def_node</vh></v>
<v t="ekr.20031218072017.3593"><vh>scan_short_val</vh></v>
<v t="ekr.20031218072017.3594"><vh>setRootFromHeadline</vh></v>
<v t="ekr.20031218072017.1259"><vh>setRootFromText</vh></v>
<v t="ekr.20031218072017.3596"><vh>skip_section_name</vh></v>
<v t="ekr.20031218072017.3598"><vh>standardize_name</vh></v>
<v t="ekr.20080923124254.16"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20080923124254.17"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3599"><vh>token_type</vh>
<v t="ekr.20031218072017.3600"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3602"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh>
<v t="ekr.20031218072017.2413"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3605"><vh>class undoer</vh>
<v t="ekr.20031218072017.3606"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20031218072017.3607"><vh>clearIvars</vh></v>
</v>
<v t="ekr.20050416092908.1"><vh>Internal helpers</vh>
<v t="ekr.20060127052111.1"></v>
<v t="ekr.20080623083646.10"><vh>dumpBead</vh></v>
<v t="EKR.20040526150818"><vh>getBead</vh></v>
<v t="EKR.20040526150818.1"><vh>peekBead</vh></v>
<v t="ekr.20060127113243"><vh>pushBead</vh></v>
<v t="ekr.20060127070008"><vh>setIvarsFromBunch</vh></v>
<v t="ekr.20050126081529"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20031218072017.3613"><vh>redoMenuName, undoMenuName</vh></v>
<v t="ekr.20031218072017.3614"><vh>setRedoType</vh></v>
<v t="ekr.20091221145433.6381"><vh>setUndoType</vh></v>
<v t="ekr.20031218072017.3616"><vh>setUndoTypes</vh></v>
<v t="EKR.20040530121329"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20050415170737.2"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.2"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="EKR.20040528075307"><vh>u.saveTree &amp; helpers</vh>
<v t="EKR.20040530114124"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20050415170737.1"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.1"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20050525151449"><vh>u.trace</vh></v>
<v t="ekr.20050410095424"><vh>updateMarks</vh></v>
</v>
<v t="ekr.20031218072017.3608"><vh>Externally visible entries</vh>
<v t="ekr.20050318085432.4"><vh>afterX...</vh>
<v t="ekr.20050315134017.4"><vh>afterChangeGroup</vh></v>
<v t="ekr.20050315134017.2"><vh>afterChangeNodeContents</vh></v>
<v t="ekr.20050315134017.3"><vh>afterChangeTree</vh></v>
<v t="ekr.20050424161505"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20050411193627.5"><vh>afterCloneNode</vh></v>
<v t="ekr.20050411193627.6"><vh>afterDehoist</vh></v>
<v t="ekr.20050411193627.8"><vh>afterDeleteNode</vh></v>
<v t="ekr.20080425060424.8"><vh>afterDemote</vh></v>
<v t="ekr.20050411193627.7"><vh>afterHoist</vh></v>
<v t="ekr.20050411193627.9"><vh>afterInsertNode</vh></v>
<v t="ekr.20050526124257"><vh>afterMark</vh></v>
<v t="ekr.20050410110343"><vh>afterMoveNode</vh></v>
<v t="ekr.20080425060424.12"><vh>afterPromote</vh></v>
<v t="ekr.20080425060424.2"><vh>afterSort</vh></v>
</v>
<v t="ekr.20050318085432.3"><vh>beforeX...</vh>
<v t="ekr.20050315134017.7"><vh>beforeChangeGroup</vh></v>
<v t="ekr.20050315133212.2"><vh>beforeChangeNodeContents</vh></v>
<v t="ekr.20050315134017.6"><vh>beforeChangeTree</vh></v>
<v t="ekr.20050424161505.1"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20050412080354"><vh>beforeCloneNode</vh></v>
<v t="ekr.20050411193627.3"><vh>beforeDeleteNode</vh></v>
<v t="ekr.20050411193627.4"><vh>beforeInsertNode</vh></v>
<v t="ekr.20050526131252"><vh>beforeMark</vh></v>
<v t="ekr.20050410110215"><vh>beforeMoveNode</vh></v>
<v t="ekr.20080425060424.3"><vh>beforeSort</vh></v>
<v t="ekr.20050318085432.2"><vh>createCommonBunch</vh></v>
</v>
<v t="ekr.20031218072017.3610"><vh>canRedo &amp; canUndo</vh></v>
<v t="ekr.20031218072017.3609"><vh>clearUndoState</vh></v>
<v t="ekr.20031218072017.3611"><vh>enableMenuItems</vh></v>
<v t="ekr.20031218072017.1490"><vh>setUndoTypingParams</vh>
<v t="ekr.20040324061854"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20040324061854.1"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1491"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1492"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20040324061854.2"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20040324061854.3"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20050125220613"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20050125203937"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2030"><vh>redo &amp; helpers...</vh>
<v t="ekr.20050424170219"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20050412083057"><vh>redoCloneNode</vh></v>
<v t="EKR.20040526072519.2"><vh>redoDeleteNode</vh></v>
<v t="ekr.20080425060424.9"><vh>redoDemote</vh></v>
<v t="ekr.20050318085432.6"><vh>redoGroup</vh></v>
<v t="ekr.20050412085138.1"><vh>redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20050412084532"><vh>redoInsertNode</vh></v>
<v t="ekr.20050526125801"><vh>redoMark</vh></v>
<v t="ekr.20050411111847"><vh>redoMove</vh></v>
<v t="ekr.20050318085432.7"><vh>redoNodeContents</vh></v>
<v t="ekr.20080425060424.13"><vh>redoPromote</vh></v>
<v t="ekr.20080425060424.4"><vh>redoSort</vh></v>
<v t="ekr.20050318085432.8"><vh>redoTree</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20031218072017.2039"><vh>undo &amp; helpers...</vh>
<v t="ekr.20050424170219.1"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20050412083057.1"><vh>undoCloneNode</vh></v>
<v t="ekr.20050412084055"><vh>undoDeleteNode</vh></v>
<v t="ekr.20080425060424.10"><vh>undoDemote</vh></v>
<v t="ekr.20050318085713"><vh>undoGroup</vh></v>
<v t="ekr.20050412083244"><vh>undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20050412085112"><vh>undoInsertNode</vh></v>
<v t="ekr.20050526124906"><vh>undoMark</vh></v>
<v t="ekr.20050411112033"><vh>undoMove</vh></v>
<v t="ekr.20050318085713.1"><vh>undoNodeContents</vh></v>
<v t="ekr.20080425060424.14"><vh>undoPromote</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20061106105812.1"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20050408100042"><vh>undoRedoTree</vh></v>
<v t="ekr.20080425060424.5"><vh>undoSort</vh></v>
<v t="ekr.20050318085713.2"><vh>undoTree</vh></v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2243"><vh>class nullUndoer (undoer)</vh>
<v t="ekr.20050415165731"><vh>other methods</vh></v>
<v t="ekr.20050415165731.1"><vh>before undo handlers...</vh></v>
<v t="ekr.20050415170018"><vh>after undo handlers...</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh>
<v t="ekr.20031218072017.3631"><vh>choose</vh></v>
<v t="ekr.20031218072017.3632"><vh>go</vh></v>
<v t="ekr.20031218072017.3633"><vh>class leoCompare</vh>
<v t="ekr.20031218072017.3634"><vh>compare.__init__</vh></v>
<v t="ekr.20031218072017.3635"><vh>compare_directories (entry)</vh></v>
<v t="ekr.20031218072017.3636"><vh>compare_files (entry)</vh></v>
<v t="ekr.20031218072017.3637"><vh>compare_lines</vh></v>
<v t="ekr.20031218072017.3638"><vh>compare_open_files</vh>
<v t="ekr.20031218072017.3639"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3640"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3641"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3642"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3643"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3644"><vh>filecmp</vh></v>
<v t="ekr.20031218072017.3645"><vh>utils...</vh>
<v t="ekr.20031218072017.3646"><vh>doOpen</vh></v>
<v t="ekr.20031218072017.3647"><vh>dump</vh></v>
<v t="ekr.20031218072017.3648"><vh>dumpToEndOfFile</vh></v>
<v t="ekr.20031218072017.3649"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="ekr.20031218072017.1144"><vh>openOutputFile (compare)</vh></v>
<v t="ekr.20031218072017.3650"><vh>show (leoCompare) (not changed)</vh></v>
<v t="ekr.20031218072017.3651"><vh>showIvars</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh>
<v t="ekr.20031218072017.2410"><vh>&lt;&lt; About handling events &gt;&gt;</vh></v>
<v t="ekr.20070228074228"><vh>&lt;&lt; define text classes &gt;&gt;</vh>
<v t="ekr.20070228074312"><vh>class baseTextWidget</vh>
<v t="ekr.20070228074312.1"><vh>Birth &amp; special methods (baseText)</vh>
<v t="ekr.20081031074455.3"><vh>baseTextWidget: must be defined in base class</vh></v>
<v t="ekr.20081031074455.4"><vh>baseTextWidget: must be defined in subclasses</vh></v>
<v t="ekr.20081031074455.5"><vh>baseTextWidget: mustBeDefined</vh></v>
</v>
<v t="ekr.20081031074455.6"><vh>must be defined in base class</vh>
<v t="ekr.20070228074312.2"><vh>onChar</vh></v>
<v t="ekr.20070228074312.12"><vh>clipboard_clear &amp; clipboard_append</vh></v>
</v>
<v t="ekr.20081031074455.8"><vh>May be defined in subclasses</vh>
<v t="ekr.20081031074455.13"><vh> do-nothings</vh></v>
<v t="ekr.20090320055710.4"><vh>toPythonIndexToRowCol (baseText) (may be overridden)</vh></v>
<v t="ekr.20070228074312.13"><vh>delete</vh></v>
<v t="ekr.20070228074312.14"><vh>deleteTextSelection</vh></v>
<v t="ekr.20070228074312.15"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20070228102413"><vh>getName &amp; GetName</vh></v>
<v t="ekr.20070228074312.25"><vh>hasSelection</vh></v>
<v t="ekr.20070228074312.5"><vh>oops</vh></v>
<v t="ekr.20070228074312.28"><vh>replace</vh></v>
<v t="ekr.20070228074312.31"><vh>selectAllText</vh></v>
<v t="ekr.20070228074312.8"><vh>w.rowColToGuiIndex</vh></v>
<v t="ekr.20070228074312.7"><vh>w.toGuiIndex &amp; toPythonIndex</vh></v>
</v>
<v t="ekr.20081031074455.9"><vh>Must be defined in subclasses (low-level interface)</vh></v>
<v t="ekr.20081031074455.2"><vh>Must be defined in subclasses (high-level interface)</vh>
<v t="ekr.20070228074312.10"><vh>appendText</vh></v>
<v t="ekr.20070228074312.18"><vh>get</vh></v>
<v t="ekr.20070228074312.19"><vh>getAllText</vh></v>
<v t="ekr.20070228074312.17"><vh>getFocus</vh></v>
<v t="ekr.20070228074312.20"><vh>getInsertPoint</vh></v>
<v t="ekr.20070228074312.21"><vh>getSelectedText</vh></v>
<v t="ekr.20070228074312.22"><vh>getSelectionRange</vh></v>
<v t="ekr.20070228074312.23"><vh>getYScrollPosition</vh></v>
<v t="ekr.20070228074312.26"><vh>insert</vh></v>
<v t="ekr.20070228074312.29"><vh>scrollLines</vh></v>
<v t="ekr.20070228074312.30"><vh>see &amp; seeInsertPoint</vh></v>
<v t="ekr.20070228074312.32"><vh>setAllText</vh></v>
<v t="ekr.20070228074312.33"><vh>setBackgroundColor</vh></v>
<v t="ekr.20070228074312.34"><vh>setFocus</vh></v>
<v t="ekr.20080510153327.3"><vh>setForegroundColor</vh></v>
<v t="ekr.20070228074312.35"><vh>setInsertPoint</vh></v>
<v t="ekr.20070228074312.36"><vh>setSelectionRange</vh></v>
<v t="ekr.20070228074312.38"><vh>setYScrollPosition</vh></v>
</v>
</v>
<v t="ekr.20070228074228.1"><vh>class stringTextWidget (baseTextWidget)</vh>
<v t="ekr.20070228074228.2"><vh>ctor</vh></v>
<v t="ekr.20070228074228.3"><vh>Overrides</vh></v>
<v t="ekr.20070228111853"><vh>setSelectionRange (stringText)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3656"><vh>class leoBody</vh>
<v t="ekr.20031218072017.3657"><vh>leoBody.__init__</vh>
<v t="ekr.20081005065934.9"><vh>leoBody.mustBeDefined</vh></v>
<v t="ekr.20031218072017.3660"><vh>leoBody.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20061109102912"><vh>define leoBody.mustBeDefinedOnlyInBaseClass</vh></v>
</v>
<v t="ekr.20081005065934.5"><vh>leoBody.mustBeDefined</vh></v>
<v t="ekr.20061109173122"><vh>leoBody: must be defined in subclasses</vh></v>
<v t="ekr.20061109173021"><vh>leoBody: must be defined in the base class</vh>
<v t="ekr.20031218072017.3677"><vh>Coloring (leoBody)</vh></v>
<v t="ekr.20060528100747"><vh>Editors (leoBody)</vh>
<v t="ekr.20070424053629"><vh>entries</vh>
<v t="ekr.20060528100747.1"><vh>addEditor (leoBody)</vh>
<v t="ekr.20060528110922"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20060528132829"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20060528170438"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20060528113806"><vh>deleteEditor</vh></v>
<v t="ekr.20070425180705"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20060530210057"><vh>select/unselectLabel</vh></v>
<v t="ekr.20061017083312"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070423102603"><vh>selectEditorHelper</vh>
<v t="ekr.20061017083312.1"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060528131618"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20070424053629.1"><vh>utils</vh>
<v t="ekr.20070422093128"><vh>computeLabel</vh></v>
<v t="ekr.20070422094710"><vh>createChapterIvar</vh></v>
<v t="ekr.20070424084651"><vh>ensurePositionExists</vh></v>
<v t="ekr.20070424080640"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20060530204135"><vh>recolorWidget</vh></v>
<v t="ekr.20070424084012"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20070424092855"><vh>updateInjectedIvars</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; update icons if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061109095450.8"><vh>onClick</vh></v>
<v t="ekr.20031218072017.3658"><vh>oops</vh></v>
<v t="ekr.20031218072017.4018"><vh>Text (leoBody)</vh>
<v t="ekr.20031218072017.4030"><vh>getInsertLines</vh></v>
<v t="ekr.20031218072017.4031"><vh>getSelectionAreas</vh></v>
<v t="ekr.20031218072017.2377"><vh>getSelectionLines</vh></v>
<v t="ekr.20031218072017.4037"><vh>setSelectionAreas</vh></v>
<v t="ekr.20031218072017.4038"><vh>get/setYScrollPosition</vh></v>
</v>
<v t="ekr.20070228080627"><vh>Text Wrappers (base class)</vh></v>
</v>
<v t="ekr.20081005065934.6"><vh>leoBody: may be defined in subclasses</vh></v>
</v>
<v t="ekr.20031218072017.3678"><vh>class leoFrame</vh>
<v t="ekr.20031218072017.3679"><vh>  leoFrame.__init__</vh>
<v t="ekr.20080429051644.1"><vh>leoFrame.mustBeDefined</vh></v>
<v t="ekr.20061109120726"><vh>leoFrame.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109120704"><vh>leoFrame.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
</v>
<v t="ekr.20061109125528.1"><vh>Must be defined in base class</vh>
<v t="ekr.20031218072017.3689"><vh>initialRatios (leoFrame)</vh></v>
<v t="ekr.20031218072017.3690"><vh>longFileName &amp; shortFileName</vh></v>
<v t="ekr.20031218072017.3691"><vh>oops</vh></v>
<v t="ekr.20031218072017.3692"><vh>promptForSave (leoFrame)</vh>
<v t="ekr.20031218072017.3693"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1375"><vh>frame.scanForTabWidth (must be fast)</vh></v>
<v t="ekr.20061119120006"><vh>Icon area convenience methods</vh></v>
<v t="ekr.20041223105114.1"><vh>Status line convenience methods</vh></v>
<v t="ekr.20070130115927.4"><vh>Cut/Copy/Paste (leoFrame)</vh>
<v t="ekr.20070130115927.5"><vh>copyText</vh></v>
<v t="ekr.20070130115927.6"><vh>leoFrame.cutText</vh></v>
<v t="ekr.20070130115927.7"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20061016071937"><vh>OnPaste (To support middle-button paste)</vh></v>
</v>
<v t="ekr.20031218072017.3980"><vh>Edit Menu... (leoFrame)</vh>
<v t="ekr.20031218072017.3981"><vh>abortEditLabelCommand (leoFrame)</vh></v>
<v t="ekr.20031218072017.3982"><vh>frame.endEditLabelCommand</vh></v>
<v t="ekr.20031218072017.3983"><vh>insertHeadlineTime</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3680"><vh>Must be defined in subclasses</vh>
<v t="ekr.20031218072017.3683"><vh>Config...</vh></v>
<v t="ekr.20031218072017.3681"><vh>Gui-dependent commands</vh></v>
<v t="ekr.20031218072017.3682"><vh>Window...</vh></v>
</v>
<v t="ekr.20061109125528"><vh>May be defined in subclasses</vh>
<v t="ekr.20071027150501"><vh>event handlers (leoFrame)</vh></v>
<v t="ekr.20031218072017.3688"><vh>getTitle &amp; setTitle</vh></v>
<v t="ekr.20081005065934.3"><vh>initAfterLoad  &amp; initCompleteHint (leoFrame)</vh></v>
<v t="ekr.20031218072017.3687"><vh>setTabWidth (leoFrame)</vh></v>
</v>
<v t="ekr.20060206093313"><vh>Focus (leoFrame)</vh></v>
</v>
<v t="ekr.20031218072017.3694"><vh>class leoLog</vh>
<v t="ekr.20031218072017.3695"><vh> ctor (leoLog)</vh></v>
<v t="ekr.20070302101344"><vh>Must be defined in the base class</vh></v>
<v t="ekr.20070302101023"><vh>May be overridden</vh>
<v t="ekr.20070302094848.1"><vh>clearTab</vh></v>
<v t="ekr.20070302094848.2"><vh>createTab</vh></v>
<v t="ekr.20070302094848.4"><vh>cycleTabFocus</vh></v>
<v t="ekr.20070302094848.5"><vh>deleteTab</vh></v>
<v t="ekr.20070302094848.6"><vh>hideTab</vh></v>
<v t="ekr.20070302094848.7"><vh>getSelectedTab</vh></v>
<v t="ekr.20070302094848.8"><vh>lower/raiseTab</vh></v>
<v t="ekr.20070302094848.9"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20070302094848.10"><vh>renameTab</vh></v>
<v t="ekr.20070302094848.11"><vh>selectTab</vh></v>
</v>
<v t="ekr.20070302101304"><vh>Must be overridden</vh></v>
<v t="ekr.20031218072017.3700"><vh>leoLog.oops</vh></v>
</v>
<v t="ekr.20031218072017.3704"><vh>class leoTree</vh>
<v t="ekr.20031218072017.3705"><vh>  tree.__init__ (base class)</vh>
<v t="ekr.20081005065934.7"><vh>leoTree.mustBeDefined</vh></v>
<v t="ekr.20061109164512"><vh>leoTree.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109164610"><vh>leoTree.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20031218072017.3706"><vh> Must be defined in subclasses</vh></v>
<v t="ekr.20061109165848"><vh>Must be defined in base class</vh>
<v t="ekr.20031218072017.3716"><vh>Getters/Setters (tree)</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20040803072955.91"><vh>onHeadChanged (leoTree)</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20040803072955.21"><vh>tree.injectCallbacks</vh>
<v t="ekr.20040803072955.22"><vh>&lt;&lt; define callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20040803072955.23"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20040803072955.24"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20040803072955.25"><vh>OnHyperLinkLeave</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2312"><vh>tree.OnIconDoubleClick (@url) &amp; helper</vh>
<v t="ekr.20031218072017.2313"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20081005065934.8"><vh>May be defined in subclasses</vh></v>
<v t="ekr.20040803072955.128"><vh>leoTree.select &amp; helpers</vh>
<v t="ekr.20070423101911"><vh>selectHelper</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20090608081524.6109"><vh>setBodyTextAfterSelect</vh></v>
</v>
<v t="ekr.20031218072017.3718"><vh>oops</vh></v>
</v>
<v t="ekr.20070317073627"><vh>class leoTreeTab</vh>
<v t="ekr.20070317073627.1"><vh> ctor (leoTreeTab)</vh></v>
<v t="ekr.20070317073755"><vh>Must be defined in subclasses</vh></v>
<v t="ekr.20070317083104"><vh>oops</vh></v>
</v>
<v t="ekr.20031218072017.2191"><vh>class nullBody (leoBody)</vh>
<v t="ekr.20031218072017.2192"><vh> nullBody.__init__</vh></v>
<v t="ekr.20031218072017.2193"><vh>Utils (internal use)</vh>
<v t="ekr.20031218072017.2194"><vh>findStartOfLine</vh></v>
<v t="ekr.20031218072017.2195"><vh>scanToStartOfLine</vh></v>
<v t="ekr.20031218072017.2196"><vh>scanToEndOfLine</vh></v>
</v>
<v t="ekr.20031218072017.2197"><vh>nullBody: leoBody interface</vh></v>
</v>
<v t="ekr.20031218072017.2222"><vh>class nullFrame</vh>
<v t="ekr.20040327105706"><vh> ctor</vh></v>
<v t="ekr.20041120073824"><vh>destroySelf</vh></v>
<v t="ekr.20040327105706.2"><vh>finishCreate  (Removed nullFrame.bodyCtrl)</vh></v>
<v t="ekr.20061109124552"><vh>Overrides</vh>
<v t="ekr.20061109123828"><vh>Config...</vh>
<v t="ekr.20041130065718.1"><vh>setTopGeometry</vh></v>
</v>
<v t="ekr.20061109124129"><vh>Gui-dependent commands</vh></v>
<v t="ekr.20041130065921"><vh>Window...</vh></v>
</v>
</v>
<v t="ekr.20070301164543"><vh>class nullIconBarClass</vh>
<v t="ekr.20070301164543.1"><vh> ctor</vh></v>
<v t="ekr.20070301164543.2"><vh>add</vh></v>
<v t="ekr.20070301165343"><vh>do nothing</vh></v>
</v>
<v t="ekr.20031218072017.2232"><vh>class nullLog</vh>
<v t="ekr.20070302095500"><vh>Birth</vh>
<v t="ekr.20041012083237"><vh>nullLog.__init__</vh></v>
<v t="ekr.20041012083237.1"><vh>createControl</vh></v>
<v t="ekr.20070302095121"><vh>createTextWidget</vh></v>
</v>
<v t="ekr.20041012083237.2"><vh>oops</vh></v>
<v t="ekr.20041012083237.3"><vh>put and putnl (nullLog)</vh></v>
<v t="ekr.20060124085830"><vh>tabs</vh></v>
</v>
<v t="ekr.20070302171509"><vh>class nullStatusLineClass</vh>
<v t="ekr.20070302171509.2"><vh> nullStatusLineClass.ctor</vh></v>
<v t="ekr.20070302171917"><vh>methods</vh></v>
</v>
<v t="ekr.20031218072017.2233"><vh>class nullTree</vh>
<v t="ekr.20031218072017.2234"><vh> nullTree.__init__</vh></v>
<v t="ekr.20070228173611"><vh>printWidgets</vh></v>
<v t="ekr.20031218072017.2236"><vh>Overrides</vh>
<v t="ekr.20070228163350"><vh>Colors &amp; fonts (nullTree)</vh></v>
<v t="ekr.20070228163350.1"><vh>Drawing &amp; scrolling (nullTree)</vh></v>
<v t="ekr.20070228163350.2"><vh>Headlines (nullTree)</vh>
<v t="ekr.20070228164730"><vh>editLabel (nullTree)</vh></v>
<v t="ekr.20070228160345"><vh>setHeadline (nullTree)</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh>
<v t="ekr.20031218072017.3720"><vh>class leoGui</vh>
<v t="ekr.20040131103531"><vh>&lt;&lt; define leoGui file types &gt;&gt; (not used yet)</vh></v>
<v t="ekr.20031218072017.3721"><vh>app.gui Birth &amp; death</vh>
<v t="ekr.20031218072017.3722"><vh> leoGui.__init__</vh></v>
<v t="ekr.20061109211054"><vh>leoGui.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20061109211022"><vh>leoGui.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20061109212618.1"><vh>Must be defined only in base class</vh>
<v t="ekr.20031218072017.3740"><vh>guiName</vh></v>
<v t="ekr.20031218072017.2231"><vh>setScript</vh></v>
</v>
<v t="ekr.20061109212618"><vh>Must be defined in subclasses</vh>
<v t="ekr.20031218072017.3723"><vh>app.gui create &amp; destroy</vh>
<v t="ekr.20031218072017.3724"><vh>createRootWindow</vh></v>
<v t="ekr.20031218072017.3725"><vh>destroySelf</vh></v>
<v t="ekr.20031218072017.3727"><vh>killGui</vh></v>
<v t="ekr.20031218072017.3728"><vh>recreateRootWindow</vh></v>
<v t="ekr.20031218072017.3729"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20031218072017.3730"><vh>app.gui dialogs</vh></v>
<v t="ekr.20061031173016"><vh>app.gui.createKeyHandlerClass</vh></v>
<v t="ekr.20031218072017.3731"><vh>app.gui file dialogs</vh></v>
<v t="ekr.20031218072017.3732"><vh>app.gui panels</vh></v>
<v t="ekr.20031218072017.3733"><vh>app.gui utils</vh>
<v t="ekr.20031218072017.3734"><vh>Clipboard (leoGui)</vh></v>
<v t="ekr.20061031132712.1"><vh>color</vh></v>
<v t="ekr.20031218072017.3735"><vh>Dialog utils</vh></v>
<v t="ekr.20061031132907"><vh>Events (leoGui)</vh></v>
<v t="ekr.20070212145124"><vh>getFullVersion</vh></v>
<v t="ekr.20031218072017.3737"><vh>Focus</vh></v>
<v t="ekr.20031218072017.3736"><vh>Font (leoGui)</vh></v>
<v t="ekr.20031218072017.3739"><vh>Idle time</vh></v>
<v t="ekr.20070212070820"><vh>makeScriptButton</vh></v>
</v>
</v>
<v t="ekr.20070228154059"><vh>May be defined in subclasses</vh>
<v t="ekr.20070219084912"><vh>finishCreate (may be overridden in subclasses)</vh></v>
<v t="ekr.20031218072017.3741"><vh>oops</vh></v>
<v t="ekr.20051206103652"><vh>widget_name (leoGui)</vh></v>
<v t="ekr.20070228160107"><vh>class leoKeyEvent (leoGui)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2223"><vh>class nullGui (leoGui)</vh>
<v t="ekr.20031218072017.2224"><vh>Birth &amp; death</vh>
<v t="ekr.20031218072017.2225"><vh> nullGui.__init__</vh></v>
<v t="ekr.20070123092623"><vh>nullGui.createKeyHandlerClass</vh></v>
<v t="ekr.20031218072017.2229"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20070228155807"><vh>isTextWidget</vh></v>
<v t="ekr.20031218072017.2230"><vh>oops</vh></v>
<v t="ekr.20070301171901"><vh>do nothings</vh></v>
<v t="ekr.20070301172456"><vh>app.gui panels</vh></v>
<v t="ekr.20031218072017.3744"><vh>dialogs (nullGui)</vh></v>
<v t="ekr.20100521090440.5893"><vh>onActivate/DeactivateEvent</vh></v>
<v t="ekr.20031218072017.3747"><vh>simulateDialog</vh></v>
</v>
<v t="ekr.20080707150137.5"><vh>class nullScriptingControllerClass</vh></v>
<v t="ekr.20031218072017.3742"><vh>class unitTestGui (nullGui)</vh>
<v t="ekr.20031218072017.3743"><vh> ctor (unitTestGui)</vh></v>
<v t="ekr.20071128094234.1"><vh>createSpellTab</vh></v>
<v t="ekr.20081119083601.1"><vh>toUnicode</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh>
<v t="ekr.20031218072017.3750"><vh>class leoMenu</vh>
<v t="ekr.20031218072017.3751"><vh> leoMenu.__init__</vh></v>
<v t="ekr.20031218072017.3775"><vh>error and oops</vh></v>
<v t="ekr.20031218072017.3776"><vh>Gui-independent menu enablers</vh>
<v t="ekr.20031218072017.3777"><vh>updateAllMenus</vh></v>
<v t="ekr.20031218072017.3778"><vh>updateFileMenu</vh></v>
<v t="ekr.20031218072017.836"><vh>updateEditMenu</vh>
<v t="ekr.20040130164211"><vh>&lt;&lt; enable cut/paste &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3779"><vh>updateOutlineMenu</vh>
<v t="ekr.20040131171020"><vh>&lt;&lt; enable top level outline menu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.1"><vh>&lt;&lt; enable expand/Contract submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.2"><vh>&lt;&lt; enable move submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.3"><vh>&lt;&lt; enable go to submenu &gt;&gt;</vh></v>
<v t="ekr.20040131171020.4"><vh>&lt;&lt; enable mark submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3780"><vh>hasSelection</vh></v>
</v>
<v t="ekr.20031218072017.3781"><vh>Gui-independent menu routines</vh>
<v t="ekr.20060926213642"><vh>capitalizeMinibufferMenuName</vh></v>
<v t="ekr.20031218072017.3785"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20031218072017.3790"><vh>createFileMenuFromTable</vh>
<v t="ekr.20031218072017.3791"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3792"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3793"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3794"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3795"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3796"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3786"><vh>createEditMenuFromTable</vh>
<v t="ekr.20031218072017.3787"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3788"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3789"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3797"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.3802"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20070926135612"><vh>createMenusFromConfigList &amp; helpers</vh>
<v t="ekr.20070927082205"><vh>createMenuFromConfigList</vh></v>
<v t="ekr.20070927172712"><vh>handleSpecialMenus</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20060912093104"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20070604205927"><vh>defineCmdsMenuChaptersTable</vh></v>
<v t="ekr.20060924124119"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20060923060822"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061011084101.1"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061011085641"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061119061958"><vh>defineCmdsMenuRunTable</vh></v>
<v t="ekr.20060923060822.1"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20060924161901"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20060926161940"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20051022053758.1"><vh>Helpers</vh>
<v t="ekr.20031218072017.3783"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20051022044950"><vh>computeOldStyleShortcutKey</vh></v>
<v t="ekr.20031218072017.1723"></v>
<v t="ekr.20031218072017.3784"><vh>createMenuItemsFromTable</vh></v>
<v t="ekr.20031218072017.3804"><vh>createNewMenu</vh></v>
<v t="ekr.20031218072017.4116"><vh>createOpenWithMenuFromTable &amp; helper (leoMenu)</vh>
<v t="ekr.20051022043608.1"></v>
</v>
<v t="ekr.20031218072017.2078"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
<v t="tbrown.20080509212202.7"><vh>deleteRecentFilesMenuItems</vh></v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20031218072017.4118"><vh>defineOpenWithMenuCallback</vh></v>
<v t="ekr.20031218072017.3805"><vh>deleteMenu</vh></v>
<v t="ekr.20031218072017.3806"><vh>deleteMenuItem</vh></v>
<v t="ekr.20031218072017.3782"><vh>get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="ekr.20031218072017.3807"><vh>getMenu, setMenu, destroyMenu</vh></v>
</v>
<v t="ekr.20031218072017.3808"><vh>Must be overridden in menu subclasses</vh>
<v t="ekr.20031218072017.3809"><vh>9 Routines with Tk spellings</vh></v>
<v t="ekr.20031218072017.3810"><vh>9 Routines with new spellings</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3811"><vh>class nullMenu</vh>
<v t="ekr.20050104094308"><vh>ctor</vh></v>
<v t="ekr.20050104094029"><vh>oops</vh></v>
</v>
</v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh>
<v t="ekr.20100221142603.5639"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20100221142603.5640"><vh>getCoreList</vh></v>
<v t="ekr.20100221142603.5641"><vh>getPassList</vh></v>
<v t="ekr.20100221142603.5642"><vh>getPluginsTable</vh></v>
<v t="ekr.20100221142603.5643"><vh>getTkPass</vh></v>
<v t="ekr.20100221142603.5644"><vh>run</vh></v>
<v t="ekr.20100221142603.5645"><vh>&lt;&lt; defines &gt;&gt;</vh></v>
</v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh>
<v t="ekr.20080730161153.3"><vh>main &amp; helpers</vh>
<v t="ekr.20080730161153.4"><vh>runUnitTests</vh></v>
<v t="ekr.20090121164439.6177"><vh>scanOptions</vh></v>
</v>
</v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh>
<v t="ekr.20080730161153.6"><vh>main &amp; helpers</vh>
<v t="ekr.20080730161153.7"><vh>runUnitTests</vh></v>
<v t="ekr.20090121164439.6176"><vh>scanOptions</vh></v>
</v>
</v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh>
<v t="ekr.20051104075904.1"><vh>&lt;&lt; leoTest imports &gt;&gt;</vh></v>
<v t="ekr.20051104075904.2"><vh>Support @profile, @suite, @test, @timer</vh>
<v t="ekr.20051104075904.3"><vh>isSuiteNode and isTestNode</vh></v>
<v t="ekr.20051104075904.4"><vh>doTests...</vh>
<v t="ekr.20051104075904.5"><vh>class generalTestCase</vh>
<v t="ekr.20051104075904.6"><vh>__init__</vh></v>
<v t="ekr.20051104075904.7"><vh> fail</vh></v>
<v t="ekr.20051104075904.9"><vh>tearDown</vh></v>
<v t="ekr.20051104075904.8"><vh>setUp</vh></v>
<v t="ekr.20051104075904.10"><vh>runTest</vh></v>
<v t="ekr.20051104075904.11"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20051104075904.12"><vh>makeTestSuite</vh></v>
<v t="ekr.20051104075904.13"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20051104075904.14"><vh>runProfileOnNode</vh></v>
<v t="ekr.20051104075904.15"><vh>runTimerOnNode</vh></v>
</v>
<v t="ekr.20051104075904.16"><vh>run gc</vh>
<v t="ekr.20051104075904.17"><vh>runGC</vh></v>
<v t="ekr.20051104075904.18"><vh>enableGc</vh></v>
<v t="ekr.20051104075904.19"><vh>makeObjectList</vh></v>
<v t="ekr.20051104075904.20"><vh>printGc</vh>
<v t="ekr.20051104075904.21"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
<v t="ekr.20051104075904.22"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20051104075904.23"><vh>printGcRefs</vh></v>
</v>
<v t="ekr.20051104075904.24"><vh> class testUtils</vh>
<v t="ekr.20060106114716.1"><vh>ctor (testUtils)</vh></v>
<v t="ekr.20051104075904.25"><vh>compareOutlines</vh></v>
<v t="ekr.20051104075904.26"><vh>Finding nodes...</vh>
<v t="ekr.20051104075904.27"><vh>findChildrenOf</vh></v>
<v t="ekr.20051104075904.28"><vh>findSubnodesOf</vh></v>
<v t="ekr.20051104075904.29"><vh>findNodeInRootTree</vh></v>
<v t="ekr.20051104075904.30"><vh>u.findNodeInTree</vh></v>
<v t="ekr.20051104075904.31"><vh>findNodeAnywhere</vh></v>
</v>
<v t="ekr.20051104075904.33"><vh>numberOfClonesInOutline</vh></v>
<v t="ekr.20051104075904.34"><vh>numberOfNodesInOutline</vh></v>
<v t="sps.20100720205345.26316"><vh>showTwoBodies</vh></v>
<v t="ekr.20051104075904.36"><vh>testUtils.writeNode/sToNode</vh>
<v t="ekr.20051104075904.37"><vh>writeNodesToNode</vh></v>
<v t="ekr.20051104075904.38"><vh>writeNodeToNode</vh></v>
<v t="ekr.20051104075904.39"><vh>writeNodeToString</vh></v>
</v>
<v t="ekr.20051104075904.40"><vh>testUtils.compareIgnoringNodeNames</vh></v>
</v>
<v t="ekr.20051104075904.41"><vh> fail</vh></v>
<v t="ekr.20051104075904.42"><vh>runLeoTest</vh></v>
<v t="ekr.20090514072254.5746"><vh>runUnitTestLeoFile</vh></v>
<v t="ekr.20070627135407"><vh>runTestsExternally</vh></v>
<v t="ekr.20070627140344"><vh>class runTestExternallyHelperClass</vh>
<v t="ekr.20070627140344.1"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20070627135336.10"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070627135336.9"><vh>createOutline &amp; helpers</vh>
<v t="ekr.20070705065154"><vh>&lt;&lt; set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 &gt;&gt;</vh></v>
<v t="ekr.20070705080413"><vh>addMarkTree</vh></v>
<v t="ekr.20070705065154.1"><vh>addNode</vh></v>
<v t="ekr.20070705075604.3"><vh>isUnitTestNode</vh></v>
</v>
<v t="ekr.20070627140344.2"><vh>runTests</vh></v>
<v t="ekr.20070627135336.8"><vh>searchOutline</vh></v>
</v>
<v t="ekr.20051104075904.43"><vh>Specific to particular unit tests...</vh>
<v t="ekr.20051104075904.44"><vh>at-File test code (leoTest.py)</vh>
<v t="ekr.20051104075904.45"><vh>&lt;&lt; dump result and expected &gt;&gt;</vh></v>
</v>
<v t="sps.20100531175334.10307"><vh>root-File tangle test code (leoTest.py)</vh>
<v t="sps.20100531175334.10309"><vh>&lt;&lt; dump result file names and expected &gt;&gt;</vh></v>
</v>
<v t="sps.20100618004337.16260"><vh>root-File untangle test code (leoTest.py)</vh></v>
<v t="ekr.20051104075904.99"><vh>createUnitTestsFromDoctests</vh></v>
<v t="ekr.20051104075904.68"><vh>Edit Body test code (leoTest.py)</vh>
<v t="ekr.20051104075904.69"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20051104075904.70"><vh>class editBodyTestCase</vh>
<v t="ekr.20051104075904.71"><vh> __init__</vh></v>
<v t="ekr.20051104075904.72"><vh> fail</vh></v>
<v t="ekr.20051104075904.73"><vh>editBody</vh></v>
<v t="ekr.20051104075904.74"><vh>runTest</vh></v>
<v t="ekr.20051104075904.75"><vh>setUp</vh></v>
<v t="ekr.20051104075904.76"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20051104075904.77"><vh>Import/Export test code (leoTest.py)</vh>
<v t="ekr.20051104075904.78"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20051104075904.79"><vh>class importExportTestCase</vh>
<v t="ekr.20051104075904.80"><vh>__init__</vh></v>
<v t="ekr.20051104075904.81"><vh> fail</vh></v>
<v t="ekr.20051104075904.82"><vh>importExport</vh></v>
<v t="ekr.20051104075904.83"><vh>runTest</vh></v>
<v t="ekr.20051104075904.84"><vh>setUp</vh></v>
<v t="ekr.20051104075904.85"><vh>shortDescription</vh></v>
<v t="ekr.20051104075904.86"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20051104075904.90"><vh>Plugin tests... (leoTest.py)</vh>
<v t="ekr.20051104075904.91"><vh>getAllPluginFilenames</vh></v>
<v t="ekr.20051104075904.92"><vh>testPlugin (no longer used)</vh></v>
<v t="ekr.20051104075904.93"><vh>checkFileSyntax (leoTest.py)</vh></v>
<v t="ekr.20051104075904.94"><vh>checkFileTabs</vh></v>
</v>
<v t="ekr.20051104075904.46"><vh>Reformat Paragraph test code (leoTest.py)</vh>
<v t="ekr.20051104075904.47"><vh>class reformatParagraphTest</vh>
<v t="ekr.20051104075904.48"><vh>__init__</vh></v>
<v t="ekr.20051104075904.49"><vh>go</vh></v>
<v t="ekr.20051104075904.50"><vh>checkPosition</vh></v>
<v t="ekr.20051104075904.51"><vh>checkText</vh></v>
<v t="ekr.20051104075904.52"><vh>copyBeforeToTemp</vh></v>
<v t="ekr.20051104075904.53"><vh>getRowCol</vh></v>
<v t="ekr.20051104075904.54"><vh>runTest</vh></v>
<v t="ekr.20051104075904.55"><vh>setUp</vh></v>
<v t="ekr.20051104075904.56"><vh>tearDown</vh></v>
</v>
<v t="ekr.20051104075904.57"><vh>class singleParagraphTest (reformatParagraphTest)</vh>
<v t="ekr.20051104075904.58"><vh>__init__</vh></v>
<v t="ekr.20051104075904.59"><vh>runTest</vh></v>
</v>
<v t="ekr.20051104075904.60"><vh>class multiParagraphTest (reformatParagraphTest)</vh>
<v t="ekr.20051104075904.61"><vh>runTest</vh></v>
</v>
<v t="ekr.20051104075904.62"><vh>class multiParagraphWithListTest (reformatParagraphTest)</vh>
<v t="ekr.20051104075904.63"><vh>runTest</vh></v>
</v>
<v t="ekr.20051104075904.64"><vh>class leadingWSOnEmptyLinesTest (reformatParagraphTest)</vh>
<v t="ekr.20051104075904.65"><vh>runTest</vh></v>
</v>
<v t="ekr.20051104075904.66"><vh>class testDirectiveBreaksParagraph (reformatParagraphTest)</vh>
<v t="ekr.20051104075904.67"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20061008140603"><vh>runEditCommandTest</vh></v>
<v t="ekr.20051104075904.95"><vh>throwAssertionError</vh></v>
</v>
<v t="ekr.20051104075904.96"><vh>Test of doctest</vh>
<v t="ekr.20051104075904.97"><vh>factorial</vh></v>
</v>
<v t="ekr.20051104075904.98"><vh>Utils</vh>
<v t="ekr.20051104075904.100"><vh>findAllAtFileNodes</vh></v>
<v t="ekr.20051104075904.101"><vh>importAllModulesInPathList</vh></v>
<v t="ekr.20051104075904.102"><vh>importAllModulesInPath</vh></v>
<v t="ekr.20051104075904.103"><vh>safeImportModule</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430152000">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self._bodyString,0,"@all")
    return flag
</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040503070514">def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
</t>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; import leo.core.leoGlobals as g
    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', '', '')

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    ('', '&lt;!--', '--&gt;')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
</t>
<t tx="EKR.20040504154039">def is_sentinel (line,delims):

    &lt;&lt; is_sentinel doc tests &gt;&gt;

    delim1,delim2,delim3 = delims

    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i &lt; j
    else:
        g.trace("can't happen. delims: %s" % repr(delims),color="red")
        return False
</t>
<t tx="EKR.20040512082621"></t>
<t tx="EKR.20040512082621.1">http://sourceforge.net/forum/message.php?msg_id=2565345
By: nobody

I just met a nice TCL-based html help viewer bundled with the evaluation version
of Fujitsu-Siemens OpenFT for Unix (see
fujitsu-siemens.com/products/software/openseas/openft.html)

It is based on a TCL library htmllib.tcl, written by Stephen Uhler in 1995 while
working in Sun's TCL group.Iit seemts that this lib is owned by Sun and i'm
not certain about license. It is freely downloadable, anyway.

The usage is really simple -- you have to create a text widget, a string variable
containing html text and a link callback, then feed all three to the library
routine. It should be not hard pythonize this process.

see http://www.usenix.org/publications/login/1999-8/features/tclsh.html,
ftp://ftp.scriptics.com/pub/tcl/misc/html_library-0.3.tar.gz
or just google for htmllib.tcl
</t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040523192553"></t>
<t tx="EKR.20040526072519.2">def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
</t>
<t tx="EKR.20040526075238.5">def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="EKR.20040526090701.4">def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="EKR.20040526150818">def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
</t>
<t tx="EKR.20040526150818.1">def peekBead (self,n):

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
</t>
<t tx="EKR.20040526202501">def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
</t>
<t tx="EKR.20040528075307">def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="EKR.20040530114124">@ The old code made a free-standing copy of the tree using v.copy and
t.copy. This looks "elegant" and is WRONG. The problem is that it can
not handle clones properly, especially when some clones were in the
"undo" tree and some were not. Moreover, it required complex
adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information
needed to properly restore the vnodes and tnodes. It creates a list of
tuples, on tuple for each vnode in the tree. Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to
recreate the nodes. The v.createUndoInfoDict and t.createUndoInfoDict
methods correspond to the old v.copy and t.copy methods.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="EKR.20040530121329">def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
</t>
<t tx="EKR.20040602125018">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=500):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler

    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
</t>
<t tx="EKR.20040602125018.1"># Disables the "idle" hook.
def disableIdleTimeHook():

    g.app.idleTimeHook = False
</t>
<t tx="EKR.20040602125018.2"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):

    trace = False and not g.unitTesting

    if trace: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if 0:
            g.pr('idleTimeHookHandler',trace_count)
        else:
            if trace_count % 10 == 0:
                for z in g.app.windowList:
                    c = z.c
                    g.pr("idleTimeHookHandler",trace_count,c.shortFileName())

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return

    for z in g.app.windowList:
        c = z.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="EKR.20040606104355">@nocolor

From: &lt;eltronic@juno.com&gt;
To: &lt;edreamleo@charter.net&gt;
Sent: Sunday, May 23, 2004 9:36 AM
Subject: fatal bug in Leo headline handling


&gt; found a fatal bug in Leo headline handling.
&gt; not sure if anyone reported before,
&gt; an oversize string can crash python 2.3.3
&gt; 
&gt; 
&gt; the text was about 4500 bytes. nothing but text.
&gt; opened the  leo again, copy a large page of text,
&gt; insert headline, paste, fatal error in python.
&gt; 
&gt; I have by mistake pasted whatever node xml was in 
&gt; the copy buffer into a headline w/o problem.
&gt; but that was just dumb luck. just verified,
&gt; had the node been large enough it crashes.
&gt; 
&gt; Leo 4.1 final, py2.3.3 win98
&gt; PYTHON caused an invalid page fault in
&gt; module TK84.DLL at 0167:1022b74f.
&gt; 
&gt; Leo 4.1 final, py2.2 win98
&gt; paste a 15k node copy into headline. no problem.
&gt; 
&gt; this is the first repeatable hard crash I've stumbled on
&gt; and thought it best to report it privately.
&gt; I can think of no advantage to allowing a headline 
&gt; of this size anyway. think of the tooltip that would create!
&gt; 
&gt; there are latent bugs in the selectall and delete from 
&gt; the edit menu related to headline as well on the todo list.
&gt; reported many times. 
&gt; covert destruction of the selected body text.
&gt; use of virtual events, with out proper focus to headline.
&gt; 
&gt; without myself being able to supply a patch, I'll guess,
&gt; the virtual event paste called can as well point 
&gt; to a function that checks the size before pasting.
&gt; or simply sets the headline directly with 
&gt; g.app.gui.getTextFromClipboard()[:1024]
&gt; 
&gt; 
&gt; e
</t>
<t tx="EKR.20040610094819"># Visible externally so plugins may add to the list of directives.

globalDirectiveList = [

    # Longer prefixes must appear before shorter.
    'all',
    'code','color', 'comment','c',
    'delims','doc','encoding','end_raw',
    'first','header','ignore','killcolor',
    'language','last','lineending',
    'markup', # Make this an official directive,
    'nocolor-node','nocolor','noheader','nowrap',
    'others','pagewidth','path','quiet',
    'raw','root-code','root-doc','root','silent',
    'tabwidth', 'terse',
    'unit','verbose', 'wrap',
]
</t>
<t tx="EKR.20040610130943">def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
</t>
<t tx="EKR.20040612114220"></t>
<t tx="EKR.20040612114220.3"># This has been replaced by readLinesClass because
# yield is not valid in jython.

# def readLinesGenerator(s):

    # for line in g.splitLines(s):
        # # g.trace(repr(line))
        # yield line
    # yield ''
</t>
<t tx="EKR.20040612114220.4">class readLinesClass:

    """A class whose next method provides a readline method for Python's tokenize module."""

    def __init__ (self,s):
        self.lines = g.splitLines(s)
        self.i = 0

    def next(self):
        if self.i &lt; len(self.lines):
            line = self.lines[self.i]
            self.i += 1
        else:
            line = ''
        # g.trace(repr(line))
        return line

    __next__ = next
</t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    f = open(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print('',s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i &lt; j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es('',s,newline=False)
    i += 1
</t>
<t tx="EKR.20040612232221"># Called from g.handleScriptException.

def goToScriptLineNumber (self,p,script,n):

    """Go to line n of a script."""

    c = self

    scriptData = {'p':p.copy(),'lines':g.splitLines(script)}
    c.goToLineNumber(c).go(n=n,scriptData=scriptData)
</t>
<t tx="EKR.20040614071102.1">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    # New in Leo 4.6 b2: use a pristine atFile handler
    # so there can be no conflict with c.atFileCommands.
    # at = c.atFileCommands
    import leo.core.leoAtFile as leoAtFile
    at = leoAtFile.atFile(c)

    w = c.frame.body.bodyCtrl
    p1 = p and p.copy()
    if not p:
        p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif p1:
            s = p.b # Bug fix: Leo 8.8.4.
        elif p == c.p:
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            # Important: converts unicode to utf-8 encoded strings.
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
</t>
<t tx="EKR.20040623090054">case_insensitiveLanguages = ['plsql',]
</t>
<t tx="EKR.20040627100424">def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="EKR.20040627114602"># Pre Leo 4.5 Only @thin vnodes had the descendentTnodeUnknownAttributes field.
# New in Leo 4.5: @thin &amp; @shadow vnodes have descendentVnodeUnknownAttributes field.

def getDescendentUnknownAttributes (self,s):

    '''Unhexlify and unpickle t/v.descendentUnknownAttribute field.'''

    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except:
        g.es_exception()
        g.trace('Can not unpickle',s)
        return None
</t>
<t tx="EKR.20040627120120">def restoreDescendentAttributes (self):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c

    for resultDict in self.descendentTnodeUaDictList:
        if trace and verbose: g.trace('t.dict',resultDict)
        for gnx in resultDict:
            tref = self.canonicalTnodeIndex(gnx)
            v = self.gnxDict.get(tref)
            if v:
                v.unknownAttributes = resultDict[gnx]
                v._p_changed = 1
            elif verbose:
                g.trace('can not find vnode (duA): gnx = %s' % (gnx),color='red')

    # New in Leo 4.5: keys are archivedPositions, values are attributes.
    for root_v,resultDict in self.descendentVnodeUaDictList:
        if trace and verbose: g.trace('v.dict',resultDict)
        for key in resultDict:
            v = self.resolveArchivedPosition(key,root_v)
            if v:
                v.unknownAttributes = resultDict[key]
                v._p_changed = 1
            elif verbose:
                g.trace('can not find vnode (duA): archivedPosition: %s, root_v: %s' % (
                    key,root_v),color='red')

    marks = {} ; expanded = {}
    for gnx in self.descendentExpandedList:
        tref = self.canonicalTnodeIndex(gnx)
        v = self.gnxDict.get(gnx)
        if v:
            expanded[v]=v
            # if trace: g.trace('expanded',v)
        elif verbose:
            g.trace('can not find vnode (expanded): gnx = %s, tref: %s' % (gnx,tref),color='red')

    for gnx in self.descendentMarksList:
        tref = self.canonicalTnodeIndex(gnx)
        v = self.gnxDict.get(gnx)
        if v: marks[v]=v
        elif verbose:
            g.trace('can not find vnode (marks): gnx = %s tref: %s' % (gnx,tref),color='red')

    if marks or expanded:
        # g.trace('marks',len(marks),'expanded',len(expanded))
        for p in c.all_unique_positions():
            if marks.get(p.v):
                p.v.initMarkedBit()
                    # This was the problem: was p.setMark.
                    # There was a big performance bug in the mark hook in the Node Navigator plugin.
            if expanded.get(p.v):
                p.expand()
                # if trace: g.trace('expand',p.h)
</t>
<t tx="bob.20071231111744.2">def getColor(name, default=None):
    """ Translate a named color into #rrggbb' format.

    if 'name' is not a string it is returned unchanged.

    If 'name' is already in '#rrggbb' format then it is returned unchanged.

    If 'name' is not in global_color_database then getColor(default, None)
    is called and that result returned.


    """

    if not g.isString(name):
        return name

    #g.trace(name, default)

    if name[0] == '#':
        return name

    name = name.replace(' ', '').lower()

    if name in leo_color_database:
        return leo_color_database[name]

    if default:
        return getColor(default, default=None)

    return None

get = getColor
</t>
<t tx="bob.20080115070511.2">@
All names added to this database should be in normalized form,
otherwise the accessor functions won't work.

Adding names here will make them availiable to all gui's and
dhtml that use this service.

Names are normalized by removing spaces and capitalization.
@c

leo_color_database = {

    # leo colors
    "leoblue": "#F0F8FF", #alice blue
    "leoyellow": "#ffffec",
    "leopink":  "#FFE4E1", # misty rose

    "aliceblue": "#F0F8FF",
    "antiquewhite": "#FAEBD7",
    "antiquewhite1": "#FFEFDB",
    "antiquewhite2": "#EEDFCC",
    "antiquewhite3": "#CDC0B0",
    "antiquewhite4": "#8B8378",
    "aquamarine": "#7FFFD4",
    "aquamarine1": "#7FFFD4",
    "aquamarine2": "#76EEC6",
    "aquamarine3": "#66CDAA",
    "aquamarine4": "#458B74",
    "azure": "#F0FFFF",
    "azure1": "#F0FFFF",
    "azure2": "#E0EEEE",
    "azure3": "#C1CDCD",
    "azure4": "#838B8B",
    "beige": "#F5F5DC",
    "bisque": "#FFE4C4",
    "bisque1": "#FFE4C4",
    "bisque2": "#EED5B7",
    "bisque3": "#CDB79E",
    "bisque4": "#8B7D6B",
    "black": "#000000",
    "blanchedalmond": "#FFEBCD",
    "blue": "#0000FF",
    "blue1": "#0000FF",
    "blue2": "#0000EE",
    "blue3": "#0000CD",
    "blue4": "#00008B",
    "blueviolet": "#8A2BE2",
    "brown": "#A52A2A",
    "brown1": "#FF4040",
    "brown2": "#EE3B3B",
    "brown3": "#CD3333",
    "brown4": "#8B2323",
    "burlywood": "#DEB887",
    "burlywood1": "#FFD39B",
    "burlywood2": "#EEC591",
    "burlywood3": "#CDAA7D",
    "burlywood4": "#8B7355",
    "cadetblue": "#5F9EA0",
    "cadetblue1": "#98F5FF",
    "cadetblue2": "#8EE5EE",
    "cadetblue3": "#7AC5CD",
    "cadetblue4": "#53868B",
    "chartreuse": "#7FFF00",
    "chartreuse1": "#7FFF00",
    "chartreuse2": "#76EE00",
    "chartreuse3": "#66CD00",
    "chartreuse4": "#458B00",
    "chocolate": "#D2691E",
    "chocolate1": "#FF7F24",
    "chocolate2": "#EE7621",
    "chocolate3": "#CD661D",
    "chocolate4": "#8B4513",
    "coral": "#FF7F50",
    "coral1": "#FF7256",
    "coral2": "#EE6A50",
    "coral3": "#CD5B45",
    "coral4": "#8B3E2F",
    "cornflowerblue": "#6495ED",
    "cornsilk": "#FFF8DC",
    "cornsilk1": "#FFF8DC",
    "cornsilk2": "#EEE8CD",
    "cornsilk3": "#CDC8B1",
    "cornsilk4": "#8B8878",
    "cyan": "#00FFFF",
    "cyan1": "#00FFFF",
    "cyan2": "#00EEEE",
    "cyan3": "#00CDCD",
    "cyan4": "#008B8B",
    "darkblue": "#00008B",
    "darkcyan": "#008B8B",
    "darkgoldenrod": "#B8860B",
    "darkgoldenrod1": "#FFB90F",
    "darkgoldenrod2": "#EEAD0E",
    "darkgoldenrod3": "#CD950C",
    "darkgoldenrod4": "#8B6508",
    "darkgray": "#A9A9A9",
    "darkgreen": "#006400",
    "darkgrey": "#A9A9A9",
    "darkkhaki": "#BDB76B",
    "darkmagenta": "#8B008B",
    "darkolivegreen": "#556B2F",
    "darkolivegreen1": "#CAFF70",
    "darkolivegreen2": "#BCEE68",
    "darkolivegreen3": "#A2CD5A",
    "darkolivegreen4": "#6E8B3D",
    "darkorange": "#FF8C00",
    "darkorange1": "#FF7F00",
    "darkorange2": "#EE7600",
    "darkorange3": "#CD6600",
    "darkorange4": "#8B4500",
    "darkorchid": "#9932CC",
    "darkorchid1": "#BF3EFF",
    "darkorchid2": "#B23AEE",
    "darkorchid3": "#9A32CD",
    "darkorchid4": "#68228B",
    "darkred": "#8B0000",
    "darksalmon": "#E9967A",
    "darkseagreen": "#8FBC8F",
    "darkseagreen1": "#C1FFC1",
    "darkseagreen2": "#B4EEB4",
    "darkseagreen3": "#9BCD9B",
    "darkseagreen4": "#698B69",
    "darkslateblue": "#483D8B",
    "darkslategray": "#2F4F4F",
    "darkslategray1": "#97FFFF",
    "darkslategray2": "#8DEEEE",
    "darkslategray3": "#79CDCD",
    "darkslategray4": "#528B8B",
    "darkslategrey": "#2F4F4F",
    "darkturquoise": "#00CED1",
    "darkviolet": "#9400D3",
    "deeppink": "#FF1493",
    "deeppink1": "#FF1493",
    "deeppink2": "#EE1289",
    "deeppink3": "#CD1076",
    "deeppink4": "#8B0A50",
    "deepskyblue": "#00BFFF",
    "deepskyblue1": "#00BFFF",
    "deepskyblue2": "#00B2EE",
    "deepskyblue3": "#009ACD",
    "deepskyblue4": "#00688B",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1E90FF",
    "dodgerblue1": "#1E90FF",
    "dodgerblue2": "#1C86EE",
    "dodgerblue3": "#1874CD",
    "dodgerblue4": "#104E8B",
    "firebrick": "#B22222",
    "firebrick1": "#FF3030",
    "firebrick2": "#EE2C2C",
    "firebrick3": "#CD2626",
    "firebrick4": "#8B1A1A",
    "floralwhite": "#FFFAF0",
    "forestgreen": "#228B22",
    "gainsboro": "#DCDCDC",
    "ghostwhite": "#F8F8FF",
    "gold": "#FFD700",
    "gold1": "#FFD700",
    "gold2": "#EEC900",
    "gold3": "#CDAD00",
    "gold4": "#8B7500",
    "goldenrod": "#DAA520",
    "goldenrod1": "#FFC125",
    "goldenrod2": "#EEB422",
    "goldenrod3": "#CD9B1D",
    "goldenrod4": "#8B6914",
    "gray": "#BEBEBE",
    "gray0": "#000000",
    "gray1": "#030303",
    "gray10": "#1A1A1A",
    "gray100": "#FFFFFF",
    "gray11": "#1C1C1C",
    "gray12": "#1F1F1F",
    "gray13": "#212121",
    "gray14": "#242424",
    "gray15": "#262626",
    "gray16": "#292929",
    "gray17": "#2B2B2B",
    "gray18": "#2E2E2E",
    "gray19": "#303030",
    "gray2": "#050505",
    "gray20": "#333333",
    "gray21": "#363636",
    "gray22": "#383838",
    "gray23": "#3B3B3B",
    "gray24": "#3D3D3D",
    "gray25": "#404040",
    "gray26": "#424242",
    "gray27": "#454545",
    "gray28": "#474747",
    "gray29": "#4A4A4A",
    "gray3": "#080808",
    "gray30": "#4D4D4D",
    "gray31": "#4F4F4F",
    "gray32": "#525252",
    "gray33": "#545454",
    "gray34": "#575757",
    "gray35": "#595959",
    "gray36": "#5C5C5C",
    "gray37": "#5E5E5E",
    "gray38": "#616161",
    "gray39": "#636363",
    "gray4": "#0A0A0A",
    "gray40": "#666666",
    "gray41": "#696969",
    "gray42": "#6B6B6B",
    "gray43": "#6E6E6E",
    "gray44": "#707070",
    "gray45": "#737373",
    "gray46": "#757575",
    "gray47": "#787878",
    "gray48": "#7A7A7A",
    "gray49": "#7D7D7D",
    "gray5": "#0D0D0D",
    "gray50": "#7F7F7F",
    "gray51": "#828282",
    "gray52": "#858585",
    "gray53": "#878787",
    "gray54": "#8A8A8A",
    "gray55": "#8C8C8C",
    "gray56": "#8F8F8F",
    "gray57": "#919191",
    "gray58": "#949494",
    "gray59": "#969696",
    "gray6": "#0F0F0F",
    "gray60": "#999999",
    "gray61": "#9C9C9C",
    "gray62": "#9E9E9E",
    "gray63": "#A1A1A1",
    "gray64": "#A3A3A3",
    "gray65": "#A6A6A6",
    "gray66": "#A8A8A8",
    "gray67": "#ABABAB",
    "gray68": "#ADADAD",
    "gray69": "#B0B0B0",
    "gray7": "#121212",
    "gray70": "#B3B3B3",
    "gray71": "#B5B5B5",
    "gray72": "#B8B8B8",
    "gray73": "#BABABA",
    "gray74": "#BDBDBD",
    "gray75": "#BFBFBF",
    "gray76": "#C2C2C2",
    "gray77": "#C4C4C4",
    "gray78": "#C7C7C7",
    "gray79": "#C9C9C9",
    "gray8": "#141414",
    "gray80": "#CCCCCC",
    "gray81": "#CFCFCF",
    "gray82": "#D1D1D1",
    "gray83": "#D4D4D4",
    "gray84": "#D6D6D6",
    "gray85": "#D9D9D9",
    "gray86": "#DBDBDB",
    "gray87": "#DEDEDE",
    "gray88": "#E0E0E0",
    "gray89": "#E3E3E3",
    "gray9": "#171717",
    "gray90": "#E5E5E5",
    "gray91": "#E8E8E8",
    "gray92": "#EBEBEB",
    "gray93": "#EDEDED",
    "gray94": "#F0F0F0",
    "gray95": "#F2F2F2",
    "gray96": "#F5F5F5",
    "gray97": "#F7F7F7",
    "gray98": "#FAFAFA",
    "gray99": "#FCFCFC",
    "green": "#00FF00",
    "green1": "#00FF00",
    "green2": "#00EE00",
    "green3": "#00CD00",
    "green4": "#008B00",
    "greenyellow": "#ADFF2F",
    "grey": "#BEBEBE",
    "grey0": "#000000",
    "grey1": "#030303",
    "grey10": "#1A1A1A",
    "grey100": "#FFFFFF",
    "grey11": "#1C1C1C",
    "grey12": "#1F1F1F",
    "grey13": "#212121",
    "grey14": "#242424",
    "grey15": "#262626",
    "grey16": "#292929",
    "grey17": "#2B2B2B",
    "grey18": "#2E2E2E",
    "grey19": "#303030",
    "grey2": "#050505",
    "grey20": "#333333",
    "grey21": "#363636",
    "grey22": "#383838",
    "grey23": "#3B3B3B",
    "grey24": "#3D3D3D",
    "grey25": "#404040",
    "grey26": "#424242",
    "grey27": "#454545",
    "grey28": "#474747",
    "grey29": "#4A4A4A",
    "grey3": "#080808",
    "grey30": "#4D4D4D",
    "grey31": "#4F4F4F",
    "grey32": "#525252",
    "grey33": "#545454",
    "grey34": "#575757",
    "grey35": "#595959",
    "grey36": "#5C5C5C",
    "grey37": "#5E5E5E",
    "grey38": "#616161",
    "grey39": "#636363",
    "grey4": "#0A0A0A",
    "grey40": "#666666",
    "grey41": "#696969",
    "grey42": "#6B6B6B",
    "grey43": "#6E6E6E",
    "grey44": "#707070",
    "grey45": "#737373",
    "grey46": "#757575",
    "grey47": "#787878",
    "grey48": "#7A7A7A",
    "grey49": "#7D7D7D",
    "grey5": "#0D0D0D",
    "grey50": "#7F7F7F",
    "grey51": "#828282",
    "grey52": "#858585",
    "grey53": "#878787",
    "grey54": "#8A8A8A",
    "grey55": "#8C8C8C",
    "grey56": "#8F8F8F",
    "grey57": "#919191",
    "grey58": "#949494",
    "grey59": "#969696",
    "grey6": "#0F0F0F",
    "grey60": "#999999",
    "grey61": "#9C9C9C",
    "grey62": "#9E9E9E",
    "grey63": "#A1A1A1",
    "grey64": "#A3A3A3",
    "grey65": "#A6A6A6",
    "grey66": "#A8A8A8",
    "grey67": "#ABABAB",
    "grey68": "#ADADAD",
    "grey69": "#B0B0B0",
    "grey7": "#121212",
    "grey70": "#B3B3B3",
    "grey71": "#B5B5B5",
    "grey72": "#B8B8B8",
    "grey73": "#BABABA",
    "grey74": "#BDBDBD",
    "grey75": "#BFBFBF",
    "grey76": "#C2C2C2",
    "grey77": "#C4C4C4",
    "grey78": "#C7C7C7",
    "grey79": "#C9C9C9",
    "grey8": "#141414",
    "grey80": "#CCCCCC",
    "grey81": "#CFCFCF",
    "grey82": "#D1D1D1",
    "grey84": "#D6D6D6",
    "grey85": "#D9D9D9",
    "grey86": "#DBDBDB",
    "grey87": "#DEDEDE",
    "grey88": "#E0E0E0",
    "grey89": "#E3E3E3",
    "grey9": "#171717",
    "grey90": "#E5E5E5",
    "grey91": "#E8E8E8",
    "grey92": "#EBEBEB",
    "grey93": "#EDEDED",
    "grey94": "#F0F0F0",
    "grey95": "#F2F2F2",
    "grey96": "#F5F5F5",
    "grey97": "#F7F7F7",
    "grey98": "#FAFAFA",
    "grey99": "#FCFCFC",
    "honeydew": "#F0FFF0",
    "honeydew1": "#F0FFF0",
    "honeydew2": "#E0EEE0",
    "honeydew3": "#C1CDC1",
    "honeydew4": "#838B83",
    "hotpink": "#FF69B4",
    "hotpink1": "#FF6EB4",
    "hotpink2": "#EE6AA7",
    "hotpink3": "#CD6090",
    "hotpink4": "#8B3A62",
    "indianred": "#CD5C5C",
    "indianred1": "#FF6A6A",
    "indianred2": "#EE6363",
    "indianred3": "#CD5555",
    "indianred4": "#8B3A3A",
    "ivory": "#FFFFF0",
    "ivory1": "#FFFFF0",
    "ivory2": "#EEEEE0",
    "ivory3": "#CDCDC1",
    "ivory4": "#8B8B83",
    "khaki": "#F0E68C",
    "khaki1": "#FFF68F",
    "khaki2": "#EEE685",
    "khaki3": "#CDC673",
    "khaki4": "#8B864E",
    "lavender": "#E6E6FA",
    "lavenderblush": "#FFF0F5",
    "lavenderblush1": "#FFF0F5",
    "lavenderblush2": "#EEE0E5",
    "lavenderblush3": "#CDC1C5",
    "lavenderblush4": "#8B8386",
    "lawngreen": "#7CFC00",
    "lemonchiffon": "#FFFACD",
    "lemonchiffon1": "#FFFACD",
    "lemonchiffon2": "#EEE9BF",
    "lemonchiffon3": "#CDC9A5",
    "lemonchiffon4": "#8B8970",
    "lightblue": "#ADD8E6",
    "lightblue1": "#BFEFFF",
    "lightblue2": "#B2DFEE",
    "lightblue3": "#9AC0CD",
    "lightblue4": "#68838B",
    "lightcoral": "#F08080",
    "lightcyan": "#E0FFFF",
    "lightcyan1": "#E0FFFF",
    "lightcyan2": "#D1EEEE",
    "lightcyan3": "#B4CDCD",
    "lightcyan4": "#7A8B8B",
    "lightgoldenrod": "#EEDD82",
    "lightgoldenrod1": "#FFEC8B",
    "lightgoldenrod2": "#EEDC82",
    "lightgoldenrod3": "#CDBE70",
    "lightgoldenrod4": "#8B814C",
    "lightgoldenrodyellow": "#FAFAD2",
    "lightgray": "#D3D3D3",
    "lightgreen": "#90EE90",
    "lightgrey": "#D3D3D3",
    "lightpink": "#FFB6C1",
    "lightpink1": "#FFAEB9",
    "lightpink2": "#EEA2AD",
    "lightpink3": "#CD8C95",
    "lightpink4": "#8B5F65",
    "lightsalmon": "#FFA07A",
    "lightsalmon1": "#FFA07A",
    "lightsalmon2": "#EE9572",
    "lightsalmon3": "#CD8162",
    "lightsalmon4": "#8B5742",
    "lightseagreen": "#20B2AA",
    "lightskyblue": "#87CEFA",
    "lightskyblue1": "#B0E2FF",
    "lightskyblue2": "#A4D3EE",
    "lightskyblue3": "#8DB6CD",
    "lightskyblue4": "#607B8B",
    "lightslateblue": "#8470FF",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#B0C4DE",
    "lightsteelblue1": "#CAE1FF",
    "lightsteelblue2": "#BCD2EE",
    "lightsteelblue3": "#A2B5CD",
    "lightsteelblue4": "#6E7B8B",
    "lightyellow": "#FFFFE0",
    "lightyellow1": "#FFFFE0",
    "lightyellow2": "#EEEED1",
    "lightyellow3": "#CDCDB4",
    "lightyellow4": "#8B8B7A",
    "limegreen": "#32CD32",
    "linen": "#FAF0E6",
    "magenta": "#FF00FF",
    "magenta1": "#FF00FF",
    "magenta2": "#EE00EE",
    "magenta3": "#CD00CD",
    "magenta4": "#8B008B",
    "maroon": "#B03060",
    "maroon1": "#FF34B3",
    "maroon2": "#EE30A7",
    "maroon3": "#CD2990",
    "maroon4": "#8B1C62",
    "mediumaquamarine": "#66CDAA",
    "mediumblue": "#0000CD",
    "mediumorchid": "#BA55D3",
    "mediumorchid1": "#E066FF",
    "mediumorchid2": "#D15FEE",
    "mediumorchid3": "#B452CD",
    "mediumorchid4": "#7A378B",
    "mediumpurple": "#9370DB",
    "mediumpurple1": "#AB82FF",
    "mediumpurple2": "#9F79EE",
    "mediumpurple3": "#8968CD",
    "mediumpurple4": "#5D478B",
    "mediumseagreen": "#3CB371",
    "mediumslateblue": "#7B68EE",
    "mediumspringgreen": "#00FA9A",
    "mediumturquoise": "#48D1CC",
    "mediumvioletred": "#C71585",
    "midnightblue": "#191970",
    "mintcream": "#F5FFFA",
    "mistyrose": "#FFE4E1",
    "mistyrose1": "#FFE4E1",
    "mistyrose2": "#EED5D2",
    "mistyrose3": "#CDB7B5",
    "mistyrose4": "#8B7D7B",
    "moccasin": "#FFE4B5",
    "navajowhite": "#FFDEAD",
    "navajowhite1": "#FFDEAD",
    "navajowhite2": "#EECFA1",
    "navajowhite3": "#CDB38B",
    "navajowhite4": "#8B795E",
    "navy": "#000080",
    "navyblue": "#000080",
    "oldlace": "#FDF5E6",
    "olivedrab": "#6B8E23",
    "olivedrab1": "#C0FF3E",
    "olivedrab2": "#B3EE3A",
    "olivedrab3": "#9ACD32",
    "olivedrab4": "#698B22",
    "orange": "#FFA500",
    "orange1": "#FFA500",
    "orange2": "#EE9A00",
    "orange3": "#CD8500",
    "orange4": "#8B5A00",
    "orangered": "#FF4500",
    "orangered1": "#FF4500",
    "orangered2": "#EE4000",
    "orangered3": "#CD3700",
    "orangered4": "#8B2500",
    "orchid": "#DA70D6",
    "orchid1": "#FF83FA",
    "orchid2": "#EE7AE9",
    "orchid3": "#CD69C9",
    "orchid4": "#8B4789",
    "palegoldenrod": "#EEE8AA",
    "palegreen": "#98FB98",
    "palegreen1": "#9AFF9A",
    "palegreen2": "#90EE90",
    "palegreen3": "#7CCD7C",
    "palegreen4": "#548B54",
    "paleturquoise": "#AFEEEE",
    "paleturquoise1": "#BBFFFF",
    "paleturquoise2": "#AEEEEE",
    "paleturquoise3": "#96CDCD",
    "paleturquoise4": "#668B8B",
    "palevioletred": "#DB7093",
    "palevioletred1": "#FF82AB",
    "palevioletred2": "#EE799F",
    "palevioletred3": "#CD6889",
    "palevioletred4": "#8B475D",
    "papayawhip": "#FFEFD5",
    "peachpuff": "#FFDAB9",
    "peachpuff1": "#FFDAB9",
    "peachpuff2": "#EECBAD",
    "peachpuff3": "#CDAF95",
    "peachpuff4": "#8B7765",
    "peru": "#CD853F",
    "pink": "#FFC0CB",
    "pink1": "#FFB5C5",
    "pink2": "#EEA9B8",
    "pink3": "#CD919E",
    "pink4": "#8B636C",
    "plum": "#DDA0DD",
    "plum1": "#FFBBFF",
    "plum2": "#EEAEEE",
    "plum3": "#CD96CD",
    "plum4": "#8B668B",
    "powderblue": "#B0E0E6",
    "purple": "#A020F0",
    "purple1": "#9B30FF",
    "purple2": "#912CEE",
    "purple3": "#7D26CD",
    "purple4": "#551A8B",
    "red": "#FF0000",
    "red1": "#FF0000",
    "red2": "#EE0000",
    "red3": "#CD0000",
    "red4": "#8B0000",
    "rosybrown": "#BC8F8F",
    "rosybrown1": "#FFC1C1",
    "rosybrown2": "#EEB4B4",
    "rosybrown3": "#CD9B9B",
    "rosybrown4": "#8B6969",
    "royalblue": "#4169E1",
    "royalblue1": "#4876FF",
    "royalblue2": "#436EEE",
    "royalblue3": "#3A5FCD",
    "royalblue4": "#27408B",
    "saddlebrown": "#8B4513",
    "salmon": "#FA8072",
    "salmon1": "#FF8C69",
    "salmon2": "#EE8262",
    "salmon3": "#CD7054",
    "salmon4": "#8B4C39",
    "sandybrown": "#F4A460",
    "seagreen": "#2E8B57",
    "seagreen1": "#54FF9F",
    "seagreen2": "#4EEE94",
    "seagreen3": "#43CD80",
    "seagreen4": "#2E8B57",
    "seashell": "#FFF5EE",
    "seashell1": "#FFF5EE",
    "seashell2": "#EEE5DE",
    "seashell3": "#CDC5BF",
    "seashell4": "#8B8682",
    "sienna": "#A0522D",
    "sienna1": "#FF8247",
    "sienna2": "#EE7942",
    "sienna3": "#CD6839",
    "sienna4": "#8B4726",
    "skyblue": "#87CEEB",
    "skyblue1": "#87CEFF",
    "skyblue2": "#7EC0EE",
    "skyblue3": "#6CA6CD",
    "skyblue4": "#4A708B",
    "slateblue": "#6A5ACD",
    "slateblue1": "#836FFF",
    "slateblue2": "#7A67EE",
    "slateblue3": "#6959CD",
    "slateblue4": "#473C8B",
    "slategray": "#708090",
    "slategray1": "#C6E2FF",
    "slategray2": "#B9D3EE",
    "slategray3": "#9FB6CD",
    "slategray4": "#6C7B8B",
    "slategrey": "#708090",
    "snow": "#FFFAFA",
    "snow1": "#FFFAFA",
    "snow2": "#EEE9E9",
    "snow3": "#CDC9C9",
    "snow4": "#8B8989",
    "springgreen": "#00FF7F",
    "springgreen1": "#00FF7F",
    "springgreen2": "#00EE76",
    "springgreen3": "#00CD66",
    "springgreen4": "#008B45",
    "steelblue": "#4682B4",
    "steelblue1": "#63B8FF",
    "steelblue2": "#5CACEE",
    "steelblue3": "#4F94CD",
    "steelblue4": "#36648B",
    "tan": "#D2B48C",
    "tan1": "#FFA54F",
    "tan2": "#EE9A49",
    "tan3": "#CD853F",
    "tan4": "#8B5A2B",
    "thistle": "#D8BFD8",
    "thistle1": "#FFE1FF",
    "thistle2": "#EED2EE",
    "thistle3": "#CDB5CD",
    "thistle4": "#8B7B8B",
    "tomato": "#FF6347",
    "tomato1": "#FF6347",
    "tomato2": "#EE5C42",
    "tomato3": "#CD4F39",
    "tomato4": "#8B3626",
    "turquoise": "#40E0D0",
    "turquoise1": "#00F5FF",
    "turquoise2": "#00E5EE",
    "turquoise3": "#00C5CD",
    "turquoise4": "#00868B",
    "violet": "#EE82EE",
    "violetred": "#D02090",
    "violetred1": "#FF3E96",
    "violetred2": "#EE3A8C",
    "violetred3": "#CD3278",
    "violetred4": "#8B2252",
    "wheat": "#F5DEB3",
    "wheat1": "#FFE7BA",
    "wheat2": "#EED8AE",
    "wheat3": "#CDBA96",
    "wheat4": "#8B7E66",
    "white": "#FFFFFF",
    "whitesmoke": "#F5F5F5",
    "yellow": "#FFFF00",
    "yellow1": "#FFFF00",
    "yellow2": "#EEEE00",
    "yellow3": "#CDCD00",
    "yellow4": "#8B8B00",
    "yellowgreen": "#9ACD32"
}

</t>
<t tx="bob.20080115070511.3"></t>
<t tx="bob.20080115070511.4">def getColorRGB(name, default=None):
    """Convert a named color into an (r, g, b) tuple."""

    s = getColor(name, default)

    try:
        color = int(s[1:3], 16), int(s[3:5], 16), int(s[5:7], 16)
    except:
        color = None

    return color

getRGB = getColorRGB

</t>
<t tx="bob.20080115072302">def getColorCairo(name, default=None):

    """Convert a named color into a cairo color tuple."""

    color = getColorRGB(name, default)
    if color is None:
        return

    r, g, b = color

    return r/255.0, g/255.0, b/255.0

getCairo = getColorCairo

</t>
<t tx="bob.20080115083029">"""Syntax coloring routines and color database for Leo.


In addition to syntax coloring routines, this module also
contains a color database and accessor functions.

leo_color_database is a dictionary of color names mapped onto the
colors '#rrggbb' representation.

The color names are derived from standard Linux color names which
includes all Tk color names.

The names have been normalized by excluding spaces and removing
capitalization. This should also be done for all new colors.

Accessor functions are provided which will normalize name requests
before looking them up in the database.

These are:
    + getColor (aka: get)
    + getColorRGB (aka: getRGB)
    + getColorCairo (aka: getCairo)

It is recommened that these functions should be used thus:

    import leo.core.leoColor as leoColor    
    leoColor.getRGB(name, default)

rather than:

    from leoColor import getRGB
    ....

If neither 'name' nor 'default' can be translated then accessor functions
will return None.
"""
</t>
<t tx="bob.20080115090639">@
plumloco:
    added &lt; &lt;docstring&gt;&gt; and &lt; &lt;changelog&gt;&gt;
    added leo_color_database and its accessor functions

</t>
<t tx="bobjack.20080324141020.4">def doPopup (self,p,kind,name,val):

    """
    Handle @popup menu items in @settings trees.
    """

    popupName = name
    popupType = val

    c = self.c ; aList = [] ; tag = '@menu'

    #g.trace(p, kind, name, val, c)

    aList = []
    p = p.copy()
    self.doPopupItems(p,aList)


    if not hasattr(g.app.config, 'context_menus'):
        g.app.config.context_menus = {}

    #if popupName in g.app.config.context_menus:
        #g.pr('*** duplicate popup ***', popupName)


    g.app.config.context_menus[popupName] = aList
</t>
<t tx="bobjack.20080324141020.5">def doPopupItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.h
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s' % itemName
                        body = p.b
                        self.doPopupItems(p,aList2)
                        aList.append((kind + '\n' + body, aList2),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.b
                        aList.append((head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.h)
            p.moveToThreadNext()
</t>
<t tx="bobjack.20080509080123.2">def universalCallback(self, function):

    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """
    def minibufferCallback(event, function=function):

        # Avoid a pylint complaint.
        if hasattr(self,'theContextMenuController'):
            cm = getattr(self,'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None

        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}

        keywords['mb_event'] = event     

        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
    return minibufferCallback

#fix bobjacks spelling error
universallCallback = universalCallback
</t>
<t tx="bwmulder.20041023131509">self.ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
</t>
<t tx="bwmulder.20041231170726">def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    trace = False and not g.unitTesting
    x = self

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    else:
        if trace: g.trace('not significant',fn)
        # Don't write *anything*.
        # if 0: # This causes considerable problems.
            # # Create the public file from the private shadow file.
            # x.copy_file_removing_sentinels(shadow_fn,fn)
            # x.message("created public %s from private %s " % (fn, shadow_fn))
</t>
<t tx="bwmulder.20050101094804">def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
</t>
<t tx="dan.20080410121257.1">def computeMachineName():
    """Returns the name of the current machine, i.e, HOSTNAME"""
    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''

    # g.trace(name)

    return name
</t>
<t tx="dan.20080410121257.2">def doIfHostname (self,p,kind,name,val):
    """headline: @ifhostname bob,!harry,joe

    Logical AND with the comma-separated list of host names, NO SPACES.

    descends this node iff:
        h = os.environ('HOSTNAME')
        h == 'bob' and h != 'harry' and h == 'joe'"""

    h = g.computeMachineName()
    names = name.split(',')

    for n in names:
        if (n[0] == '!' and h == n[1:]) or (h != n):
            # g.trace('skipping', name)
            return 'skip'

    return None

</t>
<t tx="edreamleo.20070710085115">class javaScanner (baseScannerClass):

    @others
</t>
<t tx="edreamleo.20070710093042">class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.outerBlockEndsDecls = False # To handle extern statement.
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
</t>
<t tx="edreamleo.20070710110114.2">def scanJavaText (self,s,parent,atAuto=False):

    scanner = javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="edreamleo.20070710110153">def scanCText (self,s,parent,atAuto=False):

    scanner = cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20031218072017.1144">def openOutputFile (self):

    if self.outputFileName == None:
        return
    theDir,name = g.os_path_split(self.outputFileName)
    if len(theDir) == 0:
        self.show("empty output directory")
        return
    if len(name) == 0:
        self.show("empty output file name")
        return
    if not g.os_path_exists(theDir):
        self.show("output directory not found: " + theDir)
    else:
        try:
            if self.appendOutput:
                self.show("appending to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"ab")
            else:
                self.show("writing to " + self.outputFileName)
                self.outputFile = open(self.outputFileName,"wb")
        except:
            self.outputFile = None
            self.show("exception opening output file")
            g.es_exception()
</t>
<t tx="ekr.20031218072017.1147">def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) &gt; 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1148">def outlineToWeb (self,fileName,webType):

    c = self.c ; nl = self.output_newline
    current = c.p
    if not current: return
    self.setEncoding()
    self.webType = webType
    # 10/14/02: support for output_newline setting.
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    self.treeType = "@file"
    # Set self.treeType to @root if p or an ancestor is an @root node.
    for p in current.parents():
        flag,junk = g.is_special(p.b,0,"@root")
        if flag:
            self.treeType = "@root"
            break
    for p in current.self_and_subtree():
        s = self.convertVnodeToWeb(p)
        if len(s) &gt; 0:
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
            theFile.write(s)
            if s[-1] != '\n': theFile.write(nl)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1149"># Remove sentinels command.

try:
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    # theFile = open(newFileName,mode)
    theFile = open(newFileName,'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    if not g.unitTesting:
        g.es("created:",newFileName)
except Exception:
    g.es("exception creating:",newFileName)
    g.es_exception()
</t>
<t tx="ekr.20031218072017.1150">try:
    # 10/14/02: support for output_newline setting.
        # mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        # f = open(filename,mode)
        # if not f: return

    # 2010/08/27.
    if g.isPython3:
        f = open(filename,'w',encoding=self.encoding)
    else:
        f = open(filename,'w')

except Exception:
    g.es("exception opening:",filename)
    g.es_exception()
    return
</t>
<t tx="ekr.20031218072017.1151">@
This is the top level method of the second pass. It creates a separate derived file
for each @root directive in the outline. The file is actually written only if
the new version of the file is different from the old version,or if the file did
not exist previously. If changed_only_flag FLAG is True only changed roots are
actually written.
@c

def put_all_roots(self):

    c = self.c ; outline_name = c.mFileName

    for section in self.root_list:

        # g.trace(section.name)
        file_name = c.os_path_finalize_join(self.tangle_directory,section.name)
        mode = c.config.output_newline
        textMode = mode == 'platform'
        if g.unitTesting:
            self.output_file = g.fileLikeObject()
            temp_name = 'temp-file'
        else:
            self.output_file,temp_name = g.create_temp_file(textMode=textMode)
        if not temp_name:
            g.es("can not create temp file")
            break
        &lt;&lt;Get root specific attributes&gt;&gt;
        &lt;&lt;Put @first lines&gt;&gt;
        if self.use_header_flag and self.print_mode == "verbose":
            &lt;&lt; Write a banner at the start of the output file &gt;&gt;
        for part in section.parts:
            if part.is_root:
                self.tangle_indent = 0 # Initialize global.
                self.put_part_node(part,False) # output first lws
        self.onl() # Make sure the file ends with a cr/lf
        &lt;&lt; unit testing fake files&gt;&gt;
        self.output_file.close()
        self.output_file = None
        &lt;&lt; unit testing set result and continue &gt;&gt;
        if self.errors + g.app.scanErrors == 0:
            g.update_file_if_changed(c,file_name,temp_name)
        else:
            g.es("unchanged:",file_name)
            &lt;&lt; Erase the temporary file &gt;&gt;
</t>
<t tx="ekr.20031218072017.1152"># Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines
</t>
<t tx="ekr.20031218072017.1153"># Stephen P. Schaefer 9/13/2002
if self.first_lines:
    self.os(self.first_lines)
</t>
<t tx="ekr.20031218072017.1154"># a root section must have at least one part
assert len(section.parts)&gt;0
delims=section.parts[0].delims
if delims[0]:
    self.os(delims[0])
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.onl() ; self.onl()
elif delims[1] and delims[2]:
    self.os(delims[1])
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.oblank() ; self.os(delims[2])
    self.onl() ; self.onl()
</t>
<t tx="ekr.20031218072017.1155">try: # Just delete the temp file.
    os.remove(temp_name)
except: pass
</t>
<t tx="ekr.20031218072017.1193">def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.p
    if not p: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.h
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                # Bug fix: 2009/3/23: Make sure the chapter exists!
                # This might be an @chapter node outside of @chapters tree.
                theChapter = cc.chaptersDict.get(name)
                if theChapter:
                    return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(newNode)

    c.validateOutline()
</t>
<t tx="ekr.20031218072017.1241"># This is part of the tangle code.

def update_file_if_changed(c,file_name,temp_name):

    """Compares two files.

    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(c,temp_name,file_name,mode)
    else:
        kind = 'creating'
        # 2010/02/04: g.utils_rename no longer calls
        # makeAllNonExistentDirectories
        head, tail = g.os_path_split(file_name)
        ok = True
        if head:
            ok = g.makeAllNonExistentDirectories(head,c=c)
        if ok:
            ok = g.utils_rename(c,temp_name,file_name)

    if ok:
        g.es('','%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es('',file_name," may be read-only or in use")
</t>
<t tx="ekr.20031218072017.1246">def putProlog (self):

    c = self.c

    self.putXMLLine()

    if c.config.stylesheet or c.frame.stylesheet:
        self.putStyleSheetLine()

    self.put("&lt;leo_file&gt;") ; self.put_nl()
</t>
<t tx="ekr.20031218072017.1247">def putXMLLine (self):

    '''Put the **properly encoded** &lt;?xml&gt; element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
</t>
<t tx="ekr.20031218072017.1248">def putStyleSheetLine (self):

    c = self.c

    # The stylesheet in the .leo file takes precedence over the default stylesheet.
    self.put("&lt;?xml-stylesheet ")
    self.put(c.frame.stylesheet or c.config.stylesheet)
    self.put("?&gt;")
    self.put_nl()
</t>
<t tx="ekr.20031218072017.1259">@ This code skips the file name used in @root directives.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.
If a file name is not enclosed be these delimiters it continues until
the next newline.
@c
def setRootFromText(self,s,report_errors=True):

    # g.trace(s)
    self.root_name = None
    i,self.start_mode = g.scanAtRootOptions(s,0)
    i = g.skip_ws(s,i)

    if i &gt;= len(s): return i
    # Allow &lt;&gt; or "" as delimiters, or a bare file name.
    if s[i] == '"':
        i += 1 ; delim = '"'
    elif s[i] == '&lt;':
        i += 1 ; delim = '&gt;'
    else: delim = '\n'

    root1 = i # The name does not include the delimiter.
    while i &lt; len(s) and s[i] != delim and not g.is_nl(s,i):
        i += 1
    root2 = i

    if delim != '\n' and not g.match(s,i,delim):
        if report_errors:
            g.scanError("bad filename in @root " + s[:i])
    else:
        self.root_name = s[root1:root2].strip()
    return i
</t>
<t tx="ekr.20031218072017.1263">def utils_rename (c,src,dst,verbose=True):

    '''Platform independent rename.'''

    # Don't call g.makeAllNonExistentDirectories.
    # It's not right to do this here!!

    # head, tail = g.os_path_split(dst)
    # if head: g.makeAllNonExistentDirectories(head,c=c)

    try:
        shutil.move(src,dst)
        return True
    except Exception:
        if verbose:
            g.es('exception renaming',src,'to',dst,color='red')
            g.es_exception(full=False)
        return False
</t>
<t tx="ekr.20031218072017.1264"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):

    '''Convert '!' or '.' to proper directory references.'''

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    if base and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c,'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir_to_relative_path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        # g.trace(base)
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1317">def module_date (mod,format=None):
    theFile = g.os_path_join(app.loadDir,mod.__file__)
    root,ext = g.os_path_splitext(theFile) 
    return g.file_date(root + ".py",format=format)

def plugin_date (plugin_mod,format=None):
    theFile = g.os_path_join(app.loadDir,"..","plugins",plugin_mod.__file__)
    root,ext = g.os_path_splitext(theFile) 
    return g.file_date(root + ".py",format=format)

def file_date (theFile,format=None):
    if theFile and len(theFile)and g.os_path_exists(theFile):
        try:
            n = g.os_path_getmtime(theFile)
            if format == None:
                format = "%m/%d/%y %H:%M:%S"
            return time.strftime(format,time.gmtime(n))
        except (ImportError,NameError):
            pass # Time module is platform dependent.
    return ""
</t>
<t tx="ekr.20031218072017.1318">def plugin_signon(self,module_name,verbose=False):

    # This is called from as the result of the imports
    # in self.loadOnePlugin

    m = self.signonModule

    if verbose:
        g.es('',"...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))

        g.pr(m.__name__, m.__version__)

    self.signonModule = None # Prevent double signons.
</t>
<t tx="ekr.20031218072017.1329"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    trace = False and not g.unitTesting
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.p
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.b ; changed = True
    else:
        changed = oldText != newText
    if not changed: return
    if trace:
        # g.trace(repr(ch),'changed:',changed,'newText:',len(newText),'w',w)
        g.trace('oldSel',oldSel,'newSel',newSel)
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setBodyString(newText)
    p.v.insertSpot = body.getInsertPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    &lt;&lt; update icons if necessary &gt;&gt;
</t>
<t tx="ekr.20031218072017.1356"># Called by __init__

def init_ivars(self):

    c = self.c
    g.app.scanErrors = 0
    &lt;&lt; init tangle ivars &gt;&gt;
    &lt;&lt; init untangle ivars &gt;&gt;

# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    &lt;&lt; init directive ivars &gt;&gt;
</t>
<t tx="ekr.20031218072017.1357"># Various flags and counts...

self.errors = 0 # The number of errors seen.
# self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "&lt;unknown file name&gt;"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_output = {} # For unit testing.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline.
The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@
The list of all roots. The symbol table routines add roots to self
list during pass 1. Pass 2 uses self list to generate code for all
roots.
@c
self.root_list = []

# The filename following @root in a headline.
# The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@
The following records whether we have seen an @code directive in a
body text. If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is
valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
</t>
<t tx="ekr.20031218072017.1358">@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
</t>
<t tx="ekr.20031218072017.1359"># Global options
self.page_width = c.page_width
self.tab_width = c.tab_width

# New in Leo 4.5: get these from settings.
self.output_doc_flag = c.config.getBool('output_doc_flag')
self.tangle_batch_flag = c.config.getBool('tangle_batch_flag')
self.untangle_batch_flag = c.config.getBool('untangle_batch_flag')
self.use_header_flag = c.config.getBool('use_header_flag')

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
if 0: # debug
  import sys
  g.es("tangleCommands.languague: %s at header %s"%(self.language,repr(self.p)))
  f = sys._getframe(1)
  g.es("caller: "+f.f_code.co_name)
  f = sys._getframe(2)
  g.es("caller's caller: "+f.f_code.co_name)

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
self.raw_cweb_flag = (self.language == "cweb") # A new ivar.

# Set only from directives.
self.print_mode = "verbose"

self.first_lines = ""

self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
</t>
<t tx="ekr.20031218072017.1375">def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width
    w = g.findTabWidthDirectives(c,p)
    if w is None: w = c.tab_width
    c.frame.setTabWidth(w)
</t>
<t tx="ekr.20031218072017.1380"># New in Leo 4.6:
# g.findAtTabWidthDirectives, g.findLanguageDirectives and
# g.get_directives_dict use re module for faster searching.
</t>
<t tx="ekr.20031218072017.1382"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    trace = False and not g.unitTesting

    val = g.app.language_delims_dict.get(language)
    # if language.startswith('huh'): g.pdb()

    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if trace: g.trace(repr(language),
            repr(delim1),repr(delim2),repr(delim3),g.callers(5))
        if delim2 and not delim3:
            return '',delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return '','','' # Indicate that no change should be made
</t>
<t tx="ekr.20031218072017.1383">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = ['','','']
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i] or ''
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = ''

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in range(0,3):
        if delims[i]:
            delims[i] = delims[i].replace("__",'\n').replace('_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20031218072017.1384">def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring:",g.get_line(s,i))

    return None, None, None, None,
</t>
<t tx="ekr.20031218072017.1385"># Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
</t>
<t tx="ekr.20031218072017.1386">def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))

    if g.isPython3:
        s = str(s)
    return s
</t>
<t tx="ekr.20031218072017.1416">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.atPathInBodyWarning = None # Set by get_directives_dict
        # The headline of the @&lt;file&gt; node containing
        # an @path directive in the body.
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.commandInterruptFlag = False # True: command within a command.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.db = None # Set to a leoCacher later.
    self.debug = False
        # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.dragging = False # Application-wide dragging flag.
    self.enableUnitTest = True
    self.extensionsDir = None
    self.globalConfigDir = None
        # The directory assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.guiArgName = None # The gui name given in --gui option.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.homeLeoDir = None
        # The '.leo' subdirectory of the user's home directory.
    self.homeSettingsPrefix = '.'
        # prepend to "myLeoSettings.leo" and &lt;machineName&gt;LeoSettings.leo
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100
        # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False
        # True: the global idleTimeHookHandler will reshedule itself.
    self.inBridge = False # True: running from leoBridge module.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.log = None # The LeoFrame containing the present log.
    self.logInited = False # False: all log message go to logWaiting list.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.oneConfigFilename = ''
        # If non-empty, the name of a single configuration file.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0
        # Used to generate temp file names for Open With command.
    self.openWithTable = None
        # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.printWaiting = [] # Queue of messages to be sent to the printer.
    self.qt_use_tabs = False # True: allow tabbed main window.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {}
        # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {}
        # For communication between Execute Script command and scripts.
    self.signon_printed = False
    self.silentMode = False # True if signon is more silent.
    self.statsDict = {}
        # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.translateToUpperCase = False
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTestGui = None # A way to override the gui in external unit tests.
    self.unitTesting = False # True if unit testing.
    self.useIpython = False
    self.use_psyco = False
        # Can't be a config param because it is used
        # before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = []
        # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None

    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;
</t>
<t tx="ekr.20031218072017.1417"># self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"
self.prolog_namespace_string = \
    'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
</t>
<t tx="ekr.20031218072017.1460"># New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    trace = False and not g.unitTesting

    self.p = self.c.p
    self.v = self.p.v

    for key in self.intKeys:
        val = self.svarDict[key].get()
        # if trace: g.trace(self.svarDict.get(key),val)
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    # g.trace('radio-search-scope',search_scope)
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s)
    if trace: g.trace('find',repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s)
    self.change_text = s
    if trace: g.trace('change',repr(s))
</t>
<t tx="ekr.20031218072017.1462">def exportHeadlines (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.p
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1463">def setEncoding (self,p=None,atAuto=False):

    # c.scanAllDirectives checks the encoding: may return None.
    c = self.c
    if p is None: p = c.p
    theDict = c.scanAllDirectives(p)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    elif atAuto:
        self.encoding = c.config.default_at_auto_file_encoding
    else:
        self.encoding = 'utf-8'

    # g.trace(self.encoding)
</t>
<t tx="ekr.20031218072017.1464">def weave (self,filename):

    c = self.c ; nl = self.output_newline
    p = c.p
    if not p: return
    self.setEncoding()
    &lt;&lt; open filename to f, or return &gt;&gt;
    for p in p.self_and_subtree():
        s = p.b
        s2 = s.strip()
        if s2 and len(s2) &gt; 0:
            f.write("-" * 60) ; f.write(nl)
            &lt;&lt; write the context of p to f &gt;&gt;
            f.write("-" * 60) ; f.write(nl)
            if not g.isPython3:
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
            f.write(s.rstrip() + nl)
    f.flush()
    f.close()
</t>
<t tx="ekr.20031218072017.1465"># write the headlines of p, p's parent and p's grandparent.
context = [] ; p2 = p.copy() ; i = 0
while i &lt; 3:
    i += 1
    if not p2: break
    context.append(p2.h)
    p2.moveToParent()

context.reverse()
indent = ""
for line in context:
    f.write(indent)
    indent += '\t'
    if not g.isPython3: # 2010/08/27.
        line = g.toEncodedString(line,self.encoding,reportErrors=True)
    f.write(line)
    f.write(nl)
</t>
<t tx="ekr.20031218072017.1470">def put (self,s):

    '''Put string s to self.outputFile. All output eventually comes here.'''

    # Improved code: self.outputFile (a cStringIO object) always exists.
    # g.trace(g.callers(1),repr(s))
    if s:
        self.putCount += 1
        if not g.isPython3:
            s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        self.outputFile.write(s)

def put_dquote (self):
    self.put('"')

def put_dquoted_bool (self,b):
    if b: self.put('"1"')
    else: self.put('"0"')

def put_flag (self,a,b):
    if a:
        self.put(" ") ; self.put(b) ; self.put('="1"')

def put_in_dquotes (self,a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')

def put_nl (self):
    self.put("\n")

def put_tab (self):
    self.put("\t")

def put_tabs (self,n):
    while n &gt; 0:
        self.put("\t")
        n -= 1
</t>
<t tx="ekr.20031218072017.1474">def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines &lt; n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)
</t>
<t tx="ekr.20031218072017.1488">def oblank (self):
    self.oblanks(1)

def oblanks (self,n):
    if abs(n) &gt; 0:
        s = g.toEncodedString(' ' * abs(n),encoding=self.encoding)
        self.output_file.write(s)

def onl(self):
    s = self.output_newline
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    self.output_file.write(s)

def os (self,s):
    s = s.replace('\r','\n')
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    self.output_file.write(s)

def otab (self):
    self.otabs(1)

def otabs (self,n):
    if abs(n) &gt; 0:
        s = g.toEncodedString('\t' * abs(n),self.encoding,reportErrors=True)
        self.output_file.write(s)
</t>
<t tx="ekr.20031218072017.1490">def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    &lt;&lt; return if there is nothing to do &gt;&gt;
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    return bunch
</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
</t>
<t tx="ekr.20031218072017.1492">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20031218072017.1493">def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
</t>
<t tx="ekr.20031218072017.1498"></t>
<t tx="ekr.20031218072017.1500">def isValidEncoding (encoding):

    if not encoding:
        return False

    if sys.platform == 'cli':
        return True

    import codecs

    try:
        codecs.lookup(encoding)
        return True
    except LookupError: # Windows.
        return False
    except AttributeError: # Linux.
        return False
</t>
<t tx="ekr.20031218072017.1501">def reportBadChars (s,encoding):

    if g.isPython3:
        errors = 0
        if g.isUnicode(s):
            for ch in s:
                try: ch.encode(encoding,"strict")
                except UnicodeEncodeError:
                    errors += 1
            if errors:
                s2 = "%d errors converting %s to %s" % (
                    errors, s.encode(encoding,'replace'),
                    encoding.encode('ascii','replace'))
                if not g.unitTesting:
                    g.es(s2,color='red')
        elif g.isChar(s):
            for ch in s:
                try: unicode(ch,encoding,"strict")
                except Exception: errors += 1
            if errors:
                s2 = "%d errors converting %s (%s encoding) to unicode" % (
                    errors, unicode(s,encoding,'replace'),
                    encoding.encode('ascii','replace'))
                if not g.unitTesting:
                    g.es(s2,color='red')
    else:
        errors = 0
        if g.isUnicode(s):
            for ch in s:
                try: ch.encode(encoding,"strict")
                except UnicodeEncodeError:
                    errors += 1
            if errors:
                s2 = "%d errors converting %s to %s" % (
                    errors, s.encode(encoding,'replace'),
                    encoding.encode('ascii','replace'))
                if not g.unitTesting:
                    g.es(s2,color='red')
        elif g.isChar(s):
            for ch in s:
                try: unicode(ch,encoding,"strict")
                except Exception: errors += 1
            if errors:
                s2 = "%d errors converting %s (%s encoding) to unicode" % (
                    errors, unicode(s,encoding,'replace'),
                    encoding.encode('ascii','replace'))
                if not g.unitTesting:
                    g.es(s2,color='red')
</t>
<t tx="ekr.20031218072017.1548"></t>
<t tx="ekr.20031218072017.1549">def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
</t>
<t tx="ekr.20031218072017.1550">def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
</t>
<t tx="ekr.20031218072017.1551"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.p
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    vnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)

    if not pasted: return

    copiedBunchList = []
    if pasteAsClone:
        &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)
    # paste as first child if back is expanded.
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.

    if pasteAsClone:
        # Set dirty bits for ancestors of *all* pasted nodes.
        # Note: the setDescendentsDirty flag does not do what we want.
        for p in pasted.self_and_subtree():
            p.setAllAncestorAtFileNodesDirty(
                setDescendentsDirty=False)

    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw(pasted)
    c.recolor()
</t>
<t tx="ekr.20031218072017.1553"># The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    self.warnOnReadOnlyFiles(fileName)
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    recoveryNode = None # Position of recovery node, if present.

    try:
        c.loading = True # disable c.changed
        ok = self.getLeoFileHelper(theFile,fileName,silent)

        # Do this before reading derived files.
        self.resolveTnodeLists()

        if ok and readAtFileNodesFlag:
            # Redraw before reading the @file nodes so the screen isn't blank.
            # This is important for big files like LeoPy.leo.
            c.redraw()
            c.setFileTimeStamp(fileName)
            c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
            recoveryNode = self.handleNodeConflicts()

        # Do this after reading derived files.
        if readAtFileNodesFlag:
            # The descendent nodes won't exist unless we have read the @thin nodes!
            self.restoreDescendentAttributes()

        self.setPositionsFromVnodes()
        c.selectVnode(recoveryNode or c.p) # load body pane
        if c.config.getBool('check_outline_after_read'):
            c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    finally:
        c.loading = False # reenable c.changed

    if c.changed:
        self.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.es("read only:",fileName,color="red")
</t>
<t tx="ekr.20031218072017.1559">def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; current = c.p ; check = not reassignIndices
    checkAfterRead = False or c.config.getBool('check_outline_after_read')

    self.initReadIvars() # 2010/02/05

    # Save the hidden root's children.
    children = c.hiddenRootNode.children

    # Always recreate the gnxDict
    self.gnxDict = {}
    if not reassignIndices:
        x = g.app.nodeIndices
        for v in c.all_unique_nodes():
            index = x.toString(v.fileIndex)
            self.gnxDict[index] = v

    self.usingClipboard = True
    try:
        # This encoding must match the encoding used in putLeoOutline.
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        if trace: g.trace(s)

        # readSaxFile modifies the hidden root.
        v = self.readSaxFile(
            theFile=None, fileName='&lt;clipboard&gt;',
            silent=True, # don't tell about stylesheet elements.
            inClipboard=True,reassignIndices=reassignIndices,s=s)
        if not v:
            return g.es("the clipboard is not valid ",color="blue")
    finally:
        self.usingClipboard = False

    # Restore the hidden root's children
    c.hiddenRootNode.children = children

    # Unlink v from the hidden root.
    v.parents.remove(c.hiddenRootNode)

    p = leoNodes.position(v)

    # Important: we must not adjust links when linking v
    # into the outline.  The read code has already done that.
    if current.hasChildren() and current.isExpanded():
        if check and not self.checkPaste(current,p):
            return None
        p._linkAsNthChild(current,0,adjust=False)
    else:
        if check and not self.checkPaste(current.parent(),p):
            return None
        p._linkAfter(current,adjust=False)

    if reassignIndices:
        for p2 in p.self_and_subtree():
            p2.v.fileIndex = g.app.nodeIndices.getNewIndex()

    if trace and verbose:
        g.trace('**** dumping outline...')
        c.dumpOutline()

    if checkAfterRead:
        g.trace('checking outline after paste',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.selectPosition(p)
    self.initReadIvars() # 2010/02/05
    return p

getLeoOutline = getLeoOutlineFromClipboard # for compatibility
</t>
<t tx="ekr.20031218072017.1570">def assignFileIndices (self):

    """Assign a file index to all tnodes"""

    pass # No longer needed: we assign indices as needed.

# Indices are now immutable, so there is no longer any difference between these two routines.
compactFileIndices = assignFileIndices
</t>
<t tx="ekr.20031218072017.1573">def putLeoOutline (self):

    '''Return a string, *not unicode*, encoded with self.leo_file_encoding,
    suitable for pasting to the clipboard.'''

    trace = False and not g.unitTesting
    self.outputFile = g.fileLikeObject()
    self.usingClipboard = True

    self.putProlog()
    self.putClipboardHeader()
    self.putVnodes()
    self.putTnodes()
    self.putPostlog()

    s = self.outputFile.getvalue()
    if trace: g.trace(s)
    self.outputFile = None
    self.usingClipboard = False
    return s
</t>
<t tx="ekr.20031218072017.1575">def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("&lt;tnodes&gt;\n")
    &lt;&lt; write only those tnodes that were referenced &gt;&gt;
    self.put("&lt;/tnodes&gt;\n")
</t>
<t tx="ekr.20031218072017.1576">if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
</t>
<t tx="ekr.20031218072017.1577">def putTnode (self,v):

    # Call put just once.
    gnx = g.app.nodeIndices.toString(v.fileIndex)
    ua = hasattr(v,'unknownAttributes') and self.putUnknownAttributes(v) or ''
    b = v.b
    if b:
        body = xml.sax.saxutils.escape(b)
    else:
        body = ''

    self.put('&lt;t tx="%s"%s&gt;%s&lt;/t&gt;\n' % (gnx,ua,body))
</t>
<t tx="ekr.20031218072017.1579">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;\n")

    # Make only one copy for all calls.
    self.currentPosition = c.p 
    self.rootPosition    = c.rootPosition()
    # self.topPosition     = c.topPosition()
    self.vnodesDict = {}

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;\n")
</t>
<t tx="ekr.20031218072017.1581">def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self._headString):
        g.internalError('not unicode',repr(self._headString))

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString)

def cleanHeadString (self):

    s = self._headString
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
</t>
<t tx="ekr.20031218072017.1588">lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20031218072017.1589">def clearAllIvars (o):

    """Clear all ivars of o, a member of some class."""

    if o:
        o.__dict__.clear()
</t>
<t tx="ekr.20031218072017.1590">def collectGarbage():

    try:
        if not g.app.trace_gc_inited:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            g.pr('collectGarbage:')

        gc.collect()
    except Exception:
        pass

    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
</t>
<t tx="ekr.20031218072017.1592"># Formerly called from unit tests.

def printGc(tag=None):

    if not g.app.trace_gc: return None

    tag = tag or g._callerName(n=2)

    printGcObjects(tag=tag)
    printGcRefs(tag=tag)

    if g.app.trace_gc_verbose:
        printGcVerbose(tag=tag)
</t>
<t tx="ekr.20031218072017.1593">def printGcRefs (tag=''):

    refs = gc.get_referrers(app.windowList[0])
    g.pr('-' * 30,tag)

    if g.app.trace_gc_verbose:
        g.pr("refs of", app.windowList[0])
        for ref in refs:
            g.pr(type(ref))
    else:
        g.pr("%d referers" % len(refs))
</t>
<t tx="ekr.20031218072017.1596">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. c.hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

    trace = False ; verbose = False

    if g.app.killed or g.app.hookError: # or (g.app.gui and g.app.gui.isNullGui):
        return None

    if args:
        # A minor error in Leo's core.
        g.pr("***ignoring args param.  tag = %s" % tag)

    if not g.app.config.use_plugins:
        if tag in ('open0','start1'):
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None

    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction

    if trace and (verbose or tag != 'idle'):
        g.trace('tag',tag,'f',f and f.__name__)

    if not f:
        g.app.hookFunction = f = g.app.pluginsController.doPlugins

    try:
        # Pass the hook to the hook handler.
        # g.pr('doHook',f.__name__,keywords.get('c'))
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
</t>
<t tx="ekr.20031218072017.1602"># Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
self.allBodyText = w.getAllText()
sel = w.getInsertPoint()
start,end = g.convertPythonIndexToRowCol(self.allBodyText,sel)
start += 1 # Simulate the old 1-based Tk scheme.  self.index undoes this hack.
# g.trace('new',start,end)

if self.language: self.language = self.language.lower()
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    # self.removeAllImages()

&lt;&lt; configure fonts &gt;&gt;
&lt;&lt; configure tags &gt;&gt;
&lt;&lt; configure language-specific settings &gt;&gt;

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = self.allBodyText.split('\n')
</t>
<t tx="ekr.20031218072017.1603"># g.trace('configure tags',self.c.frame.body.bodyCtrl)

for name in default_colors_dict:
    option_name,default_color = default_colors_dict[name]
    option_color = c.config.getColor(option_name)
    color = g.choose(option_color,option_color,default_color)
    # g.trace(name,color)
    # Must use foreground, not fg.
    try:
        c.frame.body.tag_configure(name, foreground=color)
    except: # Recover after a user error.
        c.frame.body.tag_configure(name, foreground=default_color)

underline_undefined = c.config.getBool("underline_undefined_section_names")
use_hyperlinks      = c.config.getBool("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    c.frame.body.tag_configure("link",underline=1) # defined
    c.frame.body.tag_configure("name",underline=0) # undefined
else:
    c.frame.body.tag_configure("link",underline=0)
    if underline_undefined:
        c.frame.body.tag_configure("name",underline=1)
    else:
        c.frame.body.tag_configure("name",underline=0)

# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = c.config.getColor(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            c.frame.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            c.frame.body.tag_configure(name,background=default_color)

# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    c.frame.body.tag_configure("latexModeBackground",foreground="black")
    c.frame.body.tag_configure("latexModeKeyword",foreground="blue")
    c.frame.body.tag_configure("latexBackground",foreground="black")
    c.frame.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    c.frame.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    c.frame.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    c.frame.body.tag_configure("latexBackground",foreground="black",background="white")
    c.frame.body.tag_configure("latexKeyword",foreground="blue",background="white")

# Tags for wiki coloring.
if self.showInvisibles:
    c.frame.body.tag_configure("elide",background="yellow")
else:
    c.frame.body.tag_configure("elide",elide="1")
c.frame.body.tag_configure("bold",font=self.bold_font)
c.frame.body.tag_configure("italic",font=self.italic_font)
c.frame.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    c.frame.body.tag_configure(name,foreground=name)
</t>
<t tx="ekr.20031218072017.1604">def removeAllTags (self):

    # Warning: the following DOES NOT WORK: w.tag_delete(self.tags)
    w = self.c.frame.body
    for tag in self.tags:
        w.tag_delete(tag)

    for tag in self.color_tags_list:
        w.tag_delete(tag)

def removeTagsFromLine (self):

    # g.pr("removeTagsFromLine",self.line_index)
    w = self.c.frame.body
    for tag in self.tags:
        w.tag_remove(tag,self.index(0),self.index("end")) # 10/27/03

    for tag in self.color_tags_list:
        w.tag_remove(tag,self.index(0),self.index("end")) # 10/27/03
</t>
<t tx="ekr.20031218072017.1605">def __init__(self,c):

    self.c = c
    self.frame = c.frame
    self.trace = c.config.getBool('trace_colorizer')
    self.count = 0 # how many times this has been called.
    self.use_hyperlinks = False # True: use hyperlinks and underline "live" links.
    self.enabled = True # True: syntax coloring enabled
    self.fonts = {}
    self.showInvisibles = False # True: show "invisible" characters.
    self.comment_string = None # Set by scanColorDirectives on @comment
    # For incremental coloring.
    self.tags = (
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string","tab",
        "elide","bold","bolditalic","italic") # new for wiki styling.
    self.incremental = False
    self.sel = None
    self.lines = []
    self.states = []
    self.last_flag = "unknown"
    self.last_language = "unknown"
    &lt;&lt; define colorizer keywords &gt;&gt;
    &lt;&lt; ivars for communication between colorizeAnyLanguage and its allies &gt;&gt;
    &lt;&lt; define dispatch dicts &gt;&gt;
    self.setFontFromConfig()
</t>
<t tx="ekr.20031218072017.1606"># Copies of arguments.
self.p = None
self.language = None
self.flag = None
self.killFlag = False
self.line_index = 0

# Others.
self.single_comment_start = None
self.block_comment_start = None
self.block_comment_end = None
self.case_sensitiveLanguage = True
self.has_string = None
self.string_delims = ("'",'"')
self.has_pp_directives = None
self.keywords = None
self.lb = None
self.rb = None
self.rootMode = None # None, "code" or "doc"

self.latex_cweb_docs     = c.config.getBool("color_cweb_doc_parts_with_latex")
self.latex_cweb_comments = c.config.getBool("color_cweb_comments_with_latex")
# g.pr("docs,comments",self.latex_cweb_docs,self.latex_cweb_comments)
</t>
<t tx="ekr.20031218072017.1607">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
</t>
<t tx="ekr.20031218072017.1609">def index (self,i):

    # Short-circuit the redundant computations.
    w = self.c.frame.body.bodyCtrl ; s = self.allBodyText
    return w.rowColToGuiIndex(s,self.line_index-1,i)

def tag (self,name,i,j):

    self.c.frame.body.tag_add(name,self.index(i),self.index(j))
</t>
<t tx="ekr.20031218072017.1610">def skip_python_string(self,s,i):

    delim = s[i:i+3]
    if delim == "'''" or delim == '"""':
        k = s.find(delim,i+3)
        if k == -1:
            return len(s),g.choose(delim=="'''","string3s","string3d")
        else:
            return k+3, "normal"
    else:
        return self.skip_string(s,i)
</t>
<t tx="ekr.20031218072017.1612"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20031218072017.1613">def continueDoublePythonString (self,s,i):
    j = s.find('"""',i)
    return self.continuePythonString(s,i,j,"string3d")

def continueSinglePythonString (self,s,i):
    j = s.find("'''",i)
    return self.continuePythonString(s,i,j,"string3s")

def continuePythonString (self,s,i,j,continueState):

    if j == -1: # The entire line is part of the triple-quoted string.
        j = len(s)
        if continueState == "string3d":
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
                self.tag("string",i,j)
        else:
            self.tag("string",i,j)
        return j,continueState # skip the rest of the line.

    else: # End the string
        if continueState == "string3d":
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
                self.tag("string",i,j+3)
            else:
                self.tag("string",i,j+3)
        else:
            self.tag("string",i,j+3)
        return j+3,"normal"
</t>
<t tx="ekr.20031218072017.1614">def continueDocPart (self,s,i):

    c = self.c ; state = "doc"
    if self.language == "cweb":
        &lt;&lt; handle cweb doc part &gt;&gt;
    else:
        &lt;&lt; handle noweb doc part &gt;&gt;
    return i,state
</t>
<t tx="ekr.20031218072017.1615">word = self.getCwebWord(s,i)
if word and len(word) &gt; 0:
    j = i + len(word)
    if word in ("@&lt;","@(","@c","@d","@f","@p"):
        state = "normal" # end the doc part and rescan
    else:
        # The control code does not end the doc part.
        self.tag("keyword",i,j)
        i = j
        if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
            j = s.find("@&gt;",i)
            if j &gt; -1:
                self.tag("cwebName",i,j)
                self.tag("nameBrackets",j,j+2)
                i = j + 2
elif g.match(s,i,self.lb):
    j = self.doNowebSecRef(s,i)
    if j == i + 2: # not a section ref.
        self.tag("docPart",i,j)
    i = j
elif self.latex_cweb_docs:
    # Everything up to the next "@" is latex colored.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.doLatexLine(s,i,j)
    i = j
else:
    # Everthing up to the next "@" is in the doc part.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.tag("docPart",i,j)
    i = j
</t>
<t tx="ekr.20031218072017.1616">if i == 0 and g.match(s,i,"&lt;&lt;"):
    # Possible section definition line.
    return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
    j = self.skip_id(s,i+1,chars='-')
    word = s[i:j]
    word = word.lower()
else:
    word = ""

if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
    # End of the doc part.
    c.frame.body.tag_remove("docPart",self.index(i),self.index(j)) # 10/27/03
    self.tag("leoKeyword",i,j)
    state = "normal"
    if word != '@nocolor': i = j # 3/8/05: Rescan @nocolor.
else:
    # The entire line is in the doc part.
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="docPart"):
        self.tag("docPart",i,j)
    i = j # skip the rest of the line.
</t>
<t tx="ekr.20031218072017.1617"># g.pr("single-line comment i,s:",i,s)

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20031218072017.1618">def continueBlockComment (self,s,i):

    j = s.find(self.block_comment_end,i)

    if j == -1:
        j = len(s) # The entire line is part of the block comment.
        if self.language=="cweb":
            self.doLatexLine(s,i,j)
        else:
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
                self.tag("comment",i,j)
        return j,"blockComment" # skip the rest of the line.

    else:
        # End the block comment.
        k = len(self.block_comment_end)
        if self.language=="cweb" and self.latex_cweb_comments:
            self.doLatexLine(s,i,j)
            self.tag("comment",j,j+k)
        else:
            if not g.doHook("color-optional-markup",
                colorer=self,p=self.p,v=self.p,s=s,i=i,j=j+k,colortag="comment"):
                self.tag("comment",i,j+k)
        i = j + k
        return i,"normal"
</t>
<t tx="ekr.20031218072017.1619">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20031218072017.1620"># Handles non-cweb keyword.

def doAtKeyword (self,s,i):

    j = self.skip_id(s,i+1,chars="-") # to handle @root-code, @root-doc
    word = s[i:j]
    word = word.lower()
    # g.trace(word,word[1:] in g.globalDirectiveList)
    if i != 0 and word not in ("@others","@all"):
        word = "" # can't be a Leo keyword, even if it looks like it.

    # 7/8/02: don't color doc parts in plain text.
    if self.language != "plain" and (word == "@" or word == "@doc"):
        # at-space is a Leo keyword.
        self.tag("leoKeyword",i,j)
        k = len(s) # Everything on the line is in the doc part.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=j,j=k,colortag="docPart"):
            self.tag("docPart",j,k)
        return k,"doc"
    elif word == "@nocolor":
        # Nothing on the line is colored.
        self.tag("leoKeyword",i,j)
        return j,"nocolor"
    elif word[1:] in g.globalDirectiveList:
        self.tag("leoKeyword",i,j)
        return j,"normal"
    else:
        return j,"normal"
</t>
<t tx="ekr.20031218072017.1623">def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    g.doHook("new",old_c=self,c=c,new_c=c)
    g.app.unlockLog()

    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.redraw()
    return c # For unit test.
</t>
<t tx="ekr.20031218072017.1624">def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
</t>
<t tx="ekr.20031218072017.1627">def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:            
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)
</t>
<t tx="ekr.20031218072017.1628">def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)

</t>
<t tx="ekr.20031218072017.1656">@others
</t>
<t tx="ekr.20031218072017.1666">def writeDirtyAtFileNodes (self,event=None):

    '''Write all changed @file Nodes.'''

    self.c.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=True)
</t>
<t tx="ekr.20031218072017.1704">def convertAllBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.p

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = c.scanAllDirectives()
    tabWidth  = d.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree():
        # g.trace(p.h,tabWidth)
        innerUndoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = c.convertBlanks(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            changed = False ; result = []
            text = p.v.b
            # assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,innerUndoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("blanks converted to tabs in",count,"nodes")
            # Must come before c.redraw().
    if count &gt; 0:
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.1705">def convertAllTabs (self,event=None):

    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.p

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = c.scanAllDirectives()
    tabWidth  = theDict.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree():
        undoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = self.convertTabs(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            result = [] ; changed = False
            text = p.v.b
            # assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,undoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("tabs converted to blanks in",count,"nodes")
    if count &gt; 0:
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.1706">def extract (self,event=None):

    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.p
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        if not g.unitTesting:
            g.es("nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        undoData = u.beforeInsertNode(current)
        p = c.createLastChildNode(current,headline,newBody)
        u.afterInsertNode(p,undoType,undoData)
        c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
    u.afterChangeGroup(current,undoType=undoType)
    c.redraw(p)
</t>
<t tx="ekr.20031218072017.1708">def extractSection (self,event=None):

    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.p
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    if not lines:
        if not g.unitTesting:
            g.es("nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        undoData = u.beforeInsertNode(current)
        p = c.createLastChildNode(current,headline,newBody)
        u.afterInsertNode(p,undoType,undoData)
        c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
    u.afterChangeGroup(current,undoType=undoType)
    c.redraw(p)
</t>
<t tx="ekr.20031218072017.1709">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20031218072017.1710">def extractSectionNames(self,event=None):

    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.p
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        found = False
        for s in lines:
            &lt;&lt; Find the next section name &gt;&gt;
            if name:
                undoData = u.beforeInsertNode(current)
                p = self.createLastChildNode(current,name,None)
                u.afterInsertNode(p,undoType,undoData)
                found = True
        c.validateOutline()
        if not found:
            g.es("selected text should contain one or more section names",color="blue")
    u.afterChangeGroup(current,undoType)
    c.redraw(p)

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20031218072017.1711">head1 = s.find("&lt;&lt;")
if head1 &gt; -1:
    head2 = s.find("&gt;&gt;",head1)
else:
    head1 = s.find("@&lt;")
    if head1 &gt; -1:
        head2 = s.find("@&gt;",head1)

if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20031218072017.1720">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)

    if ok is None:
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        c.cacher.save(fileName,changeName=True)
        ok = c.checkFileTimeStamp(fileName)
        if ok:
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            self.putSavedMessage(fileName)
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return

    trace = False
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        # Bug fix: 2009/09/30: use canonical stroke.
        accelerator = k.shortcutFromSetting(accel,addKey=False) or ''
        stroke = k.shortcutFromSetting(accel,addKey=True) or ''
        if accelerator:
            accelerator = g.stripBrackets(k.prettyPrintKey(accelerator))
        if trace: # and commandName == 'add-comments':
            g.trace(bunch.val,repr(stroke),repr(accelerator),commandName)
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            # if trace: g.trace('stroke',stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
</t>
<t tx="ekr.20031218072017.1725"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20031218072017.1732">def finishQuit(self):

    # forceShutdown may already have fired the "end1" hook.
    if not g.app.killed:
        g.doHook("end1")

    self.destroyAllOpenWithFiles()

    if g.app.gui:
        g.app.gui.destroySelf()

    # Don't use g.trace!
    # print('app.finishQuit: setting g.app.killed',g.callers())

    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called
        # even after the following code.

    if g.app.afterHandler:
        # TK bug: This appears to have no effect, at least on Windows.
        # print("finishQuit: cancelling",g.app.afterHandler)
        if g.app.gui and g.app.gui.guiName() == "tkinter":
            self.root.after_cancel(g.app.afterHandler)
        g.app.afterHandler = None
</t>
<t tx="ekr.20031218072017.1759"></t>
<t tx="ekr.20031218072017.1760"></t>
<t tx="ekr.20031218072017.1761">def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.p

    if not current: return

    c.endEditing()

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    p.setDirty(setDescendentsDirty=False)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redrawAndEdit(p,selectAll=True)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20031218072017.1762">def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    c.endEditing() # Capture any changes to the headline.
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.redraw(clone)
        return clone # For mod_labels and chapters plugins.
    else:
        clone.doDelete()
        c.setCurrentPosition(p)
        return None
</t>
<t tx="ekr.20031218072017.1765"># Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
</t>
<t tx="ekr.20031218072017.1766"></t>
<t tx="ekr.20031218072017.1767">def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.p
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper()
            return
        next.moveToNext()

    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.children[n+1:]
    # g.trace('sibs2\n',g.listToString(followingSibs2))

    # Remove the moved nodes from the parent's children.
    parent_v.children = parent_v.children[:n+1]
    # Add the moved nodes to p's children
    p.v.children.extend(followingSibs)
    # Adjust the parent links in the moved nodes.
    # There is no need to adjust descendant links.
    for child in followingSibs:
        child.parents.remove(parent_v)
        child.parents.append(p.v)

    p.expand()
    # Even if p is an @ignore node there is no need to mark the demoted children dirty.
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterDemote(p,followingSibs,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1768">@
Moving down is more tricky than moving up; we can't move p to be a child of
itself. An important optimization: we don't have to call
checkMoveWithParentWithWarning() if the parent of the moved node remains the
same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1769">if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and c.sparse_move and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20031218072017.1770">def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(parent)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
    if c.sparse_move: # New in Leo 4.4.2
        parent.contract()
    c.redraw_now(p,setFocus=True)
    c.recolor_now() # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1771">def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back,n)
    # g.trace(p,p.parent())
    # Moving an outline right can never bring it outside the range of @ignore.
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
    dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.redraw_now(p,setFocus=True)
    c.recolor_now()
</t>
<t tx="ekr.20031218072017.1772">def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    trace = False and not g.unitTesting
    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.visBack(c)
    if not back:
        if trace: g.trace('no visBack')
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    &lt;&lt; Move p up &gt;&gt;
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1773">if trace:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2 and back2.hasChildren())
    g.trace("back2.isExpanded",back2 and back2.isExpanded())

parent = p.parent()

if not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

if moved and c.sparse_move and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20031218072017.1774">def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.p
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.endEditing()
    parent_v = p._parentVnode()
    children = p.v.children
    # Add the children to parent_v's children.
    n = p.childIndex()+1
    z = parent_v.children[:]
    parent_v.children = z[:n]
    parent_v.children.extend(children)
    parent_v.children.extend(z[n:])
    # Remove v's children.
    p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in children:
        child.parents.remove(p.v)
        child.parents.append(parent_v)

    c.setChanged(True)
    if not inAtIgnoreRange and isAtIgnoreNode:
        # The promoted nodes have just become newly unignored.
        dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    u.afterPromote(p,children,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1809">def importDerivedFile (self,event=None):

    """Create a new outline from a 4.0 derived file."""

    c = self ; p = c.p
    c.endEditing()

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        g.chdir(names[0])
        c.importCommands.importDerivedFiles(parent=p,paths=names)
</t>
<t tx="ekr.20031218072017.1810">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.p
    self.tab_width = self.getTabWidth()
    if not paths: return
    u.beforeChangeGroup(current,command)
    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAfter()
        if isThin:
            p.initHeadString("@thin " + fileName)
            at.read(p)
        else:
            p.initHeadString("Imported @file " + fileName)
            at.read(p,importFileName=fileName)
        p.contract()
        u.afterInsertNode(p,command,undoData)
    current.expand()
    c.setChanged(True)
    u.afterChangeGroup(p,command)
    c.redraw(current)
</t>
<t tx="ekr.20031218072017.1821">def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = c.scanAllDirectives()
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20031218072017.1822">def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = c.scanAllDirectives()
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20031218072017.1823">def createLastChildNode (self,parent,headline,body):

    '''A helper function for the three extract commands.'''

    c = self

    if body and len(body) &gt; 0:
        body = body.rstrip()
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setBodyString(body)
    p.setDirty()
    c.validateOutline()
    return p
</t>
<t tx="ekr.20031218072017.1824">def dedentBody (self,event=None):

    '''Remove one tab's worth of indentation from all presently selected lines.'''

    c = self ; current = c.p ; undoType='Unindent'

    d = c.scanAllDirectives(current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20031218072017.1825">def findBoundParagraph (self,event=None):

    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None

    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    for line in tail_lines:
        if not line or line.isspace() or line.startswith('@'):
            break
        i += 1

    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]

    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    return head,result,tail # string, list, string
</t>
<t tx="ekr.20031218072017.1826">if 0:
    g.pr("\nhead_lines")
    for line in head_lines:
        g.pr(line)
    g.pr("\nins", ins)
    g.pr("\ntail_lines")
    for line in tail_lines:
        g.pr(line)
else:
    g.es_print("head_lines: ",head_lines)
    g.es_print("ins: ",ins)
    g.es_print("tail_lines: ",tail_lines)
</t>
<t tx="ekr.20031218072017.1827">def findMatchingBracket (self,event=None):

    '''Select the text between matching brackets.'''

    c = self ; w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 &lt;= ins-1 &lt; len(s) and s[ins-1] or ''
    ch2 = 0 &lt;= ins   &lt; len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2),ins)

    # Prefer to match the character to the left of the cursor.
    if ch1 and ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 and ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return

    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 &lt; index:
            w.setSelectionRange(index2,index+1,insert=index2) # was insert=index2+1
            # g.trace('case 1',s[index2:index+1])
        else:
            w.setSelectionRange(index,index2+1,insert=min(len(s),index2+1))
            # g.trace('case2',s[index:index2+1])
        w.see(index2)
    else:
        g.es("unmatched",repr(ch))
</t>
<t tx="ekr.20031218072017.1829">def getBodyLines (self,expandSelection=False):

    """Return head,lines,tail where:

    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    oldVview = body.getYScrollPosition()

    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0,len(s)
        lines = g.splitLines(s) # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,s,tail = body.getSelectionLines()
        lines = g.splitLines(s) # Retain the newlines of each line.

        # Expand the selection.
        i = len(head)
        j = max(i,len(head)+len(s)-1)
        oldSel = i,j

    return head,lines,tail,oldSel,oldVview # string,list,string,tuple.
</t>
<t tx="ekr.20031218072017.1830">def indentBody (self,event=None):

    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.p ; undoType='Indent Region'
    d = c.scanAllDirectives(current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20031218072017.1831">def insertBodyTime (self,event=None):

    '''Insert a time/date stamp at the cursor.'''

    c = self ; undoType = 'Insert Body Time'
    w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    oldSel = c.frame.body.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i,s)

    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
</t>
<t tx="ekr.20031218072017.1832">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55

    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20031218072017.1833">def reformatParagraph (self,event=None,undoType='Reformat Paragraph'):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        i,j = w.getSelectionRange()
        w.setInsertPoint(i)

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;
</t>
<t tx="ekr.20031218072017.1834">theDict = c.scanAllDirectives()
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
</t>
<t tx="ekr.20031218072017.1835">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)

indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20031218072017.1836">trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'
</t>
<t tx="ekr.20031218072017.1837"># This destroys recoloring.
junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins &lt; len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)
else:
    # We must always recolor, even if the text has not changed,
    # because setSelectionAreas above destroys the coloring.
    c.recolor()

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
</t>
<t tx="ekr.20031218072017.1838">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.p

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.setChanged(True)
    if p.isDirty():
        dirtyVnodeList = []
    else:
        dirtyVnodeList = p.setDirty()

    c.redraw_after_icons_changed()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20031218072017.1839">def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p

    c.endEditing()
    undoData = u.beforeChangeTree(p)
    c.fileCommands.readAtFileNodes()
    u.afterChangeTree(p,'Read @file Nodes',undoData)
    c.redraw()
</t>
<t tx="ekr.20031218072017.1847">def setLog (self,log):

    """set the frame to which log messages will go"""

    # print("app.setLog:",log,g.callers())
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True

def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False
</t>
<t tx="ekr.20031218072017.1863">def putVnode (self,p,isIgnore=False):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @&lt;file&gt; trees.

    &lt;&lt; Set gnx = vnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)
    v_head = '&lt;v t="%s"%s&gt;' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'&lt;/v&gt;\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '&lt;vh&gt;%s&lt;/vh&gt;' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            &lt;&lt; issue informational messages &gt;&gt;
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('&lt;/v&gt;\n')
        else:
            fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.
</t>
<t tx="ekr.20031218072017.1864">gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
</t>
<t tx="ekr.20031218072017.1865"># These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions &lt;v&gt; element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
</t>
<t tx="ekr.20031218072017.1880">def colorizeAnyLanguage (self,p,leading=None,trailing=None):

    """Color the body pane either incrementally or non-incrementally"""

    c = self.c ; w = c.frame.body.bodyCtrl

    if not c.config.getBool('use_syntax_coloring'):
        # There have been reports of this trace causing crashes.
        # Certainly it is not necessary.
        # g.trace('no coloring')
        return

    if self.killFlag:
        self.removeAllTags()
        return
    try:
        # g.trace('incremental',self.incremental)
        &lt;&lt; initialize ivars &amp; tags &gt;&gt;
        g.doHook("init-color-markup",colorer=self,p=self.p,v=self.p)
        if self.incremental and (
            &lt;&lt; all state ivars match &gt;&gt; ):
            &lt;&lt; incrementally color the text &gt;&gt;
        else:
            &lt;&lt; non-incrementally color the text &gt;&gt;
        &lt;&lt; update state ivars &gt;&gt;
        return "ok" # for testing.
    except:
        &lt;&lt; set state ivars to "unknown" &gt;&gt;
        if self.c:
            g.es_exception()
        else:
            import traceback ; traceback.print_exc()
        return "error" # for unit testing.
</t>
<t tx="ekr.20031218072017.1881">self.flag == self.last_flag and
self.last_language == self.language
</t>
<t tx="ekr.20031218072017.1882">@ Each line has a starting state. The starting state for the first line
is always "normal".

We need remember only self.lines and self.states between colorizing.
It is not necessary to know where the text comes from, only what the
previous text was! We must always colorize everything when changing
nodes, even if all lines match, because the context may be different.

We compute the range of lines to be recolored by comparing leading
lines and trailing lines of old and new text. All other lines (the
middle lines) must be colorized, as well as any trailing lines whose
states may have changed as the result of changes to the middle lines.
@c

if self.trace: g.trace("incremental",self.language)

# 6/30/03: make a copies of everything
old_lines = self.lines[:]
old_states = self.states[:]
new_lines = lines[:]
new_states = []

new_len = len(new_lines)
old_len = len(old_lines)

if new_len == 0:
    self.states = []
    self.lines = []
    return

# Bug fix: 11/21/02: must test against None.
if leading != None and trailing != None:
    # g.pr("leading,trailing:",leading,trailing)
    leading_lines = leading
    trailing_lines = trailing
else:
    &lt;&lt; compute leading, middle &amp; trailing lines &gt;&gt;

middle_lines = new_len - leading_lines - trailing_lines
# g.pr("middle lines", middle_lines)

&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;
&lt;&lt; initialize new states &gt;&gt;
&lt;&lt; colorize until the states match &gt;&gt;
</t>
<t tx="ekr.20031218072017.1883">@ The leading lines are the leading matching lines. The trailing lines
are the trailing matching lines. The middle lines are all other new
lines. We will color at least all the middle lines. There may be no
middle lines if we delete lines.
@c

min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading_lines = i

if leading_lines == new_len:
    # All lines match, and we must color _everything_.
    # (several routine delete, then insert the text again,
    # deleting all tags in the process).
    # g.pr("recolor all")
    leading_lines = trailing_lines = 0
else:
    i = 0
    while i &lt; min_len - leading_lines:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing_lines = i
</t>
<t tx="ekr.20031218072017.1884">@ 11/19/02: Changing @color or @nocolor directives requires we recolor
all leading states as well.
@c

if trailing_lines == 0:
    m1 = new_lines[leading_lines:]
    m2 = old_lines[leading_lines:]
else:
    m1 = new_lines[leading_lines:-trailing_lines]
    m2 = old_lines[leading_lines:-trailing_lines]
m1.extend(m2) # m1 now contains all old and new middle lines.
if m1:
    for s in m1:
        ### s = g.toUnicode(s)
        i = g.skip_ws(s,0)
        if g.match_word(s,i,"@color") or g.match_word(s,i,"@nocolor"):
            leading_lines = 0
            break
</t>
<t tx="ekr.20031218072017.1885"># Copy the leading states from the old to the new lines.
i = 0
while i &lt; leading_lines and i &lt; old_len: # 12/8/02
    new_states.append(old_states[i])
    i += 1

# We know the starting state of the first middle line!
if middle_lines &gt; 0 and i &lt; old_len:
    new_states.append(old_states[i])
    i += 1

# Set the state of all other middle lines to "unknown".
first_trailing_line = max(0,new_len - trailing_lines)
while i &lt; first_trailing_line:
    new_states.append("unknown")
    i += 1

# Copy the trailing states from the old to the new lines.
i = max(0,old_len - trailing_lines)
while i &lt; old_len and i &lt; len(old_states):
    new_states.append(old_states[i])
    i += 1

# 1/8/03: complete new_states by brute force.
while len(new_states) &lt; new_len:
    new_states.append("unknown")
</t>
<t tx="ekr.20031218072017.1886"># Colorize until the states match.
# All middle lines have "unknown" state, so they will all be colored.

# Start in the state _after_ the last leading line, which may be unknown.
i = leading_lines
while i &gt; 0:
    if i &lt; old_len and i &lt; new_len:
        state = new_states[i]
        # assert(state!="unknown") # This can fail.
        break
    else:
        i -= 1

if i == 0:
    # Color plain text unless we are under the control of @nocolor.
    # state = g.choose(self.flag,"normal","nocolor")
    state = self.setFirstLineState()
    new_states[0] = state

# The new_states[] will be "unknown" unless the lines match,
# so we do not need to compare lines here.
while i &lt; new_len:
    self.line_index = i + 1
    state = self.colorizeLine(new_lines[i],state)
    i += 1
    # Set the state of the _next_ line.
    if i &lt; new_len and state != new_states[i]:
        new_states[i] = state
    else: break

# Update the ivars
self.states = new_states
self.lines = new_lines
</t>
<t tx="ekr.20031218072017.1887">if self.trace: g.trace("non-incremental",self.language)

self.line_index = 1 # The Tk line number for indices, as in n.i
for s in lines:
    state = self.colorizeLine(s,state)
    self.line_index += 1
</t>
<t tx="ekr.20031218072017.1888">self.last_flag = self.flag
self.last_language = self.language
</t>
<t tx="ekr.20031218072017.1889">self.last_flag = "unknown"
self.last_language = "unknown"
</t>
<t tx="ekr.20031218072017.1892">def colorizeLine (self,s,state):

    # g.pr("line,inc,state,s:",self.line_index,self.incremental,state,s)

    ### s = g.toUnicode(s)

    if self.incremental:
        self.removeTagsFromLine()

    i = 0
    while i &lt; len(s):
        self.progress = i
        func = self.state_dict[state]
        i,state = func(s,i)

    return state
</t>
<t tx="ekr.20031218072017.1893">def continueDoubleString (self,s,i):
    return self.continueString(s,i,'"',"doubleString")

def continueSingleString (self,s,i):
    return self.continueString(s,i,"'","singleString")

# Similar to skip_string.
def continueString (self,s,i,delim,continueState):
    # g.trace(delim + s[i:])
    continueFlag = g.choose(self.language in ("elisp","html"),True,False)
    j = i
    while i &lt; len(s) and s[i] != delim:
        if s[i:] == "\\":
            i = len(s) ; continueFlag = True ; break
        elif s[i] == "\\":
            i += 2
        else:
            i += 1
    if i &gt;= len(s):
        i = len(s)
    elif s[i] == delim:
        i += 1 ; continueFlag = False
    self.tag("string",j,i)
    state = g.choose(continueFlag,continueState,"normal")
    return i,state
</t>
<t tx="ekr.20031218072017.1894">def continueNocolor (self,s,i):

    if i == 0 and s[i] == '@':
        j = self.skip_id(s,i+1)
        word = s[i:j]
        word = word.lower()
    else:
        word = ""

    if word == "@color" and self.language != "plain":
        # End of the nocolor part.
        self.tag("leoKeyword",0,j)
        return i,"normal"
    else:
        # The entire line is in the nocolor part.
        # Add tags for blanks and tabs to make "Show Invisibles" work.
        for ch in s[i:]:
            if ch == ' ':
                self.tag("blank",i,i+1)
            elif ch == '\t':
                self.tag("tab",i,i+1)
            i += 1
        return i,"nocolor"
</t>
<t tx="ekr.20031218072017.1895"># Colorize the line from i to j.

def doLatexLine (self,s,i,j):

    while i &lt; j:
        if g.match(s,i,"\\"):
            k = self.skip_id(s,i+1)
            word = s[i:k]
            if word in self.latex_keywords:
                self.tag("latexModeKeyword",i,k)
            i = k
        else:
            self.tag("latexModeBackground",i,i+1)
            i += 1
</t>
<t tx="ekr.20031218072017.1896">def doNormalState (self,s,i):

    ch = s[i] ; state = "normal"

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20031218072017.1897"></t>
<t tx="ekr.20031218072017.1898">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20031218072017.1899">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20031218072017.1900">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20031218072017.1901">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20031218072017.1902">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20031218072017.1903"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20031218072017.1904">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20031218072017.1905">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20031218072017.1906"></t>
<t tx="ekr.20031218072017.1907">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20031218072017.1908"></t>
<t tx="ekr.20031218072017.1909"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20031218072017.1910">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20031218072017.1911">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20031218072017.1912">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20031218072017.1913"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20031218072017.1914">def doNowebSecRef (self,s,i):

    c = self.c
    self.tag("nameBrackets",i,i+2)

    # See if the line contains the right name bracket.
    j = s.find(self.rb+"=",i+2)
    k = g.choose(j==-1,2,3)
    if j == -1:
        j = s.find(self.rb,i+2)
    if j == -1:
        return i + 2
    else:
        # includes brackets
        searchName = s[i:j]
        ref = g.findReference(c,searchName,self.p)
        if ref:
            self.tag("link",i+2,j)
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
        elif k == 3: # a section definition
            self.tag("link",i+2,j)
        else:
            self.tag("name",i+2,j)
        self.tag("nameBrackets",j,j+k)
        return j + k
</t>
<t tx="ekr.20031218072017.1915"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
c.frame.body.tag_delete(tagName)
self.tag(tagName,i+2,j)

ref.tagName = tagName
w = c.frame.body
c.tag_bind(w,tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
c.tag_bind(w,tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
c.tag_bind(w,tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)
</t>
<t tx="ekr.20031218072017.1934">def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    trace = False # and not g.unitTesting
    if trace: print('runLeo.run: sys.argv %s' % sys.argv)

    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    if not isValidPython(): return

    files,options = doPrePluginsInit(fileName,pymacs)
    if options.get('exit'): return

    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed: return

    # Phase 3: after loading plugins. Create one or more frames.
    ok = doPostPluginsInit(args,files,options)
    if ok: g.app.gui.runMainLoop()
        # For scripts, the gui is a nullGui.
        # and the gui.setScript has already been called.
</t>
<t tx="ekr.20031218072017.1936">def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.6'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                &lt;&lt; define emergency dialog class &gt;&gt;
                d = emergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
</t>
<t tx="ekr.20031218072017.1937">def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leo.core.leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        &lt;&lt; resolve symlinks &gt;&gt;
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        path = g.os_path_finalize(path)
        if path:
            loadDir = g.os_path_dirname(path)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir) or
            not g.os_path_isdir(loadDir)
        ):
            loadDir = os.getcwd()
            # From Marc-Antoine Parent.
            if loadDir.endswith("Contents/Resources"):
                loadDir += "/leo/plugins"
            else:
                g.pr("Exception getting load directory")
        loadDir = g.os_path_finalize(loadDir)
        # g.es("load dir:",loadDir,color="blue")
        return loadDir
    except:
        g.pr("Exception getting load directory")
        raise
</t>
<t tx="ekr.20031218072017.1938">def createNullGuiWithScript (self,script=None):

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.batchMode = True
        app.gui = leoGui.nullGui("nullGui")
        app.gui.setScript(script)
</t>
<t tx="ekr.20031218072017.1944">def removeAllImages (self):

    '''Remove all references to previous images.
    In Tk, this will cause all images to disappear.'''

    self.image_references = []
</t>
<t tx="ekr.20031218072017.1971">def putClipboardHeader (self):

    # Put the minimum header for sax.
    self.put('&lt;leo_header file_format="2"/&gt;\n')
</t>
<t tx="ekr.20031218072017.1978">def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeLeoDir = g.app.homeLeoDir # was homeDir.
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    &lt;&lt; return if we can set leoID from sys.leoID &gt;&gt;
    &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
    &lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
    &lt;&lt; put up a dialog requiring a valid id &gt;&gt;
    &lt;&lt; attempt to create leoID.txt &gt;&gt;
</t>
<t tx="ekr.20031218072017.1979"># This would be set by in Python's sitecustomize.py file.

# Use hasattr &amp; getattr to suppress pylint warning.
# Use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.silentMode and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Careful: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
</t>
<t tx="ekr.20031218072017.1980">for theDir in (homeLeoDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s.strip()
                # Careful: periods in the id field of a gnx
                # will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.silentMode and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',
                        spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,
                    color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
</t>
<t tx="ekr.20031218072017.1981"># New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.
if g.app.gui is None:
    # # Create the Qt gui if it exists, otherwise the Tk gui.
    g.app.createDefaultGui(fileName='g.app.setLeoId',verbose=True)

if g.app.gui is None: # Neither gui could be created: this should never happen.
    print("Please enter LeoID (e.g. your username, 'johndoe'...)")
    if g.isPython3: # 2010/02/04.
        leoid = input('LeoID: ')
    else:
        leoid = raw_input('LeoID: ')
else:
    leoid = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = leoid

# Careful: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
</t>
<t tx="ekr.20031218072017.1982">for theDir in (homeLeoDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            s = g.app.leoID
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,encoding='utf-8',reportErrors=True)
            f.write(s)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
</t>
<t tx="ekr.20031218072017.1991"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class nodeIndices (object):

    """A class to implement global node indices (gnx's)."""

    @others
</t>
<t tx="ekr.20031218072017.1992">def __init__ (self,id):

    """ctor for nodeIndices class"""

    self.userId = id
    self.defaultId = id

    # A Major simplification: Only assign the timestamp once.
    self.setTimeStamp()
    self.lastIndex = 0
</t>
<t tx="ekr.20031218072017.1993">def areEqual (self,gnx1,gnx2):

    """Return True if all fields of gnx1 and gnx2 are equal"""

    # works whatever the format of gnx1 and gnx2.
    # This should never throw an exception.
    return gnx1 == gnx2
</t>
<t tx="ekr.20031218072017.1994"># These are used by the fileCommands read/write code.

def getDefaultId (self):

    """Return the id to be used by default in all gnx's"""
    return self.defaultId

def setDefaultId (self,theId):

    """Set the id to be used by default in all gnx's"""
    self.defaultId = theId
</t>
<t tx="ekr.20031218072017.1995">def getNewIndex (self):

    '''Create a new gnx.'''

    self.lastIndex += 1
    d = (self.userId,self.timeString,self.lastIndex)
    # g.trace(d)
    return d
</t>
<t tx="ekr.20031218072017.1996">def isGnx (self,gnx):
    try:
        theId,t,n = gnx
        return t != None
    except Exception:
        return False
</t>
<t tx="ekr.20031218072017.1997">def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
</t>
<t tx="ekr.20031218072017.1998">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())

    # g.trace(self.timeString,self.lastIndex,g.callers(4))

setTimeStamp = setTimestamp
</t>
<t tx="ekr.20031218072017.1999">def toString (self,index):

    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if n in (None,0,'',):
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except Exception:
        if not g.app.unitTesting:
            g.trace('unusual gnx',repr(index),g.callers()) 
        try:
            theId,t,n = self.getNewIndex()
            if n in (None,0,'',):
                return "%s.%s" % (theId,t)
            else:
                return "%s.%s.%d" % (theId,t,n)
        except Exception:
            g.trace('double exception: returning original index')
            return repr(index)
</t>
<t tx="ekr.20031218072017.2004">def canonicalTnodeIndex(self,index):

    """Convert Tnnn to nnn, leaving gnx's unchanged."""

    # index might be Tnnn, nnn, or gnx.
    if index is None:
        g.trace('Can not happen: index is None')
        return None

    junk,theTime,junk = g.app.nodeIndices.scanGnx(index,0)
    if theTime == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    return index
</t>
<t tx="ekr.20031218072017.2012">def writeAtFileNodes (self,event=None):

    '''Write all @file nodes in the selected outline.'''

    self.c.atFileCommands.writeAll(writeAtFileNodesFlag=True)
</t>
<t tx="ekr.20031218072017.2013">def writeMissingAtFileNodes (self,event=None):

    '''Write all missing @file nodes.'''

    c = self.c

    if c.p:
        c.atFileCommands.writeMissing(c.p)
</t>
<t tx="ekr.20031218072017.2028">def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.p
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()

        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.h)
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.p
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw(p)

        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.h)
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
</t>
<t tx="ekr.20031218072017.2030">def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.newChanged is None: u.newChanged = True
    c.setChanged(u.newChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
</t>
<t tx="ekr.20031218072017.2039">def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl
    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.oldChanged is None: u.oldChanged = True
    c.setChanged(u.oldChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
</t>
<t tx="ekr.20031218072017.2066">def putPrefs (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("&lt;preferences/&gt;")
    self.put_nl()
</t>
<t tx="ekr.20031218072017.2072">def checkOutline (self,event=None,verbose=True,unittest=False,full=True,root=None):

    """Report any possible clone errors in the outline.

    Remove any tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    if root: iter = root.self_and_subtree
    else:    iter = c.all_positions

    for p in iter():
        try:
            count += 1
            &lt;&lt; remove tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors
</t>
<t tx="ekr.20031218072017.2078">def createRecentFilesMenuItems (self):

    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    if not recentFilesMenu:
        g.trace('Recent Files Menu does not exist',g.callers())
        return

    # Delete all previous entries.
    self.deleteRecentFilesMenuItems(recentFilesMenu)

    # Create the static entries.
    table = self.recentFilesStatic

    self.createMenuEntries(recentFilesMenu,table)

    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase # Not a unicode problem.
    i = 0
    n = len(accel_ch)

    # see if we're grouping when files occur in more than one place
    rf_group = c.config.getBool("recent_files_group")
    rf_always = c.config.getBool("recent_files_group_always")
    groupedEntries = rf_group or rf_always

    if groupedEntries:  # if so, make dict of groups
        dirCount = {}
        for fileName in c.recentFiles[:n]:
            dirName, baseName = g.os_path_split(fileName)
            if baseName not in dirCount:
                dirCount[baseName] = {'dirs':[], 'entry': None}
            dirCount[baseName]['dirs'].append(dirName)

    for name in c.recentFiles[:n]:
        if name.strip() == "": continue  # happens with empty list/new file
        def recentFilesCallback (event=None,c=c,name=name):
            c.openRecentFile(name)

        if groupedEntries:
            dirName, baseName = g.os_path_split(name)

            entry = dirCount[baseName]

            if len(entry['dirs']) &gt; 1 or rf_always:  # sub menus
                if entry['entry'] is None:
                    entry['entry'] = self.createNewMenu(baseName, "Recent Files...")
                    # acts as a flag for the need to create the menu
                c.add_command(self.getMenu(baseName), label=dirName,
                    command=recentFilesCallback, underline=0)
            else:  # single occurence, no submenu
                c.add_command(recentFilesMenu,label=baseName,command=recentFilesCallback,underline=0)
        else:  # original behavior
            label = "%s %s" % (accel_ch[i],g.computeWindowTitle(name))
            c.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1

    if groupedEntries:  # store so we can delete them later
        self.groupedMenus = [i for i in dirCount
                             if dirCount[i]['entry'] is not None]
</t>
<t tx="ekr.20031218072017.2079"></t>
<t tx="ekr.20031218072017.2080">def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.deleteRecentFilesMenuItems(recentFilesMenu)

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
</t>
<t tx="ekr.20031218072017.2081">def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
</t>
<t tx="ekr.20031218072017.2082">@
If this is the only open window was opened when the app started, and the window
has never been written to or saved, then we will automatically close that window
if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20031218072017.2083">def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    c = self

    if g.app.unitTesting: return

    def munge(name):
        return c.os_path_finalize(name or '').lower()
    def munge2(name):
        return c.os_path_finalize_join(g.app.loadDir,name or '')

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20031218072017.2086">def preferences (self,event=None):

    '''Handle the preferences command.'''

    c = self
    c.openLeoSettings()
</t>
<t tx="ekr.20031218072017.2088">def fontPanel (self,event=None):

    '''Open the font dialog.'''

    c = self ; frame = c.frame

    if not frame.fontPanel:
        frame.fontPanel = g.app.gui.createFontPanel(c)

    frame.fontPanel.bringToFront()
</t>
<t tx="ekr.20031218072017.2090">def colorPanel (self,event=None):

    '''Open the color dialog.'''

    c = self ; frame = c.frame

    if not frame.colorPanel:
        frame.colorPanel = g.app.gui.createColorPanel(c)

    frame.colorPanel.bringToFront()
</t>
<t tx="ekr.20031218072017.2092">def openCompareWindow (self,event=None):

    '''Open a dialog for comparing files and directories.'''

    c = self ; frame = c.frame

    if not frame.comparePanel:
        frame.comparePanel = g.app.gui.createComparePanel(c)

    if frame.comparePanel:
        frame.comparePanel.bringToFront()
    else:
        g.es('the',g.app.gui.guiName(),
            'gui does not support the compare window',color='blue')
</t>
<t tx="ekr.20031218072017.2140">def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20031218072017.2143">def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20031218072017.2145">@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
</t>
<t tx="ekr.20031218072017.2146">def os_path_abspath(path):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20031218072017.2147">def os_path_basename(path):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20031218072017.2148">def os_path_dirname(path):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20031218072017.2149">def os_path_exists(path):

    """Return True if path exists."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.exists(path)
</t>
<t tx="ekr.20031218072017.2150">def os_path_getmtime(path):

    """Return the modification time of path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.getmtime(path)
</t>
<t tx="ekr.20031218072017.2151">def os_path_isabs(path):

    """Return True if path is an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isabs(path)
</t>
<t tx="ekr.20031218072017.2152">def os_path_isdir(path):

    """Return True if the path is a directory."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isdir(path)
</t>
<t tx="ekr.20031218072017.2153">def os_path_isfile(path):

    """Return True if path is a file."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isfile(path)
</t>
<t tx="ekr.20031218072017.2154">def os_path_join(*args,**keys):

    trace = False and not g.unitTesting
    c = keys.get('c')

    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]

    if trace: g.trace('1',uargs)

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z) for z in uargs if z]

    if trace: g.trace('2',uargs)

    path = os.path.join(*uargs)

    if trace: g.trace('3',path)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    return path
</t>
<t tx="ekr.20031218072017.2156">def os_path_normcase(path):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20031218072017.2157">def os_path_normpath(path):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20031218072017.2158">def os_path_split(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
</t>
<t tx="ekr.20031218072017.2159">def os_path_splitext(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
</t>
<t tx="ekr.20031218072017.2160">def toUnicodeFileEncoding(path):

    if path: path = path.replace('\\', os.sep)

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path)
</t>
<t tx="ekr.20031218072017.2188">def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    &lt;&lt; compute the window title &gt;&gt;

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,
        relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c)
            # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
</t>
<t tx="ekr.20031218072017.2189"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20031218072017.2191">class nullBody (leoBody):

    @others
</t>
<t tx="ekr.20031218072017.2192">def __init__ (self,frame,parentFrame):

    # g.trace('nullBody','frame',frame,g.callers())

    leoBody.__init__ (self,frame,parentFrame) # Init the base class.

    self.insertPoint = 0
    self.selection = 0,0
    self.s = "" # The body text

    w = stringTextWidget(c=self.c,name='body')
    self.bodyCtrl = self.widget = w
    self.editorWidgets['1'] = w
    self.colorizer = leoColor.nullColorizer(self.c)
</t>
<t tx="ekr.20031218072017.2193"></t>
<t tx="ekr.20031218072017.2194">def findStartOfLine (self,lineNumber):

    lines = g.splitLines(self.s)
    i = 0 ; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
</t>
<t tx="ekr.20031218072017.2195">def scanToStartOfLine (self,i):

    if i &lt;= 0:
        return 0

    assert(self.s[i] != '\n')

    while i &gt;= 0:
        if self.s[i] == '\n':
            return i + 1

    return 0
</t>
<t tx="ekr.20031218072017.2196">def scanToEndOfLine (self,i):

    if i &gt;= len(self.s):
        return len(self.s)

    assert(self.s[i] != '\n')

    while i &lt; len(self.s):
        if self.s[i] == '\n':
            return i - 1

    return i
</t>
<t tx="ekr.20031218072017.2197"># Birth, death &amp; config
def bind(self,*args,**keys):                pass
def createBindings (self,w=None):           pass
def createControl (self,parentFrame,p):     pass
def setColorFromConfig (self,w=None):       pass
def setFontFromConfig (self,w=None):        pass
# Editors...
def addEditor (self,event=None):            pass
def assignPositionToEditor (self,p):        pass
def createEditorFrame (self,w):             return None
def cycleEditorFocus (self,event=None):     pass
def deleteEditor (self,event=None):         pass
def selectEditor(self,w):                   pass
def selectLabel (self,w):                   pass
def setEditorColors (self,bg,fg):           pass
def unselectLabel (self,w):                 pass
def updateEditors (self):                   pass
# Events...
def forceFullRecolor (self):                pass
def scheduleIdleTimeRoutine (self,function,*args,**keys): pass
# Low-level gui...
def hasFocus (self):                        pass
def setFocus (self):                        pass
</t>
<t tx="ekr.20031218072017.2218">class nullColorizer (colorizer):

    """A do-nothing colorer class"""

    @others
</t>
<t tx="ekr.20031218072017.2219">def __init__ (self,c):

    colorizer.__init__(self,c) # init the base class.

    self.c = c
    self.enabled = False
</t>
<t tx="ekr.20031218072017.2220">def colorize(self,p,incremental=False,interruptable=True):
    return 'ok' # Used by unit tests.

def disable(self):                          pass
def enable(self):                           pass
def scanColorDirectives(self,p):            pass

def setFontFromConfig (self):
    self.bold_font = None
    self.italic_font = None
    self.bolditalic_font = None
    self.color_tags_list = []
    self.image_references = []

def updateSyntaxColorer (self,p):           pass

</t>
<t tx="ekr.20031218072017.2222">class nullFrame (leoFrame):

    """A null frame class for tests and batch execution."""

    @others
</t>
<t tx="ekr.20031218072017.2223">class nullGui(leoGui):

    """Null gui class."""

    @others
</t>
<t tx="ekr.20031218072017.2224"></t>
<t tx="ekr.20031218072017.2225">def __init__ (self,guiName):

    leoGui.__init__ (self,guiName) # init the base class.

    self.clipboardContents = ''
    self.theDict = {}
    self.focusWidget = None
    self.frameFactory = g.nullObject()
    self.script = None
    self.lastFrame = None
    self.isNullGui = True
    self.bodyTextWidget  = leoFrame.stringTextWidget
    self.plainTextWidget = leoFrame.stringTextWidget
</t>
<t tx="ekr.20031218072017.2229">def runMainLoop(self):

    """Run the gui's main loop."""

    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nend of batch script")

    # Getting here will terminate Leo.
</t>
<t tx="ekr.20031218072017.2230">def oops(self):

    """Default do-nothing method for nullGui class.

    It is NOT an error to use this method."""

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.trace("nullGui",g.callers(4))
</t>
<t tx="ekr.20031218072017.2231">def setScript (self,script=None,scriptFileName=None):

    self.script = script
    self.scriptFileName = scriptFileName
</t>
<t tx="ekr.20031218072017.2232">class nullLog (leoLog):

    @others
</t>
<t tx="ekr.20031218072017.2233">class nullTree (leoTree):

    @others
</t>
<t tx="ekr.20031218072017.2234">def __init__ (self,frame):

    leoTree.__init__(self,frame) # Init the base class.

    assert(self.frame)

    self.editWidgetsDict = {} # Keys are tnodes, values are stringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.redrawCount = 0
    self.stayInTree = True
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
</t>
<t tx="ekr.20031218072017.2236"></t>
<t tx="ekr.20031218072017.2243">class nullUndoer (undoer):

    def __init__ (self,c):

        undoer.__init__(self,c) # init the base class.

    @others
</t>
<t tx="ekr.20031218072017.2278">def importFromPath (name,path,pluginName=None,verbose=False):

    trace = False and not g.unitTesting
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path)
    module = sys.modules.get(moduleName)
    if module:
        if trace: g.trace('already loaded',moduleName,module)
        return module

    try:
        theFile = None
        import imp
        try:
            data = imp.find_module(moduleName,[path]) # This can open the file.
            theFile,pathname,description = data
            module = imp.load_module(moduleName,theFile,pathname,description)
        except ImportError:
            if trace: # or verbose:
                g.es_print("exception in g.importFromPath",color='blue')
                g.es_exception()
        except UiTypeException:
            if not g.unitTesting and not g.app.batchMode:
                g.es_print('Plugin %s does not support %s gui' % (
                    name,g.app.gui.guiName()))          
        except Exception:
            g.es_print("unexpected exception in g.importFromPath(%s)" %
                (name),color='blue')
            g.es_exception()
    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()

    if module:
        if trace: g.trace('loaded',moduleName)
    else:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
</t>
<t tx="ekr.20031218072017.2287">def canExtract (self):

    c = self ; body = c.frame.body
    return body and body.hasTextSelection()

canExtractSectionNames = canExtract

def canExtractSection (self):

    c = self ; body = c.frame.body
    if not body: return False

    s = body.getSelectedText()
    if not s: return False

    line = g.get_line(s,0)
    i1 = line.find("&lt;&lt;")
    j1 = line.find("&gt;&gt;")
    i2 = line.find("@&lt;")
    j2 = line.find("@&gt;")
    return -1 &lt; i1 &lt; j1 or -1 &lt; i2 &lt; j2
</t>
<t tx="ekr.20031218072017.2290">def toggleAngleBrackets (self,event=None):

    '''Add or remove double angle brackets from the headline of the selected node.'''

    c = self ; p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return

    c.endEditing()
    s = p.h.strip()

    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')

    p.setHeadString(s)
    c.redrawAndEdit(p, selectAll=True)
</t>
<t tx="ekr.20031218072017.2293">@ This routine performs a single batch change operation, updating the
head or body string of p and leaving the result in s_ctrl. We update
the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text
on exit. pos and pos2 indicate the selection. The selection will never
be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 &gt; pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;
</t>
<t tx="ekr.20031218072017.2294">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.h:

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
</t>
<t tx="ekr.20031218072017.2295">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.b:

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
</t>
<t tx="ekr.20031218072017.2297">def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame

    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir:
        c.openDirectory = c.frame.openDirectory = theDir

    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)

    if ok:
        frame.resizePanesToRatio(ratio,frame.secondary_ratio)

    return ok
</t>
<t tx="ekr.20031218072017.2312">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b:
            url = p.b.strip()
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.b.split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
</t>
<t tx="ekr.20031218072017.2313"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            z_url = url[i:]
            g.es("ignoring characters after space in url:",z_url)
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20031218072017.2317"># Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception:
        name = ''
    if name == "?":
        name = "&lt;unknown&gt;"

    # Pad the caller name.
    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = [name]
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg)
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)

    # 'print s,' is not valid syntax in Python 3.x.
    g.pr(s,newline=newline)
</t>
<t tx="ekr.20031218072017.2318"># Convert all args to strings.
# Print if tracing for name has been enabled.

def trace_tag (name, *args):

    s = ""
    for arg in args:
        if type(arg) != type(""):
            arg = repr(arg)
        if len(s) &gt; 0:
            s = s + ", " + arg
        else:
            s = arg
    message = s

    t = app.trace_list
    # tracepoint names starting with '-' must match exactly.
    minus = len(name) &gt; 0 and name[0] == '-'
    if minus: name = name[1:]
    if (not minus and '*' in t) or name.lower() in t:
        s = name + ": " + message
        g.es(s) # Traces _always_ get printed.
</t>
<t tx="ekr.20031218072017.2353">def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.p
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.endEditing()
    undoData = u.beforeMoveNode(current)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(after)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(p)
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20031218072017.2368"># Set defaults. 
self.string1 = "\""
self.string2 = "'"
self.verbatim = None

# Set special cases.
if self.language == "plain":
    self.string1 = self.string2 = None # This is debatable.

# if you're not going to use { } for pascal comments, use
# @comment (* *)
# to specify the alternative
#if self.language == "pascal":
#    self.comment2 = "(*" ; self.comment2_end = "*)"

self.refpart_stack=[]
self.select_next_sentinel()

if self.language == "latex": # 3/10/03: Joo-won Jung
    self.string1 = self.string2 = None # This is debatable.
if self.language == "html":
    self.string1 = '"' ; self.string2 = None # 12/3/03

if 0:
    g.trace("sentinel,line_comment,comment,string1,string2:",
        repr(self.sentinel),
        repr(self.line_comment),
        repr(self.comment),
        repr(self.string1),
        repr(self.string2))
</t>
<t tx="ekr.20031218072017.2369">def skip_string(s,i,verbose=True):

    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20031218072017.2377">def getSelectionLines (self):

    """Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self.c

    if g.app.batchMode:
        return '','',''

    # At present, called only by c.getBodyLines.
    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)


    before = g.toUnicode(s[0:i])
    sel    = g.toUnicode(s[i:j])
    after  = g.toUnicode(s[j:len(s)])

    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 70

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2410">@ Leo must handle events or commands that change the text in the outline
or body panes. We must ensure that headline and body text corresponds
to the vnode corresponding to presently selected outline, and vice
versa. For example, when the user selects a new headline in the
outline pane, we must ensure that:

1) All vnodes have up-to-date information and

2) the body pane is loaded with the correct data.

Early versions of Leo attempted to satisfy these conditions when the user
switched outline nodes. Such attempts never worked well; there were too many
special cases. Later versions of Leo use a much more direct approach: every
keystroke in the body pane updates the presently selected vnode immediately.

The leoTree class contains all the event handlers for the tree pane, and the
leoBody class contains the event handlers for the body pane. The following
convenience methods exists:

- body.updateBody &amp; tree.updateBody:
    Called by k.masterCommand after any keystroke not handled by k.masterCommand.
    These are suprising complex.

- body.bodyChanged &amp; tree.headChanged:
    Called by commands throughout Leo's core that change the body or headline.
    These are thin wrappers for updateBody and updateTree.
</t>
<t tx="ekr.20031218072017.2411">@root directive. The stack never becomes empty because of the entry
@
The Tangle command translates the selected @root tree into one or more
well-formatted source files. The outline should contain directives,
sections references and section definitions, as described in Chapter
4. The Untangle command is essentially the reverse of the Tangle
command. The Tangle command creates a derived file from an @root tree;
the Untangle command incorporates changes made to derived files back
into the @root tree.

The Tangle command operates in two passes. The first pass discovers
the complete definitions of all sections and places these definitions
in a Tangle Symbol Table. The first pass also makes a list of root
sections. Definitions can appear in any order, so we must scan the
entire input file to know whether any particular definition has been
completed.

Tangle's second pass creates one file for each @root node. Tangle
rescans each section in the list of roots, copying the root text to
the output and replacing each section reference by the section's
definition. This is a recursive process because any definition may
contain other references. We can not allow a section to be defined in
terms of itself, either directly or indirectly. We check for such
illegally recursive definitions in pass 2 using the section stack
class. Tangle indicates where sections begin and end using comment
lines called sentinel lines. The sentinels used predate the formats
described in the "Format of external files" appendix.

The key design principle of the Tangle command is this: Tangle must
output newlines in a context-free manner. That is, Tangle must never
output conditional newlines, either directly or indirectly. Without
this rule Untangle could not determine whether to skip or copy
newlines.

The Tangle command increases the indentation level of a section
expansion the minimum necessary to align the section expansion with
the surrounding code. In essence, this scheme aligns all section
expansions with the line of code in which the reference to the section
occurs. In some cases, several nested sections expansions will have
the same indentation level. This can occur, for example, when a
section reference in an outline occurs at the left margin of the
outline.

This scheme is probably better than more obvious schemes that indent
more "consistently." Such schemes would produce too much indentation
for deeply nested outlines. The present scheme is clear enough and
avoids indentation wherever possible, yet indents sections adequately.
End sentinel lines make this scheme work by making clear where the
expansion of one section ends and the expansion of a containing
section resumes.

Tangle increases indentation if the section reference does not start a
line. Untangle is aware of this hack and adjusts accordingly. This
extra indentation handles several common code idioms, which otherwise
would create under-indented code. In short, Tangle produces highly
readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex. It must do a perfect job of updating
the outline, especially whitespace, from expansions of section
definitions created by the Tangle command. Such expansions need not be
identical because they may have been generated at different levels of
indentation. The Untangle command can not assume that all expansions
of a section will be identical in the derived file; within the derived
file, the programmer may have made incompatible changes to two
different expansions of the same section. Untangle must check to see
that all expansions of a section are "equivalent". As an added
complication, derived files do not contain all the information found
in @root trees. @root trees may contain headlines that generate no
code at all. Also, an outline may define a section in several ways:
with an @c or @code directive or with a section definition line. To be
useful, Untangle must handle all these complications flawlessly.

Untangle operates in three passes. The first pass builds a symbol
table in the same way that Tangle does. The key information there
informs how the second pass finds definitions in the derived file: to
support multi-language files (e.g., javascript embedded in html) the
second pass needs to know what comment delimiters to look for as it
discovers sentinels in the derived file. Using comment delimiters as
suggested by the first pass, it uses the sentinels to find section
parts and enters them into the Untangle Symbol Table, or UST.
Definitions often include references to other sections, so definitions
often include nested definitions of referenced sections. The second
pass of Untangle uses a definition stack to keep track of nested
definitions. The top of the stack represents the definition following
the latest reference, except for the very first entry pushed on the
stack, which represents the code in the outline that contains the
for the @root section. All definitions of a section should
match--otherwise there is an inconsistent definition. This pass uses a
forgiving compare routine that ignores differences that do not affect
the meaning of a program.

Untangle's third pass enters definitions from the outline into a
second Tangle Symbol Table, or TST. The third pass simultaneously
updates all sections in the outline whose definition in the new TST
does not match the definition in the UST. The central coding insight
of the Untangle command is that the second pass of Untangle is almost
identical to the first pass of Tangle! That is, Tangle and Untangle
share key parts of code, namely the skip_body() method and its allies.
Just when skip_body() enters a definition into the symbol table, all
the information is present that Untangle needs to update that
definition.
</t>
<t tx="ekr.20031218072017.2413">@ Think of the actions that may be Undone or Redone as a string of beads
(g.Bunches) containing all information needed to undo _and_ redo an operation.

A bead pointer points to the present bead. Undoing an operation moves the bead
pointer backwards; redoing an operation moves the bead pointer forwards. The
bead pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled.

The Undo command uses the present bead to undo the action, then moves the bead
pointer backwards. The Redo command uses the bead after the present bead to redo
the action, then moves the bead pointer forwards. The list of beads does not
branch; all undoable operations (except the Undo and Redo commands themselves)
delete any beads following the newly created bead.

New in Leo 4.3: User (client) code should call u.beforeX and u.afterX methods to
create a bead describing the operation that is being performed. (By convention,
the code sets u = c.undoer for undoable operations.) Most u.beforeX methods
return 'undoData' that the client code merely passes to the corresponding
u.afterX method. This data contains the 'before' snapshot. The u.afterX methods
then create a bead containing both the 'before' and 'after' snapshots.

New in Leo 4.3: u.beforeChangeGroup and u.afterChangeGroup allow multiple calls
to u.beforeX and u.afterX methods to be treated as a single undoable entry. See
the code for the Change All, Sort, Promote and Demote commands for examples.
u.before/afterChangeGroup substantially reduce the number of u.before/afterX
methods needed.

New in Leo 4.3: It would be possible for plugins or other code to define their
own u.before/afterX methods. Indeed, u.afterX merely needs to set the
bunch.undoHelper and bunch.redoHelper ivars to the methods used to undo and redo
the operation. See the code for the various u.before/afterX methods for
guidance.

New in Leo 4.3: p.setDirty and p.setAllAncestorAtFileNodesDirty now return a
'dirtyVnodeList' that all vnodes that became dirty as the result of an
operation. More than one list may be generated: client code is responsible for
merging lists using the pattern dirtyVnodeList.extend(dirtyVnodeList2)

I first saw this model of unlimited undo in the documentation for Apple's Yellow Box classes.
</t>
<t tx="ekr.20031218072017.2414">@nocolor-node
@
The find and change commands are tricky; there are many details that must be
handled properly. This documentation describes the leo.py code. Previous
versions of Leo used an inferior scheme. The following principles govern the
leoFind class:

1. Find and Change commands initialize themselves using only the state of the
   present Leo window. In particular, the Find class must not save internal
   state information from one invocation to the next. This means that when the
   user changes the nodes, or selects new text in headline or body text, those
   changes will affect the next invocation of any Find or Change command.
   Failure to follow this principle caused all kinds of problems in the Borland
   and Macintosh codes. There is one exception to this rule: we must remember
   where interactive wrapped searches start. This principle simplifies the code
   because most ivars do not persist. However, each command must ensure that the
   Leo window is left in a state suitable for restarting the incremental
   (interactive) Find and Change commands. Details of initialization are
   discussed below.

2. The Find and Change commands must not change the state of the outline or body
   pane during execution. That would cause severe flashing and slow down the
   commands a great deal. In particular, c.selectVnode and c.editPosition
   methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo
   window in the proper state to execute another incremental command. We restore
   the Leo window as it was on entry whenever an incremental search fails and
   after any Find All and Change All command.

Initialization involves setting the c, p, in_headline, wrapping and s_ctrl
ivars. Setting in_headline is tricky; we must be sure to retain the state of the
outline pane until initialization is complete. Initializing the Find All and
Change All commands is much easier because such initialization does not depend
on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge
simplification of the code. Indeed, the searching code does not know whether it
is searching headline or body text. The search code knows only that s_ctrl is a
Tk.Text widget that contains the text to be searched or changed and the insert
and sel Tk attributes of self.search_text indicate the range of text to be
searched. Searching headline and body text simultaneously is complicated. The
selectNextPosition() method handles the many details involved by setting s_ctrl
and its insert and sel attributes.
</t>
<t tx="ekr.20031218072017.2417">def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec(self.change_text,{},{})
    except Exception:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20031218072017.2418">def initScriptFind(c,findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):

    import leo.core.leoTest as leoTest
    import leo.core.leoGlobals as g

    # Find the scripts.
    p = c.p
    u = leoTest.testUtils(c)
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.b
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.b
    else:
        change_text = ""
    # g.pr(find_p,change_p)

    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()
</t>
<t tx="ekr.20031218072017.2604">

</t>
<t tx="ekr.20031218072017.2605">@first #! /usr/bin/env python

"""Entry point for Leo in Python."""

@language python
@tabwidth -4

&lt;&lt; imports and inits &gt;&gt;

@others

if __name__ == "__main__":
    run()

</t>
<t tx="ekr.20031218072017.2607">@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g
    import os

    theDir = os.getcwd()

    # On Windows, name must be a plain string. An apparent cProfile bug.
    name = str(g.os_path_normpath(g.os_path_join(theDir,'leoProfile.txt')))
    print ('profiling to %s' % name)
    profile.run('import leo ; leo.run()',name)
    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)

prof = profile_leo
</t>
<t tx="ekr.20031218072017.2608">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4
@pagewidth 60

import leo.core.leoGlobals as g
import leo.core.leoCache as leoCache
# import leo.core.leoPlugins as leoPlugins
import leo.core.leoVersion as leoVersion

import os
import sys
# import leo.external.pickleshare as pickleshare

class LeoApp:

    """A class representing the Leo application itself.

    Ivars of this class are Leo's global variables."""

    @others
</t>
<t tx="ekr.20031218072017.2609">def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c)
        # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
</t>
<t tx="ekr.20031218072017.2610">def createTkGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to 
    create the default Tk gui class."""

    app = self

    try:
        import tkinter as Tk
    except ImportError:
        try:
            import Tkinter as Tk
        except ImportError:
            Tk = None

    Pmw = g.importExtension('Pmw',pluginName='startup',verbose=False)

    if Tk and Pmw:
        app.pluginsController.loadOnePlugin('leo.plugins.tkGui',verbose=verbose)
        if app.gui and fileName and verbose:
            print('tkGui created in %s' % fileName)
</t>
<t tx="ekr.20031218072017.2612">def destroyAllOpenWithFiles (self):

    """Try to remove temp files created with the Open With command.

    This may fail if the files are still open.

    Called by g.app.finishQuit"""

    # We can't use g.es here because the log stream no longer exists.

    for theDict in self.openWithFiles[:]:
        g.app.destroyOpenWithFileWithDict(theDict)

    # Delete the list so the gc can recycle Leo windows!
    g.app.openWithFiles = []
</t>
<t tx="ekr.20031218072017.2613">def destroyOpenWithFilesForFrame (self,frame):

    """Close all "Open With" files associated with frame

    Called by app.destroyWindow.
    """

    # Make a copy of the list: it may change in the loop.
    openWithFiles = g.app.openWithFiles

    for theDict in openWithFiles[:]: # 6/30/03
        c = theDict.get("c")
        if c.frame == frame:
            g.app.destroyOpenWithFileWithDict(theDict)
</t>
<t tx="ekr.20031218072017.2614">def destroyOpenWithFileWithDict (self,theDict):

    '''
    A helper for app.destroyAllOpenWithFiles and
    app.destroyOpenWithFilesForFrame.
    '''

    path = theDict.get("path")
    if path and g.os_path_exists(path):
        try:
            os.remove(path)
            g.pr("deleting temp file: %s" % g.shortFileName(path))
        except:
            g.pr("can not delete temp file: %s" % path)

    # Remove theDict from the list so the gc can recycle the Leo window!
    g.app.openWithFiles.remove(theDict)
</t>
<t tx="ekr.20031218072017.2615">def destroyWindow (self,frame):

    # g.trace(frame in g.app.windowList,frame)
    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        # g.trace(g.app.windowList)
        g.app.windowList.remove(frame)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()
</t>
<t tx="ekr.20031218072017.2616">def forceShutdown (self):

    """Forces an immediate shutdown of Leo at any time.

    In particular, may be called from plugins during startup."""

    # Wait until everything is quiet before really quitting.
    g.doHook("end1")

    self.log = None # Disable writeWaitingLog
    self.killed = True # Disable all further hooks.

    for w in self.windowList[:]:
        self.destroyWindow(w)

    self.finishQuit()
</t>
<t tx="ekr.20031218072017.2617">def onQuit (self,event=None):

    '''Exit Leo, prompting to save unsaved outlines first.'''

    g.app.quitting = True
    # g.trace('True')

    while g.app.windowList:
        w = g.app.windowList[0]
        if not g.app.closeLeoWindow(w):
            break

    if g.app.windowList:
        g.app.quitting = False # If we get here the quit has been disabled.
</t>
<t tx="ekr.20031218072017.2619">def writeWaitingLog (self,c):

    app = self
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    # print('***** writeWaitingLog','unitTesting',g.unitTesting,c,g.callers())

    if not c or not c.exists:
        return

    if g.unitTesting:
        app.printWaiting = []
        app.logWaiting = []
        g.app.setLog(None) # Prepare to requeue for other commanders.
        return

    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    c.setLog() # 2010/10/20
    app.logInited = True # Prevent recursive call.
    if not app.signon_printed:
        app.signon_printed = True
        print(app.signon)
        print(app.signon2)
    for s in app.printWaiting:
        print(s)
    app.printWaiting = []
    for s,color in table:
        app.logWaiting.insert(0,(s+'\n',color),)
    for s,color in app.logWaiting:
        g.es('',s,color=color,newline=0)
            # The caller must write the newlines.

    # Essential when opening multiple files...
    app.logWaiting = []
    g.app.setLog(None) 
</t>
<t tx="ekr.20031218072017.2794">&lt;&lt; docstring &gt;&gt;
@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import re
import string

&lt;&lt; changelog &gt;&gt;

# php_re = re.compile("&lt;?(\s|=|[pP][hH][pP])")
php_re = re.compile("&lt;?(\s[pP][hH][pP])")

&lt;&lt; define colorizer constants &gt;&gt;
&lt;&lt; define global colorizer data &gt;&gt;
&lt;&lt; define leo_color_database &gt;&gt;

@others
</t>
<t tx="ekr.20031218072017.2795"># These defaults are sure to exist.
default_colors_dict = {
    # tag name       :(     option name,           default color),
    "comment"        :("comment_color",               "red"),
    "cwebName"       :("cweb_section_name_color",     "red"),
    "pp"             :("directive_color",             "blue"),
    "docPart"        :("doc_part_color",              "red"),
    "keyword"        :("keyword_color",               "blue"),
    "leoKeyword"     :("leo_keyword_color",           "blue"),
    "link"           :("section_name_color",          "red"),
    "nameBrackets"   :("section_name_brackets_color", "blue"),
    "string"         :("string_color",                "#00aa00"), # Used by IDLE.
    "name"           :("undefined_section_name_color","red"),
    "latexBackground":("latex_background_color","white"),
}

default_font_dict = {
    # tag name       : option name
    'comment'        :'comment_font',
    'cwebName'       :'cweb_section_name_font',
    'pp'             :'directive_font',
    'docPart'        :'doc_part_font',
    'keyword'        :'keyword_font',
    'leoKeyword'     :'leo_keyword_font',
    'link'           :'section_name_font',
    'nameBrackets'   :'section_name_brackets_font',
    'string'         :'string_font',
    'name'           :'undefined_section_name_font',
    'latexBackground':'latex_background_font',
}
</t>
<t tx="ekr.20031218072017.2796">class colorizer:
    """Leo's syntax colorer class"""
    def interrupt(self): pass
    @others
</t>
<t tx="ekr.20031218072017.2801"># The main colorizer entry point.

def colorize(self,p,incremental=False,interruptable=True):
    # interruptable used only in new colorizer.

    # g.trace(g.callers())

    if self.enabled:
        # if self.trace: g.trace("incremental",incremental)
        self.incremental=incremental
        self.updateSyntaxColorer(p)
        return self.colorizeAnyLanguage(p)
    else:
        return "ok" # For unit testing.

</t>
<t tx="ekr.20031218072017.2803">def getCwebWord (self,s,i):

    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None

    ch1 = ch2 = word = None
    if i + 1 &lt; len(s): ch1 = s[i+1]
    if i + 2 &lt; len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)

    return word
</t>
<t tx="ekr.20031218072017.2804"># self.flag is True unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,p):

    p = p.copy()
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)
</t>
<t tx="ekr.20031218072017.2805">def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    self.killFlag = False

    # New in Leo 4.6: @nocolor-node disables one node only.
    theDict = g.get_directives_dict(p)
    if 'nocolor-node' in theDict:
        return False

    for p in p.self_and_parents():
        theDict = g.get_directives_dict(p)
        no_color = 'nocolor' in theDict
        color = 'color' in theDict
        kill_color = 'killcolor' in theDict
        # A killcolor anywhere disables coloring.
        if kill_color:
            self.killFlag = True
            return False
        # A color anywhere in the target enables coloring.
        elif color and p == first:
            return True
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            return False
        elif color and not no_color:
            return True

    return True
</t>
<t tx="ekr.20031218072017.2806">@
These methods are like the corresponding functions in leoGlobals.py
except they issue no error messages.
</t>
<t tx="ekr.20031218072017.2807">def setFirstLineState (self):

    if self.flag:
        if self.rootMode:
            state = g.choose(self.rootMode=="code","normal","doc")
        else:
            state = "normal"
    else:
        state = "nocolor"

    return state
</t>
<t tx="ekr.20031218072017.2808">def skip_id(self,s,i,chars=None):

    n = len(s)

    # if not g.isPython3:
        # chars = chars and g.toUnicode(chars,encoding='ascii') or unicode('')

    chars = chars or g.u('')

    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
</t>
<t tx="ekr.20031218072017.2809">def skip_string(self,s,i):

    """Skip a string literal."""

    allow_newlines = self.language == "elisp"
    delim = s[i] ; i += 1
    continue_state = g.choose(delim=="'","singleString","doubleString")
    assert(delim == '"' or delim == "'")
    n = len(s)
    while i &lt; n and s[i] != delim and (allow_newlines or not s[i] == '\n'): # 6/3/04: newline ends most strings.
        if s[i:] == "\\": # virtual trailing newline.
            return n,continue_state
        elif s[i] == '\\': i += 2
        else: i += 1

    if i &gt;= n:
        return n, g.choose(allow_newlines,continue_state,"normal")
    if s[i] == delim:
        i += 1
    return i,"normal"
</t>
<t tx="ekr.20031218072017.2810">@first # -*- coding: utf-8 -*-
    # Needed because of unicode characters in tests.

@language python
@tabwidth -4
@pagewidth 70

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName,relativeFileName=None):

    trace = False
    c = self ; tag = 'Commands.__init__'

    self.requestedFocusWidget = None
    self.requestRedrawFlag = False
    self.requestedIconify = '' # 'iconify','deiconify'
    self.requestRecolorFlag = False

    if trace:
        print(tag)
        import time ; t1 = time.clock()
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep pylint happy

    # Debugging.
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0

    # Data.
    self.chapterController = None
    self.frame = frame
    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('&lt;hidden root vnode&gt;')
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    self.initIvars()
    self.nodeHistory = nodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoCache as leoCache
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo

    if trace: t2 = g.printDiffTime('%s: after imports' % (tag),t1)

    self.shadowController = leoShadow.shadowController(c)
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.rstCommands    = leoRst.rstCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)
    self.rstCommands = leoRst.rstCommands(c)

    c.cacher = leoCache.cacher(c)
    c.cacher.initFileDB(self.mFileName)

    if trace: t3 = g.printDiffTime('%s: after controllers created' % (tag),t2)

    if 0:
        g.pr("\n*** using Null undoer ***\n")
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.changed = False # True if any data has been changed since the last save.
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.hookFunction = None
self.ignoreChangedPaths = False # True: disable path changed message in at.WriteAllHelper.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.nodeConflictList = [] # List of nodes with conflicting read-time data.
self.nodeConflictFileName = None # The fileName for c.nodeConflictList.
self.openDirectory = None
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.
self.timeStampDict = {} # New in Leo 4.6.

# For tangle/untangle
self.tangle_errors = 0

# Global options: set later in initConfigSettings
self.fixed = False
self.page_width = 132
self.sparse_find = True # 2010/02/02: created ivar.
self.sparse_move = True # 2010/02/02: created ivar.
self.sparse_spell = True # 2010/02/02: created ivar.
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None
</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):

    return "Commander %d: %s" % (id(self),repr(self.mFileName))

__str__ = __repr__
</t>
<t tx="ekr.20031218072017.2817">command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.p
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.app.commandInterruptFlag = True
        g.es('ignoring command: already executing a command.',color='red')
        return 'break'

    g.app.commandInterruptFlag = False

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: g.pr('c no longer exists',c)
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es_print("exception executing command")
                g.es_exception(c=c)

        if c and c.exists:
            if c.requestCloseWindow:
                g.trace('Closing window after command')
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return "break" # Inhibit all other handlers.
</t>
<t tx="ekr.20031218072017.2818"></t>
<t tx="ekr.20031218072017.2819"></t>
<t tx="ekr.20031218072017.2820"></t>
<t tx="ekr.20031218072017.2821">def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2822">@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20031218072017.2823">def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return 'break'
</t>
<t tx="ekr.20031218072017.2824">def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @&lt;file&gt; tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
</t>
<t tx="ekr.20031218072017.2827">conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old &amp; new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
</t>
<t tx="ekr.20031218072017.2829">def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '&lt;no command&gt;'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

     This is overridden in mod_tempfname plugin
     '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
</t>
<t tx="ekr.20031218072017.2833">def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
</t>
<t tx="ekr.20031218072017.2834">def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2835">def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        if g.app.qt_use_tabs and hasattr(c.frame,'top'):
            c.frame.top.master.setTabName(c,c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2836">def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    # Does not change icons status.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2837">def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.doHook("close-frame",c=c)
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20031218072017.2838"></t>
<t tx="ekr.20031218072017.2839">def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    c = self
    c.endEditing()

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
</t>
<t tx="ekr.20031218072017.2841"></t>
<t tx="ekr.20031218072017.2842">def tangleAll (self,event=None):

    '''Tangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleAll()
</t>
<t tx="ekr.20031218072017.2843">def tangleMarked (self,event=None):

    '''Tangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.tangleMarked()
</t>
<t tx="ekr.20031218072017.2844">def tangle (self,event=None):

    '''Tangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.tangle()
</t>
<t tx="ekr.20031218072017.2845"></t>
<t tx="ekr.20031218072017.2846">def untangleAll (self,event=None):

    '''Untangle all @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleAll()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20031218072017.2847">def untangleMarked (self,event=None):

    '''Untangle all marked @root nodes in the entire outline.'''

    c = self
    c.tangleCommands.untangleMarked()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20031218072017.2848">def untangle (self,event=None):

    '''Untangle all @root nodes in the selected outline.'''

    c = self
    c.tangleCommands.untangle()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20031218072017.2849"></t>
<t tx="ekr.20031218072017.2850">def exportHeadlines (self,event=None):

    '''Export all headlines to an external file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.exportHeadlines(fileName)
</t>
<t tx="ekr.20031218072017.2851">def flattenOutline (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in MORE format.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.flattenOutline(fileName)
</t>
<t tx="ekr.20031218072017.2852">def importAtRoot (self,event=None):

    '''Import one or more external files, creating @root trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand (names,"@root")
</t>
<t tx="ekr.20031218072017.2853">def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
</t>
<t tx="ekr.20031218072017.2854">def importCWEBFiles (self,event=None):

    '''Import one or more external CWEB files, creating @file trees.'''

    c = self

    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"cweb")
</t>
<t tx="ekr.20031218072017.2855">def importFlattenedOutline (self,event=None):

    '''Import an external created by the flatten-outline command.'''

    c = self

    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFlattenedOutline(names)
</t>
<t tx="ekr.20031218072017.2856">def importNowebFiles (self,event=None):

    '''Import one or more external noweb files, creating @file trees.'''

    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importWebCommand(names,"noweb")
</t>
<t tx="ekr.20031218072017.2857">def outlineToCWEB (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in CWEB format.'''

    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")
    c.bringToFront()

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")
</t>
<t tx="ekr.20031218072017.2858">def outlineToNoweb (self,event=None):

    '''Export the selected outline to an external file.
    The outline is represented in noweb format.'''

    c = self

    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")
    c.bringToFront()

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName
</t>
<t tx="ekr.20031218072017.2859">def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
</t>
<t tx="ekr.20031218072017.2860">def weave (self,event=None):

    '''Simulate a literate-programming weave operation by writing the outline to a text file.'''

    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")
    c.bringToFront()

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        g.chdir(fileName)
        c.importCommands.weave(fileName)
</t>
<t tx="ekr.20031218072017.2861"></t>
<t tx="ekr.20031218072017.2862"></t>
<t tx="ekr.20031218072017.2883">def hideInvisibles (self,event=None):
    c = self ; c.showInvisiblesHelper(False)

def showInvisibles (self,event=None):
    c = self ; c.showInvisiblesHelper(True)

def toggleShowInvisibles (self,event=None):
    c = self ; colorizer = c.frame.body.getColorizer()
    val = g.choose(colorizer.showInvisibles,0,1)
    c.showInvisiblesHelper(val)

def showInvisiblesHelper (self,val):
    c = self ; frame = c.frame ; p = c.p
    colorizer = frame.body.getColorizer()
    colorizer.showInvisibles = val

     # It is much easier to change the menu name here than in the menu updater.
    menu = frame.menu.getMenu("Edit")
    index = frame.menu.getMenuLabel(menu,g.choose(val,'Hide Invisibles','Show Invisibles'))
    if index is None:
        if val: frame.menu.setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
        else:   frame.menu.setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

    c.frame.body.recolor(p)
</t>
<t tx="ekr.20031218072017.2884"></t>
<t tx="ekr.20031218072017.2885"></t>
<t tx="ekr.20031218072017.2886">def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return

    if k:
        k.setDefaultInputState()
        k.showStateAndMode()

    tree.editLabel(c.p)
</t>
<t tx="ekr.20031218072017.2887"></t>
<t tx="ekr.20031218072017.2888">def showFindPanel (self,event=None):

    '''Open Leo's legacy Find dialog.'''

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    if c.frame.findPanel:
        c.frame.findPanel.bringToFront()
    else:
        g.es('the',g.app.gui.guiName(),
            'gui does not support a stand-alone find dialog',color='blue')
</t>
<t tx="ekr.20031218072017.2889">def findNext (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
</t>
<t tx="ekr.20031218072017.2890">def findPrevious (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
</t>
<t tx="ekr.20031218072017.2891">def replace (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
</t>
<t tx="ekr.20031218072017.2892">def replaceThenFind (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
</t>
<t tx="ekr.20031218072017.2893">def notValidInBatchMode(self, commandName):

    g.es('the',commandName,"command is not valid in batch mode")
</t>
<t tx="ekr.20031218072017.2894"></t>
<t tx="ekr.20031218072017.2895"></t>
<t tx="ekr.20031218072017.2898"></t>
<t tx="ekr.20031218072017.2899"></t>
<t tx="ekr.20031218072017.2900">def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    for p in c.all_unique_positions():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.p
    while p and p.hasParent():
        p.moveToParent()

    c.redraw(p,setFocus=True)

    c.expansionLevel = 1 # Reset expansion level.
</t>
<t tx="ekr.20031218072017.2901">def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
</t>
<t tx="ekr.20031218072017.2902">def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.p

    parent = p.parent()
    if not parent: return

    parent.contract()

    c.redraw_after_contract(p=parent)
</t>
<t tx="ekr.20031218072017.2903">def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    p = c.rootPosition()
    while p:
        c.expandSubtree(p)
        p.moveToNext()

    c.redraw_after_expand(p=c.rootPosition(),setFocus=True)

    c.expansionLevel = 0 # Reset expansion level.
</t>
<t tx="ekr.20031218072017.2904">def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; p = c.p
    if not p: return

    child = p.firstChild()
    c.expandSubtree(p)
    while child:
        c.expandSubtree(child)
        child = child.next()

    c.redraw(p,setFocus=True)
</t>
<t tx="ekr.20031218072017.2905">def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
</t>
<t tx="ekr.20031218072017.2906">def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="ekr.20031218072017.2907">def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

</t>
<t tx="ekr.20031218072017.2908">def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="ekr.20031218072017.2909"></t>
<t tx="ekr.20031218072017.2910">def contractSubtree (self,p):

    for p in p.subtree():
        p.contract()
</t>
<t tx="ekr.20031218072017.2911">def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    while v and v != last:
        v.expand()
        v = v.threadNext()

    c.redraw()
</t>
<t tx="ekr.20031218072017.2912">def expandToLevel (self,level):

    c = self
    current = c.p
    n = current.level()
    for p in current.self_and_subtree():
        if p.level() - n + 1 &lt; level:
            p.expand()
        else:
            p.contract()
    c.expansionLevel = level
    c.expansionNode = c.p
    c.redraw()
</t>
<t tx="ekr.20031218072017.2913"></t>
<t tx="ekr.20031218072017.2914">def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self ; p = c.rootPosition()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2915">def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2916">def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.p
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.h,color='blue')
        return

    v = p.v
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if p:
        if cc:
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es("done",color="blue")

    # if cc:
        # name = cc.findChapterNameForPosition(p)
        # cc.selectChapterByName(name)
</t>
<t tx="ekr.20031218072017.2917">def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20031218072017.2918">def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20031218072017.2919">def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.next())
</t>
<t tx="ekr.20031218072017.2920">def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
</t>
<t tx="ekr.20031218072017.2921">def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.back())
</t>
<t tx="ekr.20031218072017.2922"></t>
<t tx="ekr.20031218072017.2923">def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.p

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    for p in c.all_unique_positions():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")

    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.2924">def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.p

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    for p in c.all_unique_positions():
        if p.isDirty()and not p.isMarked():
            s = p.b
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")

    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.2925">def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    c.endEditing()
    while p:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    c.redraw_after_icons_changed()

</t>
<t tx="ekr.20031218072017.2926">def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.p
    if not p: return

    c.endEditing()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    c.redraw_after_icons_changed()

</t>
<t tx="ekr.20031218072017.2928">def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    c.endEditing()
    undoType = g.choose(p.isMarked(),'Unmark','Mark')
    bunch = u.beforeMark(p,undoType)
    if p.isMarked():
        c.clearMarked(p)
    else:
        c.setMarked(p)
    dirtyVnodeList = p.setDirty()
    c.setChanged(True)
    u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.2929">def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.p
    if not current: return

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in current.children():
        if not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.2930">def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.p
    if not current: return

    c.endEditing()
    u.beforeChangeGroup(current,undoType)
    changed = False
    for p in c.all_unique_positions():
        if p.isMarked():
            bunch = u.beforeMark(p,undoType)
            # c.clearMarked(p) # Very slow: calls a hook.
            p.v.clearMarked()
            p.v.setDirty()
            u.afterMark(p,undoType,bunch)
            changed = True
    dirtyVnodeList = [p.v for p in c.all_unique_positions() if p.v.isDirty()]
    if changed:
        g.doHook("clear-all-marks",c=c,p=p,v=p)
        c.setChanged(True)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)

    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.2931"></t>
<t tx="ekr.20031218072017.2932">def openPythonWindow (self,event=None):

    '''Open Python's Idle debugger in a separate process.'''

    idlelib_path = imp.find_module('idlelib')[1]
    idle = g.os_path_join(idlelib_path,'idle.py')
    args = [sys.executable, idle ]

    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, sys.executable, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
</t>
<t tx="ekr.20031218072017.2938"></t>
<t tx="ekr.20031218072017.2939">def about (self,event=None):

    '''Bring up an About Leo Dialog.'''

    c = self

    # Don't use triple-quoted strings or continued strings here.
    # Doing so would add unwanted leading tabs.
    version = g.app.signon + '\n\n'
    theCopyright = (
        "Copyright 1999-2010 by Edward K. Ream\n" +
        "All Rights Reserved\n" +
        "Leo is distributed under the MIT License")
    url = "http://webpages.charter.net/edreamleo/front.html"
    email = "edreamleo@gmail.com"

    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
</t>
<t tx="ekr.20031218072017.2940">def leoDocumentation (self,event=None):

    '''Open LeoDocs.leo in a new Leo window.'''

    c = self ; name = "LeoDocs.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found:",name)
</t>
<t tx="ekr.20031218072017.2941">def leoHome (self,event=None):

    '''Open Leo's Home page in a web browser.'''

    import webbrowser

    url = "http://webpages.charter.net/edreamleo/front.html"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found:",url)
</t>
<t tx="ekr.20031218072017.2942">def leoTutorial (self,event=None):

    '''Open Leo's online tutorial in a web browser.'''

    import webbrowser

    if 1: # new url
        url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
    else:
        url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found:",url)
</t>
<t tx="ekr.20031218072017.2943">def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeLeoDir = g.app.homeLeoDir # was homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeLeoDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeLeoDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"\nor",homeLeoDir)
</t>
<t tx="ekr.20031218072017.2945"></t>
<t tx="ekr.20031218072017.2946">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.p
    inAtIgnoreRange = p.inAtIgnoreRange()

    # g.trace("p,parent,n:",p.h,parent.h,n)
    clone = p.clone() # Creates clone &amp; dependents, does not set undo.
    if (
        not c.checkDrag(p,parent) or
        not c.checkMoveWithParentWithWarning(clone,parent,True)
    ):
        clone.doDelete(newNode=p) # Destroys clone and makes p the current node.
        c.selectPosition(p) # Also sets root position.
        return
    c.endEditing()
    undoData = u.beforeInsertNode(current)
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    clone.moveToNthChildOf(parent,n)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(clone)
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20031218072017.2947">def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.p
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,parent): return
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.endEditing()
    undoData = u.beforeMoveNode(current)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveToNthChildOf(parent,n)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw(p)
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20031218072017.2948">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.p

    clone = p.clone() # Creates clone.  Does not set undo.
    if c.checkDrag(p,after) and c.checkMoveWithParentWithWarning(clone,after.parent(),True):
        inAtIgnoreRange = clone.inAtIgnoreRange()
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveAfter(after)
        if inAtIgnoreRange and not clone.inAtIgnoreRange():
            # The moved node have just become newly unignored.
            dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        p = clone
    else:
        # g.trace("invalid clone drag")
        clone.doDelete(newNode=p)

    c.redraw(p)
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20031218072017.2949"></t>
<t tx="ekr.20031218072017.2955"></t>
<t tx="ekr.20031218072017.2956">def canContractAllHeadlines (self):

    c = self

    for p in c.all_unique_positions():
        if p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2957">def canContractAllSubheads (self):

    c = self ; current = c.p

    for p in current.subtree():
        if p != current and p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2958">def canContractParent (self):

    c = self
    return c.p.parent()
</t>
<t tx="ekr.20031218072017.2959">def canContractSubheads (self):

    c = self ; current = c.p

    for child in current.children():
        if child.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2960">def canDeleteHeadline (self):

    c = self ; p = c.p

    if c.hoistStack:
        bunch = c.hoistStack[0]
        if p == bunch.p: return False

    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
</t>
<t tx="ekr.20031218072017.2961">def canDemote (self):

    c = self
    return c.p.hasNext()
</t>
<t tx="ekr.20031218072017.2962">def canExpandAllHeadlines (self):

    c = self

    for p in c.all_unique_positions():
        if not p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2963">def canExpandAllSubheads (self):

    c = self

    for p in c.p.subtree():
        if not p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2964">def canExpandSubheads (self):

    c = self ; current = c.p

    for p in current.children():
        if p != current and not p.isExpanded():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2965">def canFindMatchingBracket (self):

    c = self ; brackets = "()[]{}"
    body = c.frame.body
    s = body.getAllText()
    ins = body.getInsertPoint()
    c1 = 0 &lt;= ins   &lt; len(s) and s[ins] or ''
    c2 = 0 &lt;= ins-1 &lt; len(s) and s[ins-1] or ''

    return (c1 and c1 in brackets) or (c2 and c2 in brackets)
</t>
<t tx="ekr.20031218072017.2966">def canGoToNextDirtyHeadline (self):

    c = self ; current = c.p

    for p in c.all_unique_positions():
        if p != current and p.isDirty():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2967">def canGoToNextMarkedHeadline (self):

    c = self ; current = c.p

    for p in c.all_unique_positions():
        if p != current and p.isMarked():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2968">def canMarkChangedHeadlines (self):

    c = self

    for p in c.all_unique_positions():
        if p.isDirty():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2969">def canMarkChangedRoots (self):

    c = self

    for p in c.all_unique_positions():
        if p.isDirty and p.isAnyAtFileNode():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2970">def canMoveOutlineDown (self):

    c = self ; current = c.p

    return current and current.visNext(c)
</t>
<t tx="ekr.20031218072017.2971">def canMoveOutlineLeft (self):

    c = self ; p = c.p

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if p and p.hasParent():
            p.moveToParent()
            return p != bunch.p and bunch.p.isAncestorOf(p)
        else:
            return False
    else:
        return p and p.hasParent()
</t>
<t tx="ekr.20031218072017.2972">def canMoveOutlineRight (self):

    c = self ; p = c.p

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return p and p.hasBack() and p != bunch.p
    else:
        return p and p.hasBack()
</t>
<t tx="ekr.20031218072017.2973">def canMoveOutlineUp (self):

    c = self ; current = c.p

    visBack = current and current.visBack(c)

    if not visBack:
        return False
    elif visBack.visBack(c):
        return True
    elif c.hoistStack:
        limit,limitIsVisible = c.visLimit()
        if limitIsVisible: # A hoist
            return current != limit
        else: # A chapter.
            return current != limit.firstChild()
    else:
        return current != c.rootPosition()
</t>
<t tx="ekr.20031218072017.2974">def canPasteOutline (self,s=None):

    c = self
    if s == None:
        s = g.app.gui.getTextFromClipboard()
    if not s:
        return False

    # g.trace(s)
    if g.match(s,0,g.app.prolog_prefix_string):
        return True
    elif len(s) &gt; 0:
        return c.importCommands.stringIsValidMoreFile(s)
    else:
        return False
</t>
<t tx="ekr.20031218072017.2975">def canPromote (self):

    c = self ; v = c.currentVnode()
    return v and v.hasChildren()
</t>
<t tx="ekr.20031218072017.2976">def canRevert (self):

    # c.mFileName will be "untitled" for unsaved files.
    c = self
    return (c.frame and c.mFileName and c.isChanged())
</t>
<t tx="ekr.20031218072017.2977">def canSelectThreadBack (self):
    c = self ; p = c.p
    return p.hasThreadBack()

def canSelectThreadNext (self):
    c = self ; p = c.p
    return p.hasThreadNext()

def canSelectVisBack (self):
    c = self ; p = c.p
    return p.visBack(c)

def canSelectVisNext (self):
    c = self ; p = c.p
    return p.visNext(c)
</t>
<t tx="ekr.20031218072017.2978">def canShiftBodyLeft (self):

    c = self ; body = c.frame.body
    return body and body.getAllText()

canShiftBodyRight = canShiftBodyLeft
</t>
<t tx="ekr.20031218072017.2979">def canSortChildren (self):

    c = self ; p = c.p
    return p and p.hasChildren()

def canSortSiblings (self):

    c = self ; p = c.p
    return p and (p.hasNext() or p.hasBack())
</t>
<t tx="ekr.20031218072017.2980">def canUndo (self):

    c = self
    return c.undoer.canUndo()

def canRedo (self):

    c = self
    return c.undoer.canRedo()
</t>
<t tx="ekr.20031218072017.2981">def canUnmarkAll (self):

    c = self

    for p in c.all_unique_positions():
        if p.isMarked():
            return True

    return False
</t>
<t tx="ekr.20031218072017.2982"></t>
<t tx="ekr.20031218072017.2984">def clearAllMarked (self):

    c = self

    for p in c.all_unique_positions():
        p.v.clearMarked()
</t>
<t tx="ekr.20031218072017.2985">def clearAllVisited (self):

    c = self

    for p in c.all_unique_positions():
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20031218072017.2986"># Compatibility with scripts

def fileName (self):

    return self.mFileName

def relativeFileName (self):

    return self.mRelativeFileName or self.mFileName

def shortFileName (self):

    return g.shortFileName(self.mFileName)

shortFilename = shortFileName
</t>
<t tx="ekr.20031218072017.2987">def isChanged (self):

    return self.changed
</t>
<t tx="ekr.20031218072017.2989">def setChanged (self,changedFlag):

    trace = False and not g.unitTesting
    c = self
    if not c.frame: return
    c.changed = changedFlag
    if c.loading: return # don't update while loading.

    if trace: g.trace(changedFlag,g.callers())

    # Clear all dirty bits _before_ setting the caption.
    if not changedFlag:
        for v in c.all_unique_nodes():
            if v.isDirty():
                v.clearDirty()

    if g.app.qt_use_tabs and hasattr(c.frame,'top'):
        c.frame.top.master.setChanged(c,changedFlag)

    s = c.frame.getTitle()
    if len(s) &gt; 2:
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
</t>
<t tx="ekr.20031218072017.2990"></t>
<t tx="ekr.20031218072017.2991"># Sets the focus to p and edits p.

def redrawAndEdit(self,p,selectAll=False,selection=None,keepMinibuffer=False):

    '''Redraw the screen and start editing the headline at position p.'''

    c = self ; k = c.k

    c.redraw(p)

    if p:
        # This should request focus.
        c.frame.tree.editLabel(p,selectAll=selectAll,selection=selection)

        if k and not keepMinibuffer:
            # Setting the input state has no effect on focus.
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            # This *does* affect focus.
            k.showStateAndMode()

    # Update the focus immediately.
    if not keepMinibuffer:
        c.outerUpdate()
</t>
<t tx="ekr.20031218072017.2992"># Ends the editing in the outline.

def endEditing(self):

    c = self ; k = c.k

    p = c.p

    if p:
        c.frame.tree.endEditLabel()
        c.frame.tree.setSelectedLabelState(p)

    # The following code would be wrong; c.endEditing is a utility method.
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.bodyCtrl)
</t>
<t tx="ekr.20031218072017.2993">def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2994">def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.p
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2995"># This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2996">def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
</t>
<t tx="ekr.20031218072017.2997">def selectPosition(self,p):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.h,g.callers())

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20031218072017.2999">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="ekr.20031218072017.3000">def updateSyntaxColorer(self,v):

    self.frame.body.updateSyntaxColorer(v)
</t>
<t tx="ekr.20031218072017.3018">@language python
@tabwidth -4
@pagewidth 70

&lt;&lt; imports &gt;&gt;

&lt;&lt; define exception classes &gt;&gt;

if sys.platform != 'cli':
    &lt;&lt; define sax classes &gt;&gt;

class baseFileCommands:
    """A base class for the fileCommands subcommander."""
    @others

class fileCommands (baseFileCommands):
    """A class creating the fileCommands subcommander."""
    pass
</t>
<t tx="ekr.20031218072017.3019">def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a',
        'descendentTnodeUnknownAttributes',
        'descendentVnodeUnknownAttributes', # New in Leo 4.5.
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )

    self.checkOutlineBeforeSave = c.config.getBool(
        'check_outline_before_save',default=False)

    self.initIvars()
</t>
<t tx="ekr.20031218072017.3020"></t>
<t tx="ekr.20031218072017.3029">def readAtFileNodes (self):

    c = self.c ; p = c.p

    c.endEditing()
    c.atFileCommands.readAll(p,partialFlag=True)
    c.redraw()

    # Force an update of the body pane.
    c.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
</t>
<t tx="ekr.20031218072017.3030">def readOutlineOnly (self,theFile,fileName):

    c = self.c

    &lt;&lt; Set the default directory &gt;&gt;
    ok, ratio = self.getLeoFile(theFile,fileName,readAtFileNodesFlag=False)
    c.redraw()

    c.frame.deiconify()
    junk,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)

    return ok
</t>
<t tx="ekr.20031218072017.3032"></t>
<t tx="ekr.20031218072017.3035">def putFindSettings (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("&lt;find_panel_settings/&gt;")
    self.put_nl()
</t>
<t tx="ekr.20031218072017.3037"># Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.mFileName
    if use_db:
        if trace: g.trace(c.mFileName)
        c.cacher.setCachedGlobalsElement(c.mFileName)

    # Always put positions, to trigger sax methods.
    self.put("&lt;globals")
    &lt;&lt; put the body/outline ratios &gt;&gt;
    self.put("&gt;") ; self.put_nl()
    &lt;&lt; put the position of this frame &gt;&gt;
    &lt;&lt; put the position of the log window &gt;&gt;
    self.put("&lt;/globals&gt;") ; self.put_nl()
</t>
<t tx="ekr.20031218072017.3038">self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
</t>
<t tx="ekr.20031218072017.3039"># New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("&lt;global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/&gt;") ; self.put_nl()
</t>
<t tx="ekr.20031218072017.3040">top = left = height = width = 0 # no longer used

self.put_tab()
self.put("&lt;global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/&gt;") ; self.put_nl()
</t>
<t tx="ekr.20031218072017.3041">def putHeader (self):

    tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

    if 1: # For compatibility with versions before Leo 4.5.
        self.put("&lt;leo_header")
        self.put(" file_format=") ; self.put_in_dquotes("2")
        self.put(" tnodes=") ; self.put_in_dquotes(str(tnodes))
        self.put(" max_tnode_index=") ; self.put_in_dquotes(str(0))
        self.put(" clone_windows=") ; self.put_in_dquotes(str(clone_windows))
        self.put("/&gt;") ; self.put_nl()

    else:
        self.put('&lt;leo_header file_format="2"/&gt;\n')
</t>
<t tx="ekr.20031218072017.3042">def putPostlog (self):

    self.put("&lt;/leo_file&gt;") ; self.put_nl()
</t>
<t tx="ekr.20031218072017.3043">def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        c.cacher.save(fileName,changeName=True)
        # Disable path-changed messages in writeAllHelper.
        c.ignoreChangedPaths = True
        try:
            if self.write_Leo_file(fileName,outlineOnlyFlag=False):
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
        finally:
            c.ignoreChangedPaths = True

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20031218072017.3044">def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        c.cacher.save(fileName,changeName=False)
        # Disable path-changed messages in writeAllHelper.
        c.ignoreChangedPaths = True
        try:
            self.write_Leo_file(fileName,outlineOnlyFlag=False)
        finally:
            c.ignoreChangedPaths = False
        self.putSavedMessage(fileName)

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20031218072017.3045">def setDefaultDirectoryForNewFiles (self,fileName):

    """Set c.openDirectory for new files for the benefit of leoAtFile.scanAllDirectives."""

    c = self.c

    if not c.openDirectory:
        theDir = g.os_path_dirname(fileName)
        if theDir and g.os_path_isabs(theDir) and g.os_path_exists(theDir):
            c.openDirectory = c.frame.openDirectory = theDir
</t>
<t tx="ekr.20031218072017.3046">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    if self.checkOutlineBeforeSave and not self.checkOutline():
        return False
    if not outlineOnlyFlag or toOPML:
        g.app.config.writeRecentFilesFile(c)
        self.writeAllAtFileNodesHelper() # Ignore any errors.
    if self.isReadOnly(fileName):
        return False
    try:
        self.putCount = 0 ; self.toString = toString
        if toString:
            ok = self.writeToStringHelper(fileName)
        else:
            ok = self.writeToFileHelper(fileName,toOPML)
    finally:
        self.outputFile = None
        self.toString = False
    return ok

write_LEO_file = write_Leo_file # For compatibility with old plugins.
</t>
<t tx="ekr.20031218072017.3047">def createBackupFile (self,fileName):

    '''
        Create a closed backup file and copy the file to it,
        but only if the original file exists.
    '''

    c = self.c

    if g.os_path_exists(fileName):
        # backupName = g.os_path_join(g.app.loadDir,fileName+'.bak')

        fd,backupName = tempfile.mkstemp(text=False)
        f = open(fileName,'rb') # rb is essential.
        s = f.read()
        f.close()

        try:
            try:
                os.write(fd,s)
            finally:
                os.close(fd)
            ok = True
        except Exception:
            g.es('exception creating backup file',color='red')
            g.es_exception()
            ok,backupName = False,None

        if not ok and self.read_only:
            g.es("read only",color="red")
    else:
        ok,backupName = True,None

    return ok,backupName
</t>
<t tx="ekr.20031218072017.3050">def writeOutlineOnly (self,event=None):

    '''Write the entire outline without writing any derived files.'''

    c = self.c
    c.endEditing()
    self.write_Leo_file(self.mFileName,outlineOnlyFlag=True)
    g.es('done',color='blue')
</t>
<t tx="ekr.20031218072017.3053">def __init__ (self,c,title=None):

    self.c = c
    self.trace = False

    # g.trace('leoFind',c)

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        &lt;&lt; compute self.title &gt;&gt;

    &lt;&lt; init the gui-independent ivars &gt;&gt;

def init (self,c):
    self.oops()
</t>
<t tx="ekr.20031218072017.3054">self.backwardAttempts = 0
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False
self.re_obj = None

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@
Initializing a wrapped search is tricky. The search() method will fail
if p==wrapPosition and pos &gt;= wrapPos. selectNextPosition() will fail
if p == wrapPosition. We set wrapPos on entry, before the first
search. We set wrapPosition in selectNextPosition after the first
search fails. We also set wrapPosition on exit if the first search
suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
</t>
<t tx="ekr.20031218072017.3055"></t>
<t tx="ekr.20031218072017.3056"># The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20031218072017.3057"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    else:
        self.changeAll()
</t>
<t tx="ekr.20031218072017.3058"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
</t>
<t tx="ekr.20031218072017.3059"># The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20031218072017.3060"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    else:
        self.findAll()
</t>
<t tx="ekr.20031218072017.3061"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20031218072017.3062"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
</t>
<t tx="ekr.20031218072017.3063"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20031218072017.3064"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
</t>
<t tx="ekr.20031218072017.3065"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.p

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20031218072017.3066"># Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20031218072017.3067"></t>
<t tx="ekr.20031218072017.3068">def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
</t>
<t tx="ekr.20031218072017.3069">def changeAll(self):

    # g.trace('leoFind',g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.p
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.p
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw(p)
    self.restore(saveData)
</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl
    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start &gt; end: start,end = end,start
    if start == end:
        g.es("no text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
    if self.in_headline:
        c.frame.tree.onHeadChanged(p,'Change')
    else:
        c.frame.body.onBodyChanged('Change',oldSel=oldSel)

    c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
</t>
<t tx="ekr.20031218072017.3071">def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
</t>
<t tx="ekr.20031218072017.3072">def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec(self.find_text,{},{})
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20031218072017.3073">def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v not in clones:
            # g.trace(self.p.v,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                &lt;&lt; create the found node &gt;&gt;
            clones.append(self.p.v)
            &lt;&lt; create a clone of p under the find node &gt;&gt;

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
</t>
<t tx="ekr.20031218072017.3074">def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found","'%s'" % (self.find_text))
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
</t>
<t tx="ekr.20031218072017.3075"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    if trace: g.trace('entry','p',p and p.h,
        'search_headline',self.search_headline,
        'search_body',self.search_body)

    if not self.search_headline and not self.search_body:
        if trace: g.trace('nothing to search')
        return None, None

    if len(self.find_text) == 0:
        if trace: g.trace('no find text')
        return None, None

    self.errors = 0
    attempts = 0
    self.backwardAttempts = 0

    # New in Leo 4.4.8: precompute the regexp for regexHelper.
    if self.pattern_match:
        try: # Precompile the regexp.
            flags = re.MULTILINE
            if self.ignore_case: flags |= re.IGNORECASE
            # New in Leo 4.5: escape the search text.
            self.re_obj = re.compile(self.find_text,flags)
            # self.re_obj = re.compile(re.escape(self.find_text),flags)
        except Exception:
            g.es('invalid regular expression:',self.find_text,color='blue')
            self.errors += 1 # Abort the search.
            return None,None

    while p:
        pos, newpos = self.search()
        if trace: g.trace('attempt','pos',pos,'p',p.h,'in_headline',self.in_headline)
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            if trace: g.trace('success',pos,newpos)
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            # Bug fix: 2009-5-31.
            # Attempt to switch from headline to body.
            if self.in_headline:
                self.in_headline = False
                self.initNextText()
            else: 
                if trace: g.trace('fail: node only')
                return None,None # We are only searching one node.
        else:
            if trace: g.trace('failed attempt',p)
            attempts += 1
            p = self.p = self.selectNextPosition()

    if trace: g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
</t>
<t tx="ekr.20031218072017.3076">def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
</t>
<t tx="ekr.20031218072017.3077">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    trace = False and not g.unitTesting
    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)

    if trace: g.trace('pos,newpos',pos,newpos)
    if pos == -1:
        if trace: g.trace('** pos is -1',pos,newpos)
        return None,None
    &lt;&lt; fail if we are passed the wrap point &gt;&gt;
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)

    if trace: g.trace('** returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20031218072017.3081"># Selects the next node to be searched.

def selectNextPosition(self):

    trace = False and not g.unitTesting
    c = self.c ; p = self.p

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.h or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
</t>
<t tx="ekr.20031218072017.3082"></t>
<t tx="ekr.20031218072017.3083">def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
</t>
<t tx="ekr.20031218072017.3084"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.p
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
</t>
<t tx="ekr.20031218072017.3085"># Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.h, p.b)
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    c,p = self.c,self.p
    s = g.choose(self.in_headline,p.h, p.b)
    if True:
        tree = c.frame and c.frame.tree
        if tree and hasattr(tree,'killEditing'):
            # g.trace('kill editing before find')
            tree.killEditing()
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print(g.choose(self.reverse,'.','*'),)
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
</t>
<t tx="ekr.20031218072017.3086"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    trace = False
    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            editPosition = c.frame.tree.editPosition()
            focus = c.get_focus()
            # Search headline first.
            self.in_headline = (
                p == editPosition and
                focus != c.frame.body.bodyCtrl)
            if trace: g.trace(
                '** p: %s, editPosition: %s, focus: %s, bodyCtrl: %s' % (
                p and p.h,editPosition,focus, c.frame.body.bodyCtrl))
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20031218072017.3087">def initInteractiveCommands(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl

    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
</t>
<t tx="ekr.20031218072017.3088">def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('','-' * 20,'',self.p.h)
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es('',theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('','-' * 20,'',self.p.h)
        g.es('',line)
        self.p.setVisited()
    else:
        g.es('',line)
</t>
<t tx="ekr.20031218072017.3089"># Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    if p:
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        c.k.showStateAndMode(c.frame.body.bodyCtrl)
    else:
        c.widgetWantsFocusNow(t)
</t>
<t tx="ekr.20031218072017.3090">def save (self):

    c = self.c ; p = self.p

    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)

    if w:
        insert = w.getInsertPoint()
        sel = w.getSelectionRange()
        if len(sel) == 2:
            start,end = sel
        else:
            start,end = None,None
    else:
        insert,start,end = None,None,None

    return (self.in_headline,p,w,insert,start,end)
</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos,showState=True):

    '''Display the result of a successful find operation.'''

    trace = False and not g.unitTesting
    c = self.c ; p = self.p
    if not p:
        return g.trace('can not happen: self.p is None')

    current = c.p
    c.frame.bringToFront() # Needed on the Mac

    # Expand ancestors and set redraw if a redraw is needed.
    redraw1 = not p.isVisible(c)
    if c.sparse_find:
        # Show only the 'sparse' tree when redrawing.
        for p2 in c.p.self_and_parents():
            if p2.isAncestorOf(p):
                break
            p2.contract()
            redraw1 = True # Important bug fix. Was redraw = True.

    redraw2 = c.expandAllAncestors(self.p)
    redraw = redraw1 or redraw2

    # Set state vars.
    # Ensure progress in backwards searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p

    if trace: g.trace('in_headline',self.in_headline)
    if self.in_headline:
        selection = pos,newpos,insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        w = c.frame.body.bodyCtrl
        # This is like the logic in c.selectPosition.
        if redraw:
            c.redraw(p)
        else:
            c.selectPosition(p)
            c.redraw_after_select(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        # g.trace(pos,newpos,insert)
        w.setSelectionRange(pos,newpos,insert=insert)
        w.seeInsertPoint()
        c.outerUpdate()
    return w # Support for isearch.
</t>
<t tx="ekr.20031218072017.3093">@first # -*- coding: utf-8 -*-

"""Global constants, variables and utility functions used throughout Leo."""

@language python
@tabwidth -4
@pagewidth 70

import sys
isPython3 = sys.version_info &gt;= (3,0,0)
&lt;&lt; imports &gt;&gt;
print('*** isPython3: %s' % isPython3)
&lt;&lt; define globalDirectiveList &gt;&gt;
&lt;&lt; define the nullObject class &gt;&gt;
g = nullObject() # Set early in startup logic to this module.
app = None # The singleton app object.
debug = False # Set early in startup by the --debug command-line option.
unitTesting = False # A synonym for app.unitTesting.
unified_nodes = True # For compatibility with old scripts.

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.
if not enableDB:
    print('** leoGlobals.py: caching disabled')

@others

</t>
<t tx="ekr.20031218072017.3095"></t>
<t tx="ekr.20031218072017.3097"></t>
<t tx="ekr.20031218072017.3098">@ From The Python Cookbook: Often we want to just collect a bunch of
stuff together, naming each item of the bunch; a dictionary's OK for
that, but a small do-nothing class is even handier, and prettier to
use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others,
del some of them, etc:
    if point.squared &gt; threshold:
        point.isok = True
@c

class Bunch (object):

    """A class that represents a colection of things.

    Especially useful for representing a collection of related variables."""

    def __init__(self,**keywords):
        self.__dict__.update (keywords)

    def __repr__(self):
        return self.toString()

    def ivars(self):
        return sorted(self.__dict__)

    def keys(self):
        return sorted(self.__dict__)

    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    # Used by new undo code.
    def __setitem__ (self,key,value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__,key,value)

    def __getitem__ (self,key):
        '''Support aBunch[key]'''
        return operator.getitem(self.__dict__,key)

    def get (self,key,theDefault=None):
        return self.__dict__.get(key,theDefault)

bunch = Bunch
</t>
<t tx="ekr.20031218072017.3099"></t>
<t tx="ekr.20031218072017.3100">@
Important note: this routine need not deal with leading whitespace.
Instead, the caller should simply reduce pageWidth by the width of
leading whitespace wanted, then add that whitespace to the lines
returned here.

The key to this code is the invarient that line never ends in whitespace.
@c

def wrap_lines (lines,pageWidth,firstLineWidth=None):

    """Returns a list of lines, consisting of the input lines wrapped to the given pageWidth."""

    if pageWidth &lt; 10:
        pageWidth = 10

    # First line is special
    if not firstLineWidth:
        firstLineWidth = pageWidth
    if firstLineWidth &lt; 10:
        firstLineWidth = 10
    outputLineWidth = firstLineWidth

    # g.trace(lines)
    result = [] # The lines of the result.
    line = "" # The line being formed.  It never ends in whitespace.
    for s in lines:
        i = 0
        while i &lt; len(s):
            assert(len(line) &lt;= outputLineWidth) # DTHEIN 18-JAN-2004
            j = g.skip_ws(s,i)   # ;   ws = s[i:j]
            k = g.skip_non_ws(s,j) ; word = s[j:k]
            assert(k&gt;i)
            i = k
            # DTHEIN 18-JAN-2004: wrap at exactly the text width, 
            # not one character less
            # 
            wordLen = len(word)
            if len(line) &gt; 0 and wordLen &gt; 0: wordLen += len(" ")
            if wordLen + len(line) &lt;= outputLineWidth:
                if wordLen &gt; 0:
                    &lt;&lt; place blank and word on the present line &gt;&gt;
                else: pass # discard the trailing whitespace.
            else:
                &lt;&lt; place word on a new line &gt;&gt;
    if len(line) &gt; 0:
        result.append(line)
    # g.trace(result)
    return result
</t>
<t tx="ekr.20031218072017.3101">if len(line) == 0:
    # Just add the word to the start of the line.
    line = word
else:
    # Add the word, preceeded by a blank.
    line = " ".join([line,word]) # DTHEIN 18-JAN-2004: better syntax
</t>
<t tx="ekr.20031218072017.3102"># End the previous line.
if len(line) &gt; 0:
    result.append(line)
    outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines

# Discard the whitespace and put the word on a new line.
line = word

# Careful: the word may be longer than pageWidth.
if len(line) &gt; pageWidth: # DTHEIN 18-JAN-2004: line can equal pagewidth
    result.append(line)
    outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
    line = ""
</t>
<t tx="ekr.20031218072017.3103">def computeWindowTitle (fileName):

    if fileName == None:
        return "untitled"
    else:
        path,fn = g.os_path_split(fileName)
        if path:
            title = fn + " in " + path
        else:
            title = fn
        return title
</t>
<t tx="ekr.20031218072017.3104"></t>
<t tx="ekr.20031218072017.3105">def alert(message):

    g.es(message)
    g.app.gui.alert(message)
</t>
<t tx="ekr.20031218072017.3106"># Returns &lt; &lt; s &gt; &gt;

def angleBrackets(s):

    return ( "&lt;&lt;" + s +
        "&gt;&gt;") # must be on a separate line.

virtual_event_name = angleBrackets
</t>
<t tx="ekr.20031218072017.3107">def _callerName (n=1,files=False):

    try: # get the function name from the call stack.
        f1 = sys._getframe(n) # The stack frame, n levels up.
        code1 = f1.f_code # The code object
        name = code1.co_name
        if name == '__init__':
            name = '__init__(%s,line %s)' % (
                g.shortFileName(code1.co_filename),code1.co_firstlineno)
        if files:
            return '%s:%s' % (g.shortFilename(code1.co_filename),name)
        else:
            return name # The code name
    except ValueError:
        return '' # The stack is not deep enough.
    except Exception:
        g.es_exception()
        return '' # "&lt;no caller name&gt;"
</t>
<t tx="ekr.20031218072017.3108"></t>
<t tx="ekr.20031218072017.3109">def dump(s):

    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out
</t>
<t tx="ekr.20031218072017.3110">def es_error (*args,**keys):

    color = keys.get('color')

    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor(None,"log_error_color") or 'red'

    g.es(*args,**keys)


def es_print_error (*args,**keys):

    color = keys.get('color')

    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor(None,"log_error_color") or 'red'

    g.es_print(*args,**keys)
</t>
<t tx="ekr.20031218072017.3111">def es_event_exception (eventName,full=False):

    g.es("exception handling ",eventName,"event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es('',i)

    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
</t>
<t tx="ekr.20031218072017.3112">def es_exception (full=True,c=None,color="red"):

    typ,val,tb = sys.exc_info()

    # val is the second argument to the raise statement.

    if full or g.app.debugSwitch &gt; 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)

    for line in lines:
        g.es_error(line,color=color)

    # if g.app.debugSwitch &gt; 1:
        # import pdb # Be careful: g.pdb may or may not have been defined.
        # pdb.set_trace()

    fileName,n = g.getLastTracebackFileAndLineNumber()

    return fileName,n
</t>
<t tx="ekr.20031218072017.3113">def print_bindings (name,window):

    bindings = window.bind()

    g.pr("\nBindings for", name)
    for b in bindings:
        g.pr(b)
</t>
<t tx="ekr.20031218072017.3114">def printGlobals(message=None):

    # Get the list of globals.
    globs = list(globals())
    globs.sort()

    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    for glob in globs:
        g.pr(glob)
</t>
<t tx="ekr.20031218072017.3115">def printLeoModules(message=None):

    # Create the list.
    mods = []
    for name in sys.modules:
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    mods.sort()
    for m in mods:
        g.pr(m,newline=False)
    g.pr('')
</t>
<t tx="ekr.20031218072017.3116"></t>
<t tx="ekr.20031218072017.3117">def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''

    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
    except Exception:
        g.es('unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
</t>
<t tx="ekr.20031218072017.3118">def ensure_extension (name, ext):

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name # don't add to an empty name.
    elif old_ext and old_ext == ext:
        return name
    else:
        return name + ext
</t>
<t tx="ekr.20031218072017.3119"># This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    trace = False and not g.unitTesting
    testing = trace # True: don't actually make the directories.

    if force:
        create = True # Bug fix: g.app.config will not exist during startup.
    elif c:
        create = c.config and c.config.create_nonexistent_directories
    else:
        create = (g.app and g.app.config and
            g.app.config.create_nonexistent_directories)

    if c: theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    ok = g.os_path_isdir(dir1) and g.os_path_exists(dir1)

    if trace: g.trace('ok',ok,'create',create,'force',force,dir1,g.callers())

    if ok:
        return ok
    elif not force and not create:
        if trace:
            g.trace('did not create: force and create are both false')
        return False

    if trace:
        g.trace('\n',theDir,'\n',g.callers(4))
        # g.trace('c exists: %s force: %s create: %s dir: %s' % (
            # c is not None,force,create,theDir))

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) &gt; 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    if trace: g.trace('paths:',paths)
    for s in paths:
        path = g.os_path_finalize_join(path,s)
        if not g.os_path_exists(path):
            try:
                if testing:
                    g.trace('***making',path)
                else:
                    os.mkdir(path)
                if verbose and not testing and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
</t>
<t tx="ekr.20031218072017.3120">@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim,
while the windows versions force the string to use the Unix convention
of using only "\n". This routine causes the Unix readline to do the
same.
@c

def readlineForceUnixNewline(f):

    s = f.readline()
    if len(s) &gt;= 2 and s[-2] == "\r" and s[-1] == "\n":
        s = s[0:-2] + "\n"
    return s
</t>
<t tx="ekr.20031218072017.3121">class redirectClass:

    """A class to redirect stdout and stderr to Leo's log pane."""

    &lt;&lt; redirectClass methods &gt;&gt;

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

&lt;&lt; define convenience methods for redirecting streams &gt;&gt;

if 0: # Test code: may be executed in the child node.
    &lt;&lt; test code &gt;&gt;
</t>
<t tx="ekr.20031218072017.3122">@others
</t>
<t tx="ekr.20031218072017.3123">import leo.core.leoGlobals as g ; import sys
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leo.core.leoGlobals as g ; import sys
g.redirectStderr()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leo.core.leoGlobals as g ; import sys
g.restoreStderr()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leo.core.leoGlobals as g ; import sys
g.restoreStdout()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leo.core.leoGlobals as g ; import sys
g.redirectStdout()
print &gt;&gt; sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print &gt;&gt; sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
</t>
<t tx="ekr.20031218072017.3124">def sanitize_filename(s):

    """Prepares string s to be a valid file name:

    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
</t>
<t tx="ekr.20031218072017.3125">def shortFileName (fileName):

    return g.os_path_basename(fileName)

shortFilename = shortFileName
</t>
<t tx="ekr.20031218072017.3126">@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class. That
is, it converts the function to a method of the class. The method just added is
available instantly to all existing instances of the class, and to all instances
created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional
name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):

    setattr(theClass,name or f.__name__,f)
    # g.trace(name)
</t>
<t tx="ekr.20031218072017.3127"># Very useful for tracing.

def get_line (s,i):

    nl = ""
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
        nl = "[nl]"
    j = g.find_line_start(s,i)
    k = g.skip_to_end_of_line(s,i)
    return nl + s[j:k]

# Important: getLine is a completely different function.
# getLine = get_line

def get_line_after (s,i):

    nl = ""
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
        nl = "[nl]"
    k = g.skip_to_end_of_line(s,i)
    return nl + s[i:k]

getLineAfter = get_line_after
</t>
<t tx="ekr.20031218072017.3128">def pause (s):

    g.pr(s)

    i = 0 ; n = long(1000) * long(1000)
    while i &lt; n:
        i += 1
</t>
<t tx="ekr.20031218072017.3129">@
Starting with this release, you will see trace statements throughout the code.
The trace function is defined in leoGlobals.py; trace implements much of the
functionality of my Sherlock tracing package. Traces are more convenient than
print statements for two reasons: 1) you don't need explicit trace names and 2)
you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

g.trace(string) prints string if tracing for f has been enabled. For example,
the following statment prints from s[i] to the end of the line if tracing for f
has been enabled.

  j = g.skip_line(s,i) ; g.trace(s[i:j])

g.trace(function) exectutes the function if tracing for f has been enabled. For
example,

  g.trace(self.f2)

You enable and disable tracing by calling g.init_trace(args). Examples:

  g.init_trace("+*")         # enable all traces
  g.init_trace("+a","+b")    # enable traces for a and b
  g.init_trace(("+a","+b"))  # enable traces for a and b
  g.init_trace("-a")         # disable tracing for a
  traces = g.init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint
name" and the second argument is the "tracepoint action" as shown in the
examples above. If tracing for the tracepoint name is enabled, the tracepoint
action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.
For example,

  g.trace_tag("-nocolor", self.disable_color)
</t>
<t tx="ekr.20031218072017.3130"># Called by startup code.
# Args are all the arguments on the command line.

def init_sherlock (args):

    g.init_trace(args,echo=0)
    # g.trace("sys.argv:",sys.argv)
</t>
<t tx="ekr.20031218072017.3131">@
If no args are given we attempt to get them from the "SherlockArgs"
file. If there are still no arguments we trace everything. This
default makes tracing much more useful in Python.
@c

def get_Sherlock_args (args):

    if not args or len(args)==0:
        try:
            fn = g.os_path_join(app.loadDir,"SherlockArgs")
            f = open(fn)
            args = f.readlines()
            f.close()
        except Exception: pass
    elif type(args[0]) == type(("1","2")):
        args = args[0] # strip away the outer tuple.

    # No args means trace everything.
    if not args or len(args)==0: args = ["+*"] 
    # g.pr("get_Sherlock_args:", args)
    return args
</t>
<t tx="ekr.20031218072017.3132">def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]

        if prefix == '?':
            g.pr("trace list:", t)
        elif prefix == '+' and not arg in t:
            t.append(arg.lower())
            if echo:
                g.pr("enabling:", arg)
        elif prefix == '-' and arg in t:
            t.remove(arg.lower())
            if echo:
                g.pr("disabling:", arg)
        else:
            g.pr("ignoring:", prefix + arg)
</t>
<t tx="ekr.20031218072017.3133"></t>
<t tx="ekr.20031218072017.3134">def clear_stats():

    g.trace()

    g.app.statsDict = {}

clearStats = clear_stats
</t>
<t tx="ekr.20031218072017.3135">def print_stats (name=None):

    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.

    g.printDict(g.app.statsDict,tag='statistics at %s' % name)

printStats = print_stats
</t>
<t tx="ekr.20031218072017.3136">def stat (name=None):

    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """

    d = g.app.statsDict

    if name:
        if type(name) != type(""):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.

    # g.trace(name)

    d [name] = 1 + d.get(name,0)
</t>
<t tx="ekr.20031218072017.3137">def getTime():
    return time.clock()

def esDiffTime(message, start):
    delta = time.clock()-start
    g.es('',"%s %6.3f sec." % (message,delta))
    return time.clock()

def printDiffTime(message, start):
    delta = time.clock()-start
    g.pr("%s %6.3f sec." % (message,delta))
    return time.clock()

def timeSince(start):
    return "%6.3f sec." % (time.clock()-start)
</t>
<t tx="ekr.20031218072017.3138">def executeScript (name):

    """Execute a script whose short python file name is given.

    This is called only from the scripts_menu plugin."""

    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except Exception:
        g.es("exception executing",name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()
</t>
<t tx="ekr.20031218072017.3139"></t>
<t tx="ekr.20031218072017.3140"></t>
<t tx="ekr.20031218072017.3141">def appendToList(out, s):

    for i in s:
        out.append(i)
</t>
<t tx="ekr.20031218072017.3142">def flattenList (theList):

    result = []
    for item in theList:
        if type(item) == types.ListType:
            result.extend(g.flattenList(item))
        else:
            result.append(item)
    return result
</t>
<t tx="ekr.20031218072017.3144"># From the Python cookbook.

def makeDict(**keys):

    """Returns a Python dictionary from using the optional keyword arguments."""

    return keys
</t>
<t tx="ekr.20031218072017.3145"># These are guaranteed always to exist for scripts.
</t>
<t tx="ekr.20031218072017.3147">def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20031218072017.3150">def windows():
    return app.windowList
</t>
<t tx="ekr.20031218072017.3151"></t>
<t tx="ekr.20031218072017.3154">def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        &lt;&lt; scan another @root option &gt;&gt;

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    # g.trace(mode,g.callers(3))

    return i,mode
</t>
<t tx="ekr.20031218072017.3155">i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','\n','-'):
    i += 1

if err &gt; -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s,i)
    g.es("unknown option:",z_opt,"in",z_line)
</t>
<t tx="ekr.20031218072017.3156"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    '''Bump the error count in the tangle command.'''

    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es('',s)
</t>
<t tx="ekr.20031218072017.3157"># A quick and dirty sscanf.  Understands only %s and %d.

def scanf (s,pat):
    count = pat.count("%s") + pat.count("%d")
    pat = pat.replace("%s","(\S+)")
    pat = pat.replace("%d","(\d+)")
    parts = re.split(pat,s)
    result = []
    for part in parts:
        if len(part) &gt; 0 and len(result) &lt; count:
            result.append(part)
    # g.trace("scanf returns:",result)
    return result

if 0: # testing
    g.scanf("1.0","%d.%d",)
</t>
<t tx="ekr.20031218072017.3158">@ These scanners all call g.scanError() directly or indirectly, so they
will call g.es if they find an error. g.scanError() also bumps
c.tangleCommands.errors, which is harmless if we aren't tangling, and
useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20031218072017.3159"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)

    k = s.find("*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2
</t>
<t tx="ekr.20031218072017.3160">@ This code is called only from the import logic, so we are allowed to
try some tricks. In particular, we assume all braces are matched in
#if blocks.
@c

def skip_braces(s,i):

    '''Skips from the opening to the matching brace.

    If no matching is found i is set to len(s)'''

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3161">@ 08-SEP-2002 DTHEIN: Added for PHP import support
Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, and only for PHP imports.
@c

def skip_php_braces(s,i):

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i + 1
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"&lt;&lt;&lt;"): i = g.skip_heredoc_string(s,i)
        elif g.match(s,i,'//') or g.match(s,i,'#'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3162">def skip_parens(s,i):

    '''Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s)'''

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3163">def skip_pascal_begin_end(s,i):

    '''Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try.'''

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3164"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):

    j = i
    assert(g.match(s,i,"(*"))
    i = s.find("*)",i)
    if i &gt; -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)
</t>
<t tx="ekr.20031218072017.3165">def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i
</t>
<t tx="ekr.20031218072017.3166">@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

  &lt;&lt;&lt;EOS
  This is my string.
  It is mine. I own it.
  No one else has it.
  EOS

It begins with &lt;&lt;&lt; plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.

@c
def skip_heredoc_string(s,i):

    j = i
    assert(g.match(s,i,"&lt;&lt;&lt;"))
    m = re.match("\&lt;\&lt;\&lt;([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
    if (None == m):
        i += 3
        return i

    # 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
    delim = m.group(1) + '\n' 

    i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: look after \n, not before
    n = len(s)
    while i &lt; n and not g.match(s,i,delim):
        i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: move past \n

    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif g.match(s,i,delim):
        i += len(delim)
    return i
</t>
<t tx="ekr.20031218072017.3167"># Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i):
            if g.escaped(s,i): i = g.skip_nl(s,i)
            else: break
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3168"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):

    start_line = g.get_line(s,i) # used for error messages.
    # g.trace(start_line)

    assert(
        g.match_word(s,i,"#if") or
        g.match_word(s,i,"#ifdef") or
        g.match_word(s,i,"#ifndef"))

    i = g.skip_line(s,i)
    i,delta1 = g.skip_pp_part(s,i)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#else"):
        i = g.skip_line(s,i)
        i = g.skip_ws(s,i)
        i,delta2 = g.skip_pp_part(s,i)
        if delta1 != delta2:
            g.es("#if and #else parts have different braces:",start_line)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#endif"):
        i = g.skip_line(s,i)
    else:
        g.es("no matching #endif:",start_line)

    # g.trace(delta1,start_line)
    return i,delta1
</t>
<t tx="ekr.20031218072017.3169"># Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s,i):

    # g.trace(g.get_line(s,i))

    delta = 0
    while i &lt; len(s):
        c = s[i]
        if 0:
            if c == '\n':
                g.trace(delta,g.get_line(s,i))
        if g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta1 = g.skip_pp_if(s,i)
            delta += delta1
        elif g.match_word(s,i,"#else") or g.match_word(s,i,"#endif"):
            return i,delta
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif c == '{':
            delta += 1 ; i += 1
        elif c == '}':
            delta -= 1 ; i += 1
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i,delta
</t>
<t tx="ekr.20031218072017.3170">def skip_python_string(s,i,verbose=True):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = s.find(delim,i)
        if k &gt; -1: return k+3
        if verbose:
            g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)
</t>
<t tx="ekr.20031218072017.3171"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3172">def skip_typedef(s,i):

    n = len(s)
    while i &lt; n and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i)
        i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        i = g.skip_to_semicolon(s,i)
    return i
</t>
<t tx="ekr.20031218072017.3173"></t>
<t tx="ekr.20031218072017.3174"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 &gt;= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
</t>
<t tx="ekr.20031218072017.3175">def find_line_start(s,i):

    if i &lt; 0:
        return 0 # New in Leo 4.4.5: add this defensive code.

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = s.rfind('\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
</t>
<t tx="ekr.20031218072017.3176">def find_on_line(s,i,pattern):

    j = s.find('\n',i)
    if j == -1: j = len(s)
    k = s.find(pattern,i,j)
    return k
</t>
<t tx="ekr.20031218072017.3177">def is_c_id(ch):

    return g.isWordChar(ch)

</t>
<t tx="ekr.20031218072017.3178">def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')
</t>
<t tx="ekr.20031218072017.3179"># We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    '''Return True if the body text contains the @ directive.'''

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
</t>
<t tx="ekr.20031218072017.3180">def is_ws(c):

    return c == '\t' or c == ' '

def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i &lt; len(s) and g.is_ws(s[i]))
</t>
<t tx="ekr.20031218072017.3181"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and s.find(pattern,i,i+len(pattern)) == i
</t>
<t tx="ekr.20031218072017.3182">def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
</t>
<t tx="ekr.20031218072017.3183">def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False

    return s1.lower() == s2.lower()
</t>
<t tx="ekr.20031218072017.3184">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20031218072017.3185"># This routine differs from skip_ws_and_nl in that
# it does not advance over whitespace at the start
# of a non-empty or non-nl terminated line
def skip_blank_lines(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
</t>
<t tx="ekr.20031218072017.3186">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3187">@ These methods skip to the next newline, regardless of whether the
newline may be preceeded by a backslash. Consequently, they should be
used only when we know that we are not in a preprocessor directive or
string.
@c

def skip_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i &gt;= len(s): return len(s)
    if i &lt;= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
</t>
<t tx="ekr.20031218072017.3188">def skip_long(s,i):

    '''Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.'''

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in '+-'):
        return i, None
    j = i
    if s[i] in '+-': # Allow sign before the first digit
        i +=1
    while i &lt; n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except Exception:
        return i,None
</t>
<t tx="ekr.20031218072017.3189">def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):

    '''Skip from the opening delim to the matching delim2.

    Return the index of the matching ')', or -1'''

    level = 0 ; n = len(s)
    # g.trace('delim1/2',repr(delim1),repr(delim2),'i',i,'s[i]',repr(s[i]),'s',repr(s[i-5:i+5]))
    assert(g.match(s,i,delim1))
    if reverse:
        while i &gt;= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i &lt; n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
</t>
<t tx="ekr.20031218072017.3190"># We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    '''Skips a single "logical" end-of-line character.'''

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
</t>
<t tx="ekr.20031218072017.3191">def skip_non_ws (s,i):

    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3192"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = s.find('}',i)
    if i == -1: return len(s)
    else: return k
</t>
<t tx="ekr.20031218072017.3193">def skip_to_char(s,i,ch):

    j = s.find(ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
</t>
<t tx="ekr.20031218072017.3194">def skip_ws(s,i):

    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i

def skip_ws_and_nl(s,i):

    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3195">def splitLines (s):

    '''Split s into lines, preserving the number of lines and
    the endings of all lines, including the last line.'''

    # g.stat()

    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):

    return ''.join(aList)

joinlines = joinLines
</t>
<t tx="ekr.20031218072017.3197"></t>
<t tx="ekr.20031218072017.3198"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width &lt;= 0:
        return ""
    if tab_width &gt; 1:
        tabs   = int(width / tab_width)
        blanks = int(width % tab_width)
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)
</t>
<t tx="ekr.20031218072017.3199"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):

    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            w += 1
    return w
</t>
<t tx="ekr.20031218072017.3200">def get_leading_ws(s):

    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i &lt; n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
</t>
<t tx="ekr.20031218072017.3201"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

    i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
    s = g.computeLeadingWhitespace(width,tab_width) + line[i:]
    return s
</t>
<t tx="ekr.20031218072017.3202"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j &gt; 0:
        s = s[j:]
    return s
</t>
<t tx="ekr.20031218072017.3203"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

    j = len(s)-1
    while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[:j+1]
</t>
<t tx="ekr.20031218072017.3204"># Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

    count = 0
    while count &lt; ws and i &lt; len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i
</t>
<t tx="ekr.20031218072017.3205">def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent), 

    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count
</t>
<t tx="ekr.20031218072017.3206">@first # -*- coding: utf-8 -*-
    # Required so non-ascii characters will be valid in unit tests.

@language python
@tabwidth -4
@pagewidth 70
@encoding utf-8

&lt;&lt; how to write a new importer &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; class scanUtility &gt;&gt;
&lt;&lt; class leoImportCommands &gt;&gt;
&lt;&lt; class baseScannerClass &gt;&gt;
&lt;&lt; scanner classes &gt;&gt;
</t>
<t tx="ekr.20031218072017.3207">def __init__ (self,c):

    self.c = c
    self.default_directory = None # For @path logic.
    self.encoding = 'utf-8'
    self.errors = 0
    self.fileName = None # The original file name, say x.cpp
    self.fileType = None # ".py", ".c", etc.
    self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
    self.output_newline = g.getOutputNewline(c=c) # Value of @bool output_newline
    self.rootLine = "" # Empty or @root + self.fileName
    self.tab_width = c.tab_width # The tab width in effect in the c.currentPosition.
    self.trace = c.config.getBool('trace_import')
    self.treeType = "@file" # None or "@file"
    self.webType = "@noweb" # "cweb" or "noweb"
    self.web_st = [] # noweb symbol table.

    self.createImportDispatchDict()
</t>
<t tx="ekr.20031218072017.3209"></t>
<t tx="ekr.20031218072017.3210">def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body

    self.default_directory = g.setDefaultDirectory(c,parent,importing=False)
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node.
        # Important: this often sets the bit in the wrong node:
        # The caller may have to set the bit in the "real" root node.
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
</t>
<t tx="ekr.20031218072017.3212">def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw(current)
</t>
<t tx="ekr.20031218072017.3213">@ The two filenames have a common prefix everything before the last
period is the same. For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
</t>
<t tx="ekr.20031218072017.3214"></t>
<t tx="ekr.20031218072017.3215"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,first_p):
    s = s.replace("\r","")
    strings = s.split("\n")
    return self.convertMoreStringsToOutlineAfter(strings,first_p)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,first_p):

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    firstLevel, junk = self.moreHeadlineLevel(strings[0])
    lastLevel = -1 ; theRoot = last_p = None
    index = 0
    while index &lt; len(strings):
        progress = index
        s = strings[index]
        level,junk = self.moreHeadlineLevel(s)
        level -= firstLevel
        if level &gt;= 0:
            &lt;&lt; Link a new position p into the outline &gt;&gt;
            &lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
            &lt;&lt; Count the number of following body lines &gt;&gt;
            &lt;&lt; Add the lines to the body text of p &gt;&gt;
            p.setDirty()
        else: index += 1
        assert progress &lt; index
    if theRoot:
        theRoot.setDirty()
        c.setChanged(True)
    c.redraw()

    return theRoot
</t>
<t tx="ekr.20031218072017.3216">assert(level &gt;= 0)
if not last_p:
    # g.trace(first_p)
    theRoot = p = first_p.insertAfter()
elif level == lastLevel:
    p = last_p.insertAfter()
elif level == lastLevel + 1:
    p = last_p.insertAsNthChild(0)
else:
    assert(level &lt; lastLevel)
    while level &lt; lastLevel:
        lastLevel -= 1
        last_p = last_p.parent()
        assert(last_p)
        assert(lastLevel &gt;= 0)
    p = last_p.insertAfter()
last_p = p
lastLevel = level
</t>
<t tx="ekr.20031218072017.3217">j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

p.initHeadString(s[j:])
</t>
<t tx="ekr.20031218072017.3218">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level &gt;= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
</t>
<t tx="ekr.20031218072017.3219">if bodyLines &gt; 0:
    body = ""
    n = index - bodyLines
    while n &lt; index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    p.setBodyString(body)
</t>
<t tx="ekr.20031218072017.3220">def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.p
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    s,e = g.readFileIntoString(fileName)
    if s is None: return ''
    s = s.replace('\r','') # Fixes bug 626101.
    array = s.split("\n")

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.redrawAndEdit(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es("not a valid MORE file",fileName)
</t>
<t tx="ekr.20031218072017.3222"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
</t>
<t tx="ekr.20031218072017.3223"># Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = s.replace("\r","")
    strings = s.split("\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) &lt; 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i &lt; len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level &gt; 0:
            if level &lt; level1 or level &gt; lastLevel + 1:
                return False # improper level.
            elif level &gt; lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
</t>
<t tx="ekr.20031218072017.3224"></t>
<t tx="ekr.20031218072017.3225">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        self.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
</t>
<t tx="ekr.20031218072017.3226">def importWebCommand (self,files,webType):

    c = self.c ; current = c.p
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    for fileName in files:
        g.setGlobalOpenDir(fileName)
        p = self.createOutlineFromWeb(fileName,current)
        p.contract()
        p.setDirty()
        c.setChanged(True)

    c.redraw(current)
</t>
<t tx="ekr.20031218072017.3227">def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i &lt; k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
</t>
<t tx="ekr.20031218072017.3228">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        &lt;&lt; scan cweb body for headline &gt;&gt;
    else:
        &lt;&lt; scan noweb body for headline &gt;&gt;
    return "@" # default.
</t>
<t tx="ekr.20031218072017.3229">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @&lt;.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i &lt; len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@&lt;"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@&gt;")
        if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20031218072017.3230">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"&lt;&lt;"):
        k = g.find_on_line(s,i,"&gt;&gt;=")
        if k &gt; -1:
            ref = s[i:k+2]
            name = s[i+2:k].strip()
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20031218072017.3231">def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

    s,e = g.readFileIntoString(fileName)
    if s is None: return

    &lt;&lt; Create a symbol table of all section names &gt;&gt;
    &lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
    while i &lt; len(s):
        outer_progress = i
        &lt;&lt; Create a node for the next module &gt;&gt;
        assert(i &gt; outer_progress)
</t>
<t tx="ekr.20031218072017.3232">i = 0 ; self.web_st = []

while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i &gt; progress)

# g.trace(self.cstDump())
</t>
<t tx="ekr.20031218072017.3233">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i &gt; progress)

j = g.skip_ws(s,0)
if j &lt; i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i &gt; progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
</t>
<t tx="ekr.20031218072017.3234">if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
    &lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i &gt; progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20031218072017.3235">if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i &gt; progress)
    i = g.skip_ws_and_nl(s,i)

while i &lt; len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i &gt; progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i &lt; len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i &gt; progress)
</t>
<t tx="ekr.20031218072017.3236"></t>
<t tx="ekr.20031218072017.3237"># We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = s.lower()

    s = s.replace("\t"," ").replace("\r","")
    s = s.replace("\n"," ").replace("  "," ")

    return s.strip()
</t>
<t tx="ekr.20031218072017.3238">def cstDump (self):

    s = "Web Symbol Table...\n\n"

    for name in sorted(self.web_st):
        s += name + "\n"
    return s
</t>
<t tx="ekr.20031218072017.3239"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = s.rstrip()
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if name.lower() == lower:
            return
    self.web_st.append(upper)
</t>
<t tx="ekr.20031218072017.3240"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = target.strip()
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget).strip()
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es('',"****** %s" % (target),"is also a prefix of",s)
            else:
                found = True ; result = s
                # g.es("replacing",target,"with",s)
    return result
</t>
<t tx="ekr.20031218072017.3241"># All these classes are subclasses of baseScannerClass.

@others
</t>
<t tx="ekr.20031218072017.3289"></t>
<t tx="ekr.20031218072017.329">@nocolor

@all
</t>
<t tx="ekr.20031218072017.3290"># Headlines not containing a section reference are ignored in noweb and generate index index in cweb.

def convertCodePartToWeb (self,s,i,v,result):

    # g.trace(g.get_line(s,i))
    c = self.c ; nl = self.output_newline
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
    h = v.headString().strip()
    &lt;&lt; put v's headline ref in head_ref &gt;&gt;
    &lt;&lt; put name following @root or @file in file_name &gt;&gt;
    if g.match_word(s,i,"@root"):
        i = g.skip_line(s,i)
        &lt;&lt; append ref to file_name &gt;&gt;
    elif g.match_word(s,i,"@c") or g.match_word(s,i,"@code"):
        i = g.skip_line(s,i)
        &lt;&lt; append head_ref &gt;&gt;
    elif g.match_word(h,0,"@file"):
        # Only do this if nothing else matches.
        &lt;&lt; append ref to file_name &gt;&gt;
        i = g.skip_line(s,i) # 4/28/02
    else:
        &lt;&lt; append head_ref &gt;&gt;
    i,result = self.copyPart(s,i,result)
    return i, result.strip() + nl

@ %defs a b c
</t>
<t tx="ekr.20031218072017.3291">@ We look for either noweb or cweb brackets. head_ref does not include these brackets.
@c

head_ref = None
j = 0
if g.match(h,j,"&lt;&lt;"):
    k = h.find("&gt;&gt;",j)
elif g.match(h,j,"&lt;@"):
    k = h.find("@&gt;",j)
else:
    k = -1

if k &gt; -1:
    head_ref = h[j+2:k].strip()
    if len(head_ref) == 0:
        head_ref = None
</t>
<t tx="ekr.20031218072017.3292">if g.match(h,0,"@file") or g.match(h,0,"@root"):
    line = h[5:].strip()
    &lt;&lt; set file_name &gt;&gt;
else:
    file_name = line = None
</t>
<t tx="ekr.20031218072017.3293"># set j &amp; k so line[j:k] is the file name.
# g.trace(line)

if g.match(line,0,"&lt;"):
    j = 1 ; k = line.find("&gt;",1)
elif g.match(line,0,'"'):
    j = 1 ; k = line.find('"',1)
else:
    j = 0 ; k = line.find(" ",0)
if k == -1:
    k = len(line)

file_name = line[j:k].strip()
if file_name and len(file_name) == 0:
    file_name = None
</t>
<t tx="ekr.20031218072017.3294">if self.webType == "cweb":
    if not file_name:
        result += "@&lt;root@&gt;=" + nl
    else:
        result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
else:
    if not file_name:
        file_name = "*"
    result += lb + file_name + rb + "=" + nl
</t>
<t tx="ekr.20031218072017.3295">if self.webType == "cweb":
    if not head_ref:
        result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
        result += "@c" + nl # @c denotes a new section.
    else: 
        escaped_head_ref = head_ref.replace("@","@@")
        result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
else:
    if not head_ref:
        if v == c.currentVnode():
            head_ref = g.choose(file_name,file_name,"*")
        else:
            head_ref = "@others"

    result += lb + head_ref + rb + "=" + nl
</t>
<t tx="ekr.20031218072017.3296">def convertDocPartToWeb (self,s,i,result):

    nl = self.output_newline

    # g.trace(g.get_line(s,i))
    if g.match_word(s,i,"@doc"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
        i += 2
    elif g.match(s,i,"@\n"):
        i += 1
    i = g.skip_ws_and_nl(s,i)
    i, result2 = self.copyPart(s,i,"")
    if len(result2) &gt; 0:
        # Break lines after periods.
        result2 = result2.replace(".  ","." + nl)
        result2 = result2.replace(". ","." + nl)
        result += nl+"@"+nl+result2.strip()+nl+nl
    else:
        # All nodes should start with '@', even if the doc part is empty.
        result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
    return i, result
</t>
<t tx="ekr.20031218072017.3297">@ This code converts a vnode to noweb text as follows:

Convert @doc to @
Convert @root or @code to &lt; &lt; name &gt; &gt;=, assuming the headline contains &lt; &lt; name &gt; &gt;
Ignore other directives
Format doc parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertVnodeToWeb (self,v):

    c = self.c
    if not v or not c: return ""
    startInCode = not c.config.at_root_bodies_start_in_doc_mode
    nl = self.output_newline
    s = v.b
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    i = 0 ; result = "" ; docSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i) or g.match_word(s,i,"@doc"):
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        elif (g.match_word(s,i,"@code") or g.match_word(s,i,"@root") or
            g.match_word(s,i,"@c") or g.match(s,i,lb)):
            &lt;&lt; Supply a missing doc part &gt;&gt;
            i,result = self.convertCodePartToWeb(s,i,v,result)
        elif self.treeType == "@file" or startInCode:
            &lt;&lt; Supply a missing doc part &gt;&gt;
            i,result = self.convertCodePartToWeb(s,i,v,result)
        else:
            i,result = self.convertDocPartToWeb(s,i,result)
            docSeen = True
        assert(progress &lt; i)
    result = result.strip()
    if len(result) &gt; 0:
        result += nl
    return result
</t>
<t tx="ekr.20031218072017.3298">if not docSeen:
    docSeen = True
    result += g.choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
</t>
<t tx="ekr.20031218072017.3299"># Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

    # g.trace(g.get_line(s,i))
    lb = g.choose(self.webType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(self.webType=="cweb","@&gt;","&gt;&gt;")
    theType = self.webType
    while i &lt; len(s):
        progress = j = i # We should be at the start of a line here.
        i = g.skip_nl(s,i) ; i = g.skip_ws(s,i)
        if self.isDocStart(s,i):
            return i, result
        if (g.match_word(s,i,"@doc") or
            g.match_word(s,i,"@c") or
            g.match_word(s,i,"@root") or
            g.match_word(s,i,"@code")): # 2/25/03
            return i, result
        elif (g.match(s,i,"&lt;&lt;") and # must be on separate lines.
            g.find_on_line(s,i,"&gt;&gt;=") &gt; -1):
            return i, result
        else:
            # Copy the entire line, escaping '@' and
            # Converting @others to &lt; &lt; @ others &gt; &gt;
            i = g.skip_line(s,j) ; line = s[j:i]
            if theType == "cweb":
                line = line.replace("@","@@")
            else:
                j = g.skip_ws(line,0)
                if g.match(line,j,"@others"):
                    line = line.replace("@others",lb + "@others" + rb)
                elif g.match(line,0,"@"):
                    # Special case: do not escape @ %defs.
                    k = g.skip_ws(line,1)
                    if not g.match(line,k,"%defs"):
                        line = "@" + line
            result += line
        assert(progress &lt; i)
    return i, result.rstrip()
</t>
<t tx="ekr.20031218072017.3300">def removeSentinelsCommand (self,paths,toString=False):

    c = self.c

    self.setEncoding()

    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        path, self.fileName = g.os_path_split(fileName)
        s,e = g.readFileIntoString(fileName,self.encoding)
        if s is None: return
        if e: self.encoding = e
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = c.os_path_finalize_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = c.os_path_finalize_join(path,head+ext+ext2)
        if toString:
            return s
        else:
            &lt;&lt; Write s into newFileName &gt;&gt;
            return None
</t>
<t tx="ekr.20031218072017.3302"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and g.find_on_line(s,i,"@+leo") == -1:
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,junk,start_delim,end_delim,junk = at.parseLeoSentinel(line)
if not valid:
    if not toString: g.es("invalid @+leo sentinel in",fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
</t>
<t tx="ekr.20031218072017.3303"># This does not handle @nonl properly, but that's a nit...

def removeSentinelLines(self,s,line_delim,start_delim,unused_end_delim):

    '''Properly remove all sentinle lines in s.'''

    delim = (line_delim or start_delim or '') + '@'
    verbatim = delim + 'verbatim' ; verbatimFlag = False
    result = [] ; lines = g.splitLines(s)
    for line in lines:
        i = g.skip_ws(line,0)
        if not verbatimFlag and g.match(line,i,delim):
            if g.match(line,i,verbatim):
                verbatimFlag = True # Force the next line to be in the result.
            # g.trace(repr(line))
        else:
            result.append(line)
            verbatimFlag = False
    result = ''.join(result)
    return result
</t>
<t tx="ekr.20031218072017.3305"></t>
<t tx="ekr.20031218072017.3306">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()

    body = g.u(body)
    headline = g.u(headline)

    p.initHeadString(headline)
    if len(body) &gt; 0:
        self.setBodyString(p,body)

    return p
</t>
<t tx="ekr.20031218072017.3307">def error (self,s):
    g.es('',s)
</t>
<t tx="ekr.20031218072017.3309"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20031218072017.3312">def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
    &lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
    &lt;&lt; Replace abbreviated names with full names &gt;&gt;
    s = s.rstrip()
    return s
</t>
<t tx="ekr.20031218072017.3313">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i &lt; len(s):
            progress2 = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
            assert (i &gt; progress2)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = doc.replace("\n"," ")
        doc = doc.replace("\r","")
        doc = doc.strip()
        if doc and len(doc) &gt; 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20031218072017.3314">i = 0
while i &lt; len(s):
    progress = i
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20031218072017.3320">@language python
@tabwidth -4
@pagewidth 70

use_zodb = False

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20031218072017.3341">if use_zodb and ZODB:
    class baseVnode (ZODB.Persistence.Persistent):
        pass
else:
    class baseVnode (object):
        pass

class vnode (baseVnode):
    &lt;&lt; vnode constants &gt;&gt;
    @others
</t>
<t tx="ekr.20031218072017.3342"></t>
<t tx="ekr.20031218072017.3344"># To support ZODB, the code must set v._p_changed = 1 whenever
# v.unknownAttributes or any mutable vnode object changes.

def __init__ (self,context):

    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')

    # Structure data...
    self.children = [] # Ordered list of all children of this node.
    self.parents = [] # Unordered list of all parents of this node.

    # Other essential data...
    self.fileIndex = g.app.nodeIndices.getNewIndex()
        # The immutable file index for this vnode.
        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.iconVal = 0 # The present value of the node's icon.
    self.statusBits = 0 # status bits

    # v.t no longer exists.  All code must now be aware of the one-node world.
    # self.t = self # For compatibility with scripts and plugins.

    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
</t>
<t tx="ekr.20031218072017.3345">def __repr__ (self):

    return "&lt;vnode %d:'%s'&gt;" % (id(self),self.cleanHeadString())

__str__ = __repr__
</t>
<t tx="ekr.20031218072017.3346"></t>
<t tx="ekr.20031218072017.3348"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self,h=None):
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto","@auto-rst",)
    return self.findAtFileName(names,h=h)

def atAutoRstNodeName (self,h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names,h=h)

def atEditNodeName (self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atShadowFileNodeName (self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
</t>
<t tx="ekr.20031218072017.3350">def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@auto",
        "@auto-rst",
        "@edit",
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@nosent", "@file-nosent", "@nosentinelsfile",
        "@shadow",)

    return self.findAtFileName(names)
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self._bodyString, 0, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3352">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self._bodyString,0,"@others")
    return flag
</t>
<t tx="ekr.20031218072017.3353">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString())
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern)
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
</t>
<t tx="ekr.20031218072017.3359"></t>
<t tx="ekr.20031218072017.3360"></t>
<t tx="ekr.20031218072017.3362">def firstChild (self):

    v = self
    return v.children and v.children[0]
</t>
<t tx="ekr.20031218072017.3364">def lastChild (self):

    v = self
    return v.children and v.children[-1] or None
</t>
<t tx="ekr.20031218072017.3365"># childIndex and nthChild are zero-based.

def nthChild (self, n):

    v = self

    if 0 &lt;= n &lt; len(v.children):
        return v.children[n]
    else:
        return None
</t>
<t tx="ekr.20031218072017.3366">def numberOfChildren (self):

    v = self
    return len(v.children)
</t>
<t tx="ekr.20031218072017.3367"></t>
<t tx="ekr.20031218072017.3368">def isCloned (self):

    return len(self.parents) &gt; 1
</t>
<t tx="ekr.20031218072017.3369">def isDirty (self):

    return (self.statusBits &amp; self.dirtyBit) != 0
</t>
<t tx="ekr.20031218072017.3370">def isExpanded (self):

    # g.trace( ( self.statusBits &amp; self.expandedBit ) != 0, g.callers())

    return ( self.statusBits &amp; self.expandedBit ) != 0
</t>
<t tx="ekr.20031218072017.3371">def isMarked (self):

    return ( self.statusBits &amp; vnode.markedBit ) != 0
</t>
<t tx="ekr.20031218072017.3372">def isOrphan (self):

    return ( self.statusBits &amp; vnode.orphanBit ) != 0
</t>
<t tx="ekr.20031218072017.3373">def isSelected (self):

    return ( self.statusBits &amp; vnode.selectedBit ) != 0
</t>
<t tx="ekr.20031218072017.3374">def isTopBitSet (self):

    return ( self.statusBits &amp; self.topBit ) != 0
</t>
<t tx="ekr.20031218072017.3376">def isVisited (self):

    return ( self.statusBits &amp; vnode.visitedBit ) != 0
</t>
<t tx="ekr.20031218072017.3377">def status (self):

    return self.statusBits
</t>
<t tx="ekr.20031218072017.3378">def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if g.isUnicode(self._bodyString):
        return self._bodyString
    else:
        g.internalError('not unicode:',repr(self._bodyString))
        return g.toUnicode(self._bodyString)

getBody = bodyString
</t>
<t tx="ekr.20031218072017.3384"></t>
<t tx="ekr.20031218072017.3385">def computeIcon (self):

    val = 0 ; v = self
    if v.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
</t>
<t tx="ekr.20031218072017.3386"></t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree (self):

    for p in self.self_and_subtree():
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20031218072017.3389">def clearClonedBit (self):

    self.statusBits &amp;= ~ self.clonedBit
</t>
<t tx="ekr.20031218072017.3390">def clearDirty (self):

    v = self
    # g.trace(v,g.callers())
    v.statusBits &amp;= ~ v.dirtyBit

</t>
<t tx="ekr.20031218072017.3391">def clearMarked (self):

    self.statusBits &amp;= ~ self.markedBit
</t>
<t tx="ekr.20031218072017.3392">def clearOrphan (self):

    self.statusBits &amp;= ~ self.orphanBit
</t>
<t tx="ekr.20031218072017.3393">def clearVisited (self):

    self.statusBits &amp;= ~ self.visitedBit
</t>
<t tx="ekr.20031218072017.3395">def contract(self):

    # if self.context.p.v == self: g.trace(self,g.callers(4))
    # if self.isExpanded(): g.trace(self,g.callers())

    self.statusBits &amp;= ~ self.expandedBit

def expand(self):

    # g.trace(self,g.callers(4))

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    # g.trace(self._headString)

    self.statusBits |= self.expandedBit
</t>
<t tx="ekr.20031218072017.3396">def initStatus (self, status):

    self.statusBits = status
</t>
<t tx="ekr.20031218072017.3397">def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &amp;= ~ self.clonedBit
</t>
<t tx="ekr.20031218072017.3398">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20031218072017.3399">def setOrphan (self):

    self.statusBits |= self.orphanBit
</t>
<t tx="ekr.20031218072017.3400"># This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
</t>
<t tx="ekr.20031218072017.3401"># Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
</t>
<t tx="ekr.20031218072017.3402">def setSelection (self, start, length):

    v = self
    v.selectionStart = start
    v.selectionLength = length
</t>
<t tx="ekr.20031218072017.3404">def trimTrailingLines (self,p):

    """Trims trailing blank lines from a node.

    It is surprising difficult to do this during Untangle."""

    c = self
    body = p.b
    lines = body.split('\n')
    i = len(lines) - 1 ; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = ''.join(body) + '\n' # Add back one last newline.
        # g.trace(body)
        c.setBodyString(p,body)
        # Don't set the dirty bit: it would just be annoying.
</t>
<t tx="ekr.20031218072017.3425">def _linkAsNthChild (self,parent_v,n):

    """Links self as the n'th child of vnode pv"""

    v = self # The child node.
    v._addLink(n,parent_v)
</t>
<t tx="ekr.20031218072017.3439">'''define the LeoPluginsController class.'''

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import bisect
import sys

@others
</t>
<t tx="ekr.20031218072017.3446">@language python
@tabwidth -4
@pagewidth 70

# Tangle and Untangle.
import leo.core.leoGlobals as g
import os
import string

&lt;&lt; about Tangle and Untangle &gt;&gt;
&lt;&lt; constants &gt;&gt;

@others
</t>
<t tx="ekr.20031218072017.3447">max_errors = 20

# All these must be defined together, because they form a single enumeration.
# Some of these are used by utility functions.

# Used by token_type().
plain_line = 1 # all other lines
at_at      = 2 # double-at sign.
at_chapter = 3 # @chapter
# at_c     = 4 # @c in noweb mode
at_code    = 5 # @code, or @c or @p in CWEB mode.
at_doc     = 6 # @doc
at_other   = 7 # all other @directives
at_root    = 8 # @root or noweb * sections
at_section = 9 # @section
# at_space = 10 # @space
at_web     = 11 # any CWEB control code, except at_at.

# Returned by self.skip_section_name() and allies and used by token_type.
bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
section_ref  = 13  # &lt; &lt; name &gt; &gt;
section_def  = 14  # &lt; &lt; name &gt; &gt; =

# Returned by is_sentinal_line.
non_sentinel_line   = 15
start_sentinel_line = 16
end_sentinel_line   = 17

# Stephen P. Schaefer 9/13/2002
# add support for @first
at_last    = 18
</t>
<t tx="ekr.20031218072017.3448"></t>
<t tx="ekr.20031218072017.3449">class tst_node:
    @others
</t>
<t tx="ekr.20031218072017.3450">def __init__ (self,name,root_flag):

    # g.trace("tst_node.__init__",name)
    self.name = name
    self.is_root = root_flag
    self.referenced = False
    self.parts = []
    self.delims = None

</t>
<t tx="ekr.20031218072017.3451">def __repr__ (self):

    return "tst_node:" + self.name
</t>
<t tx="ekr.20031218072017.3452">class part_node:
    @others
</t>
<t tx="ekr.20031218072017.3453">def __init__ (self,name,code,doc,is_root,is_dirty,delims):

    # g.trace("part_node.__init__",name)
    self.name = name # Section or file name.
    self.code = code # The code text.
    self.doc = doc # The doc text.
    self.is_dirty = is_dirty # True: vnode for body text is dirty.
    self.is_root = is_root # True: name is a root name.
    self.delims = delims
    self.refs = []

</t>
<t tx="ekr.20031218072017.3454">def __repr__ (self):

    return "part_node:" + self.name
</t>
<t tx="ekr.20031218072017.3455">class ust_node:
    @others
</t>
<t tx="ekr.20031218072017.3456">@
The text has been masssaged so that 1) it contains no leading
indentation and 2) all code arising from section references have been
replaced by the reference line itself. Text for all copies of the same
part can differ only in non-critical white space.
@c

def __init__ (self,name,code,part,of,nl_flag,update_flag):

    # g.trace("ust_node.__init__",name,part)
    self.name = name # section name
    self.parts = {} # parts dict
    self.code = code # code text
    self.part = part # n in "(part n of m)" or zero.
    self.of = of  # m in "(part n of m)" or zero.
    self.nl_flag = nl_flag  # True: section starts with a newline.
    self.update_flag = update_flag # True: section corresponds to a section in the outline.
</t>
<t tx="ekr.20031218072017.3457">def __repr__ (self):

    return "ust_node:" + self.name
</t>
<t tx="ekr.20031218072017.3458">class def_node:
    @others
</t>
<t tx="ekr.20031218072017.3459">@
The text has been masssaged so that 1) it contains no leading
indentation and 2) all code arising from section references have been
replaced by the reference line itself. Text for all copies of the same
part can differ only in non-critical white space.
@c

def __init__ (self,name,indent,part,of,nl_flag,code):

    if 0:
        g.trace("def_node.__init__:",
            "name:",name," part:",part," of:",of," indent:",indent)
    self.name = name
    self.indent = indent
    self.code = code
    if self.code == None: self.code = ""
    self.part = part
    self.of = of
    self.nl_flag = nl_flag
</t>
<t tx="ekr.20031218072017.3460">def __repr__ (self):

    return "def_node:" + self.name
</t>
<t tx="ekr.20031218072017.3461">@ Stephen P. Schaefer, 9/2/2002
Collect the root node specific attributes in an
easy-to-use container.
@c

class root_attributes:
    @others
</t>
<t tx="ekr.20031218072017.3462">@ Stephen P. Schaefer, 9/2/2002
Keep track of the attributes of a root node
@c

def __init__ (self, tangle_state):

    if 0:
        &lt;&lt; trace the state &gt;&gt;
    self.language = tangle_state.language
    self.use_header_flag = tangle_state.use_header_flag
    self.print_mode = tangle_state.print_mode

    # of all the state variables, this one isn't set in tangleCommands.__init__
    # peculiar
    try:
        self.path = tangle_state.path
    except AttributeError:
        self.path = None

    self.page_width = tangle_state.page_width
    self.tab_width = tangle_state.tab_width
    self.first_lines = tangle_state.first_lines # Stephen P. Schaefer 9/13/2002
</t>
<t tx="ekr.20031218072017.3463">try:
    if tangle_state.path: pass
except AttributeError:
    tangle_state.path = None

if 0:
    g.trace("def_root_attribute.__init__",
        "language:" + tangle_state.language +
        ", use_header_flag: " + repr(tangle_state.use_header_flag) +
        ", print_mode: " + tangle_state.print_mode +
        ", path: " + repr(tangle_state.path) +
        ", page_width: " + repr(tangle_state.page_width) +
        ", tab_width: " + repr(tangle_state.tab_width) +
        # Stephen P. Schaefer 9/13/2002
        ", first_lines: " + tangle_state.first_lines)
</t>
<t tx="ekr.20031218072017.3464">def __repr__ (self):

    return ("root_attributes: language: " + self.language +
        ", use_header_flag: " + repr(self.use_header_flag) +
        ", print_mode: " + self.print_mode +
        ", path: " + self.path +
        ", page_width: " + repr(self.page_width) +
        ", tab_width: " + repr(self.tab_width) +
        # Stephen P. Schaefer 9/13/2002
        ", first_lines: " + self.first_lines)
</t>
<t tx="ekr.20031218072017.3465">class baseTangleCommands:
    """The base class for Leo's tangle and untangle commands."""
    @others

class tangleCommands (baseTangleCommands):
    """A class that implements Leo' tangle and untangle commands."""
    pass
</t>
<t tx="ekr.20031218072017.3466">def __init__ (self,c):

    self.c = c
    self.init_ivars()
</t>
<t tx="ekr.20031218072017.3467">@ Only top-level drivers initialize ivars.
</t>
<t tx="ekr.20031218072017.3468"># This code is called from tangleTree and untangleTree.

def cleanup (self):

    c = self.c

    if self.errors + g.app.scanErrors == 0:
        &lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;

    # Reinitialize the symbol tables and lists.
    self.tst = {}
    self.ust = {}
    self.root_list = []
    self.def_stack = []
</t>
<t tx="ekr.20031218072017.3469"># Create a list of root names:
root_names = []
theDir = self.tangle_directory # Bug fix: 12/04/02
if not theDir: theDir = ""
for section in self.root_list:
    for part in section.parts:
        if part.is_root:
            root_names.append(c.os_path_finalize_join(theDir,part.name))

if self.tangling and self.tangle_batch_flag:
    try:
        import tangle_done
        tangle_done.run(root_names)
    except:
        g.es("can not execute","tangle_done.run()")
        g.es_exception()
if not self.tangling and self.untangle_batch_flag:
    try:
        import untangle_done
        untangle_done.run(root_names)
    except:
        g.es("can not execute","tangle_done.run()")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3470">def initTangleCommand (self):

    c = self.c
    c.endEditing()

    if not g.unitTesting:
        g.es("tangling...")
    self.init_ivars()
    self.tangling = True
</t>
<t tx="ekr.20031218072017.3471">def initUntangleCommand (self):

    c = self.c
    c.endEditing()

    if not g.unitTesting:
        g.es("untangling...")
    self.init_ivars()
</t>
<t tx="ekr.20031218072017.3472">def tangle(self,event=None,p=None):

    c = self.c
    if not p: p = c.p
    self.initTangleCommand()

    # Paul Paterson's patch.
    if not self.tangleTree(p,report_errors=True):
        g.es("looking for a parent to tangle...")
        while p:
            assert(self.head_root == None)
            d = g.get_directives_dict(p,[self.head_root])
            if 'root' in d:
                g.es("tangling parent")
                self.tangleTree(p,report_errors=True)
                break
            p.moveToParent()

    if not g.unitTesting:
        g.es("tangle complete")
</t>
<t tx="ekr.20031218072017.3473">def tangleAll(self,event=None):

    c = self.c
    self.initTangleCommand()
    has_roots = False

    for p in c.rootPosition().self_and_siblings():
        ok = self.tangleTree(p,report_errors=False)
        if ok: has_roots = True
        if self.path_warning_given:
            break # Fatal error.

    self.errors += g.app.scanErrors

    if not has_roots:
        self.warning("----- the outline contains no roots")
    elif self.errors &gt; 0 and not self.path_warning_given:
        self.warning("----- tangle halted because of errors")
    else:
        if not g.unitTesting:
            g.es("tangle complete")
</t>
<t tx="ekr.20031218072017.3474">def tangleMarked(self,event=None):

    c = self.c ; p = c.rootPosition()
    c.clearAllVisited() # No roots have been tangled yet.
    self.initTangleCommand()
    any_marked = False
    while p:
        is_ignore, i = g.is_special(p.b,0,"@ignore")
        # Only tangle marked and unvisited nodes.
        if is_ignore:
            p.moveToNodeAfterTree()
        elif p.isMarked():
            ok = self.tangleTree(p,report_errors=False)
            if ok: any_marked = True
            if self.path_warning_given:
                break # Fatal error.
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()

    self.errors += g.app.scanErrors

    if not any_marked:
        self.warning("----- The outline contains no marked roots")
    elif self.errors &gt; 0 and not self.path_warning_given:
        self.warning("----- Tangle halted because of errors")
    else:
        if not g.unitTesting:
            g.es("tangle complete")
</t>
<t tx="ekr.20031218072017.3476"># At this point p is the root of the tree that has been tangled.

def tanglePass2(self):

    self.p = None # self.p is not valid in pass 2.

    self.errors += g.app.scanErrors

    if self.errors &gt; 0:
        self.warning("----- No file written because of errors")
    elif self.root_list == None:
        self.warning("----- The outline contains no roots")
    else:
        self.put_all_roots() # pass 2 top level function.
</t>
<t tx="ekr.20031218072017.3477"># This function is called only from the top level, so there is no need to initialize globals.

def tangleTree(self,p,report_errors):

    """Tangles all nodes in the tree whose root is p.

    Reports on its results if report_errors is True."""

    p = p.copy() # 9/14/04
    assert(p)
    any_root_flag = False
    next = p.nodeAfterTree()
    self.path_warning_given = False
    self.tangling = True

    while p and p != next:
#        g.trace(p)
        self.setRootFromHeadline(p)
        assert(self.head_root == None)
        theDict = g.get_directives_dict(p,[self.head_root])
        is_ignore = 'ignore' in theDict
        is_root = 'root' in theDict
        is_unit = 'unit' in theDict
        if is_ignore:
            p.moveToNodeAfterTree()
        elif not is_root and not is_unit:
            p.moveToThreadNext()
        else:
            self.scanAllDirectives(p) # sets self.init_delims
            self.tanglePass1(p,self.init_delims) # sets self.p
            if self.root_list and self.tangling:
                any_root_flag = True
                self.tanglePass2() # self.p invalid in pass 2.
            self.cleanup()
            p.moveToNodeAfterTree()
            if self.path_warning_given: break # Fatal error.

    if self.tangling and report_errors and not any_root_flag:
        # This is done by Untangle if we are untangling.
        self.warning("----- The outline contains no roots")
    return any_root_flag
</t>
<t tx="ekr.20031218072017.3478">def untangle(self,event=None,p=None):

    c = self.c
    if p == None:
        p = c.p
    self.initUntangleCommand()
    # must be done at this point, since initUntangleCommand blows away tangle_output
    &lt;&lt; read fake files for unit testing &gt;&gt;
    self.untangleTree(p,report_errors=True)
    if not g.unitTesting:
        g.es("untangle complete")
    c.redraw()
</t>
<t tx="ekr.20031218072017.3479">def untangleAll(self,event=None):

    c = self.c
    self.initUntangleCommand()
    has_roots = False

    for p in c.rootPosition().self_and_siblings():
        ok = self.untangleTree(p,False)
        if ok: has_roots = True
    c.redraw()

    self.errors += g.app.scanErrors

    if not has_roots:
        self.warning("----- the outline contains no roots")
    elif self.errors &gt; 0:
        self.warning("----- untangle command halted because of errors")
    else:
        if not g.unitTesting:
            g.es("untangle complete")
</t>
<t tx="ekr.20031218072017.3480">def untangleMarked(self,event=None):

    c = self.c ; p = c.rootPosition()
    self.initUntangleCommand()
    marked_flag = False

    while p: # Don't use an iterator.
        if p.isMarked():
            ok = self.untangleTree(p,report_errors=False)
            if ok: marked_flag = True
            if self.errors + g.app.scanErrors &gt; 0: break
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

    self.errors += g.app.scanErrors

    if not marked_flag:
        self.warning("----- the outline contains no marked roots")
    elif self.errors &gt; 0:
        self.warning("----- untangle command halted because of errors")
    else:
        if not g.unitTesting:
            g.es("untangle complete")
</t>
<t tx="ekr.20031218072017.3481">@
This method untangles the derived files in a vnode known to contain at
least one @root directive. The work is done in three passes. The first
pass creates a TST from the Leo tree so that the next pass will know
what comment conventions to use; that pass is performed in
untangleTree. The second pass creates the UST by scanning the derived
file. The third pass updates the outline using the UST and a new TST
that is created during the pass.

We assume that all sections from root to end are contained in the
derived file, and we attempt to update all such sections. The
begin/end params indicate the range of nodes to be scanned when
building the TST.
@c

def untangleRoot(self,root,begin,end):

    # g.trace("root,begin,end:",root,begin,end)
    c = self.c
    &lt;&lt; return if @silent &gt;&gt;
    s = root.b
    i = 0
    while i &lt; len(s):
        # g.trace("i: %d" % i)
        &lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;
        path = c.os_path_finalize_join(self.tangle_directory,path)
        if g.unitTesting:
            &lt;&lt; fake the file access &gt;&gt;
        else:
            file_buf,e = g.readFileIntoString(path)
        if not file_buf is None:
            file_buf = file_buf.replace('\r','')

            if not g.unitTesting:
                g.es('','@root ' + path)
            if 0: # debug
                g.es(self.st_dump())
                g.es("path: " + path)
            section = self.tst[self.root_name]
            assert section
            # Pass 2: Scan the derived files, creating the UST
            self.scan_derived_file(file_buf)
            # g.trace(self.ust_dump())
            if self.errors + g.app.scanErrors == 0:
                &lt;&lt; Pass 3: Untangle the outline using the UST and a newly-created TST &gt;&gt;

    self.cleanup()
</t>
<t tx="ekr.20031218072017.3482">if self.print_mode in ("quiet","silent"):
    g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
    return
</t>
<t tx="ekr.20031218072017.3483">self.root_name = None
while i &lt; len(s):
    code, junk = self.token_type(s,i,report_errors=True)
    i = g.skip_line(s,i)
    if code == at_root:
        # token_type sets root_name unless there is a syntax error.
        if self.root_name: path = self.root_name
        break

if not self.root_name:
    # A bad @root command.  token_type has already given an error.
    self.cleanup()
    return
</t>
<t tx="ekr.20031218072017.3485">@
This code untangles the root and all its siblings. We don't call tangleTree here
because we must handle all siblings. tanglePass1 handles an entire tree. It also
handles @ignore.
@c

self.tangling = False
p = begin
while p and p != end: # Don't use iterator.
    self.scanAllDirectives(p) # sets self.init_delims
    self.tst = {}
    self.untangle_stage1 = False
    self.tanglePass1(p, self.init_delims)
    if self.errors + g.app.scanErrors != 0:
        break
    p.moveToNodeAfterTree()

self.ust_warn_about_orphans()
</t>
<t tx="ekr.20031218072017.3486"># This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,p,report_errors):

    p = p.copy() # 9/14/04
    c = self.c
    any_root_flag = False
    afterEntireTree = p.nodeAfterTree()
    # Initialize these globals here: they can't be cleared later.
    self.head_root = None
    self.errors = 0 ; g.app.scanErrors = 0
    c.clearAllVisited() # Used by untangle code.
    self.tangling = False
    self.delims_table = False

    while p and p != afterEntireTree and self.errors + g.app.scanErrors == 0:
        self.setRootFromHeadline(p)
        assert(self.head_root == None)
        theDict = g.get_directives_dict(p,[self.head_root])
        ignore = 'ignore' in theDict
        root = 'root' in theDict
        unit = 'unit' in theDict
        if ignore:
            p.moveToNodeAfterTree()
        elif unit:
            # Expand the context to the @unit directive.
            unitNode = p   # 9/27/99
            afterUnit = p.nodeAfterTree()
            self.scanAllDirectives() # sets self.init_delims
            p.moveToThreadNext()
            while p and p != afterUnit and self.errors + g.app.scanErrors== 0:
                self.setRootFromHeadline(p)
                assert(self.head_root == None)
                theDict = g.get_directives_dict(p,[self.head_root])
                root = 'root' in theDict
                if root:
                    any_root_flag = True
                    end = None
                    &lt;&lt; set end to the next root in the unit &gt;&gt;
                    # g.trace("end:",end)
                    self.scanAllDirectives(p)
                    self.tanglePass1(p,self.init_delims)
                    self.untangleRoot(p,unitNode,afterUnit)
                    p = end.copy()
                else: p.moveToThreadNext()
        elif root:
            # Limit the range of the @root to its own tree.
            afterRoot = p.nodeAfterTree()
            any_root_flag = True
            self.scanAllDirectives(p)
            # get the delims table
            self.untangle_stage1 = True
            self.tanglePass1(p,self.init_delims)
            self.untangleRoot(p,p,afterRoot)
            p = afterRoot.copy()
        else:
            p.moveToThreadNext()

    self.errors += g.app.scanErrors

    if report_errors:
        if not any_root_flag:
            self.warning("----- The outline contains no roots")
        elif self.errors &gt; 0:
            self.warning("----- Untangle command halted because of errors")
    return any_root_flag
</t>
<t tx="ekr.20031218072017.3487">@
The untangle_root function will untangle an entire tree by calling
untangleTree, so the following code ensures that the next @root node
will not be an offspring of p.
@c

end = p.threadNext()
while end and end != afterUnit:
    flag, i = g.is_special(end.b,0,"@root")
    if flag and not p.isAncestorOf(end):
        break
    end.moveToThreadNext()
</t>
<t tx="ekr.20031218072017.3488"></t>
<t tx="ekr.20031218072017.3489"></t>
<t tx="ekr.20031218072017.3503">def skip_doc(self,s,i,delims):

    # g.trace(g.get_line(s,i))
    # Skip @space, @*, @doc, @chapter and @section directives.
    doc1 = i
    while i &lt; len(s):
        if g.is_nl(s,i):
            doc1 = i = g.skip_nl(s,i)
        elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@*"):
            i = g.skip_ws(s,i+2) ; doc1 = i
        elif g.match(s,i,"@\n"):
            i += 1 ; doc1 = i
        elif (g.match_word(s,i,"@doc") or
              g.match_word(s,i,"@chapter") or
              g.match_word(s,i,"@section")):
            doc1 = i = g.skip_line(s,i)
        else: break

    while i &lt; len(s):
        kind, junk = self.token_type(s,i,report_errors=False)
        if kind == at_code or kind == at_root or kind == section_def:
            break
        # @language and @comment are honored within document parts
        k = g.skip_line(s,i)
        if kind == at_other:
            if g.match_word(s,i,"@language"):
                lang,d1,d2,d3 = g.set_language(s,i)
                delims = (d1,d2,d3)
            elif g.match_word(s,i,"@comment"):
                delims = g.set_delims_from_string(s[i:k])               
        i = k

    doc = s[doc1:i]
    # g.trace(doc)
    return i, doc, delims
</t>
<t tx="ekr.20031218072017.3504">@
This function sets ivars that keep track of the indentation level. We
also remember where the next line starts because it is assumed to be
the first line of a documentation section.

A headline can contain a leading section name. If it does, we
substitute the section name if we see an @c directive in the body
text.
@c

def skip_headline(self,p):

    self.header = s = p.h
    # Set self.header_name.
    j = i = g.skip_ws(s,0)
    i, kind, end = self.is_section_name(s,i)
    if kind == bad_section_name:
        self.header_name = None
    else:
        self.header_name = s[j:end]
</t>
<t tx="ekr.20031218072017.3505"></t>
<t tx="ekr.20031218072017.3506">@
This method outputs a code section, expanding section references by
their definition. We should see no @directives or section definitions
that would end the code section.

Most of the differences bewteen noweb mode and CWEB mode are handled
by token_type(called from put_newline). Here, the only difference is
that noweb handles double-@ signs only at the start of a line.
@c

def put_code(self,s,no_first_lws_flag,delims):

    # g.trace(g.get_line(s,0))
    i = 0
    if i &lt; len(s):
        i = self.put_newline(s,i,no_first_lws_flag)
        # Double @ is valid in both noweb and CWEB modes here.
        if g.match(s,i,"@@"):
            self.os('@') ; i += 2
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.match(s,i,"&lt;&lt;"):
            &lt;&lt; put possible section reference &gt;&gt;
        elif ch == '@': # We are in the middle of a line.
            &lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;
        elif ch == '\r':
            i += 1
        elif ch == '\n':
            i += 1 ; self.onl()
            &lt;&lt; elide @comment or @language &gt;&gt;
            i = self.put_newline(s,i,False) # Put full lws
        else: self.os(s[i]) ; i += 1
        assert(progress &lt; i)
</t>
<t tx="ekr.20031218072017.3507">j, kind, name_end = self.is_section_name(s,i)
if kind == section_def:
    # We are in the middle of a code section
    self.error(
        "Should never happen:\n" +
        "section definition while putting a section reference: " +
        s[i:j])
    i += 1
elif kind == bad_section_name:
    self.os(s[i]) ; i += 1 # This is not an error.
else:
    assert(kind == section_ref)
    name = s[i:name_end]
    self.put_section(s,i,name,name_end,delims)
    i = j
</t>
<t tx="ekr.20031218072017.3509">@
The user must ensure that neither @ &lt; &lt; nor @ &gt; &gt; occurs in comments
or strings. However, it is valid for @ &lt; &lt; or @ &gt; &gt; to appear in the
doc chunk or in a single-line comment.
@c

if g.match(s,i,"@&lt;&lt;"):
    self.os("/*@*/&lt;&lt;") ; i += 3

elif g.match(s,i,"@&gt;&gt;"):
    self.os("/*@*/&gt;&gt;") ; i += 3

else: self.os("@") ; i += 1
</t>
<t tx="ekr.20031218072017.3510"># This method outputs a doc section within a block comment.

def put_doc(self,s,delims):

    # g.trace(g.get_line(s,0))
    width = self.page_width
    words = 0 ; word_width = 0 ; line_width = 0
    # 8/1/02: can't use choose here!
    if delims[0] == None: single_w = 0
    else: single_w = len(delims[0])
    # Make sure we put at least 20 characters on a line.
    if width - max(0,self.tangle_indent) &lt; 20:
        width = max(0,self.tangle_indent) + 20
    # Skip Initial white space in the doc part.
    i = g.skip_ws_and_nl(s,0)
    if i &lt; len(s) and (self.print_mode == "verbose" or self.print_mode == "quiet"):
        use_block_comment = delims[1] and delims[2]
        use_single_comment = not use_block_comment and delims[0]
        # javadoc_comment = use_block_comment and delims[1] == "/**"
        if use_block_comment or use_single_comment:
            self.put_leading_ws(self.tangle_indent)
            if use_block_comment:
                self.os(delims[1])
            &lt;&lt; put the doc part &gt;&gt;
            self.onl()
            self.put_leading_ws(self.tangle_indent)
            if use_block_comment:
                self.os(delims[2])
            self.onl()
        else: self.onl()
</t>
<t tx="ekr.20031218072017.3511">@
This code fills and outputs each line of a doc part. It keeps track of
whether the next word will fit on a line,and starts a new line if
needed.
@c

if use_single_comment:
    self.os(delims[0]) ; self.otab()
    line_width =(single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
else:
    line_width = abs(self.tab_width)
    self.onl() ; self.otab()
self.put_leading_ws(self.tangle_indent)
line_width += max(0,self.tangle_indent)
words = 0 ; word_width = 0
while i &lt; len(s):
    &lt;&lt;output or skip whitespace or newlines&gt;&gt;
    if i &gt;= len(s):
        break
    j = i ; word_width = 0
    while j &lt; len(s) and not g.is_ws_or_nl(s,j):
        word_width += 1
        j += 1
    if words == 0 or line_width + word_width &lt; width:
        words += 1
        self.os(s[i:j])
        i = j
        line_width += word_width
    else:
        # 11-SEP-2002 DTHEIN: Fixed linewrapping bug in
        # tab-then-comment sequencing
        self.onl()
        if use_single_comment:
            self.os(delims[0]) ; self.otab()
            line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
        else:
            self.otab()
            line_width = abs(self.tab_width)
        words = 0
        self.put_leading_ws(self.tangle_indent)
        # tangle_indent is in spaces.
        line_width += max(0,self.tangle_indent)
</t>
<t tx="ekr.20031218072017.3512">@
This outputs whitespace if it fits, and ignores it otherwise, and
starts a new line if a newline is seen. The effect of self code is
that we never start a line with whitespace that was originally at the
end of a line.
@c

while g.is_ws_or_nl(s,i):
    ch = s[i]
    if ch == '\t':
        pad = abs(self.tab_width) - (line_width % abs(self.tab_width))
        line_width += pad
        if line_width &lt; width: self.otab()
        i += 1
    elif ch == ' ':
        line_width += 1
        if line_width &lt; width: self.os(ch)
        i += 1
    else:
        assert(g.is_nl(s,i))
        self.onl()
        if use_single_comment:
            # New code: 5/31/00
            self.os(delims[0]) ; self.otab()
            line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
        else:
            self.otab()
            line_width = abs(self.tab_width)
        i = g.skip_nl(s,i)
        words = 0
        self.put_leading_ws(self.tangle_indent)
        # tangle_indent is in spaces.
        line_width += max(0,self.tangle_indent)
</t>
<t tx="ekr.20031218072017.3515"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def put_leading_ws(self,n):

    # g.trace("tab_width,indent:",self.tab_width,indent)
    w = self.tab_width

    if w &gt; 1:
        q,r = divmod(n,w)
        self.otabs(q) 
        self.oblanks(r) 
    else:
        self.oblanks(n)
</t>
<t tx="ekr.20031218072017.3516">@
This method handles scanning when putting the start of a new line.
Unlike the corresponding method in pass one, this method doesn't need
to set a done flag in the caller because the caller already knows
where the code section ends.
@c

def put_newline(self,s,i,no_first_lws_flag):

    kind, junk = self.token_type(s,i,report_errors=False)
    &lt;&lt; Output leading white space except for blank lines &gt;&gt;
    if i &gt;= len(s):
        return i
    elif kind == at_web or kind == at_at:
        i += 2 # Allow the line to be scanned.
    elif kind == at_doc or kind == at_code:
        pass
    else:
        # These should have set limit in pass 1.
        assert(kind != section_def and kind != at_chapter and kind != at_section)
    return i
</t>
<t tx="ekr.20031218072017.3517">j = i ; i = g.skip_ws(s,i)
if i &lt; len(s) and not g.is_nl(s,i):
    # Conditionally output the leading previous leading whitespace.
    if not no_first_lws_flag:
        self.put_leading_ws(self.tangle_indent)
    # Always output the leading whitespace of _this_ line.
    k, width = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    self.put_leading_ws(width)
</t>
<t tx="ekr.20031218072017.3518"># This method outputs one part of a section definition.

def put_part_node(self,part,no_first_lws_flag):

    if 0:
        if part: name = part.name # can't use choose.
        else: name = "&lt;NULL part&gt;"
        g.trace(name)

    if part.doc and self.output_doc_flag and self.print_mode != "silent":
        self.put_doc(part.doc,part.delims)

    if part.code:
        # comment convention cannot change in the middle of a doc part
        self.put_code(part.code,no_first_lws_flag,part.delims)
</t>
<t tx="ekr.20031218072017.3519">@
This method outputs the definition of a section and all sections
referenced from the section. name is the section's name. This code
checks for recursive definitions by calling section_check(). We can
not allow section x to expand to code containing another call to
section x, either directly or indirectly.
@c

def put_section(self,s,i,name,name_end,delims):

    j = g.skip_line(s,i)
    # g.trace("indent:",self.tangle_indent,s[i:j])
    outer_old_indent = self.tangle_indent
    trailing_ws_indent = 0 # Set below.
    inner_old_indent = 0 # Set below.
    newline_flag = False  # True if the line ends with the reference.
    assert(g.match(name,0,"&lt;&lt;") or g.match(name,0,"@&lt;"))
    &lt;&lt; Calculate the new value of tangle_indent &gt;&gt;
    &lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;
    section = self.st_lookup(name)
    if section and section.parts:
        # Expand the section only if we are not already expanding it.
        if self.section_check(name):
            self.section_stack.append(name)
            &lt;&lt; put all parts of the section definition &gt;&gt;
            self.section_stack.pop()
    else:
        &lt;&lt; Put a comment about the undefined section &gt;&gt;
    if not newline_flag:
        self.put_leading_ws(trailing_ws_indent)
    self.tangle_indent = outer_old_indent
    return i, name_end
</t>
<t tx="ekr.20031218072017.3520"># Find the start of the line containing the reference.
j = i
while j &gt; 0 and not g.is_nl(s,j):
    j -= 1
if g.is_nl(s,j):
    j = g.skip_nl(s,j)

# Bump the indentation
j, width = g.skip_leading_ws_with_indent(s,j,self.tab_width)
self.tangle_indent += width
# g.trace("leading ws,new indent:",width,self.tangle_indent)

# 4/27/01: Force no trailing whitespace in @silent mode.
if self.print_mode == "silent":
    trailing_ws_indent = 0
else:
    trailing_ws_indent = self.tangle_indent

# Increase the indentation if the section reference does not immediately follow
# the leading white space.  4/3/01: Make no adjustment in @silent mode.
if (j &lt; len(s) and self.print_mode != "silent" and s[j] != '&lt;'):
    self.tangle_indent += abs(self.tab_width)
</t>
<t tx="ekr.20031218072017.3521">if self.print_mode != "silent":
    i = name_end
    i = g.skip_ws(s,i)
    newline_flag = (i &gt;= len(s) or g.is_nl(s,i))
</t>
<t tx="ekr.20031218072017.3522">@
This section outputs each part of a section definition. We first count
how many parts there are so that the code can output a comment saying
'part x of y'.
@c

# Output each part of the section.
sections = len(section.parts)
count = 0
for part in section.parts:
    count += 1
    # In @silent mode, there is no sentinel line to "use up" the previously output
    # leading whitespace.  We set the flag to tell put_part_node and put_code
    # not to call put_newline at the start of the first code part of the definition.
    no_first_leading_ws_flag = (count == 1 and self.print_mode == "silent")
    inner_old_indent = self.tangle_indent
    # 4/3/01: @silent inhibits newlines after section expansion.
    if self.print_mode != "silent":
        &lt;&lt; Put the section name in a comment &gt;&gt;
    self.put_part_node(part,no_first_leading_ws_flag)
    # 4/3/01: @silent inhibits newlines after section expansion.
    if count == sections and (self.print_mode != "silent" and self.print_mode != "quiet"):
        &lt;&lt; Put the ending comment &gt;&gt;
    # Restore the old indent.
    self.tangle_indent = inner_old_indent
</t>
<t tx="ekr.20031218072017.3523">if count &gt; 1:
    self.onl()
    self.put_leading_ws(self.tangle_indent)

# Don't print trailing whitespace
name = name.rstrip()
if part.delims[0]:
    self.os(part.delims[0]) ; self.oblank() ; self.os(name)
    &lt;&lt; put (n of m) &gt;&gt;
else:
    assert(
        part.delims[1] and len(part.delims[1]) &gt; 0 and
        part.delims[2] and len(part.delims[2])&gt; 0)
    self.os(part.delims[1]) ; self.oblank() ; self.os(name)
    &lt;&lt; put (n of m) &gt;&gt;
    self.oblank() ; self.os(part.delims[2])

self.onl() # Always output a newline.
</t>
<t tx="ekr.20031218072017.3524">if sections &gt; 1:
    self.oblank()
    self.os("(%d of %d)" % (count,sections))
</t>
<t tx="ekr.20031218072017.3525">@
We do not produce an ending comment unless we are ending the last part
of the section,and the comment is clearer if we don't say(n of m).
@c

self.onl() ; self.put_leading_ws(self.tangle_indent)
#  Don't print trailing whitespace
while name_end &gt; 0 and g.is_ws(s[name_end-1]):
    name_end -= 1

if section.delims[0]:
    self.os(section.delims[0]) ; self.oblank()
    self.os("-- end -- ") ; self.os(name)
else:
    self.os(section.delims[1]) ; self.oblank()
    self.os("-- end -- ") ; self.os(name)
    self.oblank() ; self.os(section.delims[2])

@ The following code sets a flag for untangle.

If something follows the section reference we must add a newline,
otherwise the "something" would become part of the comment. Any
whitespace following the (!newline) should follow the section
defintion when Untangled.
@c

if not newline_flag:
    self.os(" (!newline)") # LeoCB puts the leading blank, so we must do so too.
    # Put the whitespace following the reference.
    while name_end &lt; len(s) and g.is_ws(s[name_end]):
        self.os(s[name_end])
        name_end += 1
    self.onl() # We must supply the newline!
</t>
<t tx="ekr.20031218072017.3527">@
We can not allow a section to be defined in terms of itself, either
directly or indirectly.

We push an entry on the section stack whenever beginning to expand a
section and pop the section stack at the end of each section. This
method checks whether the given name appears in the stack. If so, the
section is defined in terms of itself.
@c

def section_check (self,name):

    if name in self.section_stack:
        s = "Invalid recursive reference of " + name + "\n"
        for n in self.section_stack:
            s += "called from: " + n + "\n"
        self.error(s)
        return False
    return True
</t>
<t tx="ekr.20031218072017.3528"></t>
<t tx="ekr.20031218072017.3529">def st_check(self):

    """Checks the given symbol table for defined but never referenced sections."""

    # g.trace(keys)
    for name in sorted(self.tst):
        section = self.tst[name]
        if not section.referenced:
            lp = "&lt;&lt; "
            rp = " &gt;&gt;"
            g.es('',' ' * 4,'warning:',lp,section.name,rp,'has been defined but not used.')
</t>
<t tx="ekr.20031218072017.3530"># Dumps the given symbol table in a readable format.

def st_dump(self,verbose_flag=True):

    s = "\ndump of symbol table...\n"

    for name in sorted(self.tst):
        section = self.tst[name]
        if verbose_flag:
            s += self.st_dump_node(section)
        else:
            theType = g.choose(len(section.parts)&gt;0,"  ","un")
            s += ("\n" + theType + "defined:[" + section.name + "]")
        s += "\nsection delims: "+repr(section.delims)
    return s
</t>
<t tx="ekr.20031218072017.3531"># Dumps each part of a section's definition.

def st_dump_node(self,section):

    return section.dump()

</t>
<t tx="ekr.20031218072017.3532"># The comment delimiters for the start sentinel are kept in the part;
# for the end sentinel, in the section
def st_enter(self,name,code,doc,delims_begin,delims_end,is_root_flag=False):

    """Enters names and their associated code and doc parts into the given symbol table."""
    if 0: # debug
        import sys
        g.trace("name: %s ======code\n%s======doc\n%s" % (name, code, doc))
        f = sys._getframe(1)
        g.trace("caller: "+f.f_code.co_name)
        f = sys._getframe(2)
        g.trace("caller's caller: "+f.f_code.co_name)

    section = self.st_lookup(name,is_root_flag)
    assert(section)
    if doc:
        doc = doc.rstrip() # remove trailing lines.
    if code:
        if self.print_mode != "silent": # @silent supresses newline processing.
            i = g.skip_blank_lines(code,0) # remove leading lines.
            if i &gt; 0: code = code[i:] 
            if code and len(code) &gt; 0: code = code.rstrip() # remove trailing lines.
        if len(code) == 0: code = None
    if self.tangling and code:
        &lt;&lt; check for duplicate code definitions &gt;&gt;
    if code or doc:
        part = part_node(name,code,doc,is_root_flag,False,delims_begin)
        section.parts.append(part)
        section.delims = delims_end
    else: # A reference
        section.referenced = True
    if is_root_flag:
        self.root_list.append(section)
        section.referenced = True # Mark the root as referenced.
        &lt;&lt;remember root node attributes&gt;&gt;
    return len(section.parts) # part number
</t>
<t tx="ekr.20031218072017.3533">for part in section.parts:
    if code == part.code:
        s = g.angleBrackets(section.name)
        g.es('warning: possible duplicate definition of:',s)
</t>
<t tx="ekr.20031218072017.3534"># Stephen Schaefer, 9/2/02
# remember the language and comment characteristics
section.root_attributes = root_attributes(self)
</t>
<t tx="ekr.20031218072017.3535"># Enters a root name into the given symbol table.

def st_enter_root_name(self,name,code,doc,delims_begin,delims_end):

    # assert(code)
    if name: # User errors can result in an empty @root name.
        self.st_enter(name,code,doc,delims_begin,delims_end,is_root_flag=True)
</t>
<t tx="ekr.20031218072017.3536">def st_enter_section_name(self,name,code,doc,delims_begin,delims_end):

    """Enters a section name into the given symbol table.

    The code and doc pointers are None for references."""

    return self.st_enter(name,code,doc,delims_begin,delims_end)
</t>
<t tx="ekr.20031218072017.3537">def st_lookup(self,name,is_root_flag=False):

    """Looks up name in the symbol table and creates a tst_node for it if it does not exist."""

    if is_root_flag:
        key = name
    else:
        key = self.standardize_name(name)

    if key in self.tst:
        section = self.tst[key]
        # g.trace("found:" + key)
        return section
    else:
        # g.trace("not found:" + key)
        section = tst_node(key,is_root_flag)
        self.tst [key] = section
        return section
</t>
<t tx="ekr.20031218072017.3538"></t>
<t tx="ekr.20031218072017.3539">def ust_dump (self):

    s = "\n---------- Untangle Symbol Table ----------"

    for name in sorted(self.ust):
        section = self.ust[name]
        s += "\n\n" + section.dump()

    s += "\n--------------------"

    return s
</t>
<t tx="ekr.20031218072017.3540">@
This routine enters names and their code parts into the given table.
The 'part' and 'of' parameters are taken from the "(part n of m)"
portion of the line that introduces the section definition in the C
code.

If no part numbers are given the caller should set the 'part' and 'of'
parameters to zero. The caller is reponsible for checking for
duplicate parts.

This function handles names scanned from a source file; the
corresponding st_enter routine handles names scanned from outlines.
@c

def ust_enter (self,name,part,of,code,nl_flag,is_root_flag=False):

    if not is_root_flag:
        name = self.standardize_name(name)
    &lt;&lt; remove blank lines from the start and end of the text &gt;&gt;
    u = ust_node(name,code,part,of,nl_flag,False) # update_flag
    if name not in self.ust:
        self.ust[name] = u
    section = self.ust[name]
    section.parts[part]=u # Parts may be defined in any order.
    # g.trace("section [%s](part %d of %d)...&lt;code&gt;%s&lt;/code&gt;" % (name,part,of,code))
</t>
<t tx="ekr.20031218072017.3541">i = g.skip_blank_lines(code,0)
if i &gt; 0:
    code = code[i:].rstrip()

</t>
<t tx="ekr.20031218072017.3542"># Searches the given table for a part matching the name and part number.

def ust_lookup (self,name,part_number,is_root_flag=False,update_flag=False):

    # g.trace(name,part_number,is_root_flag)

    if not is_root_flag:
        name = self.standardize_name(name)

    if part_number == 0: part_number = 1 # A hack: zero indicates the first part.
    if name in self.ust:
        section = self.ust[name]
        # g.trace("section dump: %s" % section.dump())
        if part_number in section.parts:
            part = section.parts[part_number]
            if update_flag: part.update_flag = True
            # g.trace("update_flag: %s part.update_flag: %s found: %s(%d)(%s):%s...\n" % (repr(update_flag),repr(part.update_flag),name,part_number,repr(part.part),part.code))
            return part, True

    # g.trace("not found: %s(%d)...\n" % (name,part_number))
    return None, False
</t>
<t tx="ekr.20031218072017.3543">def ust_warn_about_orphans (self):

    """Issues a warning about any sections in the derived file for which
    no corresponding section has been seen in the outline."""

    # g.trace(self.ust_dump())
    for section in self.ust.values():
        # g.trace(section)
        for part in section.parts.values():
            assert(part.of == section.of)
            if not part.update_flag:
                lp = "&lt;&lt; "
                rp = " &gt;&gt;"
                # g.es("warning:",'%s%s(%s)%s' % (lp,part.name,part.part,rp),"is not in the outline")
                break # One warning per section is enough.
</t>
<t tx="ekr.20031218072017.3544"></t>
<t tx="ekr.20031218072017.3545">@
This function compares the interior of comments and returns True if
they are identical except for whitespace or newlines. It is up to the
caller to eliminate the opening and closing delimiters from the text
to be compared.
@c

def compare_comments (self,s1,s2):

    tot_len = 0
    if self.comment: tot_len += len(self.comment)
    if self.comment_end: tot_len += len(self.comment_end)

    p1, p2 = 0, 0
    while p1 &lt; len(s1) and p2 &lt; len(s2):
        p1 = g.skip_ws_and_nl(s1,p1)
        p2 = g.skip_ws_and_nl(s2,p2)
        if self.comment and self.comment_end:
            &lt;&lt; Check both parts for @ comment conventions &gt;&gt;
        if p1 &gt;= len(s1) or p2 &gt;= len(s2):
            break
        if s1[p1] != s2[p2]:
            return False
        p1 += 1 ; p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    return p1 == len(s1) and p2 == len(s2)
</t>
<t tx="ekr.20031218072017.3546">@
This code is used in forgiving_compare()and in compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
We must be careful not to run afoul of this very convention here!
@c

if p1 &lt; len(s1) and s1[p1] == '@':
    if g.match(s2,p2,self.comment + '@' + self.comment_end):
        p1 += 1
        p2 += tot_len + 1
        continue
elif p2 &lt; len(s2) and s2[p2] == '@':
    if g.match(s1,p1,self.comment + '@' + self.comment_end):
        p2 += 1
        p1 += tot_len + 1
        continue
</t>
<t tx="ekr.20031218072017.3547">@
This function is called to massage an @doc part in the ust. We call
this routine only after a mismatch in @doc parts is found between the
ust and tst. On entry, the parameters point to the inside of a block C
comment: the opening and closing delimiters are not part of the text
handled by self routine.

This code removes newlines that may have been inserted by the Tangle
command in a block comment. Tangle may break lines differently in
different expansions, but line breaks are ignored by
forgiving_compare() and doc_compare() within block C comments.

We count the leading whitespace from the first non-blank line and
remove this much whitespace from all lines. We also remove singleton
newlines and replace sequences of two or more newlines by a single
newline.
@c

def massage_block_comment (self,s):

    c = self.c
    newlines = 0  # Consecutive newlines seen.
    i = g.skip_blank_lines(s,0)
    # Copy the first line and set n
    i, n = g.skip_leading_ws_with_indent(s,i,c.tab_width)
    j = i ; i = g.skip_to_end_of_line(s,i)
    result = s[j:i]
    while i &lt; len(s):
        assert(g.is_nl(s,i))
        newlines += 1
        # Replace the first newline with a blank.
        result += ' ' ; i += 1
        while i &lt; len(s) and g.is_nl(s,i):
            i += 1 # skip the newline.
        j = i ; i = g.skip_ws(s,i)
        if g.is_nl(s,i)and newlines &gt; 1:
            # Skip blank lines.
            while g.is_nl(s,i):
                i += 1
        else:
            # Skip the leading whitespace.
            i = j # back track
            i = g.skip_leading_ws(s,i,n,c.tab_width)
            newlines = 0
            # Copy the rest of the line.
            j = i ; i = g.skip_to_end_of_line(s,i)
            result += s[j:i]
    return result
</t>
<t tx="ekr.20031218072017.3548">@
This is the "forgiving compare" function. It compares two texts and
returns True if they are identical except for comments or non-critical
whitespace. Whitespace inside strings or preprocessor directives must
match exactly. @language and @comment in the outline version are
ignored. s1 is the outline version, s2 is the external file version.
@c

def forgiving_compare (self,name,part,s1,s2):

    if 0:
        g.trace(name,part,
            "\n1:",g.get_line(s1,0),
            "\n2:",g.get_line(s2,0))
    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)
    &lt;&lt; Define forgiving_compare vars &gt;&gt;
    p1 = g.skip_ws_and_nl(s1,0) 
    p2 = g.skip_ws_and_nl(s2,0)
    result = True
    while result and p1 &lt; len(s1) and p2 &lt; len(s2):
        first1 = p1 ; first2 = p2
        if self.comment and self.comment_end:
            &lt;&lt; Check both parts for @ comment conventions &gt;&gt;
        ch1 = s1[p1]
        if ch1 == '\r' or ch1 == '\n':
            &lt;&lt; Compare non-critical newlines &gt;&gt;
        elif ch1 ==  ' ' or ch1 == '\t':
            &lt;&lt; Compare non-critical whitespace &gt;&gt;
        elif ch1 == '\'' or ch1 == '"':
            &lt;&lt; Compare possible strings &gt;&gt;
        elif ch1 == '#':
            &lt;&lt; Compare possible preprocessor directives &gt;&gt;
        elif ch1 == '&lt;':
            # NB: support for derived noweb or CWEB file
            &lt;&lt; Compare possible section references &gt;&gt;
        elif ch1 == '@':
            &lt;&lt; Skip @language or @comment in outline &gt;&gt;
        else:
            &lt;&lt; Compare comments or single characters &gt;&gt;
    &lt;&lt; Make sure both parts have ended &gt;&gt;
    if not result:
        &lt;&lt; trace the mismatch &gt;&gt;
    return result
</t>
<t tx="ekr.20031218072017.3549"># scan_derived_file has set the ivars describing comment delims.
first1 = first2 = 0

tot_len = 0
if self.comment: tot_len += len(self.comment)
if self.comment_end: tot_len += len(self.comment_end)
</t>
<t tx="ekr.20031218072017.3550">p1 = g.skip_ws_and_nl(s1,p1)
p2 = g.skip_ws_and_nl(s2,p2)
</t>
<t tx="ekr.20031218072017.3551">p1 = g.skip_ws(s1,p1)
p2 = g.skip_ws(s2,p2)
</t>
<t tx="ekr.20031218072017.3552">if self.language == "c":
    &lt;&lt; compare preprocessor directives &gt;&gt;
else:
    &lt;&lt; compare single characters &gt;&gt;
</t>
<t tx="ekr.20031218072017.3553">assert(p1 &lt; len(s1) and p2 &lt; len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")
</t>
<t tx="ekr.20031218072017.3554"># We cannot assume that newlines are single characters.

result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 &lt; len(s1) and p2 &lt; len(s2):
    if g.is_nl(s1,p1):
        result = g.is_nl(s2,p2)
        if not result or self.is_end_of_directive(s1,p1):
            break
        p1 = g.skip_nl(s1,p1)
        p2 = g.skip_nl(s2,p2)
    else:
        result = s1[p1] == s2[p2]
        p1 += 1 ; p2 += 1
if not result:
    self.mismatch("Mismatched preprocessor directives")
</t>
<t tx="ekr.20031218072017.3555"># This code implicitly assumes that string1_len == string2_len == 1.
# The match test ensures that the language actually supports strings.

if (g.match(s1,p1,self.string1) or g.match(s1,p1,self.string2)) and s1[p1] == s2[p2]:

    if self.language == "pascal":
        &lt;&lt; Compare Pascal strings &gt;&gt;
    else:
        &lt;&lt; Compare C strings &gt;&gt;
    if not result:
        self.mismatch("Mismatched strings")
else:
    &lt;&lt; Compare single characters &gt;&gt;
</t>
<t tx="ekr.20031218072017.3556">delim = s1[p1]
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1

while result and p1 &lt; len(s1) and p2 &lt; len(s2):
    if s1[p1] == delim and self.is_end_of_string(s1,p1,delim):
        result =(s2[p2] == delim and self.is_end_of_string(s2,p2,delim))
        p1 += 1 ; p2 += 1
        break
    elif g.is_nl(s1,p1) and g.is_nl(s2,p2):
        p1 = g.skip_nl(s1,p1)
        p2 = g.skip_nl(s2,p2)
    else:
        result = s1[p1] == s2[p2]
        p1 += 1 ; p2 += 1
</t>
<t tx="ekr.20031218072017.3557">@
We assume the Pascal string is on a single line so the problems with
cr/lf do not concern us.
@c

first1 = p1 ; first2 = p2
p1 = g.skip_pascal_string(s1,p1)
p2 = g.skip_pascal_string(s2,p2)
result = s1[first1,p1] == s2[first2,p2]
</t>
<t tx="ekr.20031218072017.3558">if s1[p1] == '&lt;':  start_ref = "&lt;&lt;"
else: start_ref = None

# Tangling may insert newlines.
p2 = g.skip_ws_and_nl(s2,p2)

junk, kind1, junk2 = self.is_section_name(s1,p1)
junk, kind2, junk2 = self.is_section_name(s2,p2)

if start_ref and (kind1 != bad_section_name or kind2 != bad_section_name):
    result = self.compare_section_names(s1[p1:],s2[p2:])
    if result:
        p1, junk1, junk2 = self.skip_section_name(s1,p1)
        p2, junk1, junk2 = self.skip_section_name(s2,p2)
    else: self.mismatch("Mismatched section names")
else:
    # Neither p1 nor p2 points at a section name.
    result = s1[p1] == s2[p2]
    p1 += 1 ; p2 += 1
    if not result:
        self.mismatch("Mismatch at '@' or '&lt;'")
</t>
<t tx="ekr.20031218072017.3559">if g.match(s1,p1,self.sentinel) and g.match(s2,p2,self.sentinel):
    first1 = p1 ; first2 = p2
    p1 = g.skip_to_end_of_line(s1,p1)
    p2 = g.skip_to_end_of_line(s2,p2)
    result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    if not result:
        self.mismatch("Mismatched sentinel comments")
elif g.match(s1,p1,self.line_comment) and g.match(s2,p2,self.line_comment):
    first1 = p1 ; first2 = p2
    p1 = g.skip_to_end_of_line(s1,p1)
    p2 = g.skip_to_end_of_line(s2,p2)
    result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    if not result:
        self.mismatch("Mismatched single-line comments")
elif g.match(s1,p1,self.comment) and g.match(s2,p2,self.comment):
    while (p1 &lt; len(s1) and p2 &lt; len(s2) and
        not g.match(s1,p1,self.comment_end) and not g.match(s2,p2,self.comment_end)):
        # ws doesn't have to match exactly either!
        if g.is_nl(s1,p1)or g.is_ws(s1[p1]):
            p1 = g.skip_ws_and_nl(s1,p1)
        else: p1 += 1
        if g.is_nl(s2,p2)or g.is_ws(s2[p2]):
            p2 = g.skip_ws_and_nl(s2,p2)
        else: p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    if g.match(s1,p1,self.comment_end) and g.match(s2,p2,self.comment_end):
        first1 = p1 ; first2 = p2
        p1 += len(self.comment_end)
        p2 += len(self.comment_end)
        result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    else: result = False
    if not result:
        self.mismatch("Mismatched block comments")
elif g.match(s1,p1,self.comment2) and g.match(s2,p2,self.comment2):
    while (p1 &lt; len(s1) and p2 &lt; len(s2) and
        not g.match(s1,p1,self.comment2_end) and not g.match(s2,p2,self.comment2_end)):
        # ws doesn't have to match exactly either!
        if  g.is_nl(s1,p1)or g.is_ws(s1[p1]):
            p1 = g.skip_ws_and_nl(s1,p1)
        else: p1 += 1
        if g.is_nl(s2,p2)or g.is_ws(s2[p2]):
            p2 = g.skip_ws_and_nl(s2,p2)
        else: p2 += 1
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    if g.match(s1,p1,self.comment2_end) and g.match(s2,p2,self.comment2_end):
        first1 = p1 ; first2 = p2
        p1 += len(self.comment2_end)
        p2 += len(self.comment2_end)
        result = self.compare_comments(s1[first1:p1],s2[first2:p2])
    else: result = False
    if not result:
        self.mismatch("Mismatched alternate block comments")
else:
    &lt;&lt; Compare single characters &gt;&gt;
</t>
<t tx="ekr.20031218072017.3560">if result:
    p1 = g.skip_ws_and_nl(s1,p1)
    p2 = g.skip_ws_and_nl(s2,p2)
    result = p1 &gt;= len(s1) and p2 &gt;= len(s2)
    if not result:
        # Show the ends of both parts.
        p1 = len(s1)
        p2 = len(s2)
        self.mismatch("One part ends before the other.")
</t>
<t tx="ekr.20031218072017.3561">if 0:
    g.trace(self.message +
        "\nPart ",part," section ",name,
        "\n1:",g.get_line(s1,p1),
        "\n2:",g.get_line(s2,p2))
</t>
<t tx="ekr.20031218072017.3562">def mismatch (self,message):

    self.message = message
</t>
<t tx="ekr.20031218072017.3563">@

This function scans an entire derived file in s, discovering section or part
definitions.

This is the easiest place to delete leading whitespace from each line: we simply
don't copy it. We also ignore leading blank lines and trailing blank lines. The
resulting definition must compare equal using the "forgiving" compare to any
other definitions of that section or part.

We use a stack to handle nested expansions. The outermost level of expansion
corresponds to the @root directive that created the file. When the stack is
popped, the indent variable is restored.

self.root_name is the name of the file mentioned in the @root directive.

The caller has deleted all body_ignored_newlines from the text.
@c

def scan_derived_file (self,s):

    # g.trace(s)
    c = self.c
    self.def_stack = []
    &lt;&lt; set the private global matching vars &gt;&gt;
    line_indent = 0  # The indentation to use if we see a section reference.
    # indent is the leading whitespace to be deleted.
    i, indent = g.skip_leading_ws_with_indent(s,0,self.tab_width)
    &lt;&lt; Skip the header line output by tangle &gt;&gt;
    # The top level of the stack represents the root.
    self.push_new_def_node(self.root_name,indent,1,1,True)
    while i &lt; len(s):
        if 0:
            eol = g.skip_to_end_of_line(s,i)
            g.trace("i: %s sentinel: %s" % (s[i:eol], self.sentinel))        
        ch = s[i]
        if ch == '\r':
            i += 1 # ignore
        elif ch == '\n':
            &lt;&lt; handle the start of a new line &gt;&gt;
        elif g.match(s,i,self.sentinel) and self.is_sentinel_line(s,i):
            &lt;&lt; handle a sentinel line  &gt;&gt;
        elif g.match(s,i,self.line_comment) or g.match(s,i,self.verbatim):
            &lt;&lt; copy the entire line &gt;&gt;
        elif g.match(s,i,self.comment):
            &lt;&lt; copy a multi-line comment &gt;&gt;
        elif g.match(s,i,self.string1) or g.match(s,i,self.string2):
            &lt;&lt; copy a string &gt;&gt;
        else:
            self.copy(ch) ; i += 1
    &lt;&lt; end all open sections &gt;&gt;
</t>
<t tx="ekr.20031218072017.3565">self.copy(ch) ; i += 1 # This works because we have one-character newlines.
# g.trace("handle start of new line: "+g.get_line(s,i))

# Set line_indent, used only if we see a section reference.
junk, line_indent = g.skip_leading_ws_with_indent(s,i,c.tab_width)
i = g.skip_leading_ws(s,i,indent,c.tab_width) # skip indent leading white space.
</t>
<t tx="ekr.20031218072017.3566">@
This is the place to eliminate the proper amount of whitespace from
the start of each line. We do this by setting the 'indent' variable to
the leading whitespace of the first _non-blank_ line following the
opening sentinel.

Tangle increases the indentation by one tab if the section reference
is not the first non-whitespace item on the line,so self code must do
the same.
@c

# g.trace("handle sentinel line: "+g.get_line(s,i))
result,junk,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
assert(result)
# g.trace("kind %s name %s" % (repr(kind),repr(name)))
# g.trace(repr(self.def_stack))
# g.trace(repr(self.refpart_stack_dump()))
&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;

if kind == start_sentinel_line:
    indent = line_indent
    # Increase line_indent by one tab width if the
    # the section reference does not start the line.
    j = i - 1
    while j &gt;= 0:
        if g.is_nl(s,j):
            break
        elif not g.is_ws(s[j]):
            indent += abs(self.tab_width) ; break
        j -= 1
    # copy the section reference to the _present_ section,
    # but only if this is the first part of the section.
    if part &lt; 2: self.copy(name)
    # Skip to the first character of the new section definition.
    i = g.skip_to_end_of_line(s,i)
    # Start the new section.
    self.push_new_def_node(name,indent,part,of,nl_flag)
    self.select_next_sentinel()
else:
    assert(kind == end_sentinel_line)
    # Skip the sentinel line.
    i = g.skip_to_end_of_line(s,i)
    # Skip a newline only if it was added after(!newline)
    if not nl_flag:
        i = g.skip_ws(s,i)
        i = g.skip_nl(s,i)
        i = g.skip_ws(s,i)
        # Copy any whitespace following the (!newline)
        while end and g.is_ws(s[end]):
            self.copy(s[end])
            end += 1
    # Restore the old indentation level.
    if len(self.def_stack) &gt; 0:
        indent = self.def_stack[-1].indent
    self.select_next_sentinel(part_start_flag=False)

# g.trace(repr(self.def_stack))
# g.trace(repr(self.refpart_stack_dump()))
</t>
<t tx="ekr.20031218072017.3567">@
We have just seen a sentinel line. Any kind of sentinel line will
terminate a previous part of the present definition. For end sentinel
lines, the present section name must match the name on the top of the
stack.
@c

if len(self.def_stack) &gt; 0:
    dn = self.def_stack[-1]
    if self.compare_section_names(name,dn.name):
        dn = self.def_stack.pop()
        if len(dn.code) &gt; 0:
            thePart, found = self.ust_lookup(name,dn.part,False,False) # not root, not update
            # Check for incompatible previous definition.
            if found and not self.forgiving_compare(name,dn.part,dn.code,thePart.code):
                self.error("Incompatible definitions of " + name)
            elif not found:
                self.ust_enter(name,dn.part,dn.of,dn.code,dn.nl_flag,False) # not root
    elif kind == end_sentinel_line:
        self.error("Missing sentinel line for %s found end %s instead" % (name,dn.name))
</t>
<t tx="ekr.20031218072017.3568"># g.trace("copy the entire line:"+g.get_line(s,i))
j = i ; i = g.skip_to_end_of_line(s,i)
self.copy(s[j:i])
</t>
<t tx="ekr.20031218072017.3569"># g.trace("copy a string:"+g.get_line(s,i))
j = i
if self.language == "pascal":
    i = g.skip_pascal_string(s,i)
else:
    i = g.skip_string(s,i)
self.copy(s[j:i])
</t>
<t tx="ekr.20031218072017.3572"># g.trace("end all open sections")
dn= None
while len(self.def_stack) &gt; 0:
    dn = self.def_stack.pop()
    if len(self.def_stack) &gt; 0:
        self.error("Unterminated section: " + dn.name)
if dn:
    # Terminate the root setcion.
    i = len(s)
    if dn.code and len(dn.code) &gt; 0:
        self.ust_enter(dn.name,dn.part,dn.of,dn.code,dn.nl_flag,is_root_flag=True)
    else:
        self.error("Missing root part")
else:
    self.error("Missing root section")
</t>
<t tx="ekr.20031218072017.3573">@
This function handles the actual updating of section definitions in the web.
Only code parts are updated, never doc parts.

During pass 2 of Untangle, skip_body() calls this routine when it discovers the
definition of a section in the outline. We look up the name in the ust. If an
entry exists, we compare the code (the code part of an outline node) with the
code part in the ust. We update the code part if necessary.

We use the forgiving_compare() to compare code parts. It's not possible to
change only trivial whitespace using Untangle because forgiving_compare()
ignores trivial whitespace.
@c

# Major change: 2/23/01: Untangle never updates doc parts.

def update_def (self,name,part_number,head,code,tail,is_root_flag=False): # Doc parts are never updated!

    # g.trace(name,part_number,"===head===\n%s\n===code===\n%s\n===tail===\n%s\n==="%(head,code,tail))
    p = self.p ; body = p.b
    if not head: head = ""
    if not tail: tail = ""
    if not code: code = ""
    false_ret = head + code + tail, len(head) + len(code), False
    part, found = self.ust_lookup(name,part_number,is_root_flag,update_flag=True)
    if not found:
        # g.trace("not found: name &lt;%s&gt; part_number &lt;%s&gt; is_root_flag &lt;%s&gt;" % (name, repr(part_number), repr(is_root_flag)))
        return false_ret  # Not an error.
    ucode = g.toUnicode(part.code,self.encoding)
    &lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;
    # g.trace(ucode)
    if not ucode or len(ucode) == 0:
        return false_ret # Not an error.
    if code and self.forgiving_compare(name,part,code,ucode):
        return false_ret # Not an error.
    # Update the body.
    if not g.unitTesting:
        g.es("***Updating:",p.h)
    ucode = ucode.strip()
    &lt;&lt; Add the trailing whitespace of code to ucode. &gt;&gt;
    &lt;&lt; Move any @language or @comment from code to ucode &gt;&gt;
    body = head + ucode + tail
    self.update_current_vnode(body)
    # g.trace("\nhead:",head,"\nucode:"ucode,"\ntail:",tail)
    return body, len(head) + len(ucode),True
</t>
<t tx="ekr.20031218072017.3574">@
We formerly assumed that any leading comments came from an @doc part, which might
be the case if self.output_doc_flag were true.  For now, we treat leading comments
as "code".

Elsewhere in the code is a comment that "we never update doc parts" when untangling.

Needs to be dealt with.
@c

i = g.skip_blank_lines(ucode,0)
#j = g.skip_ws(ucode,i)
# g.trace("comment,end,single:",self.comment,self.comment_end,self.line_comment)

@
if self.comment and self.comment_end:
    if ucode and g.match(ucode,j,self.comment):
        # Skip to the end of the block comment.
        i = j + len(self.comment)
        i = ucode.find(self.comment_end,i)
        if i == -1: ucode = None # An unreported problem in the user code.
        else:
            i += len(self.comment_end)
            i = g.skip_blank_lines(ucode,i)
elif self.line_comment:
    while ucode and g.match(ucode,j,self.line_comment):
        i = g.skip_line(ucode,i)
        i = g.skip_blank_lines(ucode,i)
        j = g.skip_ws(ucode,i)
# Only the value of ucode matters here.
@c
if ucode: ucode = ucode[i:]
</t>
<t tx="ekr.20031218072017.3575">def update_current_vnode (self,s):

    """Called from within the Untangle logic to update the body text of self.p."""

    c = self.c ; p = self.p
    assert(self.p)
    c.setBodyString(p,s)

    c.setChanged(True)
    p.setDirty()
    p.setMarked()

    # 2010/02/02: was update_after_icons_changed.
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20031218072017.3576">@ These utilities deal with tangle ivars, so they should be methods.
</t>
<t tx="ekr.20031218072017.3577"># Compares section names or root names.
# Arbitrary text may follow the section name on the same line.

def compare_section_names (self,s1,s2):

    # g.trace(g.get_line(s1,0),':',g.get_line(s2,0))
    if g.match(s1,0,"&lt;&lt;") or g.match(s1,0,"@&lt;"):
        # Use a forgiving compare of the two section names.
        delim = "&gt;&gt;"
        i1 = i2 = 0
        while i1 &lt; len(s1) and i2 &lt; len(s2):
            ch1 = s1[i1] ; ch2 = s2[i2]
            if g.is_ws(ch1) and g.is_ws(ch2):
                i1 = g.skip_ws(s1,i1)
                i2 = g.skip_ws(s2,i2)
            elif g.match(s1,i1,delim) and g.match(s2,i2,delim):
                return True
            elif ch1.lower() == ch2.lower():
                i1 += 1 ; i2 += 1
            else: return False
        return False
    else: # A root name.
        return s1 == s2
</t>
<t tx="ekr.20031218072017.3578">def copy (self, s):

    assert(len(self.def_stack) &gt; 0)
    dn = self.def_stack[-1] # Add the code at the top of the stack.
    dn.code += s
</t>
<t tx="ekr.20031218072017.3579">def error (self,s):
    self.errors += 1
    g.es_error(g.translateString(s))

def pathError (self,s):
    if not self.path_warning_given:
        self.path_warning_given = True
        self.error(s)

def warning (self,s):
    g.es_error(g.translateString(s))
</t>
<t tx="ekr.20031218072017.3580"># This function returns True if we are at the end of preprocessor directive.

def is_end_of_directive (self,s,i):

    return g.is_nl(s,i) and not self.is_escaped(s,i)
</t>
<t tx="ekr.20031218072017.3581">def is_end_of_string (self,s,i,delim):

    return i &lt; len(s) and s[i] == delim and not self.is_escaped(s,i)
</t>
<t tx="ekr.20031218072017.3582"># This function returns True if the s[i] is preceded by an odd number of back slashes.

def is_escaped (self,s,i):

    back_slashes = 0 ; i -= 1
    while i &gt;= 0 and s[i] == '\\':
        back_slashes += 1
        i -= 1
    return (back_slashes &amp; 1) == 1
</t>
<t tx="ekr.20031218072017.3583">def is_section_name(self,s,i):

    kind = bad_section_name ; end = -1

    if g.match(s,i,"&lt;&lt;"):
        i, kind, end = self.skip_section_name(s,i)

    # g.trace(kind,g.get_line(s,end))
    return i, kind, end
</t>
<t tx="ekr.20031218072017.3584">@
This function returns True if i points to a line a sentinel line of
one of the following forms:

start_sentinel &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel &lt;&lt;section name&gt;&gt; (n of m) end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; (n of m) end_sentinel

start_sentinel: the string that signals the start of sentinel lines\
end_sentinel:   the string that signals the endof sentinel lines.

end_sentinel may be None,indicating that sentinel lines end with a newline.

Any of these forms may end with (!newline), indicating that the
section reference was not followed by a newline in the orignal text.
We set nl_flag to False if such a string is seen. The name argument
contains the section name.

The valid values of kind param are:

non_sentinel_line,   # not a sentinel line.
start_sentinel_line, #   /// &lt;section name&gt; or /// &lt;section name&gt;(n of m)
end_sentinel_line  //  /// -- end -- &lt;section name&gt; or /// -- end -- &lt;section name&gt;(n of m).
@c
def is_sentinel_line (self,s,i):

    result,i,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
    return result

def is_sentinel_line_with_data (self,s,i):

    start_sentinel = self.sentinel
    end_sentinel = self.sentinel_end
    # g.trace("line: %s start: &lt;%s&gt; end: &lt;%s&gt;" % (s[i:g.skip_to_end_of_line(s,i)],start_sentinel,end_sentinel))
    &lt;&lt; Initialize the return values &gt;&gt;
    &lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;
    &lt;&lt; Set end_flag if we have -- end -- &gt;&gt;
    &lt;&lt; Make sure we have a section reference &gt;&gt;
    &lt;&lt; Set part and of if they exist &gt;&gt;
    &lt;&lt; Set nl_flag to False if !newline exists &gt;&gt;
    &lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;
    kind = g.choose(end_flag,end_sentinel_line,start_sentinel_line)
    return True,i,kind,name,part,of,end,nl_flag
</t>
<t tx="ekr.20031218072017.3585">name = end = None
part = of = 1
kind = non_sentinel_line
nl_flag = True
false_data = (False,i,kind,name,part,of,end,nl_flag)
</t>
<t tx="ekr.20031218072017.3586">if g.is_nl(s,i): i = g.skip_nl(s,i)
i = g.skip_ws(s,i)

# 4/18/00: We now require an exact match of the sentinel.
if g.match(s,i,start_sentinel):
    i += len(start_sentinel)
else:
    return false_data
</t>
<t tx="ekr.20031218072017.3587"># If i points to "-- end --", this code skips it and sets end_flag.

end_flag = False
i = g.skip_ws(s,i)
if g.match(s,i,"--"):
    while i &lt; len(s) and s[i] == '-':
        i += 1
    i = g.skip_ws(s,i)
    if not g.match(s,i,"end"):
        return false_data # Not a valid sentinel line.
    i += 3 ; i = g.skip_ws(s,i)
    if not g.match(s,i,"--"):
        return false_data # Not a valid sentinel line.
    while i &lt; len(s) and s[i] == '-':
        i += 1
    end_flag = True
</t>
<t tx="ekr.20031218072017.3588">i = g.skip_ws(s,i)

if g.match(s,i,"&lt;&lt;"):

    j = i ; i, kind, end = self.skip_section_name(s,i)
    if kind != section_ref:
        return false_data
    name = s[j:i]
else:
    return false_data
</t>
<t tx="ekr.20031218072017.3589"># This code handles (m of n), if it exists.
i = g.skip_ws(s,i)
if g.match(s,i,'('):
    j = i
    i += 1 ; i = g.skip_ws(s,i)
    i, part = self.scan_short_val(s,i)
    if part == -1:
        i = j # back out of the scanning for the number.
        part = 1
    else:
        i = g.skip_ws(s,i)
        if not g.match(s,i,"of"):
            return false_data
        i += 2 ; i = g.skip_ws(s,i)
        i, of = self.scan_short_val(s,i)
        if of == -1:
            return false_data
        i = g.skip_ws(s,i)
        if g.match(s,i,')'):
            i += 1 # Skip the paren and do _not_ return.
        else:
            return false_data
</t>
<t tx="ekr.20031218072017.3590">line = "(!newline)"
i = g.skip_ws(s,i)
if g.match(s,i,line):
    i += len(line)
    nl_flag = False
</t>
<t tx="ekr.20031218072017.3591">i = g.skip_ws(s,i)
if end_sentinel:
    # Make sure the line ends with the end sentinel.
    if g.match(s,i,end_sentinel):
        i += len(end_sentinel)
    else:
        return false_data

end = i # Show the start of the whitespace.
i = g.skip_ws(s,i)
if i &lt; len(s) and not g.is_nl(s,i):
    return false_data
</t>
<t tx="ekr.20031218072017.3592"># This function pushes a new def_node on the top of the section stack.

def push_new_def_node (self,name,indent,part,of,nl_flag):

    # g.trace(name,part)
    node = def_node(name,indent,part,of,nl_flag,None)
    self.def_stack.append(node)
</t>
<t tx="ekr.20031218072017.3593"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):


    if i &gt;= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i &lt; len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val
</t>
<t tx="ekr.20031218072017.3594">def setRootFromHeadline (self,p):

    s = p.h

    if s[0:5] == "@root":
        i,self.start_mode = g.scanAtRootOptions(s,0)
        i = g.skip_ws(s,i)

        if i &lt; len(s): # Non-empty file name.
            # self.root_name must be set later by token_type().
            self.root = s[i:]
            # implement headline @root (but create unit tests first):
            # arguments: name, is_code, is_doc
            # st_enter_root_name(self.root, False, False)
</t>
<t tx="ekr.20031218072017.3596">@
This function skips past a section name that starts with &lt; &lt; and might
end with &gt; &gt; or &gt; &gt; =. The entire section name must appear on the same
line.

Note: this code no longer supports extended noweb mode.

Returns (i, kind, end),
    end indicates the end of the section name itself (not counting the =).
    kind is one of:
        bad_section_name: "no matching "&gt;&gt;" or "&gt;&gt;"  This is _not_ a user error!
        section_ref: &lt; &lt; name &gt; &gt;
        section_def: &lt; &lt; name &gt; &gt; =
        at_root:     &lt; &lt; * &gt; &gt; =
@c
def skip_section_name(self,s,i):

    assert(g.match(s,i,"&lt;&lt;"))
    i += 2
    j = i # Return this value if no section name found.
    kind = bad_section_name ; end = -1 ; empty_name = True

    # Scan for the end of the section name.
    while i &lt; len(s) and not g.is_nl(s,i):
        if g.match(s,i,"&gt;&gt;="):
            i += 3 ; end = i - 1 ; kind = section_def ; break
        elif g.match(s,i,"&gt;&gt;"):
            i += 2 ; end = i ; kind = section_ref ; break
        elif g.is_ws_or_nl(s,i):
            i += 1
        elif empty_name and s[i] == '*':
            empty_name = False
            i = g.skip_ws(s,i+1) # skip the '*'
            if g.match(s,i,"&gt;&gt;="):
                i += 3 ; end = i - 1 ; kind = at_root ; break
        else:
            i += 1 ; empty_name = False

    if empty_name:
        kind = bad_section_name
    if kind == bad_section_name:
        i = j
    return i, kind, end
</t>
<t tx="ekr.20031218072017.3598">def standardize_name (self,name):

    """Removes leading and trailing brackets, converts white space to a single blank and converts to lower case."""

    # Convert to lowercase.
    # Convert whitespace to a single space.
    name = name.lower().replace('\t',' ').replace('  ',' ')

    # Remove leading '&lt;'
    i = 0 ; n = len(name)
    while i &lt; n and name[i] == '&lt;':
        i += 1
    j = i

    # Find the first '&gt;'
    while i &lt; n and name [i] != '&gt;':
        i += 1
    name = name[j:i].strip()

    return name
</t>
<t tx="ekr.20031218072017.3599">def token_type(self,s,i,report_errors=True):

    """This method returns a code indicating the apparent kind of token at the position i.

    The caller must determine whether section definiton tokens are valid.

    returns (kind, end) and sets global root_name using setRootFromText().
    end is only valid for kind in (section_ref, section_def, at_root)."""

    kind = plain_line ; end = -1
    &lt;&lt; set token_type in noweb mode &gt;&gt;
    if kind == at_other :
        &lt;&lt; set kind for directive &gt;&gt;
    # g.trace(kind,g.get_line(s,i))
    return kind, end
</t>
<t tx="ekr.20031218072017.3600">if g.match(s,i,"&lt;&lt;"):
    i, kind, end = self.skip_section_name(s,i)
    if kind == bad_section_name:
        kind = plain_line # not an error.
    elif kind == at_root:
        assert(self.head_root == None)
        if self.head_root:
            self.setRootFromText(self.head_root,report_errors)
        else:
            kind = bad_section_name # The warning has been given.
elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
    # 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_doc)
elif g.match(s,i,"@@"): kind = at_at
elif i &lt; len(s) and s[i] == '@': kind = at_other
else: kind = plain_line
</t>
<t tx="ekr.20031218072017.3602"># This code will return at_other for any directive other than those listed.

if g.match_word(s,i,"@c"):
    # 10/30/02: Only @code starts a code section in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_code)
else:
    for name, theType in [
        ("@chapter", at_chapter),
        ("@code", at_code),
        ("@doc", at_doc),
        ("@root", at_root),
        ("@section", at_section) ]:
        if g.match_word(s,i,name):
            kind = theType ; break

if self.raw_cweb_flag and kind == at_other:
    # 10/30/02: Everything else is plain text in raw cweb mode.
    kind = plain_line

if kind == at_root:
    end = self.setRootFromText(s[i:],report_errors)
</t>
<t tx="ekr.20031218072017.3603">'''Undo manager.'''

@language python
@tabwidth -4
@pagewidth 70

&lt;&lt; How Leo implements unlimited undo &gt;&gt;

import leo.core.leoGlobals as g
# import string

@others
</t>
<t tx="ekr.20031218072017.3605">class undoer:
    """A class that implements unlimited undo and redo."""
    @others
</t>
<t tx="ekr.20031218072017.3606">def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
</t>
<t tx="ekr.20031218072017.3607">def clearIvars (self):

    u = self

    # g.trace(g.callers(5))

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
</t>
<t tx="ekr.20031218072017.3608"></t>
<t tx="ekr.20031218072017.3609">def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
</t>
<t tx="ekr.20031218072017.3610"># Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="ekr.20031218072017.3611">def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
        frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="ekr.20031218072017.3613">def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
</t>
<t tx="ekr.20031218072017.3614"># These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
</t>
<t tx="ekr.20031218072017.3616">def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3630">@language python
@tabwidth -4
@pagewidth 70

"""Leo's base compare class."""

import leo.core.leoGlobals as g
import filecmp
import os
import string

@others
</t>
<t tx="ekr.20031218072017.3631">def choose(cond, a, b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20031218072017.3632">def go ():

    compare = leoCompare(
        commands = None,

        appendOutput = True,

        ignoreBlankLines = True,
        ignoreFirstLine1 = False,
        ignoreFirstLine2 = False,
        ignoreInteriorWhitespace = False,
        ignoreLeadingWhitespace = True,
        ignoreSentinelLines = False,

        limitCount = 9, # Zero means don't stop.
        limitToExtension = ".py",  # For directory compares.
        makeWhitespaceVisible = True,

        printBothMatches = False,
        printMatches = False,
        printMismatches = True,
        printTrailingMismatches = False,

        outputFileName = None)

    if 1: # Compare all files in Tangle test directories

        path1 = "c:\\prog\\test\\tangleTest\\"
        path2 = "c:\\prog\\test\\tangleTestCB\\"
        compare.compare_directories(path1,path2)

    else: # Compare two files.

        name1 = "c:\\prog\\test\\compare1.txt"
        name2 = "c:\\prog\\test\\compare2.txt"
        compare.compare_files(name1,name2)
</t>
<t tx="ekr.20031218072017.3633">class baseLeoCompare:
    """The base class for Leo's compare code."""
    @others

class leoCompare (baseLeoCompare):
    """A class containing Leo's compare code."""
    pass
</t>
<t tx="ekr.20031218072017.3634"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

    # Keyword arguments are much convenient and more clear for scripts.
    commands = None,

    appendOutput = False,

    ignoreBlankLines = True,
    ignoreFirstLine1 = False,
    ignoreFirstLine2 = False,
    ignoreInteriorWhitespace = False,
    ignoreLeadingWhitespace = True,
    ignoreSentinelLines = False,

    limitCount = 0, # Zero means don't stop.
    limitToExtension = ".py",  # For directory compares.
    makeWhitespaceVisible = True,

    printBothMatches = False,
    printMatches = False,
    printMismatches = True,
    printTrailingMismatches = False,

    outputFileName = None ):

    # It is more convenient for the leoComparePanel to set these directly.
    self.c = commands

    self.appendOutput = appendOutput

    self.ignoreBlankLines = ignoreBlankLines
    self.ignoreFirstLine1 = ignoreFirstLine1
    self.ignoreFirstLine2 = ignoreFirstLine2
    self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
    self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
    self.ignoreSentinelLines = ignoreSentinelLines

    self.limitCount = limitCount
    self.limitToExtension = limitToExtension

    self.makeWhitespaceVisible = makeWhitespaceVisible

    self.printBothMatches = printBothMatches
    self.printMatches = printMatches
    self.printMismatches = printMismatches
    self.printTrailingMismatches = printTrailingMismatches

    # For communication between methods...
    self.outputFileName = outputFileName
    self.fileName1 = None 
    self.fileName2 = None
    # Open files...
    self.outputFile = None
</t>
<t tx="ekr.20031218072017.3635"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):

    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)

    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)

    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return None

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)

    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)

    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None

    return None # To keep pychecker happy.
</t>
<t tx="ekr.20031218072017.3636">def compare_files (self, name1, name2):

    if name1 == name2:
        self.show("File names are identical.\nPlease pick distinct files.")
        return

    f1 = f2 = None
    try:
        f1 = self.doOpen(name1)
        f2 = self.doOpen(name2)
        if self.outputFileName:
            self.openOutputFile()
        ok = self.outputFileName == None or self.outputFile
        ok = g.choose(ok and ok != 0,1,0)
        if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
            self.compare_open_files(f1,f2,name1,name2)
    except:
        self.show("exception comparing files")
        g.es_exception()
    try:
        if f1: f1.close()
        if f2: f2.close()
        if self.outputFile:
            self.outputFile.close() ; self.outputFile = None
    except:
        self.show("exception closing files")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3637">def compare_lines (self,s1,s2):

    if self.ignoreLeadingWhitespace:
        s1 = s1.lstrip()
        s2 = s2.lstrip()

    if self.ignoreInteriorWhitespace:
        k1 = g.skip_ws(s1,0)
        k2 = g.skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = tail1.replace(" ","").replace("\t","")
        tail2 = tail2.replace(" ","").replace("\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2
</t>
<t tx="ekr.20031218072017.3638">def compare_open_files (self, f1, f2, name1, name2):

    # self.show("compare_open_files")
    lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = True
    sentinelComment1 = sentinelComment2 = None
    if self.openOutputFile():
        self.show("1: " + name1)
        self.show("2: " + name2)
        self.show("")
    s1 = s2 = None
    &lt;&lt; handle opening lines &gt;&gt;
    while 1:
        if s1 == None:
            s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
        if s2 == None:
            s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
        &lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
        n1 = len(s1) ; n2 = len(s2)
        if n1==0 and n2 != 0: self.show("1.eof***:")
        if n2==0 and n1 != 0: self.show("2.eof***:")
        if n1==0 or n2==0: break
        match = self.compare_lines(s1,s2)
        if not match: mismatches += 1
        &lt;&lt; print matches and/or mismatches &gt;&gt;
        &lt;&lt; warn if mismatch limit reached &gt;&gt;
        s1 = s2 = None # force a read of both lines.
    &lt;&lt; handle reporting after at least one eof is seen &gt;&gt;
</t>
<t tx="ekr.20031218072017.3639">if self.ignoreSentinelLines:

    s1 = g.readlineForceUnixNewline(f1) ; lines1 += 1
    s2 = g.readlineForceUnixNewline(f2) ; lines2 += 1
    # Note: isLeoHeader may return None.
    sentinelComment1 = self.isLeoHeader(s1)
    sentinelComment2 = self.isLeoHeader(s2)
    if not sentinelComment1: self.show("no @+leo line for " + name1)
    if not sentinelComment2: self.show("no @+leo line for " + name2)

if self.ignoreFirstLine1:
    if s1 == None:
        g.readlineForceUnixNewline(f1) ; lines1 += 1
    s1 = None

if self.ignoreFirstLine2:
    if s2 == None:
        g.readlineForceUnixNewline(f2) ; lines2 += 1
    s2 = None
</t>
<t tx="ekr.20031218072017.3640"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
    if self.ignoreBlankLines and len(s1.strip()) == 0:
        s1 = None ; continue

    if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
        s1 = None ; continue

if s2 and len(s2) &gt; 0:
    if self.ignoreBlankLines and len(s2.strip()) == 0:
        s2 = None ; continue

    if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
        s2 = None ; continue
</t>
<t tx="ekr.20031218072017.3641">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

    if match and self.printMatches:

        if self.printBothMatches:
            z1 = "1." + str(lines1)
            z2 = "2." + str(lines2)
            self.dump(z1.rjust(6) + ' :',s1)
            self.dump(z2.rjust(6) + ' :',s2)
        else:
            self.dump(str(lines1).rjust(6) + ' :',s1)

    if not match and self.printMismatches:
        z1 = "1." + str(lines1)
        z2 = "2." + str(lines2)
        self.dump(z1.rjust(6) + '*:',s1)
        self.dump(z2.rjust(6) + '*:',s2)
</t>
<t tx="ekr.20031218072017.3642">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:

    if printTrailing:
        self.show("")
        self.show("limit count reached")
        self.show("")
        printTrailing = False
</t>
<t tx="ekr.20031218072017.3643">if n1 &gt; 0: 
    lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)

if n2 &gt; 0:
    lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + str(lines1))
self.show("lines2:" + str(lines2))
self.show("mismatches:" + str(mismatches))
</t>
<t tx="ekr.20031218072017.3644">def filecmp (self,f1,f2):

    val = filecmp.cmp(f1,f2)
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val
</t>
<t tx="ekr.20031218072017.3645"></t>
<t tx="ekr.20031218072017.3646">def doOpen (self,name):

    try:
        f = open(name,'r')
        return f
    except:
        self.show("can not open:" + '"' + name + '"')
        return None
</t>
<t tx="ekr.20031218072017.3647">def dump (self,tag,s):

    compare = self ; out = tag

    for ch in s[:-1]: # don't print the newline

        if compare.makeWhitespaceVisible:
            if ch == '\t':
                out += "[" ; out += "t" ; out += "]"
            elif ch == ' ':
                out += "[" ; out += " " ; out += "]"
            else: out += ch
        else:
            if 1:
                out += ch
            else: # I don't know why I thought this was a good idea ;-)
                if ch == '\t' or ch == ' ':
                    out += ' '
                else:
                    out += ch

    self.show(out)
</t>
<t tx="ekr.20031218072017.3648">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

    trailingLines = 0
    while 1:
        if not s:
            s = g.readlineForceUnixNewline(f)
        if len(s) == 0: break
        trailingLines += 1
        if self.printTrailingMismatches and printTrailing:
            z = tag + str(line)
            tag2 = z.rjust(6) + "+:"
            self.dump(tag2,s)
        s = None

    self.show(tag + str(trailingLines) + " trailing lines")
    return trailingLines
</t>
<t tx="ekr.20031218072017.3649">@ These methods are based on atFile.scanHeader(). They are simpler
because we only care about the starting sentinel comment: any line
starting with the starting sentinel comment is presumed to be a
sentinel line.
@c

def isLeoHeader (self,s):

    tag = "@+leo"
    j = s.find(tag)
    if j &gt; 0:
        i = g.skip_ws(s,0)
        if i &lt; j: return s[i:j]
        else: return None
    else: return None

def isSentinel (self,s,sentinelComment):

    i = g.skip_ws(s,0)
    return g.match(s,i,sentinelComment)
</t>
<t tx="ekr.20031218072017.365"></t>
<t tx="ekr.20031218072017.3650">def show (self,s):

    # g.pr(s)
    if self.outputFile:
        # self.outputFile is opened in 'wb' mode.
        s = g.toEncodedString(s + '\n')
        self.outputFile.write(s)
    elif self.c:
        g.es(s)
    else:
        g.pr(s)
        g.pr('')
</t>
<t tx="ekr.20031218072017.3651">def showIvars (self):

    self.show("fileName1:"        + str(self.fileName1))
    self.show("fileName2:"        + str(self.fileName2))
    self.show("outputFileName:"   + str(self.outputFileName))
    self.show("limitToExtension:" + str(self.limitToExtension))
    self.show("")

    self.show("ignoreBlankLines:"         + str(self.ignoreBlankLines))
    self.show("ignoreFirstLine1:"         + str(self.ignoreFirstLine1))
    self.show("ignoreFirstLine2:"         + str(self.ignoreFirstLine2))
    self.show("ignoreInteriorWhitespace:" + str(self.ignoreInteriorWhitespace))
    self.show("ignoreLeadingWhitespace:"  + str(self.ignoreLeadingWhitespace))
    self.show("ignoreSentinelLines:"      + str(self.ignoreSentinelLines))
    self.show("")

    self.show("limitCount:"              + str(self.limitCount))
    self.show("printMatches:"            + str(self.printMatches))
    self.show("printMismatches:"         + str(self.printMismatches))
    self.show("printTrailingMismatches:" + str(self.printTrailingMismatches))
</t>
<t tx="ekr.20031218072017.3655">"""The base classes for all Leo Windows, their body, log and tree panes, key bindings and menus.

These classes should be overridden to create frames for a particular gui."""

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import leo.core.leoColor as leoColor
import leo.core.leoMenu as leoMenu
import leo.core.leoNodes as leoNodes
import leo.core.leoUndo as leoUndo

&lt;&lt; About handling events &gt;&gt;
&lt;&lt; define text classes &gt;&gt;

@others
</t>
<t tx="ekr.20031218072017.3656">class leoBody:

    """The base class for the body pane in Leo windows."""

    @others
</t>
<t tx="ekr.20031218072017.3657">def __init__ (self,frame,parentFrame):

    frame.body = self
    self.c = c = frame.c
    self.editorWidgets = {} # keys are pane names, values are text widgets
    self.forceFullRecolorFlag = False
    self.frame = frame
    self.parentFrame = parentFrame # New in Leo 4.6.
    self.totalNumberOfEditors = 0

    # May be overridden in subclasses...
    self.bodyCtrl = self.widget = None
    self.numberOfEditors = 1
    self.pb = None # paned body widget.

    self.use_chapters = c.config.getBool('use_chapters')

    # Must be overridden in subclasses...
    self.colorizer = None
</t>
<t tx="ekr.20031218072017.3658">def oops (self):

    g.trace("leoBody oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20031218072017.366">use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
    cvs add leoConfig.txt
    cvs add leoConfig.py
    (then do commit)

remove readme*.doc
    remove files from working area (done)
    cvs remove readme1.doc
    cvs remove readme2.doc
    ...
    (then do commit)
</t>
<t tx="ekr.20031218072017.3660">mustBeDefinedInSubclasses = (
    # Birth, death &amp; config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
)
</t>
<t tx="ekr.20031218072017.367">@nocolor

- Add new entries in the following Python dictionariues in leoApp.py:
  self.language_delims_dict, self.language_extension_dict and self.extension_dict

- Add an entry to the languages list in &lt;&lt;configure language-specific settings&gt;&gt;

- Add a list of the keywords of the language to &lt;&lt; define colorizer keywords &gt;&gt;

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done.

- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  &lt;&lt; define global colorizer data &gt;&gt;

- Create the files theLanguage.xml and theLanguage.py file was added to the leo\modes directory.
  See Chapter 15 of Leo's users guide for full details.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

@color
</t>
<t tx="ekr.20031218072017.3677">
def getColorizer(self):

    return self.colorizer

def updateSyntaxColorer(self,p):

    return self.colorizer.updateSyntaxColorer(p.copy())

def recolor(self,p,incremental=False):

    self.c.requestRecolorFlag = True
    self.c.incrementalRecolorFlag = incremental

recolor_now = recolor
</t>
<t tx="ekr.20031218072017.3678">class leoFrame:

    """The base class for all Leo windows."""

    instances = 0

    @others
</t>
<t tx="ekr.20031218072017.3679">def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.gui = gui
    self.iconBarClass = nullIconBarClass
    self.statusLineClass = nullStatusLineClass
    self.title = None # Must be created by subclasses.

    # Objects attached to this frame.
    self.body = None
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.log = None
    self.menu = None
    self.miniBufferWidget = None
    self.outerFrame = None
    self.prefsPanel = None
    self.statusLine = None
    self.tree = None
    self.useMiniBufferWidget = False

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.
    self.tab_width = 0 # The tab width in effect in this pane.
</t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @&gt;", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "&lt;!-- --&gt;",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "&lt;!-- --&gt;",
    "xslt"          : "&lt;!-- --&gt;",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
</t>
<t tx="ekr.20031218072017.3680"></t>
<t tx="ekr.20031218072017.3681"># In the Edit menu...

def OnCopy  (self,event=None): self.oops()
def OnCut   (self,event=None): self.oops()

#def OnCutFromMenu  (self,event=None):     self.oops()
#def OnCopyFromMenu (self,event=None):     self.oops()

# Expanding and contracting panes.
def contractPane         (self,event=None): self.oops()
def expandPane           (self,event=None): self.oops()
def contractBodyPane     (self,event=None): self.oops()
def contractLogPane      (self,event=None): self.oops()
def contractOutlinePane  (self,event=None): self.oops()
def expandBodyPane       (self,event=None): self.oops()
def expandLogPane        (self,event=None): self.oops()
def expandOutlinePane    (self,event=None): self.oops()
def fullyExpandBodyPane  (self,event=None): self.oops()
def fullyExpandLogPane   (self,event=None): self.oops()
def fullyExpandPane      (self,event=None): self.oops()
def fullyExpandOutlinePane (self,event=None): self.oops()
def hideBodyPane         (self,event=None): self.oops()
def hideLogPane          (self,event=None): self.oops()
def hidePane             (self,event=None): self.oops()
def hideOutlinePane      (self,event=None): self.oops()

# In the Window menu...
def cascade              (self,event=None): self.oops()
def equalSizedPanes      (self,event=None): self.oops()
def hideLogWindow        (self,event=None): self.oops()
def minimizeAll          (self,event=None): self.oops()
def resizeToScreen       (self,event=None): self.oops()
def toggleActivePane     (self,event=None): self.oops()
def toggleSplitDirection (self,event=None): self.oops()

# In help menu...
def leoHelp (self,event=None): self.oops()
</t>
<t tx="ekr.20031218072017.3682"># Important: nothing would be gained by calling gui versions of these methods:
#            they can be defined in a gui-dependent way in a subclass.

def bringToFront (self):    self.oops()
def deiconify (self):       self.oops()
def get_window_info(self):  self.oops()
def lift (self):            self.oops()
def update (self):          self.oops()
</t>
<t tx="ekr.20031218072017.3683">def resizePanesToRatio (self,ratio,secondary_ratio):    self.oops()
def setInitialWindowGeometry (self):                    self.oops()
def setTopGeometry (self,w,h,x,y,adjustSize=True):      self.oops()
</t>
<t tx="ekr.20031218072017.3687">def setTabWidth (self,w):

    # Subclasses may override this to affect drawing.
    self.tab_width = w
</t>
<t tx="ekr.20031218072017.3688">def getTitle (self):
    return self.title

def setTitle (self,title):
    self.title = title
</t>
<t tx="ekr.20031218072017.3689">def initialRatios (self):

    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
</t>
<t tx="ekr.20031218072017.3690">def longFileName (self):

    return self.c.mFileName

def shortFileName (self):

    return g.shortFileName(self.c.mFileName)
</t>
<t tx="ekr.20031218072017.3691">def oops(self):

    g.pr("leoFrame oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20031218072017.3692">def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # g.pr(answer)
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
</t>
<t tx="ekr.20031218072017.3693"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
</t>
<t tx="ekr.20031218072017.3694">class leoLog:

    """The base class for the log pane in Leo windows."""

    @others
</t>
<t tx="ekr.20031218072017.3695">def __init__ (self,frame,parentFrame):

    self.frame = frame
    if frame: # 7/16/05: Allow no commander for Null logs.
        self.c = frame.c
    else:
        self.c = None
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Official status variables.  Can be used by client code.
    self.canvasCtrl = None # Set below. Same as self.canvasDict.get(self.tabName)
    self.logCtrl = None # Set below. Same as self.textDict.get(self.tabName)
    self.tabName = None # The name of the active tab.
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)

    self.canvasDict = {} # Keys are page names.  Values are Tk.Canvas's.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    self.textDict = {}  # Keys are page names. Values are logCtrl's (text widgets).
</t>
<t tx="ekr.20031218072017.370"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","ruby","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "&lt;&lt;"
    self.rb = "&gt;&gt;"
else:
    self.lb = g.choose(self.language == "cweb","@&lt;","&lt;&lt;")
    self.rb = g.choose(self.language == "cweb","@&gt;","&gt;&gt;")
</t>
<t tx="ekr.20031218072017.3700">def oops (self):

    g.pr("leoLog oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20031218072017.3704"># This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoTree:

    """The base class for the outline pane in Leo windows."""

    @others
</t>
<t tx="ekr.20031218072017.3705">def __init__ (self,frame):

    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widget (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).

    # Debugging.
    self.redrawCount = 0

    # "public" ivars: correspond to setters &amp; getters.
    self.drag_p = None
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.revertHeadline = None
    self.use_chapters = False # May be overridden in subclasses.

    # Define these here to keep pylint happy.
    self.canvas = None
    self.stayInTree = True
    self.trace_select = None
</t>
<t tx="ekr.20031218072017.3706"># Bidings.
def setBindings (self):                         self.oops()

# Fonts.
def getFont(self):                              self.oops()
def setFont(self,font=None,fontName=None):      self.oops()
def setFontFromConfig (self):                   self.oops()

# Drawing &amp; scrolling.
def drawIcon(self,p):                                       self.oops()
def redraw(self,p=None,scroll=True,forceDraw=False):        self.oops()
def redraw_now(self,p=None,scroll=True,forceDraw=False):    self.oops()
def scrollTo(self,p):                           self.oops()
idle_scrollTo = scrollTo # For compatibility.

# Headlines.
def editLabel(self,v,selectAll=False,selection=None): self.oops()
def edit_widget (self,p):                       self.oops() ; return None
def headWidth(self,p=None,s=''):                self.oops() ; return 0
def setEditLabelState(self,v,selectAll=False):  self.oops()
def setSelectedLabelState(self,p):              self.oops()
def setUnselectedLabelState(self,p):            self.oops()
</t>
<t tx="ekr.20031218072017.371">@others
</t>
<t tx="ekr.20031218072017.3716">def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
</t>
<t tx="ekr.20031218072017.3718">def oops(self):

    g.pr("leoTree oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20031218072017.3719">@first # -*- coding: utf-8 -*-

"""A module containing the base leoGui class.

This class and its subclasses hides the details of which gui is actually being used.
Leo's core calls this class to allocate all gui objects.

Plugins may define their own gui classes by setting g.app.gui."""

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import leo.core.leoFind as leoFind # for nullFindTab.
import leo.core.leoFrame as leoFrame # for nullGui.

@others
</t>
<t tx="ekr.20031218072017.372">self.actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
</t>
<t tx="ekr.20031218072017.3720">class leoGui:

    """The base class of all gui classes.

    Subclasses are expected to override all do-nothing methods of this class."""

    &lt;&lt; define leoGui file types &gt;&gt;

    @others
</t>
<t tx="ekr.20031218072017.3721"></t>
<t tx="ekr.20031218072017.3722">def __init__ (self,guiName):

    # g.trace("leoGui",guiName,g.callers())

    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.root = None
    self.script = None
    self.utils = None
    self.isNullGui = False
    self.bodyTextWidget = None
    self.plainTextWidget = None
    self.trace = False

    # To keep pylint happy.
    self.ScriptingControllerClass = nullScriptingControllerClass
</t>
<t tx="ekr.20031218072017.3723"></t>
<t tx="ekr.20031218072017.3724">def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    self.oops()
</t>
<t tx="ekr.20031218072017.3725">def destroySelf (self):

    self.oops()
</t>
<t tx="ekr.20031218072017.3727">def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    self.oops()
</t>
<t tx="ekr.20031218072017.3728">def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    self.oops()
</t>
<t tx="ekr.20031218072017.3729">def runMainLoop(self):

    """Run the gui's main loop."""

    self.oops()
</t>
<t tx="ekr.20031218072017.373">self.c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t",
]

self.cweb_keywords = self.c_keywords
</t>
<t tx="ekr.20031218072017.3730">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()

def runPropertiesDialog(self,title='Properties', data={}, callback=None, buttons=None):
    """Dispay a modal TkPropertiesDialog"""
    self.oops()
</t>
<t tx="ekr.20031218072017.3731">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
</t>
<t tx="ekr.20031218072017.3732">def createColorPanel(self,c):
    """Create a color panel"""
    self.oops()

def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a find tab in the indicated frame."""
    self.oops()

def createFontPanel (self,c):
    """Create a hidden Font panel."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    self.oops()
</t>
<t tx="ekr.20031218072017.3733">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for
None returns.

The type of commander passed to methods depends on the type of frame
or dialog being created. The commander may be a Commands instance or
one of its subcommanders.
</t>
<t tx="ekr.20031218072017.3734">def replaceClipboardWith (self,s):

    self.oops()

def getTextFromClipboard (self):

    self.oops()
</t>
<t tx="ekr.20031218072017.3735">def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self,dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info (self,window):
    """Return the window information."""
    self.oops()
</t>
<t tx="ekr.20031218072017.3736">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    # g.trace('g.app.gui',g.callers()) # 'family',family,'size',size,'defaultSize',defaultSize,
    self.oops()
</t>
<t tx="ekr.20031218072017.3737">def get_focus(self,frame):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self,commander,widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
</t>
<t tx="ekr.20031218072017.3739">def setIdleTimeHook (self,idleTimeHookHandler):

    # g.pr('leoGui:setIdleTimeHook')
    pass # Not an error.

def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    # g.pr('leoGui:setIdleTimeHookAfterDelay')
    pass # Not an error.
</t>
<t tx="ekr.20031218072017.374"># EKR: needs more work.
self.elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
</t>
<t tx="ekr.20031218072017.3740">def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"
</t>
<t tx="ekr.20031218072017.3741">def oops (self):

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.pr("leoGui oops", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20031218072017.3742">class unitTestGui(nullGui):

    '''A gui class for use by unit tests.'''

    # Presently used only by the import/export unit tests.

    @others
</t>
<t tx="ekr.20031218072017.3743">def __init__ (self,theDict=None,trace=False):

    self.oldGui = g.app.gui

    # Init the base class
    nullGui.__init__ (self,"unitTestGui")

    # Use the same kind of widgets as the old gui.
    self.bodyTextWidget = self.oldGui.bodyTextWidget
    self.plainTextWidget = self.oldGui.plainTextWidget

    if theDict is None: theDict = {}
    self.theDict = theDict
    self.trace = trace
    g.app.gui = self

def destroySelf (self):

    g.app.gui = self.oldGui
</t>
<t tx="ekr.20031218072017.3744">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
</t>
<t tx="ekr.20031218072017.3747">def simulateDialog (self,key,defaultVal=None):

    val = self.theDict.get(key,defaultVal)

    if self.trace:
        g.pr(key, val)

    return val
</t>
<t tx="ekr.20031218072017.3749">"""Gui-independent menu handling for Leo."""

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import string
import sys

@others
</t>
<t tx="ekr.20031218072017.375"># No longer used by syntax colorer.
self.html_keywords = []

if 0: # Not used at present.
    self.unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    self.html_specials = [ "&lt;%","%&gt;" ]
</t>
<t tx="ekr.20031218072017.3750">class leoMenu:

    """The base class for all Leo menus."""

    @others
</t>
<t tx="ekr.20031218072017.3751">def __init__ (self,frame):

    # g.trace('leoMenu',g.callers())

    self.c = c = frame.c
    self.frame = frame
    self.menus = {} # Menu dictionary.
    self.menuShortcuts = {}

    # static part of recent files menu
    self.recentFilesStatic = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("Clean Recent Files",None,c.cleanRecentFiles),
        ("Sort Recent Files",None,c.sortRecentFiles),
        # ("-",None,None),
        )

    # To aid transition to emacs-style key handling.
    self.useCmdMenu = c.config.getBool('useCmdMenu')

    self.newBinding = True
        # True if using new binding scheme.
        # You can set this to False in an emergency to revert to the old way.

    if 0: # Must be done much later.
        self.defineMenuTables()
</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20031218072017.3753">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20031218072017.3754">def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20031218072017.3755">def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20031218072017.3756">def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-&amp;next',
        '*find-&amp;prev',
        '*&amp;change',
        '*find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")

    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20031218072017.3758">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20031218072017.3759">def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20031218072017.376">self.java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
</t>
<t tx="ekr.20031218072017.3760">def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save As &amp;Unzipped','save-file-as-unzipped'),
        ('Save As &amp;Zipped','save-file-as-zipped'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20031218072017.3761">def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&amp;check-derived-file',
        '*check-leo-file',
        '-',
        '*&amp;read-outline-only',
        '*write-&amp;outline-only',
        '-',
        '*read-&amp;file-into-node',
        '*writ&amp;e-file-from-node',
        '-',
        ('Read @&amp;auto Nodes','read-at-auto-nodes'),
        ('Write @a&amp;uto Nodes','write-at-auto-nodes'),
        ('Write D&amp;irty @a&amp;uto Nodes','write-dirty-at-auto-nodes'),
        '-',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]

    # a,cd,e,f,i,l,m,n,o,r,u,w
</t>
<t tx="ekr.20031218072017.3762">def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20031218072017.3763">def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20031218072017.3764">def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20031218072017.3765">def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20031218072017.3766">def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20031218072017.3767">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20031218072017.3768">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20031218072017.3769">def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20031218072017.377">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

self.latex_special_keyword_characters = "@(){}%"

self.latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx", "\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap",
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus",
    "\\bigvee", "\\bigwedge", "\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter",
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage",
    "\\cline", "\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh",
    "\\cot", "\\coth", "csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl",
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj",
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath",
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote",
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing",
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright", "\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill", "\\hspace", "\\huge", "\\Huge", "\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota", "\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", "\\linebreak", 
    "\\linethickness", "\\linewidth", "\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow", "longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength", "\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox", "\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", "\\phi", "\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi", "\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", "\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow", "\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow", "\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone", "\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark", "\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title", "\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow", "\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", "\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
</t>
<t tx="ekr.20031218072017.3770">def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20031218072017.3771">def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20031218072017.3772">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &amp;First Node','goto-first-node'),
        ('Go To First V&amp;isible','goto-first-visible-node'),
        ('Go To First Si&amp;bling','goto-first-sibling'),
        '-',
        ('Go To Next C&amp;hanged','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next N&amp;ode','goto-next-node'),
        ('Go To Next &amp;Sibling','goto-next-sibling'),
        ('Go To Next Visibl&amp;e','goto-next-visible'),
        ('Go To Next Visite&amp;d','go-forward'),
        '-',
        ('Go To P&amp;arent','goto-parent'),
        '-',
        ('Go To &amp;Prev Node','goto-prev-node'),
        ('Go To P&amp;rev Sibling','goto-prev-sibling'),
        ('Go To Pre&amp;v Visible','goto-prev-visible'),
        ('Go To Prev Visi&amp;ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&amp;g','goto-last-sibling'),
        ('Go To &amp;Last Visible','goto-last-visible-node'),
    ]
</t>
<t tx="ekr.20031218072017.3773">def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &amp;: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&amp;equal-sized-panes',
        '*&amp;toggle-active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*contract-&amp;body-pane',
        '*contract-&amp;log-pane',
        '*contract-&amp;outline-pane',
        '*contract-&amp;pane',
        '-',
        '*expand-bo&amp;dy-pane',
        '*expand-lo&amp;g-pane',
        '*expand-o&amp;utline-pane',
        '*expand-pa&amp;ne',
        '-',
        '*&amp;fully-expand-body-pane',
        '*full&amp;y-expand-log-pane',
        '*fully-e&amp;xpand-outline-pane',
        '*fully-exp&amp;and-pane',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&amp;window',
    ]
</t>
<t tx="ekr.20031218072017.3774">def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;debugging-commands',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20031218072017.3775">def oops (self):

    g.pr("leoMenu oops:", g.callers(4), "should be overridden in subclass")

def error (self,s):

    g.es_print('',s,color='red')
</t>
<t tx="ekr.20031218072017.3776"></t>
<t tx="ekr.20031218072017.3777">def updateAllMenus (self):

    """The Tk "postcommand" callback called when a click happens in any menu.

    Updates (enables or disables) all menu items."""

    # Allow the user first crack at updating menus.
    c = self.c

    if c and c.exists:
        c.setLog()
        p = c.p

        if not g.doHook("menu-update",c=c,p=p,v=p):
            self.updateFileMenu()
            self.updateEditMenu()
            self.updateOutlineMenu()
</t>
<t tx="ekr.20031218072017.3778">def updateFileMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    try:
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("File")
        if menu:
            enable(menu,"Revert To Saved", c.canRevert())
            enable(menu,"Open With...", g.app.hasOpenWithMenu)
    except:
        g.es("exception updating File menu")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3779">def updateOutlineMenu (self):

    c = self.c ; frame = c.frame
    if not c: return

    p = c.p
    hasParent = p.hasParent()
    hasBack = p.hasBack()
    hasNext = p.hasNext()
    hasChildren = p.hasChildren()
    isExpanded = p.isExpanded()
    isCloned = p.isCloned()
    isMarked = p.isMarked()

    try:
        enable = frame.menu.enableMenu
        &lt;&lt; enable top level outline menu &gt;&gt;
        &lt;&lt; enable expand/contract submenu &gt;&gt;
        &lt;&lt; enable move submenu &gt;&gt;
        &lt;&lt; enable go to submenu &gt;&gt;
        &lt;&lt; enable mark submenu &gt;&gt;
    except:
        g.es("exception updating Outline menu")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.378">self.pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
</t>
<t tx="ekr.20031218072017.3780"># Returns True if text in the outline or body text is selected.

def hasSelection (self):

    c = self.c ; w = c.frame.body.bodyCtrl

    if c.frame.body:
        first,last = w.getSelectionRange()
        return first != last
    else:
        return False
</t>
<t tx="ekr.20031218072017.3781"></t>
<t tx="ekr.20031218072017.3782"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)

def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in","setRealMenuNamesFromTable")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3783">def canonicalizeMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch.isalnum()])

def canonicalizeTranslatedMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch not in '&amp; \t\n\r'])
</t>
<t tx="ekr.20031218072017.3784">def createMenuItemsFromTable (self,menuName,table,dynamicMenu=False):

    try:
        menu = self.getMenu(menuName)
        if menu == None:
            if not g.app.gui.isNullGui:
                g.es_print("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,dynamicMenu=dynamicMenu)
    except:
        g.es_print("exception creating items for",menuName,"menu")
        g.es_exception()

    g.app.menuWarningsGiven = True
</t>
<t tx="ekr.20031218072017.3785">def createMenusFromTables (self):

    c = self.c

    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        self.defineMenuTables()

        self.createFileMenuFromTable()
        self.createEditMenuFromTable()
        self.createOutlineMenuFromTable()

        g.doHook("create-optional-menus",c=c)

        if self.useCmdMenu:
            self.createCmndsMenuFromTable()

        self.createWindowMenuFromTable()
        self.createHelpMenuFromTable()
</t>
<t tx="ekr.20031218072017.3786">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
</t>
<t tx="ekr.20031218072017.3787">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
</t>
<t tx="ekr.20031218072017.3788">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
</t>
<t tx="ekr.20031218072017.3789">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
</t>
<t tx="ekr.20031218072017.379">self.perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 &amp; FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 &amp; f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn",
]

self.perlpod_keywords = self.perl_keywords
</t>
<t tx="ekr.20031218072017.3790">def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
</t>
<t tx="ekr.20031218072017.3791">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
</t>
<t tx="ekr.20031218072017.3792">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
</t>
<t tx="ekr.20031218072017.3793">tangleMenu = self.createNewMenu("Tan&amp;gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
</t>
<t tx="ekr.20031218072017.3794">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
</t>
<t tx="ekr.20031218072017.3795">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
</t>
<t tx="ekr.20031218072017.3796">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
</t>
<t tx="ekr.20031218072017.3797">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;
</t>
<t tx="ekr.20031218072017.3798">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
</t>
<t tx="ekr.20031218072017.3799">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
</t>
<t tx="ekr.20031218072017.380">self.php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]

# The following are supposed to be followed by ()
self.php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]

# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="ekr.20031218072017.3800">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
</t>
<t tx="ekr.20031218072017.3801">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
</t>
<t tx="ekr.20031218072017.3802">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
</t>
<t tx="ekr.20031218072017.3803">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        pass # self.getMacHelpMenu(table)
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
</t>
<t tx="ekr.20031218072017.3804">def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists:",menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0,label=menuName)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&amp;")
            label = label.replace("&amp;","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&amp;")
                index_label = index_label.replace("&amp;","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating",menuName,"menu")
        g.es_exception()
        return None
</t>
<t tx="ekr.20031218072017.3805">def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu:",menuName)
    except:
        g.es("exception deleting",menuName,"menu")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3806">def deleteMenuItem (self,itemName,menuName="top"):

    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found:",menuName)
    except:
        g.es("exception deleting",itemName,"from",menuName,"menu")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.3807">def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    # if cmn == 'openwith': g.trace('leoMenu',g.dictToString(self.menus))
    return self.menus.get(cmn)

def setMenu (self,menuName,menu):

    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu

def destroyMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
</t>
<t tx="ekr.20031218072017.3808"></t>
<t tx="ekr.20031218072017.3809">def add_cascade (self,parent,label,menu,underline):
    self.oops()

def add_command (self,menu,**keys):
    self.oops()

def add_separator(self,menu):
    self.oops()

def bind (self,bind_shortcut,callback):
    self.oops()

def delete (self,menu,realItemName):
    self.oops()

def delete_range (self,menu,n1,n2):
    self.oops()

def destroy (self,menu):
    self.oops()

def insert (self,menuName,position,label,command,underline=None): # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0,label=''): # 2010: added label arg for pylint.
    self.oops() ; return None
</t>
<t tx="ekr.20031218072017.381">self.python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
</t>
<t tx="ekr.20031218072017.3810">def activateMenu (self,menuName): # New in Leo 4.4b2.
    self.oops()

def clearAccel (self,menu,name):
    self.oops()

def createMenuBar (self,frame):
    self.oops()

def createOpenWithMenu (self,parent,label,index,amp_index):
    self.oops() ; return None

def disableMenu (self,menu,name):
    self.oops()

def enableMenu (self,menu,name,val):
    self.oops()

def getMacHelpMenu (self,table):
    return None

def getMenuLabel (self,menu):
    self.oops()

def setMenuLabel (self,menu,name,label,underline=-1):
    self.oops()
</t>
<t tx="ekr.20031218072017.3811">class nullMenu(leoMenu):

    """A null menu class for testing and batch execution."""

    @others
</t>
<t tx="ekr.20031218072017.382">self.rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
</t>
<t tx="ekr.20031218072017.383">self.tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
</t>
<t tx="ekr.20031218072017.384">Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
</t>
<t tx="ekr.20031218072017.385">To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
</t>
<t tx="ekr.20031218072017.386">teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
&gt; I am plowing through old bug reports, and I found the following, from whom 
&gt; I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

&gt;&gt; - Source files still have the dreaded \r in them. Why don't you switch 
&gt;&gt; to \n only, once and for all, and live happily ever after? ;^) 

&gt; I sure whould like to do that, and I'm not sure how to do this. All 
&gt; versions of the read code attempt to remove '\r' characters, and all 
&gt; versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 

</t>
<t tx="ekr.20031218072017.387">Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

&gt; Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
</t>
<t tx="ekr.20031218072017.388">In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; f = open("crlf.txt")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
&gt;&gt;&gt; f = open("crlf.txt", "rU")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline" problem,\n'

</t>
<t tx="ekr.20031218072017.389">&gt; You can open the file in 'binary' mode (adding 'b' to the mode string) and
&gt; the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
</t>
<t tx="ekr.20031218072017.391">@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.
</t>
<t tx="ekr.20031218072017.392"></t>
<t tx="ekr.20031218072017.398">In general, everything you can do in Python is accessible through the C API.

    lines = block.split('\n');

&gt; That will be

    lines = PyObject_CallMethod(block, "split", "s", "\n");
</t>
<t tx="ekr.20031218072017.3980"></t>
<t tx="ekr.20031218072017.3981">def abortEditLabelCommand (self,event=None):

    '''End editing of a headline and revert to its previous value.'''

    frame = self ; c = frame.c ; tree = frame.tree
    p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    # Revert the headline text.
    # Calling c.setHeadString is required.
    # Otherwise c.redraw would undo the change!
    c.setHeadString(p,tree.revertHeadline)
    c.redraw(p)
</t>
<t tx="ekr.20031218072017.3982">def endEditLabelCommand (self,event=None,p=None):

    '''End editing of a headline and move focus to the body pane.'''

    frame = self ; c = frame.c ; k = c.k
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        # g.trace('setting focus')
        if c.config.getBool('stayInTreeAfterEditHeadline'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()

            if k:
                k.setDefaultInputState()
                # Recolor the *body* text, **not** the headline.
                k.showStateAndMode(w=c.frame.body.bodyCtrl)
</t>
<t tx="ekr.20031218072017.3983">def insertHeadlineTime (self,event=None):

    '''Insert a date/time stamp in the headline of the selected node.'''

    frame = self ; c = frame.c ; p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return

    c.endEditing()
    time = c.getTime(body=False)
    s = p.h.rstrip()
    c.setHeadString(p,'%s %s' % (s,time))
    c.redrawAndEdit(p,selectAll=True)
</t>
<t tx="ekr.20031218072017.399"></t>
<t tx="ekr.20031218072017.400">It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\&gt;set PATH=%PATH%;c:\python22\tools\Scripts

C:\&gt;google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\&gt;google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\&gt;
</t>
<t tx="ekr.20031218072017.401">&gt;&gt; It has a header of just one line. All the ugly stuff is at the end.
&gt;&gt;
&gt;&gt; -------------------------------------------------------------------
&gt;&gt; goto ="python"
&gt;&gt;
&gt;&gt; # Python code goes here
&gt;&gt;
&gt;&gt; ''' hybrid python/batch footer:
&gt;&gt; @:="python"
&gt;&gt; @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
&gt;&gt; @if errorlevel 9009 echo Python may be downloaded from
&gt;www.python.org/download
&gt;&gt; @rem '''
&gt;&gt; -------------------------------------------------------------------
&gt;&gt;
&gt;&gt;         Oren
&gt;&gt;
&gt;

It's for running python scripts on windows, without having to type:

[&lt;path to python&gt;\]python[.exe] &lt;scriptname&gt; [&lt;arguments&gt;*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

</t>
<t tx="ekr.20031218072017.4018"></t>
<t tx="ekr.20031218072017.4030">def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before)
    ins    = g.toUnicode(ins)
    after  = g.toUnicode(after)

    return before,ins,after
</t>
<t tx="ekr.20031218072017.4031">def getSelectionAreas (self):

    """Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j: j = i + 1

    before = s[0:i]
    sel    = s[i:j]
    after  = s[j:]

    before = g.toUnicode(before)
    sel    = g.toUnicode(sel)
    after  = g.toUnicode(after)
    return before,sel,after
</t>
<t tx="ekr.20031218072017.4037">def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
</t>
<t tx="ekr.20031218072017.4038">def getYScrollPosition (self):
    return self.bodyCtrl.getYScrollPosition()

def setYScrollPosition (self,scrollPosition):
    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.setYScrollPosition(first)
</t>
<t tx="ekr.20031218072017.4116">def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    trace = False and not g.unitTesting
    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            if trace:
                g.trace('unexpected exception')
                g.es_exception()
            return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        if trace: g.trace('openWithMenu returns None')
        return
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es('','createOpenWithMenuFromTable:','invalid data',color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name,minibufferCommand):

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label)

        return legacyMenuCallback
</t>
<t tx="ekr.20031218072017.4118">def defineOpenWithMenuCallback(self,data):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        return self.c.openWith(data=data)

    return openWithMenuCallback
</t>
<t tx="ekr.20031218072017.4146">def lastVisible(self):

    """Move to the last visible node of the present chapter or hoist."""

    c = self ; p = c.p

    while 1:
        next = p.visNext(c)
        # g.trace('next',next)
        if next and next.isVisible(c):
            p = next
        else: break
    return p
</t>
<t tx="ekr.20031218072017.434">@ignore
@language python
@color
</t>
<t tx="ekr.20031218072017.663"></t>
<t tx="ekr.20031218072017.664">@nocolor

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse.

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node.

Doing copy and paste works normally when done through the edit menu.

@color
</t>
<t tx="ekr.20031218072017.665"></t>
<t tx="ekr.20031218072017.666">@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
</t>
<t tx="ekr.20031218072017.667">abc bbb bbbxyz bbb
</t>
<t tx="ekr.20031218072017.668">@nocolor

Bumping the thread because the bug still persists. 

I've also noticed that the automatic select'n'paste doesn't work between nodes. That is, I can select text and paste a copy of it in the same node with middle button, but if I change click to another node, the paste buffer is erased. The automatic pasting works between Leo and other applications, however, and I can paste between nodes if I copy the selection to buffer by CTR-C. 

Maybe this is related to the non-sticking bug?

----

This may be a Linux-only bug related to the control-v workaround.
</t>
<t tx="ekr.20031218072017.669">These may indicate problems with Tk on Linux.  I can not reproduce them on XP.
</t>
<t tx="ekr.20031218072017.670">(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. 
</t>
<t tx="ekr.20031218072017.671">When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
</t>
<t tx="ekr.20031218072017.672">This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&amp;aid=605277&amp;group_id=12997&amp;atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
</t>
<t tx="ekr.20031218072017.673">The following bugs can not be fixed because they are Tk bugs.
</t>
<t tx="ekr.20031218072017.674">Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
</t>
<t tx="ekr.20031218072017.675">1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.
</t>
<t tx="ekr.20031218072017.676"></t>
<t tx="ekr.20031218072017.677">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

</t>
<t tx="ekr.20031218072017.718"></t>
<t tx="ekr.20031218072017.719">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1906790
By: dspeed
Open Discussion

-- Tabs are not expanded correctly in .c files, when language in preferences is set to c, and when the tabs occur in the middle of a line. The tabs are expanded as spaces until the next tab location is reached, then the tabs are expanded correctly. 
</t>
<t tx="ekr.20031218072017.720">This is a test line.
</t>
<t tx="ekr.20031218072017.721">This is a test line.
put the text insertion point in the space between 'a' and 'test' above. Enter 3 tabs in a row and watch it not work.

If your expansion works correctly, then maybe something with leoconfig?  But wait, Im using the leoconfig from the beta download.

The contents of my Log Windows when opening this file:

Leo Log Window...
Pyton 2.2.2, Tk 8.3.2
reading d:\test.leo


</t>
<t tx="ekr.20031218072017.729"></t>
<t tx="ekr.20031218072017.731">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2283466
By: billp9619

FYI
I played around with opml a while back and it seemed very versatile.

It basically consists of an xml file of nested outline tags similiar to v-nodes
in leo xml. This then works with an xsl stylesheet that displays the outline
in a browser with scripted outline manipulation. (Uses div tags for this
display.)

What I discovered is that any html can make up the outline nodes , even forms,
etc. which collapse with the outline interaction. Just that the angle brackets
in the html must be escaped as is done within leo t nodes in .leo xml.

Actually, it would be interesting to see an addin that just passes leo nodes
to opml and then pops into the default browser. Also keep in mind that javascript
has an eval() statement that can be passed any script as a string. The leo text
box could be a form textarea box except that then there is no way to emulate
syntax coloring. Alternatively, this could be a floating window wrappiing node
text in html/body. (if nothing else, just destroy/close the window and reinitialize).
Maybe the images used in the opml could have javascript events like onclick()
to trigger refreshing leo text box from the t-nodes stored in an array or in
hidden form boxes.

Of course the effect of the stylesheet could be done via python script if no
xslt in the receiving browser. The minimal html and script might be just boilerplate
output.

regards,
bill p
</t>
<t tx="ekr.20031218072017.740">1. Warn when creating _any_ new file.

2. Warn when rewriting any file that was not read properly.

This prevents "hijacking" an already existing file.
</t>
<t tx="ekr.20031218072017.743">http://sourceforge.net/forum/message.php?msg_id=2205285
From: Rich

I envision a short window at the bottom of the edit window that could hold notes
and comments about the code, such as "Test this harder" or "Find a better way of
phrasing this". This is currently available in uSoft Office and the Eclipse IDE
(http://www.eclipse.org). Perhaps a numeric reference, such as "&lt;&lt;1&gt;&gt;" could be
used.
</t>
<t tx="ekr.20031218072017.745">@nocolor

Hate to break into the grand design discussions, but here's a hopefully small thing. If you need to place a good sized copyright statement at the top of your files, LEO doesn't handle this case very cleanly. As I'm sure you're aware, you wind up with a matching number of @@first lines for each leading line in your source. 

As an example: 
# 1 
# 2 
# 3 
# 4 
# 5 
@verbatim
@verbatim
@verbatim
#@+leo 
@verbatim
@verbatim
@verbatim
#@+node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@+body 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@@first 
@verbatim
@verbatim
@verbatim
#@+doc 
# 
# How many firsts do I get? 

@verbatim
@verbatim
@verbatim
#@-doc 
@verbatim
@verbatim
@verbatim
#@@c 
Start code. 
@verbatim
@verbatim
@verbatim
#@-body 
@verbatim
@verbatim
@verbatim
#@-node:0::@file /tmp/firstcheck.py 
@verbatim
@verbatim
@verbatim
#@-leo 

My fellow co-workers who don't use LEO, aren't exactly loving me here. 

Might we introduce an: 

@@first &lt;num&gt; 

Type tag instead? So one '@@first 5' could represent all 5 of the above @@first lines? It makes for a smaller, cleaner LEO footprint and will tick off non-LEO users much less. 

Thanks. 

- ordinarius 
</t>
<t tx="ekr.20031218072017.748">Need a good yaml parser first: I don't want to write another parser by hand.
</t>
<t tx="ekr.20031218072017.753">@nocolor

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
</t>
<t tx="ekr.20031218072017.790">@nocolor

Other options I though would be really handy:

1. Use an existing node as a source also

2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly

3. From a URL.. this would be really cool. People could post outlines not only
as existing Leo xml files, but as text files or even dynamic scripts. The code
to handle these would presumably need to deal with http:// intelligently. But
that's easy in Python. Rebol is great at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

Jason
</t>
<t tx="ekr.20031218072017.793">This is done automatically now!  I may have to use configure events.

&gt; When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
</t>
<t tx="ekr.20031218072017.795">@nocolor

By: nobody ( Nobody/Anonymous ) 
 RE: 3.11 todo list &amp; schedule   
2003-02-11 03:25  

Here are some features I'd like to see: 

3. Metatags. @sectionname or @savedate are expanded to the appropriate text when saved.

-marshall-  

There are quite a few of these now.  It would be good to generalize:
- Register @node type.
</t>
<t tx="ekr.20031218072017.797">@nocolor

I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new"&gt;ftp://user:pass@ftp.sd.org/python/foo.py&gt; 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?

@color
</t>
<t tx="ekr.20031218072017.800">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1858824
By: gilshwartz
Open discusstion

Currently Extract Section is only available if the first line in a selection
is a section name &lt;&lt;x&gt;&gt;. I would like to propose a few enhancements I think
should be useful, while I believe most of the code is already implemented in
Leo.

1. If the first line in a selection is not &lt;&lt;x&gt;&gt;, than Extract Section WILL
make a section name from the first line (or a version of it, see below), leave
the section name in the body, create a new node with that section name, and
will copy the selection including the first line to the new node.

Rational: this is useful when selecting a function or a class. Thus the section
name becomes the function or the class definition. The section name can either
be the full first line, or, knowing the language, Leo can make a nice section
name like it does in import, e.g. "function foo", or "class bar", without the
parameters list.

2. Even better, when Extract Section is called WITHOUT a selection it will look
for the first function/class definition before the cursor's position and will
either use it as a selection and do 1 above, or just mark it as selection, which
will enable 1 above upon a second Extract Section.

Rational: Leo does it beautifully in import and when a node's code starts to
build it is most convenient. Also, I think a variation on this was recently
asked by another user.

3. Add an option Merge Section, which when called from a named section will
merge it back to all the sections containing it.

Rational: make it easy (together with 2) to create/delete sections until the
sections picture of a new code becomes clear.

Gil

--

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1859516
By: nobody

Simpler &amp; more intutive:
Mark text, select from menu - 'extract section', this presents a dialog box
in which you fill in the section name. It is too much work to type &lt;&lt;name&gt;&gt;
then select the whole thing...

As an enhancement, the dialog can show the first line of the selection as the
default section name, which obviously can be changed.

- Rajiv Bhagwat
</t>
<t tx="ekr.20031218072017.805">Maybe the section operator could be customizable, 
I personally prefer the wiki way [[name of section]]. 

@setlink-tag [[ ]] 
</t>
<t tx="ekr.20031218072017.807">@nocolor

Open Discussion
https://sourceforge.net/forum/message.php?msg_id=2003457
By: dsalomoni

Proposal: modify the code for @url so that if you type for example just "@url"
(no file specified) in a headline, a window pops up allowing you to browse the
local file system and select the file (similar to what browsers do when you
want to open a file).

This would be more convenient than manually writing @url
file://a/long/path/to/the/file. @read-only nodes already allow this, it would
perhaps be nice if all these types of plugins (@folder might be another one
for example) and directives (@file etc) had the same behavior (and this should
probably be specified in some guidelines for writing new plugins -see e.g. the
jedit plugin guidelines).

Davide
</t>
<t tx="ekr.20031218072017.810">I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
</t>
<t tx="ekr.20031218072017.822">def createTopologyList (c,root=None,useHeadlines=False):

    """Creates a list describing a node and all its descendents"""

    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(),v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c,child,useHeadlines))
        child = child.next()
    return aList
</t>
<t tx="ekr.20031218072017.833">@nocolor

Open discussion
By: jasonic ( Jason Cunliffe ) 
 use of @language   
2003-07-16 03:40  

I am wondering why Leo does not default to just use the file suffix in @file nodes, instead of obliging @language line in in the body pane 

For example any @file ending with a suffix as defined in the language extensions could just default to use those. 

".py" for python 
".r" for rebol 
".as" for actionscript etc.. 

Should anyone need to over-ride those, they could use @language.
</t>
<t tx="ekr.20031218072017.836">def updateEditMenu (self):

    c = self.c ; frame = c.frame
    w = c.frame.body.bodyCtrl
    if not c: return
    try:
        # Top level Edit menu...
        enable = frame.menu.enableMenu
        menu = frame.menu.getMenu("Edit")
        c.undoer.enableMenuItems()
        &lt;&lt; enable cut/paste &gt;&gt;
        if 0: # Always on for now.
            menu = frame.menu.getMenu("Find...")
            enable(menu,"Find Next",c.canFind())
            flag = c.canReplace()
            enable(menu,"Replace",flag)
            enable(menu,"Replace, Then Find",flag)
        # Edit Body submenu...
        menu = frame.menu.getMenu("Edit Body...")
        if menu:
            enable(menu,"Extract Section",c.canExtractSection())
            enable(menu,"Extract Names",c.canExtractSectionNames())
            enable(menu,"Extract",c.canExtract())
            enable(menu,"Match Brackets",c.canFindMatchingBracket())
    except:
        g.es("exception updating Edit menu")
        g.es_exception()
</t>
<t tx="ekr.20031218072017.839">def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20031218072017.889">&lt;&lt; about the position class &gt;&gt;

# Positions should *never* be saved by the ZOBD.
class position (object):
    @others
</t>
<t tx="ekr.20031218072017.890">@killcolor
@

A position marks the spot in a tree traversal. A position p consists of a vnode
p.v, a child index p._childIndex, and a stack of tuples (v,childIndex), one for
each ancestor **at the spot in tree traversal. Positions p has a unique set of
parents.

The p.moveToX methods may return a null (invalid) position p with p.v = None.

The tests "if p" or "if not p" are the _only_ correct way to test whether a
position p is valid. In particular, tests like "if p is None" or "if p is not
None" will not work properly.
</t>
<t tx="ekr.20031218072017.915"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
# def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()

# New in Leo 4.4.3 b2: add c args.
def getVisBack (self,c): return self.copy().moveToVisBack(c)
def getVisNext (self,c): return self.copy().moveToVisNext(c)

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
# lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext

# New in Leo 4.4.3:
hasVisBack = visBack
hasVisNext = visNext
</t>
<t tx="ekr.20031218072017.951"># Define the meaning of status bits in new vnodes.

# Archived...
clonedBit   = 0x01 # True: vnode has clone mark.
# unused      0x02
expandedBit = 0x04 # True: vnode is expanded.
markedBit   = 0x08 # True: vnode is marked
orphanBit   = 0x10 # True: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # True: vnode is current vnode.
topBit      = 0x40 # True: vnode was top vnode when saved.

# Not archived...
richTextBit = 0x080 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  = 0x100
dirtyBit    = 0x200
writeBit    = 0x400
</t>
<t tx="ekr.20031219074948.1"># From the Python cookbook, recipe 5.23

# This is now defined at the start of this file.
</t>
<t tx="ekr.20040104162835.13">Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


</t>
<t tx="ekr.20040104162835.14">&gt; 1. The python that FC installs is MacPython.  I think that because the
&gt; MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

&gt;
&gt;
&gt; I have the TkTclAquBI (Batteries included) installer.  Is installing 
&gt; this
&gt; enough to get Leo to work with Aqua?  Do I have to de-install the
&gt; present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

</t>
<t tx="ekr.20040104162835.15">Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
</t>
<t tx="ekr.20040104162835.8"></t>
<t tx="ekr.20040105064959">@nocolor
</t>
<t tx="ekr.20040105070023.5">Leo 4.1 rc3, build 1.62 , December 19, 2003
Python 2.3.0, Tk 8.4.2
Linux 2.4.22-21mdkenterprise

1. Any tab typed before the first tab stop behaves correctly (the cursor is moved to the tab stop). Good.

2. Any tab typed after a non-tab character (even a space) _and_ after the first tab stop position doesn't behave like a tab and doesn't move the cursor to the next tab stop. Bad.

3. Any tab typed after a tab character will behave properly no matter what position on the line. Okay.

To reproduce this, set your global tab prefernence to 4. Show invisibles. And then create a node containing:

[BEGIN BODY TEXT]
@language plain
@tabwidth 8
[END BODY TEXT]

Create a child node to that one, containing:

[BEGIN BODY TEXT]
@root-code somefilename
\t\tThis works
bbb\tAnd This works
So\tdoes this

But, this \tdoes not.
Here is the two-tab \t\t behavior.
[END BODY TEXT]

I hope this is a Leo bug and not a Tk bug. 

Dave Hein 
</t>
<t tx="ekr.20040115165036">@language html
@ignore
@color
</t>
<t tx="ekr.20040115165036.1">@ 
This document demonstrates what appears to be a bug in Leo 4.1 rc3, build 1.62 of December 19, 2003.

It has manifested when Leo is executed under Python 2.3.3, Tk 8.4.3 under Windows 2000.

In brief, derived XML files are not well-formed with respect to comments under some conditions.  Comments can wind up nested, which looks okay to humans but not to XML parsers.
@c
</t>
<t tx="ekr.20040115165036.3">@first
@language HTML
&lt;HiMom&gt;
@
This will produce, in the derived file, an XML comment with another XML comment
embedded. Or, if you prefer, it will produce an unclosed XML comment followed by
a well-formed one, followed by a string of text containing a comment-close
marker.

This text is sitting in the inner comment, according to the first view.
@c


@
This comment is well-formed, seemingly because its content does not begin on the
same line as the at-sign.
@c
&lt;/HiMom&gt;
</t>
<t tx="ekr.20040115165036.4">&lt;?xml version='1.0'?&gt;
&lt;!--@+leo-ver=4--&gt;
&lt;!--@+node:@file xmlcommentbug.xml--&gt;
&lt;!--@@first--&gt;
&lt;!--@@language HTML--&gt;
&lt;HiMom&gt;
&lt;!--@+at --&gt;
&lt;!--
&lt;!--@nonl--&gt;
This will produce, in the derived file, an XML comment with another XML 
comment embedded.  Or, if you prefer, it will produce an unclosed XML comment 
followed by a well-formed one, followed by a string of text containing a 
comment-close marker.

This text is sitting in the inner comment, according to the first view.
--&gt;
&lt;!--@-at--&gt;
&lt;!--@@c--&gt;


&lt;!--@+at--&gt;
&lt;!--
This comment is well-formed, seemingly because its content does not begin on 
the same line as the at-sign.
--&gt;
&lt;!--@-at--&gt;
&lt;!--@@c--&gt;
&lt;/HiMom&gt;
&lt;!--@nonl--&gt;
&lt;!--@-node:@file xmlcommentbug.xml--&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20040117092727">By: dthein ( Dave Hein ) 
 RE: BUG: Non-leading tabs not working properl   
2004-01-17 14:40  

 This seems to be a TK bug. I've reproduced the problem directly in Tk.

It's been around for a long time :-(

More details on this page, along with a patch for an earlier version.

http://www.qs.co.nz/Tcl/TkTabs.html

The Tk folks fixed a bug I reported with Ctrl-V behavior, but it took about a year for them to get to it. I don't have high expectations with this problem either, but I'll probably put together a patch for some of the recent version of Tk and submit the patches and bug report.  
</t>
<t tx="ekr.20040117170612"># No longer used.  All code must now be aware of the one-node world.

# def __getattr__ (self,attr):

    # """Convert references to p.t into references to p.v."""

    # if attr=="t":
        # return self.v
    # else:
        # # New in 4.3: _silently_ raise the attribute error.
        # # This allows plugin code to use hasattr(p,attr) !
        # if 0:
            # print("unknown position attribute: %s" % attr)
            # import traceback ; traceback.print_stack()
        # raise AttributeError(attr)
</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
</t>
<t tx="ekr.20040117173448">@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test
whether a position p is valid. In particular, tests like 'if p is
None' or 'if p is not None' will not work properly.
@c

if g.isPython3:

    def __bool__ ( self):

        """Return True if a position is valid."""

        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())

        return self.v is not None

else:

    def __nonzero__ ( self):

        """Return True if a position is valid."""

        # if g.app.trace: "__nonzero__",self.v

        # g.trace(repr(self))

        return self.v is not None
</t>
<t tx="ekr.20040118090055">https://sourceforge.net/forum/message.php?msg_id=2380238
By: dthein

I've submitted a patch and bug report to the Tk project.

The patch, #879073, for those that want to fix this problem on their systems,
is at:

http://sourceforge.net/tracker/?func=detail&amp;aid=879073&amp;group_id=12997&amp;atid=31299
7

And the bug report, #879077, is at:

http://sourceforge.net/tracker/?func=detail&amp;aid=879077&amp;group_id=12997&amp;atid=11299
7

The patch is for 8.4.2.  If you have a different version, you can probably figure
out the changes needed by looking at the patch file.  If not, let me know your
version and I may be able to produce a patch for it.

Note: If you use tabs for anything other than leading whitespace, you will find
this patch really helpful.  I make lots of little tables when I'm documenting
or note-taking ... this fix really helped my sanity when making those tables
inside Leo.

Dave Hein
</t>
<t tx="ekr.20040123102724"></t>
<t tx="ekr.20040125114453">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2391076
By: thyrsus

There is a lot of correct intepretation going on, but there are some errors.
As an example, the anaconda code, in text.py, contains the following lines.
I'll use periods for leading whitespace, the two characters ^I for leading tabs,
and a $ to indicate a newline:

class WaitWindow:
def pop(self):
    self.screen.popWindow()
    self.screen.refresh()

def __init__(self, screen, title, text):
    self.screen = screen
    width = 40
    if (len(text) &lt; width): width = len(text)

    t = TextboxReflowed(width, text)

    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()


After importing file text.py, I get three associated nodes like so:

[class WaitWindow]
.|
.+-[pop]
.|
.+-[__init__]

However, the contents of the nodes are off.  In node [class WaitWindow] the
text is

class WaitWindow:
@others
    self.screen = screen
    width = 40
    if (len(text) &lt; width): width = len(text)

    t = TextboxReflowed(width, text)
    g = GridForm(self.screen, title, 1, 1)
    g.add(t, 0, 0)
    g.draw()
    self.screen.refresh()

Node [pop] contains the text

def pop(self):

Node [__init__] contains the text

self.screen.popWindow()
self.screen.refresh()

def __init__(self, screen, title, text):

This anaconda code is being correctly interpreted by the python 1.5 interpreter.
I'm too green with python to pronounce on whether the formatting is conventional.
I don't consider this a bug a major problem, but it should probably be addressed
before we start touting Leo for large collections of existing code.

This is my first experience importing python; in the past I've imported perl
code, and Leo gave me just one big @file node, and I was on my own to better
structure it.  Given the perversity of perl syntax ("Nothing but perl can parse
Perl." - Tom Christiansen), that's probably the right thing to do.  It's a judgement
call for whomever wants to take responsibility for the python importer as to
whether that may be the right thing to do for python.
</t>
<t tx="ekr.20040129133809.5">sometimes after a drag of a node, 
then the expand/contract doesnt work.
click or menu has no effect.
in an open leo
maybe it is ok after you save the file
other times only fix is to exit &amp; restart.
</t>
<t tx="ekr.20040129133809.8">@nocolor

When opening a .leo file Leo selects the correct node but it is no longer the top most node in the window.

What I did:

- Eliminated entries like a="":  This happened because Leo no longer writes clone bits.

- Made sure Leo writes a="T" entries.  However, Leo really can't use this easily.

Another possibility would be to save the scrolling state, but that is very gui-dependent.
</t>
<t tx="ekr.20040130164211">if frame.body.hasFocus():
    data = w.getSelectedText()
    canCut = data and len(data) &gt; 0
else:
    # This isn't strictly correct, but we can't get the Tk headline selection.
    canCut = True

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = g.app.gui.getTextFromClipboard()
canPaste = data and len(data) &gt; 0
enable(menu,"Paste",canPaste)
</t>
<t tx="ekr.20040131103531">allFullFiletypes = [
    ("All files",   "*"),
    ("C/C++ files", "*.c"),
    ("C/C++ files", "*.cpp"),
    ("C/C++ files", "*.h"),
    ("C/C++ files", "*.hpp"),
    ("Java files",  "*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py")]
    # To do: *.php, *.php3, *.php4")
pythonFullFiletypes = [
    ("Python files","*.py"),
    ("All files","*"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas")]
    # To do: *.php, *.php3, *.php4")
textFullFiletypes = [
    ("Text files","*.txt"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py"),
    ("All files","*")]
    # To do: *.php, *.php3, *.php4")
CWEBTextAllFiletypes = [
    ("CWEB files","*.w"),
    ("Text files","*.txt"),
    ("All files", "*")]
leoAllFiletypes = [
    ("Leo files","*.leo"),
    ("All files","*")]
leoFiletypes = [
    ("Leo files","*.leo")]
nowebTextAllFiletypes = [
    ("Noweb files","*.nw"),
    ("Text files", "*.txt"),
    ("All files",  "*")]
textAllFiletypes = [
    ("Text files","*.txt"),
    ("All files", "*")]
</t>
<t tx="ekr.20040131170659">def canClone (self):

    c = self

    if c.hoistStack:
        current = c.p
        bunch = c.hoistStack[-1]
        return current != bunch.p
    else:
        return True
</t>
<t tx="ekr.20040131171020">menu = frame.menu.getMenu("Outline")
if menu:
    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Paste Node As Clone",c.canPasteOutline())
    enable(menu,"Clone Node",c.canClone()) # 1/31/04
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Hoist",c.canHoist())
    enable(menu,"De-Hoist",c.canDehoist())
</t>
<t tx="ekr.20040131171020.1">menu = frame.menu.getMenu("Expand/Contract...")
if menu:
    enable(menu,"Contract Parent",c.canContractParent())
    enable(menu,"Contract Node",hasChildren and isExpanded)
    enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
    enable(menu,"Expand Node",hasChildren and not isExpanded)
    enable(menu,"Expand Prev Level",hasChildren and isExpanded)
    enable(menu,"Expand Next Level",hasChildren)
    enable(menu,"Expand To Level 1",hasChildren and isExpanded)
    enable(menu,"Expand Or Go Right",hasChildren)
    for i in range(2,9):
        frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
</t>
<t tx="ekr.20040131171020.2">menu = frame.menu.getMenu("Move...")
if menu:
    enable(menu,"Move Down",c.canMoveOutlineDown())
    enable(menu,"Move Left",c.canMoveOutlineLeft())
    enable(menu,"Move Right",c.canMoveOutlineRight())
    enable(menu,"Move Up",c.canMoveOutlineUp())
    enable(menu,"Promote",c.canPromote())
    enable(menu,"Demote",c.canDemote())
</t>
<t tx="ekr.20040131171020.3">menu = frame.menu.getMenu("Go To...")
if menu:
    enable(menu,"Go To Prev Visited",c.nodeHistory.canGoToPrevVisited())
    enable(menu,"Go To Next Visited",c.nodeHistory.canGoToNextVisited())
    enable(menu,"Go To Prev Visible",c.canSelectVisBack())
    enable(menu,"Go To Next Visible",c.canSelectVisNext())
    if 0: # These are too slow.
        enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
        enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
    enable(menu,"Go To Next Clone",isCloned)
    enable(menu,"Go To Prev Node",c.canSelectThreadBack())
    enable(menu,"Go To Next Node",c.canSelectThreadNext())
    enable(menu,"Go To Parent",hasParent)
    enable(menu,"Go To Prev Sibling",hasBack)
    enable(menu,"Go To Next Sibling",hasNext)
</t>
<t tx="ekr.20040131171020.4">menu = frame.menu.getMenu("Mark/Unmark...")
if menu:
    label = g.choose(isMarked,"Unmark","Mark")
    frame.menu.setMenuLabel(menu,0,label)
    enable(menu,"Mark Subheads",hasChildren)
    if 0: # These are too slow.
        enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
        enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
    enable(menu,"Mark Clones",isCloned)
</t>
<t tx="ekr.20040206072057">self.csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
</t>
<t tx="ekr.20040216054459">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2424151
By: ksejlod ( Peter Barrel ) 
 I Have a (maybe) great idea!   
2004-02-15 04:29

I've been using LEO for a while and finding surprinsingly powerfull new uses now
and then, (hey, not a week passes that i dont think to myself : "why did'nt
anyone thought of that kind of tool that is LEO. It's so stupid to program such
a tool, yet no one thought of doing such a thing ! ")

I was wondering if there was a leo keyword (beginning with "@") that would do a
feature I thought would be great: something such as :
@h
@endh
and of course, similarily...
@f
@endf

Standing for "Header", "End Header", "Footer" and "End Footer". Let me please explain ...

When creating files with @file (or nosentinels) I use the keyword "@others" in
the starting node body of the file and place in the file, as it's decendants
(children, grand-children &amp; so on) some clones of other stuff somewhere else
outside of this file (usualy, clones of parts of program regrouped as children
of a "components" node up in the leo outline. Typical Example:

-Introduction
-+components
-a
-b
-c
-+@file program.BAS
-b
-c
-a

a, b, and c are clones and the @file node contains @others.

As you see, I proceed that way because in older programming languages or in lower level languages, the order of components such as procs, declarations, etc as an importance. It also has the implication that &lt;&lt; and &gt;&gt; brackets are irrelevant in my way of using leo.

Now, my feature that I looked for in the doc but could not find (so i suggest it here in case no one had any need of this before) is that when used in the BODY of a node part of an "@file" the @h and @endh would define a chunk of text in the body, you've guessed it, to be added before _each_ children node and ONLY children no grandchildren or any deeper. But It could also be used INSIDE the body of a children to define headers or footers for IT'S OWN direct children.

so, eehh, do you see the relevance of such a feature? Have i explained it clearly? maybe this would help:
CONST baba=2 AS INTEGER
CONST bebe=7 AS INTEGER
CONST zaza=5 AS INTEGER
CONST bobo=1 AS INTEGER
... the beginning and end of each of those "parts-of-a-program" is the same for a potential lot of lines... 

To Be Precise :
It's just really for adding something at end or beginning of a direct children of a node part of an @file in the tangling process. 

Is this feature already implemented but i have not found it? I'm pretty sure it easy to implement... what do you people think of this?
Thanks 
--
k

p.s. I'm the guy who proposed that in the untangling process, a clone would not be updated by it's _Last-Instance-Found_ in the @file beeing untangled, but instead updated by the _Last-Modified-One-Found_ in the @file... :)

(ooouuuuhh that would be slick...)  

By: ksejlod ( Peter Barrel ) 
 RE: I Have a (maybe) great idea!   
2004-02-15 04:35  

 The tree i tried to draw in ascii did not came out the way i did it,
sourceforge "eated" leading spaces sorry a, b and c are children of their "+"
node just above them . -- k
</t>
<t tx="ekr.20040217153407">@template plugin does some (most?) of this.
</t>
<t tx="ekr.20040217153407.1">@nocolor

- There is no way to unify the syntax: a different syntax is needed to specify sections that may appear in pieces.

- I have little interest in this project, even if a better read logic for @root derived files might make automatic untangling possible.
</t>
<t tx="ekr.20040220110030">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2431552
By: nobody

From: Rich

 I just got nipped twice by the following effect: the Caps-Lock key is ON, but
because the LED is on the Caps-Lock key, it is hidden behind my hand. I hit
Ctrl-x, expecting to cut my selection, but the entire node is cut.

   I know there's a problem with tk and the shift key status, so I'm wondering
if it would be possible to change the shape of the cursor when the Caps-Lock
is ON (preferrably a big red flashing blot 8-), or otherwise show that Caps-Lock
is active ( "CAPS" on a status line, for instance).

  Another way: I don't know if this goes against an "anti-modalism rule," but
only allowing Ctrl-Shift-x|c|v in the outline pane would also be acceptable
to me.
</t>
<t tx="ekr.20040228094013"></t>
<t tx="ekr.20040301205720">def __str__ (self):

    p = self

    if p.v:
        return "&lt;pos %d childIndex: %d lvl: %d [%d] %s&gt;" % (
            id(p),p._childIndex,p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d [%d] None&gt;" % (id(p),len(p.stack))

__repr__ = __str__
</t>
<t tx="ekr.20040303163330">def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
</t>
<t tx="ekr.20040303165342">def canDehoist(self):

    c = self
    return c.hoistLevel() &gt; 0

def canHoist(self):

    # N.B.  This is called at idle time, so minimizing positions is crucial!
    c = self
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return bunch.p and not c.isCurrentPosition(bunch.p)
    elif c.currentPositionIsRootPosition():
        return c.currentPositionHasNext()
    else:
        return True
</t>
<t tx="ekr.20040303175026"></t>
<t tx="ekr.20040303175026.10">def moveAfter (self,a):

    """Move a position after position a."""

    p = self # Do NOT copy the position!

    # g.trace('before','p',p,p.stack,'\na',a,a.stack)

    a._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAfter(a)

    # g.trace('before','p',p,p.stack,'\na',a,a.stack)

    return p
</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!

    parent._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsNthChild(parent,n)

    return p
</t>
<t tx="ekr.20040303175026.13"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):

    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p._childIndex

    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result
</t>
<t tx="ekr.20040303175026.14">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))
</t>
<t tx="ekr.20040303175026.15">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )
</t>
<t tx="ekr.20040303175026.16">if not p.v and pv:
    self.invalidOutline ( "Empty t" )
</t>
<t tx="ekr.20040303175026.2">@ This is the main delete routine.
It deletes the receiver's entire tree from the screen.
Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newNode=None):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!

    # Adjust newNode._childIndex if newNode is a following sibling of p.
    sib = p.copy()
    while sib.hasNext():
        sib.moveToNext()
        if sib == newNode:
            newNode._childIndex -= 1
            break

    p._unlink()
</t>
<t tx="ekr.20040303175026.3">def insertAfter (self):

    """Inserts a new position after self.

    Returns the newly created position."""

    p = self ; context = p.v.context
    p2 = self.copy()

    p2.v = vnode(context=context)
    p2.v.iconVal = 0
    p2._linkAfter(p)

    return p2
</t>
<t tx="ekr.20040303175026.4">def insertAsLastChild (self):

    """Inserts a new vnode as the last child of self.

    Returns the newly created position."""

    p = self
    n = p.numberOfChildren()

    return p.insertAsNthChild(n)
</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild (self,n):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.

    Returns the newly created position."""

    p = self ; context = p.v.context
    p2 = self.copy()

    p2.v = vnode(context=context)
    p2.v.iconVal = 0
    p2._linkAsNthChild(p,n)

    return p2
</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.

    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    if oldRoot:
        oldRoot._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsRoot(oldRoot)

    return p
</t>
<t tx="ekr.20040303175026.8">def clone (self):

    """Create a clone of back.

    Returns the newly created position."""

    p = self
    p2 = p.copy() # Do *not* copy the vnode!
    p2._linkAfter(p) # This should "just work"
    return p2
</t>
<t tx="ekr.20040303175026.9"># These used by unit tests and by the group_operations plugin.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2

def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v._headString = p.h
    p2.v._bodyString = p.b

    # 2009/10/02: no need to copy arg to iter
    for child in p.children():
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)
</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
</t>
<t tx="ekr.20040305162628"></t>
<t tx="ekr.20040305222924"></t>
<t tx="ekr.20040305223225">def setHeadString (self,p,s):

    '''Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.'''

    c = self

    p.initHeadString(s)
    p.setDirty()

    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p,s)
</t>
<t tx="ekr.20040305223522">def setBodyString (self,p,s):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v==current.v:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the vnode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20040306060312">def moveToFirstChildOf (self,parent):

    """Move a position to the first child of parent."""

    p = self # Do NOT copy the position!
    p._unlink()
    p._linkAsNthChild(parent,0)
    return p


def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!
    p._unlink()
    n = parent.numberOfChildren()
    p._linkAsNthChild(parent,n)
    return p
</t>
<t tx="ekr.20040306210951"></t>
<t tx="ekr.20040306211032">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atAutoNodeName            (self): return self.v.atAutoNodeName()
def atEditNodeName            (self): return self.v.atEditNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
# def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atShadowFileNodeName      (self): return self.v.atShadowFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtAutoNode            (self): return self.v.isAtAutoNode()
def isAtAutoRstNode         (self): return self.v.isAtAutoRstNode()
def isAtEditNode            (self): return self.v.isAtEditNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
# def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtShadowFileNode      (self): return self.v.isAtShadowFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
</t>
<t tx="ekr.20040306212636"></t>
<t tx="ekr.20040306214240.2"></t>
<t tx="ekr.20040306214240.3">def hasChildren (self):

    p = self
    return len(p.v.children) &gt; 0

hasFirstChild = hasChildren

def numberOfChildren (self):

    p = self
    return len(p.v.children)
</t>
<t tx="ekr.20040306214401">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
</t>
<t tx="ekr.20040306215056">def isCloned (self):

    p = self
    return p.v.isCloned()
</t>
<t tx="ekr.20040306220230">def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
</t>
<t tx="ekr.20040306220230.1">def edit_widget (self,p):

    c = self

    return p and c.frame.tree.edit_widget(p)
</t>
<t tx="ekr.20040306220634"></t>
<t tx="ekr.20040306220634.17"># Compatibility routine for scripts.

def clearVisitedInTree (self):

    for p in self.self_and_subtree():
        p.clearVisited()
</t>
<t tx="ekr.20040306220634.29">def setSelection (self,start,length):

    return self.v.setSelection(start,length)
</t>
<t tx="ekr.20040306220634.8">def computeIcon (self):

    return self.v.computeIcon()

def setIcon (self):

    pass # Compatibility routine for old scripts
</t>
<t tx="ekr.20040306220634.9"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self): return self.v.clearMarked()
def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)

def setMarked   (self): return self.v.setMarked()
def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
</t>
<t tx="ekr.20040307085922">def hasChildren (self):

    v = self
    return len(v.children) &gt; 0

hasFirstChild = hasChildren
</t>
<t tx="ekr.20040307104131.2">def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
</t>
<t tx="ekr.20040307104131.3">def positionExists(self,p,root=None):

    """Return True if a position exists in c's tree"""

    c = self ; p = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        if p == root:
            return True
        if p.hasParent():
            old_v = p.v
            i = p._childIndex
            p.moveToParent()
            children = p.v.children
            # Major bug fix: 2009/1/2 and 2009/1/5
            if i &lt; 0 or i &gt;= len(children) or children[i] != old_v:
                return False
        else:
            # A top-level position, check from hidden root vnode.
            i = p._childIndex
            children = c.hiddenRootNode.children
            return 0 &lt;= i &lt; len(children) and children[i] == p.v

    return False
</t>
<t tx="ekr.20040310062332.1">def invalidOutline (self, message):

    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))
</t>
<t tx="ekr.20040310153624">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):

    p = self
    if p.v:
        p.v.dump() # Don't print a label
</t>
<t tx="ekr.20040311022923"></t>
<t tx="ekr.20040311094927">def nullPosition (self):

    c = self ; v = None
    return leoNodes.position(v)
</t>
<t tx="ekr.20040311113514">def clearDirty (self):

    p = self
    p.v.clearDirty()
</t>
<t tx="ekr.20040311173238">def topPosition(self):

    """Return the root position."""

    c = self

    if c._topPosition:
        return c._topPosition.copy()
    else:
        return c.nullPosition()

def setTopPosition(self,p):

    """Set the root positioin."""

    c = self

    if p:
        c._topPosition = p.copy()
    else:
        c._topPosition = c.nullPosition()

# Define these for compatibiility with old scripts.
topVnode = topPosition
setTopVnode = setTopPosition
</t>
<t tx="ekr.20040312015908"></t>
<t tx="ekr.20040312145256">def dumpLink (self,link):
    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):

    v = self
    print('%s %s %s' % ('-'*10,label,v))
    print('len(parents) %s' % len(v.parents))
    print('len(children) %s' % len(v.children))
    print('parents %s' % g.listToString(v.parents))
    print('children%s' % g.listToString(v.children))
</t>
<t tx="ekr.20040313150633"># Empty tnodeLists are not errors.
v = p.v

if hasattr(v,"tnodeList"): # and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        g.es_print(s,color="blue")
    delattr(v,"tnodeList")
    v._p_changed = True
</t>
<t tx="ekr.20040314035615">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
</t>
<t tx="ekr.20040314035615.1">back = p.back()
next = p.next()

if back:
    assert p == back.next(), 'p!=back.next(),  back: %s back.next: %s' % (
        back,back.next())

if next:
    assert p == next.back(), 'p!=next.back, next: %s next.back: %s' % (
        next,next.back())
</t>
<t tx="ekr.20040314035615.2">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
</t>
<t tx="ekr.20040314043900">if full:
    g.enl()

if errors or verbose:
    color = g.choose(errors,'red','blue')
    g.es_print('',count,'nodes checked',errors,'errors',color=color)
</t>
<t tx="ekr.20040314044652">junk, value, junk = sys.exc_info()

s = "test failed at position %s\n%s" % (repr(p),value)

g.es_print(s,color="red")
</t>
<t tx="ekr.20040315023430">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315023430.1">def convertTreeToString (self):

    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()

    array = []
    for p in p.self_and_subtree():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20040315023430.2">def moreHead (self, firstLevel,useVerticalBar=False):

    """Return the headline string in MORE format."""

    # useVerticalBar is unused, but it would be useful in over-ridden methods.

    p = self
    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")

    return "%s%s %s" % ('\t'*level,plusMinus,p.h)
</t>
<t tx="ekr.20040315023430.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  

    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = p.b.split('\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)
</t>
<t tx="ekr.20040315032144">def setBodyString (self,s):

    # trace = False and not g.unitTesting
    v = self
    # if trace and v._bodyString != s:
        # g.trace('v %s %s -&gt; %s %s\nold: %s\nnew: %s' % (
            # v.h, len(v._bodyString),len(s),g.callers(5),
            # v._bodyString,s))
    v._bodyString = g.toUnicode(s,reportErrors=True)

def setHeadString (self,s):
    v = self
    v._headString = g.toUnicode(s,reportErrors=True)

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
</t>
<t tx="ekr.20040315032503">def appendStringToBody (self,p,s):

    c = self
    if not s: return

    body = p.b
    assert(g.isUnicode(body))
    s = g.toUnicode(s)

    c.setBodyString(p,body + s)
</t>
<t tx="ekr.20040315034158">def setBodyString (self,s):

    p = self
    return p.v.setBodyString(s)

initBodyString = setBodyString
setTnodeText = setBodyString
scriptSetBodyString = setBodyString

def initHeadString (self,s):

    p = self
    p.v.initHeadString(s)

def setHeadString (self,s):

    p = self
    p.v.initHeadString(s)
    # Note: p.setDirty is expensive.
    # We can't change this because Leo's core uses
    # p.setDirty and c.setDirty interchangeably.
    p.setDirty()
</t>
<t tx="ekr.20040315060557">By: nobody ( Nobody/Anonymous ) 
 having a declone() method for vnodes?   
2004-03-15 04:36  

 hi,

Ive had a use for a declone() method in vnodes recently. Have you ever thought about adding a method that declones a clone? This would entail:

1. Making a clone node a normal node.

I can see this happening when cutting a node and pasting a node that is a clone. But there doesn't seem to be a dedicated function to do the operation. :)  
</t>
<t tx="ekr.20040318125934">def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()
</t>
<t tx="ekr.20040321065415">def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children():
        if p.h.strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree():
        if p.h.strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.all_unique_positions():
        if p.h.strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings():
        if p.h.strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
</t>
<t tx="ekr.20040323100443">def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    This is NOT the same as the list of ancestors of the vnode."""

    v = self
    return v.parents
</t>
<t tx="ekr.20040323155951">if not unittest:
    if count % 1000 == 0:
        g.es('','.',newline=False)
    if count % 8000 == 0:
        g.enl()

@others
</t>
<t tx="ekr.20040323160302">def directParents (self):

    return self.v.directParents()
</t>
<t tx="ekr.20040323172420"></t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20040324061854.1"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20040324061854.2"># Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@ New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
</t>
<t tx="ekr.20040324080359.1">def isReadOnly (self,fileName):

    # self.read_only is not valid for Save As and Save To commands.

    if g.os_path_exists(fileName):
        try:
            if not os.access(fileName,os.W_OK):
                g.es("can not write: read only:",fileName,color="red")
                return True
        except Exception:
            pass # os.access() may not exist on all platforms.

    return False
</t>
<t tx="ekr.20040324080819.1">def putLeoFile (self):

    self.updateFixedStatus()
    self.putProlog()
    self.putHeader()
    self.putGlobals()
    self.putPrefs()
    self.putFindSettings()
    #start = g.getTime()
    self.putVnodes()
    #start = g.printDiffTime("vnodes ",start)
    self.putTnodes()
    #start = g.printDiffTime("tnodes ",start)
    self.putPostlog()
</t>
<t tx="ekr.20040324082713"># v.unknownAttributes are now put in &lt;t&gt; elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
</t>
<t tx="ekr.20040325073709">def isAtAutoNode (self):
    return g.choose(self.atAutoNodeName(),True,False)

def isAtAutoRstNode (self):
    return g.choose(self.atAutoRstNodeName(),True,False)

def isAtEditNode (self):
    return g.choose(self.atEditNodeName(),True,False)

def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtShadowFileNode (self):
    return g.choose(self.atShadowFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode   = isAtSilentFileNode
</t>
<t tx="ekr.20040326031436">def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
</t>
<t tx="ekr.20040326064330"># This used to be time-critical code.

def childIndex(self):

    p = self
    return p._childIndex
</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040327105706">def __init__ (self,title,gui,useNullUndoer=False):

    # g.trace('nullFrame')

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)

    self.body = None
    self.bodyCtrl = None
    self.iconBar = nullIconBarClass(self.c,self)
    self.isNullFrame = True
    self.outerFrame = None
    self.statusLineClass = nullStatusLineClass
    self.title = title
    self.tree = nullTree(frame=self) # New in Leo 4.4.4 b3.
    self.useNullUndoer = useNullUndoer

    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20040327105706.2">def finishCreate(self,c):

    self.c = c

    # g.pr('nullFrame')

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)

    # 2010/10/20: The log will be created later.
    # c.setLog()

    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
</t>
<t tx="ekr.20040329094003"></t>
<t tx="ekr.20040329185649"></t>
<t tx="ekr.20040331083824.1"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
</t>
<t tx="ekr.20040331145826">self.rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
</t>
<t tx="ekr.20040401103539">self.css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
</t>
<t tx="ekr.20040401111125">self.shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
</t>
<t tx="ekr.20040411081633">def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20040412060927">def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self
    seen = {}

    print ; print('='*40)
    v = c.hiddenRootNode
    v.dump()
    seen[v] = True
    for p in c.all_positions():
        if p.v not in seen:
            seen[p.v] = True
            p.v.dump()
</t>
<t tx="ekr.20040629162023"></t>
<t tx="ekr.20040701065235.1">def getDescendentAttributes (self,s,tag=""):

    '''s is a list of gnx's, separated by commas from a &lt;v&gt; or &lt;t&gt; element.
    Parses s into a list.

    This is used to record marked and expanded nodes.
    '''

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) &gt; 0]
    # g.trace(tag,result)
    return result
</t>
<t tx="ekr.20040701065235.2">def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
</t>
<t tx="ekr.20040702085529">if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
</t>
<t tx="ekr.20040702104823">def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents():
        if p.isAtIgnoreNode():
            return True

    return False
</t>
<t tx="ekr.20040703054646">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    t = type(obj)
    if t == 'instance' and t != types.UnicodeType:
        try: t = obj.__class__
        except Exception: pass
    if t != types.FrameType:
        r = repr(t) # was type(obj) instead of repr(t)
        n = typesDict.get(r,0) 
        typesDict[r] = n + 1

# Create the union of all the keys.
keys = {}
for key in lastTypesDict:
    if key not in typesDict:
        keys[key]=None

empty = True
for key in keys:
    n3 = lastTypesDict.get(key,0)
    n4 = typesDict.get(key,0)
    delta2 = n4-n3
    if delta2 != 0:
        empty = False
        break

if not empty:
    g.pr('-' * 30)
    g.pr("%s: garbage: %d, objects: %d, delta: %d" % (tag,n,n2,delta))

    if 0:
        for key in sorted(keys):
            n1 = lastTypesDict.get(key,0)
            n2 = typesDict.get(key,0)
            delta2 = n2-n1
            if delta2 != 0:
                g.pr("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
</t>
<t tx="ekr.20040703065638"># import types
import inspect

global lastFunctionsDict

funcDict = {}

# Don't print more than 50 objects.
n = 0
for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        n += 1

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if n &lt; 50 and key not in lastFunctionsDict:
            g.pr(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.pr("args", args)
            if varargs: g.pr("varargs",varargs)
            if varkw: g.pr("varkw",varkw)
            if defaults:
                g.pr("defaults...")
                for s in defaults: g.pr(s)

lastFunctionsDict = funcDict
funcDict = {}
</t>
<t tx="ekr.20040705195048">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars) or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
</t>
<t tx="ekr.20040705201018">def findAtFileName (self,names,h=''):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    # Allow h argument for unit testing.
    if not h: h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(repr(word),repr(name))
        return name
    else:
        return ""
</t>
<t tx="ekr.20040711135244.10">def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
</t>
<t tx="ekr.20040711135244.11">def doOp (self):

    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20040711135244.12">def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
</t>
<t tx="ekr.20040711135244.4">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.h
    s = p.b
    if not s: return

    readlines = g.readLinesClass(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("error pretty-printing",h,"not changed.",color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
</t>
<t tx="ekr.20040711135244.5">class prettyPrinter:

    @others
</t>
<t tx="ekr.20040711135244.6">def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.p
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    &lt;&lt; define dispatch dict &gt;&gt;
</t>
<t tx="ekr.20040711135244.7">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        g.pr("----- line",srow,repr(line))
    self.line = srow

    g.pr("%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val)))
</t>
<t tx="ekr.20040711135244.8">def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
</t>
<t tx="ekr.20040711135244.9">def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
</t>
<t tx="ekr.20040711135959.1"></t>
<t tx="ekr.20040711135959.2"></t>
<t tx="ekr.20040711140738">def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,l,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*compare-&amp;leo-files',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20040711140738.1">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
</t>
<t tx="ekr.20040712045933">import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

# These imports are now done in the ctor and c.finishCreate.
    # import leo.core.leoAtFile as leoAtFile
    # import leo.core.leoCache as leoCashe
    # import leo.core.leoEditCommands as leoEditCommands
    # import leo.core.leoFileCommands as leoFileCommands
    # import leo.core.leoImport as leoImport
    # import leo.core.leoRst as leoRst
    # import leo.core.leoTangle as leoTangle
    # import leo.core.leoUndo as leoUndo

import leo.core.leoNodes as leoNodes
# import leo.external.pickleshare as pickleshare

# import hashlib
import keyword
import os
import subprocess
import sys
import tempfile
import time
import tokenize # for Check Python command
import imp
import re
import itertools

try:
    import tabnanny # for Check Python command # Does not exist in jython
except ImportError:
    tabnanny = None

# The following import _is_ used.
import token    # for Check Python command
</t>
<t tx="ekr.20040712053025">def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_unique_positions():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    return self.prettyPrintAllPythonCode (event,dump)
</t>
<t tx="ekr.20040712053025.1">def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree to make it look more beautiful.'''

    c = self

    if p: root = p.copy()
    else: root = c.p

    pp = c.prettyPrinter(c)

    for p in root.self_and_subtree():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    return self.prettyPrintPythonCode (event,dump)

</t>
<t tx="ekr.20040712084911.1">def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents():
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
</t>
<t tx="ekr.20040713064323">def dumpLines (self,p,lines):

    g.pr('\n','-'*10,p.cleanHeadString())

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,reportErrors=True)
            g.pr(line2,newline=False) # Don't add a trailing newline!)
    else:
        for i in range(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,reportErrors=True)
            g.pr("%3d" % i, repr(lines[i]))
</t>
<t tx="ekr.20040713070356">def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.b
    body = ''.join(lines)

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20040713091855">def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.p

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20040713093048">def clear (self):
    self.lines = []
</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents():
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True

    return False
</t>
<t tx="ekr.20040719161756">"""

Return True if line starts with a sentinel comment.

&gt;&gt;&gt; import leo.core.leoGlobals as g
&gt;&gt;&gt; py_delims = g.comment_delims_from_extension('.py')
&gt;&gt;&gt; g.is_sentinel("#@+node",py_delims)
True
&gt;&gt;&gt; g.is_sentinel("#comment",py_delims)
False

&gt;&gt;&gt; c_delims = g.comment_delims_from_extension('.c')
&gt;&gt;&gt; g.is_sentinel("//@+node",c_delims)
True
&gt;&gt;&gt; g.is_sentinel("//comment",c_delims)
False

&gt;&gt;&gt; html_delims = g.comment_delims_from_extension('.html')
&gt;&gt;&gt; g.is_sentinel("&lt;!--@+node--&gt;",html_delims)
True
&gt;&gt;&gt; g.is_sentinel("&lt;!--comment--&gt;",html_delims)
False

"""
</t>
<t tx="ekr.20040723093558">@ The caller should call g.stripBlankLines before calling this routine
if desired.

This routine does _not_ simply call rstrip(): that would delete all
trailing whitespace-only lines, and in some cases that would change
the meaning of program or data.
@c

def regularizeTrailingNewlines(s,kind):

    """Kind is 'asis', 'zero' or 'one'."""

    pass
</t>
<t tx="ekr.20040723093558.1">def stripBlankLines(s):

    lines = g.splitLines(s)

    for i in range(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j &gt;= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))

    return ''.join(lines)
</t>
<t tx="ekr.20040723094220"># This code is no longer used by any Leo command,
# but it will be retained for use of scripts.
</t>
<t tx="ekr.20040723094220.1">def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_unique_positions():
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (
                not ignoreAtIgnore or not g.scanForAtIgnore(c,p)
            ):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except Exception:
                    return "surprise" # abort
                if unittest and result != "ok":
                    g.pr("Syntax error in %s" % p.cleanHeadString())
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("check complete",color="blue")

    return result
</t>
<t tx="ekr.20040723094220.2">if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20040723094220.3">def checkPythonCode (self,event=None,
    unittest=False,ignoreAtIgnore=True,
    suppressErrors=False,checkOnSave=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.p.self_and_subtree():

        count += 1
        if not unittest and not checkOnSave:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except Exception:
                    return "surprise" # abort

    if not unittest:
        g.es("check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
</t>
<t tx="ekr.20040723094220.4">if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20040723094220.5">def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self ; h = p.h

    # Call getScript to ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        fn = '&lt;node: %s&gt;' % p.h
        if not g.isPython3:
            body = g.toEncodedString(body)
        compile(body+'\n',fn,'exec')
        c.tabNannyNode(p,h,body,unittest,suppressErrors)
    except SyntaxError:
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
            g.es_exception(full=False,color="black")
        if unittest: raise
    except Exception:
        g.es_print('unexpected exception')
        g.es_exception()
        if unittest: raise

</t>
<t tx="ekr.20040723094220.6"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except IndentationError:
        junk,msg,junk = sys.exc_info()
        if not suppressErrors:
            g.es("IndentationError in",headline,color="blue")
            g.es('',msg)
        if unittest: raise

    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.es("TokenError in",headline,color="blue")
            g.es('',msg)
        if unittest: raise

    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("indentation error in",headline,"line",badline,color="blue")
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n",line2)
        if unittest: raise

    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;

    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
</t>
<t tx="ekr.20040731204831">def getLastTracebackFileAndLineNumber():

    typ,val,tb = sys.exc_info()

    if typ == SyntaxError:
        # IndentationError is a subclass of SyntaxError.
        # Much easier in Python 2.6 and 3.x.
        return val.filename,val.lineno
    else:
        # Data is a list of tuples, one per stack entry.
        # Tupls have the form (filename,lineNumber,functionName,text).
        data = traceback.extract_tb(tb)
        if data:
            item = data[-1] # Get the item at the top of the stack.
            filename,n,functionName,text = item
            return filename,n
        else:
            # Should never happen.
            return '&lt;string&gt;',0
</t>
<t tx="ekr.20040803072955.126">def endEditLabel (self):

    '''End editing of a headline and update p.h.'''

    trace = False and g.unitTesting
    c = self.c ; k = c.k ; p = c.p

    if trace: g.trace('leoTree',p and p.h,g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
</t>
<t tx="ekr.20040803072955.128">tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p: # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
</t>
<t tx="ekr.20040803072955.130"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
</t>
<t tx="ekr.20040803072955.133">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
</t>
<t tx="ekr.20040803072955.143">def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController
    redraw_flag = False

    for p in p.parents():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    if trace: g.trace(redraw_flag,repr(p and p.h),g.callers())
    return redraw_flag
</t>
<t tx="ekr.20040803072955.21">def injectCallbacks(self):

    c = self.c

    &lt;&lt; define callbacks to be injected in the position class &gt;&gt;

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):

        g.funcToMethod(f,leoNodes.position)
</t>
<t tx="ekr.20040803072955.22"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
</t>
<t tx="ekr.20040803072955.23">def OnHyperLinkControlClick (self,event=None,c=c):

    """Callback injected into position class."""

    p = self
    if not c or not c.exists:
        return

    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.selectPosition(p)
            c.redraw()
            c.frame.body.bodyCtrl.setInsertPoint(0) # 2007/10/27
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
</t>
<t tx="ekr.20040803072955.24">def OnHyperLinkEnter (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="green") # 10/27/07
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
</t>
<t tx="ekr.20040803072955.25">def OnHyperLinkLeave (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="white") # 2007/20/25

        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '')
</t>
<t tx="ekr.20040803112200"></t>
<t tx="ekr.20040803112450">def isCurrentPosition (self,p):

    c = self

    if p is None or c._currentPosition is None:
        return False
    else:
        return p == c._currentPosition
</t>
<t tx="ekr.20040803112450.1">def isRootPosition (self,p):

    c = self

    if p is None or c._rootPosition is None:
        return False
    else:
        return p == c._rootPosition
</t>
<t tx="ekr.20040803140033">def currentPosition (self):

    """Return the presently selected position."""

    c = self

    if hasattr(c,'_currentPosition') and getattr(c,'_currentPosition'):
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
currentVnode = currentPosition
</t>
<t tx="ekr.20040803140033.1">def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.h,g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p == c._currentPosition:
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
</t>
<t tx="ekr.20040803140033.2">def rootPosition(self):

    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """

    c = self

    if hasattr(c,'_rootPosition') and getattr(c,'_rootPosition'):
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
</t>
<t tx="ekr.20040803140033.3">def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.h,g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p == c._rootPosition:
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
</t>
<t tx="ekr.20040803155551">def currentPositionIsRootPosition (self):

    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """

    c = self

    return (
        c._currentPosition and c._rootPosition and
        c._currentPosition == c._rootPosition)
</t>
<t tx="ekr.20040803160656">def currentPositionHasNext (self):

    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """

    c = self ; current = c._currentPosition 

    return current and current.hasNext()
</t>
<t tx="ekr.20040908104644">To create a splash screen:

- Draw the screen.
- Erase the screen with self.after(5000, self.destroy)
</t>
<t tx="ekr.20040908221501"></t>
<t tx="ekr.20040917061619">def cantImport (moduleName,pluginName=None,verbose=True):

    """Print a "Can't Import" message and return None."""

    s = "Can not import %s" % moduleName
    if pluginName: s = s + " from plugin %s" % pluginName

    if not g.app or not g.app.gui:
        print (s)
    elif g.unitTesting:
        # print s
        return
    elif g.app.gui.guiName() == 'tkinter' and moduleName in ('Tkinter','Pmw'):
        return
    else:
        g.es_print('',s,color="blue")

</t>
<t tx="ekr.20040930064232">def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p

    if p.hasChildren() and p.isExpanded():
        c.contractNode()

    elif p.hasParent() and p.parent().isVisible(c):
        c.goToParent()
</t>
<t tx="ekr.20040930064232.1">def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.p

    if p.hasChildren():
        if p.isExpanded():
            c.selectPosition(p.firstChild())
        else:
            c.expandNode()

    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
</t>
<t tx="ekr.20040930135204">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
</t>
<t tx="ekr.20041005105605.1">@first # -*- coding: utf-8 -*-
    # Needed because of unicode characters in tests.

"""Classes to read and write @file nodes."""

@language python
@tabwidth -4
@pagewidth 60

new_write = True
    # True: write simplified thin sentinels, except for private @shadow files.
    # False: write traditional thin sentinels.

&lt;&lt; imports &gt;&gt;

if False and new_write:
    fill = '=' * 10
    g.es_print('\n==== leoAtFile.py: new_write on ====\n',color='red')

class atFile:

    """The class implementing the atFile subcommander."""

    &lt;&lt; define class constants &gt;&gt;
    &lt;&lt; define sentinelDict &gt;&gt;

    @others
</t>
<t tx="ekr.20041005105605.10">def initCommonIvars (self):

    """Init ivars common to both reading and writing.

    The defaults set here may be changed later."""

    at = self ; c = at.c

    at.at_auto_encoding = c.config.default_at_auto_file_encoding
    at.default_directory = None
    at.encoding = c.config.default_derived_file_encoding
    at.endSentinelComment = ""
    at.errors = 0
    at.inCode = True
    at.indent = 0  # The unit of indentation is spaces, not tabs.
    at.language = None
    at.output_newline = g.getOutputNewline(c=c)
    at.page_width = None
    at.pending = []
    at.raw = False # True: in @raw mode
    at.root = None # The root (a position) of tree being read or written.
    at.root_seen = False # True: root vnode has been handled in this file.
    at.startSentinelComment = ""
    at.startSentinelComment = ""
    at.tab_width  = None
    at.toString = False # True: sring-oriented read or write.
    at.writing_to_shadow_directory = False
</t>
<t tx="ekr.20041005105605.100"># Ooops: shadow files are cleared if there is a read error!!
</t>
<t tx="ekr.20041005105605.101">def  ignoreOldSentinel (self,s,unused_i):

    """Ignore an 3.x sentinel."""

    g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
</t>
<t tx="ekr.20041005105605.102">def  readAfterRef (self,s,i):

    """Read an @afterref sentinel."""

    at = self
    trace = False and not g.unitTesting
    assert g.match(s,i,"afterref"),'missing afterref'

    # Append the next line to the text.
    s = at.readLine(at.inputFile)

    v = at.lastRefNode
    hasList = hasattr(v,'tempBodyList')
    hasString = hasattr(v,'tempBodyString')
    # g.trace('hasList',hasList,'hasString',hasString,'v',v and v.h)

    if at.readVersion5:
        if hasList and at.v.tempBodyList:
            # Remove the trailing newline.
            s2 = at.v.tempBodyList[-1]
            if s2.endswith('\n'): s2 = s2[:-1]
            at.v.tempBodyList[-1] = s2
            if trace: g.trace('v: %30s %s' % (at.v.h,repr(s2+s)))

    at.appendToOut(s)
</t>
<t tx="ekr.20041005105605.103">def readClone (self,s,i):

    at = self ; tag = "clone"

    assert g.match(s,i,tag),'missing clone sentinel'

    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))

    # Get the clone count.
    junk,val = g.skip_long(s,i)

    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
</t>
<t tx="ekr.20041005105605.104">def readComment (self,s,i):

    """Read an @comment sentinel."""

    assert g.match(s,i,"comment"),'missing comment sentinel'

    # Just ignore the comment line!
</t>
<t tx="ekr.20041005105605.105">def readDelims (self,s,i):

    """Read an @delims sentinel."""

    at = self
    assert g.match(s,i-1,"@delims"),'missing @delims'

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)

    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1

    if j &lt; i:
        at.startSentinelComment = s[j:i]

        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.appendToOut(line+'\n')
        else:
            at.endSentinelComment = end
            line = s[i0:i]
            line = line.rstrip()
            at.appendToOut(line+'\n')
    else:
        at.readError("Bad @delims")
        at.appendToOut("@delims")
</t>
<t tx="ekr.20041005105605.106">def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel'
        # The first '@' has already been eaten.

    if trace: g.trace(repr(s[i:]))
        # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    # An @c ends the doc part when using new sentinels.
    if at.readVersion5 and s2 in ('@c','@c\n','@code','@code\n'):
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
        at.inCode = True # End the doc part.

    at.appendToOut(s2)
</t>
<t tx="ekr.20041005105605.107"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
</t>
<t tx="ekr.20041005105605.108">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
</t>
<t tx="ekr.20041005105605.109">def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nl"),'missing nl sentinel'

    if at.inCode:
        at.appendToOut('\n')
    else:
        at.docOut.append('\n')
</t>
<t tx="ekr.20041005105605.11"># These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.at_auto_encoding = c.config.default_at_auto_file_encoding
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
</t>
<t tx="ekr.20041005105605.110">def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nonl"),'missing nonl sentinel'

    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[:-1]] # Do not use at.appendToOut here!
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
</t>
<t tx="ekr.20041005105605.111">@ The sentinel contains an @ followed by a section name in angle brackets.
This code is different from the code for the @@ sentinel: the expansion
of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @&lt;&lt; sentinel."""

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+"),'g.match(s,i,"+")'
        i += 1 # Skip the new plus sign.

        # New in Leo 4.8: Ignore the spellling in leadingWs.
        # Instead, compute lws2, the regularized leading whitespace.
        junk_i,w = g.skip_leading_ws_with_indent(s,0,at.tab_width)
        lws2 = g.computeLeadingWhitespace(max(0,w-at.indent),at.tab_width)
    else:
        lws2 = ''

    j = g.skip_ws(s,i)
    assert g.match(s,j,"&lt;&lt;"),'missing @&lt;&lt; sentinel'

    # g.trace(repr(at.endSentinelComment))
    if len(at.endSentinelComment) == 0:
        if at.readVersion5:
            line = lws2 + s[i:]
        else:
            line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        if at.readVersion5:
            line = lws2 + s[i:k] + '\n' # Restore the newline.
        else:
            line = s[i:k] # No trailing newline, whatever k is.
        # g.trace(repr(line))

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.appendToOut(line)

    if at.readVersion5:
        # g.trace(at.indent,repr(line))
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
        at.endSentinelIndentStack.append(at.indent)
        at.endSentinelStack.append(at.endRef)
        at.endSentinelNodeStack.append(at.v)
    else:
        pass # There is no paired @-ref sentinel.
</t>
<t tx="ekr.20041005105605.112">def readVerbatim (self,s,i):

    """Read an @verbatim sentinel."""

    at = self
    assert g.match(s,i,"verbatim"),'missing verbatim sentinel'

    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    # Do **not** insert the verbatim line itself!
        # at.appendToOut("@verbatim\n")
    at.appendToOut(s[i:])
</t>
<t tx="ekr.20041005105605.113">def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert at.endSentinelStack,'empty sentinel stack'
    s = "(badEndSentinel) Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        if 1: g.trace('%s\n%s' % (
            [at.sentinelName(z) for z in at.endSentinelStack],
            g.callers(4)))
        at.badEndSentinel(expectedKind)
</t>
<t tx="ekr.20041005105605.114">def sentinelKind4(self,s):

    """Return the kind of sentinel at s."""

    trace = False and not g.unitTesting
    verbose = False
    at = self

    val = at.sentinelKind4_helper(s)

    if trace and (verbose or val != at.noSentinel):
        g.trace('%-20s %s' % (
            at.sentinelName(val),s.rstrip()))

    return val
</t>
<t tx="ekr.20041005105605.115">def skipSentinelStart4(self,s,i):

    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert start and len(start)&gt;0,'skipSentinelStart4 1'

    i = g.skip_ws(s,i)
    assert g.match(s,i,start),'skipSentinelStart4 2'
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert i &lt; len(s) and s[i] == '@','skipSentinelStart4 3'
    return i + 1
</t>
<t tx="ekr.20041005105605.116"></t>
<t tx="ekr.20041005105605.117"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j &gt;= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="ekr.20041005105605.118"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j &lt; -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
</t>
<t tx="ekr.20041005105605.119">def createImportedNode (self,root,headline):

    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True

    p.v.setVisited() # Suppress warning about unvisited node.
    return p
</t>
<t tx="ekr.20041005105605.12"># These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root (a position) of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
self.writing_to_shadow_directory = False
</t>
<t tx="ekr.20041005105605.120">def parseLeoSentinel (self,s):

    trace = False and not g.unitTesting
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    start = '' ; end = '' ; isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    &lt;&lt; set the opening comment delim &gt;&gt;
    &lt;&lt; make sure we have @+leo &gt;&gt;
    &lt;&lt; read optional version param &gt;&gt;
    &lt;&lt; read optional thin param &gt;&gt;
    &lt;&lt; read optional encoding param &gt;&gt;
    &lt;&lt; set the closing comment delim &gt;&gt;
    if trace:
        g.trace('valid',valid,'isThin',isThinDerivedFile)
    return valid,new_df,start,end,isThinDerivedFile
</t>
<t tx="ekr.20041005105605.121"># s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i &lt; n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j &lt; i:
    start = s[j:i]
else:
    if trace: g.trace('no opening delim')
    valid = False

</t>
<t tx="ekr.20041005105605.122">@
REM hack: leading whitespace is significant before the
@+leo. We do this so that sentinelKind need not skip
whitespace following self.startSentinelComment. This is
correct: we want to be as restrictive as possible about what
is recognized as a sentinel. This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else:
    if trace: g.trace('no @+leo')
    valid = False
</t>
<t tx="ekr.20041005105605.123">new_df = g.match(s,i,version_tag)

if trace and not new_df:
    g.trace('not new_df',repr(s[0:100]))

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line,
    #                or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1
    at.readVersion = s[j:i] # 2010/05/18.
    at.readVersion5 = at.readVersion &gt;= '5'

    if j &lt; i:
        pass
    else:
        if trace: g.trace('no version')
        valid = False
</t>
<t tx="ekr.20041005105605.124">if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
</t>
<t tx="ekr.20041005105605.125"># Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j &gt; -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j &gt; -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            g.es_print("bad encoding in derived file:",encoding)
    else:
        if trace: g.trace('no encoding')
        valid = False
</t>
<t tx="ekr.20041005105605.126"># The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i &lt; n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
</t>
<t tx="ekr.20041005105605.127">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- read error. line: %s, file: %s" % (
            self.lineNumber,self.targetFileName,))

    # g.trace(self.root,g.callers())
    self.error(message)

    # Delete all of root's tree.
    self.root.v.children = []
    self.root.setDirty()
        # 2010/10/22: the dirty bit gets cleared later, though.
    self.root.setOrphan()

</t>
<t tx="ekr.20041005105605.128">def readLine (self,theFile):

    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    # g.trace(repr(s),g.callers(4))
    u = g.toUnicode(s,self.encoding)
    return u
</t>
<t tx="ekr.20041005105605.129">def scanHeader(self,theFile,fileName):

    """Scan the @+leo sentinel.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file."""

    trace = False and not g.unitTesting
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
        # g.trace('start',repr(start),'end',repr(end))
    else:
        at.error("No @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    # g.trace(fileName,firstLines)
    return firstLines,new_df,isThinDerivedFile
</t>
<t tx="ekr.20041005105605.13">def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):
    at = self

    at.initCommonIvars()

    at.cloneSibCount = 0
        # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
    at.correctedLines = 0
        # For perfect import.
    at.docOut = [] # The doc part being accumulated.
    at.done = False # True when @-leo seen.
    at.endSentinelIndentStack = []
        # Restored indentation for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelStack = []
        # Contains entries for +node sentinels only when not readVersion5
    at.endSentinelLevelStack = []
        # The saved level, len(at.thinNodeStack), for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelNodeStack = []
        # Used only when readVersion5.
    at.fromString = False
    at.importing = bool(importFileName)
    at.importRootSeen = False
    at.indentStack = []
    at.inputFile = None
    at.lastLines = [] # The lines after @-leo
    at.lastRefNode = None
        # The previous reference node, for at.readAfterRef.
        # No stack is needed because -&lt;&lt; sentinels restore at.v
        # to the node needed by at.readAfterRef.
    at.lastThinNode = None
        # The last thin node at this level.
        # Used by createThinChild4.
    at.leadingWs = ""
    at.lineNumber = 0 # New in Leo 4.4.8.
    at.out = None
    at.outStack = []
    at.perfectImportRoot = perfectImportRoot
    at.readVersion = ''
        # New in Leo 4.8: "4" or "5" for new-style thin files.
    at.readVersion5 = False
        # synonym for at.readVersion &gt;= '5' and not atShadow.
        # set by at.parseLeoSentinel()
    at.root = root
    at.rootSeen = False
    at.atShadow = atShadow
    at.targetFileName = fileName
    at.tnodeList = []
        # Needed until old-style @file nodes are no longer supported.
    at.tnodeListIndex = 0
    at.v = None
    at.vStack = [] # Stack of at.v values.
    at.thinFile = False # 2010/01/22: was thinFile
    at.thinNodeStack = [] # Entries are vnodes.
    at.updateWarningGiven = False
</t>
<t tx="ekr.20041005105605.130">@ Queue up the lines before the @+leo.

These will be used to add as parameters to the @first directives, if any.
Empty lines are ignored (because empty @first directives are ignored).
NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on
the comment delimiters we set here.

at-first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
if trace: g.trace('first line',repr(s))
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)

n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20041005105605.131"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i &lt; n and ws &lt; width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i
</t>
<t tx="ekr.20041005105605.132"></t>
<t tx="ekr.20041005105605.133"></t>
<t tx="ekr.20041005105605.135"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        # g.trace('**closing',at.outputFileName,at.outputFile)
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
</t>
<t tx="ekr.20041005105605.14">self.cloneSibCount = 0
    # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelIndentStack = []
    # Restored indentation for @-others and @-&lt;&lt; sentinels.
    # Used only when readVersion5.
self.endSentinelStack = []
    # Contains entries for +node sentinels only when not readVersion5
self.endSentinelLevelStack = []
    # The saved level, len(at.thinNodeStack), for @-others and @-&lt;&lt; sentinels.
    # Used only when readVersion5.
self.endSentinelNodeStack = []
    # Used only when readVersion5.
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastRefNode = None
    # The previous reference node, for at.readAfterRef.
    # No stack is needed because -&lt;&lt; sentinels restore at.v
    # to the node needed by at.readAfterRef.
self.lastThinNode = None
    # The last thin node at this level.
    # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.readVersion = '' # New in Leo 4.8: "4" or "5" for new-style thin files.
self.readVersion5 = False # synonym for at.readVersion &gt;= '5' and not atShadow.
self.rootSeen = False
self.tnodeList = []
    # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.vStack = [] # Stack of at.v values.
self.thinNodeStack = [] # Entries are vnodes.
self.updateWarningGiven = False
</t>
<t tx="ekr.20041005105605.142">def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        ok = at.openFileForWritingHelper(fileName)

        # New in Leo 4.4.8: set dirty bit if there are errors.
        if not ok: at.outputFile = None

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
</t>
<t tx="ekr.20041005105605.143">def openFileForWritingHelper (self,fileName):

    '''Open the file and return True if all went well.'''

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        at.targetFileName = c.os_path_finalize_join(at.default_directory,fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return False
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return False

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not open: read only: " + at.targetFileName)
                return False
        except AttributeError:
            pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        kind,at.outputFile = self.openForWrite(at.outputFileName,'wb')
        if not at.outputFile:
            kind = g.choose(kind=='check',
                'did not overwrite','can not create')
            at.writeError("%s %s" % (kind,at.outputFileName))
            return False
    except Exception:
        at.exception("exception creating:" + at.outputFileName)
        return False

    return True
</t>
<t tx="ekr.20041005105605.144">def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    &lt;&lt; set at.targetFileName &gt;&gt;
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)

    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn',exists,eventualFileName)

    if not scriptWrite and not toString:
        # 2010/7/28: The read logic now sets the at_read bit for @nosent nodes,
        # so we can just use promptForDangerousWrite.
        if not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                &lt;&lt; set dirty and orphan bits &gt;&gt; # 2010/10/21.
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root,'write'
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors &gt; 0 or root.isOrphan():
                &lt;&lt; set dirty and orphan bits &gt;&gt;
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
</t>
<t tx="ekr.20041005105605.145">if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
</t>
<t tx="ekr.20041005105605.146"># Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

</t>
<t tx="ekr.20041005105605.147">def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False
):

    """Write @file nodes in all or part of the outline"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
    writtenFiles = [] # Files that might be written again.
    force = writeAtFileNodesFlag

    if writeAtFileNodesFlag:
        # The Write @&lt;file&gt; Nodes command.
        # Write all nodes in the selected tree.
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    at.clearAllOrphanBits(p)
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
        c.scanAtPathDirectivesCount-scanAtPathDirectivesCount))
</t>
<t tx="ekr.20041005105605.148">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

def clearAllOrphanBits (self,p):

    for v2 in p.self_and_subtree():
        v2.clearOrphan()
</t>
<t tx="ekr.20041005105605.149">def writeAllHelper (self,p,
    force,toString,writeAtFileNodesFlag,writtenFiles
):

    trace = False and not g.unitTesting
    at = self ; c = at.c

    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        pathChanged = False
    else:
        oldPath = at.getPathUa(p).lower()
        newPath = at.fullPath(p).lower()
        pathChanged = oldPath and oldPath != newPath
        # 2010/01/27: suppress this message during save-as and save-to commands.
        if pathChanged and not c.ignoreChangedPaths:
            at.setPathUa(p,newPath) # Remember that we have changed paths.
            g.es_print('path changed for',p.h,color='blue')
            if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
                p.h,repr(oldPath),repr(newPath)))

    if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v in writtenFiles:

        # Tricky: @ignore not recognised in @asis nodes.
        if p.isAtAsisFileNode():
            at.asisWrite(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtIgnoreNode():
            pass
        elif p.isAtAutoNode():
            at.writeOneAtAutoNode(p,toString=toString,force=force)
            writtenFiles.append(p.v)
        elif p.isAtEditNode():
            at.writeOneAtEditNode(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtNoSentFileNode():
            at.write(p,kind='@nosent',nosentinels=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtShadowFileNode():
            at.writeOneAtShadowNode(p,toString=toString,force=force or pathChanged)
            writtenFiles.append(p.v)
        elif p.isAtThinFileNode():
            at.write(p,kind='@thin',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtFileNode():
            # Write old @file nodes using @thin format.
            at.write(p,kind='@file',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
</t>
<t tx="ekr.20041005105605.15">def initWriteIvars(self,root,targetFileName,
    atAuto=False,atEdit=False,atShadow=False,
    nosentinels=False,thinFile=False,
    scriptWrite=False,toString=False,
    forcePythonSentinels=None,
):
    at = self ; c = at.c

    assert root
    self.initCommonIvars()

    at.atAuto = atAuto
    at.atEdit = atEdit
    at.atShadow = atShadow
    # at.default_directory: set by scanAllDirectives()
    at.docKind = None
    if forcePythonSentinels:
        at.endSentinelComment = None
    # else: at.endSentinelComment set by initCommonIvars.
    # at.encoding: set by scanAllDirectives() below.
    # at.explicitLineEnding # True: an @lineending directive specifies the ending.
        # Set by scanAllDirectives() below.
    at.fileChangedFlag = False # True: the file has actually been updated.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force_newlines_in_at_nosent_bodies')
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite
    # at.language:      set by scanAllDirectives() below.
    # at.outputFile:    set below.
    # at.outputNewline: set below.
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        at.startSentinelComment = "#"
    # else:                 set by initCommonIvars.
    # at.stringOutput:      set below.
    # at.outputFileName:    set below.
    # at.output_newline:    set by scanAllDirectives() below.
    # at.page_width:        set by scanAllDirectives() below.
    at.sentinels = not nosentinels
    at.shortFileName = ""   # For messages.
    at.root = root
    # at.tab_width:         set by scanAllDirectives() below.
    at.targetFileName = targetFileName
        # Must be None for @shadow.
    at.thinFile = thinFile
    at.toString = toString
    at.writeVersion5 = at.new_write and not atShadow

    at.scanAllDirectives(root,
        scripting=scriptWrite,
        forcePythonSentinels=forcePythonSentinels,
        issuePathWarning=True)
    # Sets the following ivars:
        # at.default_directory
        # at.encoding
        # at.explicitLineEnding
        # at.language
        # at.output_newline
        # at.page_width
        # at.tab_width

    if toString:
        at.outputFile = g.fileLikeObject()
        if g.app.unitTesting:
            at.output_newline = '\n'
        # else: at.output_newline set in initCommonIvars.
        at.stringOutput = ""
        at.outputFileName = "&lt;string-file&gt;"
    else:
        at.outputFile = None # The temporary output file.
        # at.outputNewline set in initCommonIvars.
        at.stringOutput = None
        at.outputFileName = g.u('')

    # Init all other ivars even if there is an error.
    if not at.errors and at.root:
        if hasattr(at.root.v,'tnodeList'):
            delattr(at.root.v,'tnodeList')
        at.root.v._p_changed = True
</t>
<t tx="ekr.20041005105605.150">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @&lt;file&gt; nodes in the selected tree")
    else:
        g.es("no dirty @&lt;file&gt; nodes")
</t>
<t tx="ekr.20041005105605.151">def writeMissing(self,p,toString=False):

    at = self ; c = at.c
    writtenFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = c.os_path_finalize_join(
                    self.default_directory,at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    ok = at.openFileForWriting(p,at.targetFileName,toString)
                    # openFileForWriting calls p.setDirty() if there are errors.
                    if ok:
                        &lt;&lt; write the @file node &gt;&gt;
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    if writtenFiles &gt; 0:
        g.es("finished")
    else:
        g.es("no @file node in the selected tree")
</t>
<t tx="ekr.20041005105605.152">if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,kind='@nosent',nosentinels=True)
elif p.isAtFileNode():
    at.write(p,kind='@file')
else: assert 0,'writeMissing'

writtenFiles = True
</t>
<t tx="ekr.20041005105605.154">def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        # "look ahead" computation of eventual fileName.
        eventualFileName = c.os_path_finalize_join(
            at.default_directory,at.targetFileName)
        exists = g.os_path_exists(eventualFileName)
        if not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @asis node would overwrite the existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind='@asis')
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                return
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return
        for p in root.self_and_subtree():
            &lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
            &lt;&lt; Write p's body &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
</t>
<t tx="ekr.20041005105605.155">s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) &gt; 0:
        # at.outputFile is a fileLikeObject.
        s = g.toEncodedString(s,at.encoding,reportErrors=True)
        at.outputFile.write(s)
</t>
<t tx="ekr.20041005105605.156">s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
</t>
<t tx="ekr.20041005105605.157"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self
    s = g.choose(fromString,fromString,root.v.b)
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=%s" % (
        g.choose(at.writeVersion5,5,4)))
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
</t>
<t tx="ekr.20041005105605.16">at.docKind = None
at.explicitLineEnding = False
    # True: an @lineending directive specifies the ending.
at.fileChangedFlag = False # True: the file has actually been updated.
at.atAuto = atAuto
at.atEdit = atEdit
at.atShadow = atShadow
at.shortFileName = "" # short version of file name used for messages.
at.thinFile = False
at.writeVersion5 = at.new_write and not atShadow

at.force_newlines_in_at_nosent_bodies = c.config.getBool(
    'force_newlines_in_at_nosent_bodies')

if toString:
    at.outputFile = g.fileLikeObject()
    at.stringOutput = ""
    at.targetFileName = at.outputFileName = "&lt;string-file&gt;"
else:
    at.outputFile = None # The temporary output file.
    at.stringOutput = None
    at.targetFileName = at.outputFileName = g.u('')
</t>
<t tx="ekr.20041005105605.160"></t>
<t tx="ekr.20041005105605.161"># oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    if not fromString:
        # 2010/10/08: cleanLines calls c.setChanged(!)
        s = self.cleanLines(p,s)
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert next_i &gt; i,'putBody'
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
</t>
<t tx="ekr.20041005105605.162">@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20041005105605.163">if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    at.putSentinel("@verbatim")
    at.putIndent(at.indent)
    i = next_i
    next_i = g.skip_line(s,i)
    at.os(s[i:next_i])
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert 0,'putBody: unknown directive'
</t>
<t tx="ekr.20041005105605.164"></t>
<t tx="ekr.20041005105605.165"></t>
<t tx="ekr.20041005105605.166">def putAtAllLine (self,s,i,p):

    """Put the expansion of @all."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    lws = at.leadingWs or ''

    if at.writeVersion5 or not lws:
        at.putSentinel("@+all")
    else:
        at.putSentinel("@" + at.leadingWs + "@+all") 

    for child in p.children():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.167">def putAtAllBody(self,p):

    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.b

    p.v.setVisited()
    # g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.

    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag and not at.writeVersion5:
        at.putSentinel("@nonl")
</t>
<t tx="ekr.20041005105605.168"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20041005105605.169">@ This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the external
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):

    at = self

    parent_v = p._parentVnode()

    if False: # 2010/01/23: This generates atFile errors about orphan nodes.
        clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
        if clonedSibs &gt; 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else:
            g.trace('**** ignoring',p.h)
            p.v.setVisited() # 2010/01/23
            return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 

    for child in p.children():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.17">&lt;&lt; about new sentinels &gt;&gt;
</t>
<t tx="ekr.20041005105605.170"></t>
<t tx="ekr.20041005105605.171">def inAtOthers(self,p):

    """Returns True if p should be included in the expansion of the at-others directive

    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False

    # Return False if this is a definition node.
    h = p.h ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    if self.sentinels or self.atAuto or self.toString:
        # 2010/09/29: @ignore must not stop expansion here!
        return True 

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
</t>
<t tx="ekr.20041005105605.172">def putAtOthersChild(self,p):

    at = self

    parent_v = p._parentVnode()
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")
        g.es_print(p.h,color='red')

    at.putOpenNodeSentinel(p)
    at.putBody(p) 

    # Insert expansions of all children.
    for child in p.children():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.173">def putAtOthersLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta

    lws = at.leadingWs or ''

    if at.writeVersion5 or not lws:
        # Never write lws in new sentinels.
        at.putSentinel("@+others")
    else:
        # Use the old (bizarre) convention when writing old sentinels.
        # Note: there are *two* at signs here.
        at.putSentinel("@" + lws + "@+others")

    for child in p.children():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    # This is the same in both old and new sentinels.
    at.putSentinel("@-others")

    at.indent -= delta
</t>
<t tx="ekr.20041005105605.174">def putCodeLine (self,s,i):

    '''Put a normal code line.'''

    trace = False and not g.unitTesting
    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')

    j = g.skip_line(s,i)
    line = s[i:j]

    if trace: g.trace(self.atShadow,repr(line))

    # Don't put any whitespace in otherwise blank lines.
    if line.strip(): # The line has non-empty content.
        if not at.raw:
            at.putIndent(at.indent,line)

        if line[-1:]=='\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    else:
        g.trace('Can not happen: completely empty line')

</t>
<t tx="ekr.20041005105605.175"></t>
<t tx="ekr.20041005105605.176">def putRefLine(self,s,i,n1,n2,p):

    """Put a line containing one or more references."""

    at = self

    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03

    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break

    self.putAfterLastRef(s,i,delta)
</t>
<t tx="ekr.20041005105605.177">def putRefAt (self,s,i,n1,n2,p,delta):

    """Put a reference at s[n1:n2+2] from p."""

    at = self ; c = at.c ; name = s[n1:n2+2]

    ref = g.findReference(c,name,p)
    if not ref:
        if not g.unitTesting:
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                    ( name,p.h))
        return None

    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)

    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()

    at.indent += delta

    lws = at.leadingWs or ''
    if at.writeVersion5:
        at.putSentinel("@+" + name)
    else:
        at.putSentinel("@" + lws + name)

    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)

    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)

    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)

    if at.writeVersion5:
        at.putSentinel("@-" + name)

    at.indent -= delta

    return delta
</t>
<t tx="ekr.20041005105605.178">def putAfterLastRef (self,s,start,delta):

    """Handle whatever follows the last ref of a line."""

    at = self

    j = g.skip_ws(s,start)

    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        if at.writeVersion5:
            pass # Never write @nl sentinels.
        else:
            # Temporarily readjust delta to make @nl look better.
            at.indent += delta
            at.putSentinel("@nl")
            at.indent -= delta
</t>
<t tx="ekr.20041005105605.179">def putAfterMiddleRef (self,s,start,end,delta):

    """Handle whatever follows a ref that is not the last ref of a line."""

    at = self

    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        if at.writeVersion5:
            pass # Never write @nonl sentinels.
        else:
            at.putSentinel("@nonl")
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.18">@ All reading happens in the readOpenFile logic, so plugins
should need to override only this method.
</t>
<t tx="ekr.20041005105605.180"></t>
<t tx="ekr.20041005105605.181">def putBlankDocLine (self):

    at = self

    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
</t>
<t tx="ekr.20041005105605.182">def putStartDocLine (self,s,i,kind):

    """Write the start of a doc part."""

    at = self ; at.docKind = kind

    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")

    if at.writeVersion5: # Put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)

        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)

        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()

        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
</t>
<t tx="ekr.20041005105605.183">def putDocLine (self,s,i):

    """Handle one line of a doc part.

    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""

    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    elif at.writeVersion5:
        &lt;&lt; write the line as is &gt;&gt;
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20041005105605.184">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])

    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])

# Output the remaining line: no more is left.
at.putPending(split=False)
</t>
<t tx="ekr.20041005105605.185">def putEndDocLine (self):

    """Write the conclusion of a doc part."""

    at = self

    at.putPending(split=False)

    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    if at.writeVersion5:
        pass # Never write @-doc or @-at sentinels.
    else:
        sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
        at.putSentinel(sentinel)
</t>
<t tx="ekr.20041005105605.186">def putPending (self,split):

    """Write the pending part of a doc part.

    We retain trailing whitespace iff the split flag is True."""

    at = self ; s = ''.join(at.pending) ; at.pending = []

    # g.trace("split",s)

    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
</t>
<t tx="ekr.20041005105605.187"></t>
<t tx="ekr.20041005105605.188">def nodeSentinelText(self,p):

    """Return the text of a @+node or @-node sentinel for p."""

    at = self ; h = p.h
    &lt;&lt; remove comment delims from h if necessary &gt;&gt;

    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.fileIndex)
        if at.writeVersion5:
            level = 1 + p.level() - self.root.level()
            stars = '*' * level
            if 1: # Put the gnx in the traditional place.
                if level &gt; 2:
                    return "%s: *%s* %s" % (gnx,level,h)
                else:
                    return "%s: %s %s" % (gnx,stars,h)
            else: # Hide the gnx to the right.
                pad = max(1,100-len(stars)-len(h)) * ' '
                return '%s %s%s::%s' % (stars,h,pad,gnx)
        else:
            return "%s:%s" % (gnx,h)
    else:
        return h
</t>
<t tx="ekr.20041005105605.189">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment
we remove all block comment delims from h. This prevents headline text from
interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) &gt; 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
</t>
<t tx="ekr.20041005105605.19">def openFileForReading(self,fromString=False):

    '''Open the file given by at.root.
    This will be the private file for @shadow nodes.'''

    trace = False and not g.app.unitTesting
    at = self ; c = at.c

    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.inputFile = g.fileLikeObject(fromString=fromString)
        fn = None
    else:
        fn = at.fullPath(self.root)
            # Returns full path, including file name.
        at.setPathUa(self.root,fn) # Remember the full path to this node.

        if at.atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn     = x.shadowPathName(fn)
            shadow_exists = g.os_path_exists(shadow_fn) and \
                g.os_path_isfile(shadow_fn)
            if not shadow_exists:
                g.trace('can not happen: no private file',
                    shadow_fn,g.callers())
                return at.error(
                    'can not happen: private file does not exist: %s' % (
                        shadow_fn))
            # This method is the gateway to the shadow algorithm.
            if trace:
                g.trace('         fn:       ',fn)
                g.trace('reading: shadow_fn:',shadow_fn)
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
            fn = None

    return fn
</t>
<t tx="ekr.20041005105605.190">def putLeadInSentinel (self,s,i,j,delta):

    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.

    Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(at.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        if at.writeVersion5:
            pass # Never write @nonl sentinels.
        else:
            at.indent += delta # Align the @nonl with the following line.
            at.putSentinel("@nonl")
            at.indent -= delta # Let the caller set at.indent permanently.
</t>
<t tx="ekr.20041005105605.191">def putCloseNodeSentinel(self,p,middle=False):

    at = self

    if at.writeVersion5:
        at.raw = False # Bug fix: 2010/07/04
        return # Never write @-node or @-middle sentinels.

    s = self.nodeSentinelText(p)

    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
</t>
<t tx="ekr.20041005105605.192">def putOpenLeoSentinel(self,s):

    """Write @+leo sentinel."""

    at = self

    if not at.sentinels:
        return # Handle @nosentinelsfile.

    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)

    at.putSentinel(s)
</t>
<t tx="ekr.20041005105605.193">def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):

    """Write @+node sentinel for p."""

    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.h)
        return

    # g.trace(at.thinFile,p)

    s = at.nodeSentinelText(p)

    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    # Leo 4.7 b2: we never write tnodeLists.
</t>
<t tx="ekr.20041005105605.194"># This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."

    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    &lt;&lt; apply the cweb hack to s &gt;&gt;
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
</t>
<t tx="ekr.20041005105605.195">@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first,
which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
</t>
<t tx="ekr.20041005105605.196"></t>
<t tx="ekr.20041005105605.197">def compareFiles (self,path1,path2,ignoreLineEndings,ignoreBlankLines=False):

    """Compare two text files."""
    at = self

    # We can't use 'U' mode because of encoding issues (Python 2.x only).
    s1,e = g.readFileIntoString(path1,mode='rb',raw=True)
    if s1 is None:
        g.internalError('empty compare file: %s' % path1)
        return False
    s2,e = g.readFileIntoString(path2,mode='rb',raw=True)
    if s2 is None:
        g.internalError('empty compare file: %s' % path2)
        return False
    equal = s1 == s2

    # 2010/03/29: Make sure both strings are unicode.
    # This is requred to handle binary files in Python 3.x.
    s1 = g.toUnicode(s1,encoding=at.encoding)
    s2 = g.toUnicode(s2,encoding=at.encoding)

    if ignoreBlankLines and not equal:
        s1 = g.removeBlankLines(s1)
        s2 = g.removeBlankLines(s2)
        equal = s1 == s2

    if ignoreLineEndings and not equal:
        # Wrong: equivalent to ignoreBlankLines!
            # s1 = s1.replace('\n','').replace('\r','')
            # s2 = s2.replace('\n','').replace('\r','')
        s1 = s1.replace('\r','')
        s2 = s2.replace('\r','')
        equal = s1 == s2
    # g.trace('equal',equal,'ignoreLineEndings',ignoreLineEndings,'encoding',at.encoding)
    return equal
</t>
<t tx="ekr.20041005105605.198">def directiveKind4(self,s,i):

    """Return the kind of at-directive or noDirective."""

    trace = False and not g.unitTesting
    at = self
    n = len(s)

    if trace and s.startswith('@'): g.trace(s.rstrip())

    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective),
        ("@verbatim",at.startVerbatim))

    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # New in Leo 4.4.3: add support for add_directives plugin.
    for name in g.globalDirectiveList:
        if g.match_word(s,i+1,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20041005105605.199">def findSectionName(self,s,i):

    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    ok = -1 &lt; n1 &lt; n2

    # New in Leo 4.4.3: warn on extra brackets.
    if ok:
        for ch,j in (('&lt;',n1+2),('&gt;',n2+2)):
            if g.match(s,j,ch):
                line = g.get_line(s,i)
                g.es('dubious brackets in',line)
                break

    return ok, n1, n2
</t>
<t tx="ekr.20041005105605.2">import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # print("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import leo.core.leoNodes as leoNodes

import os
import sys
import time

</t>
<t tx="ekr.20041005105605.20">def warnOnReadOnlyFile (self,fn):

    # os.access() may not exist on all platforms.
    try:
        read_only = not os.access(fn,os.W_OK)
    except AttributeError:
        read_only = False 

    if read_only:
        g.es("read only:",fn,color="red")
</t>
<t tx="ekr.20041005105605.200"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"&lt;&lt;"):
        return False, -1
    i = g.find_on_line(s,i,"&gt;&gt;")
    if i &gt; -1:
        return True, i + 2
    else:
        return False, -1
</t>
<t tx="ekr.20041005105605.201"># Note:  self.outputFile may be either a fileLikeObject or a real file.
</t>
<t tx="ekr.20041005105605.202">def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))

def otabs(self,n):
    self.os('\t' * abs(n))
</t>
<t tx="ekr.20041005105605.203">def onl(self):

    """Write a newline to the output stream."""

    self.os(self.output_newline)

def onl_sent(self):

    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
</t>
<t tx="ekr.20041005105605.204">def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    trace = False and not g.unitTesting
    at = self ; tag = self.underindentEscapeString
    f = at.outputFile

    if s and f:
        try:
            if s.startswith(tag):
                junk,s = self.parseUnderindentTag(s)
            # at.outputFile is a fileLikeObject.
            # Bug fix: this must be done last.
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            if trace: g.trace(repr(s),g.callers(5))
            f.write(s)
        except Exception:
            at.exception("exception writing:" + s)
</t>
<t tx="ekr.20041005105605.205"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):
    at = self

    # Calling self.onl() runs afoul of queued newlines.
    if g.isPython3:
        s = g.ue(s,at.encoding)

    s = s.replace('\n',at.output_newline)
    self.os(s)

</t>
<t tx="ekr.20041005105605.206">@ It is important for PHP and other situations that \@first
and \@last directives get translated to verbatim lines that
do _not_ include what follows the @first &amp; @last directives.
@c

def putDirective(self,s,i):

    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        &lt;&lt; handle @delims &gt;&gt;
    elif g.match_word(s,k,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,k,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
</t>
<t tx="ekr.20041005105605.207"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
</t>
<t tx="ekr.20041005105605.208">self.putSentinel("@" + directive)

if 0: # Bug fix: Leo 4.4.1
    # Do not scan the @language directive here!
    # These ivars have already been scanned by the init code.

    # Skip the keyword and whitespace.
    i = k + len("@language")
    i = g.skip_ws(s,i)
    j = g.skip_c_id(s,i)
    language = s[i:j]

    delim1,delim2,delim3 = g.set_delims_from_language(language)

    # g.trace(delim1,delim2,delim3)

    # Returns a tuple (single,start,end) of comment delims
    if delim1:
        self.startSentinelComment = delim1
        self.endSentinelComment = ""
    elif delim2 and delim3:
        self.startSentinelComment = delim2
        self.endSentinelComment = delim3
    else:
        line = g.get_line(s,i)
        g.es("ignoring bad @language directive:",line,color="blue")
</t>
<t tx="ekr.20041005105605.209">self.putSentinel("@" + directive)

if 0: # Bug fix: Leo 4.4.1
    # Do not scan the @comment directive here!
    # These ivars have already been scanned by the init code.

    # g.trace(delim1,delim2,delim3)

    j = g.skip_line(s,i)
    line = s[i:j]
    delim1,delim2,delim3 = g.set_delims_from_string(line)

    # Returns a tuple (single,start,end) of comment delims
    if delim1:
        self.startSentinelComment = delim1
        self.endSentinelComment = None
    elif delim2 and delim3:
        self.startSentinelComment = delim2
        self.endSentinelComment = delim3
    else:
        g.es("ignoring bad @comment directive:",line,color="blue")
</t>
<t tx="ekr.20041005105605.21">def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        g.trace('No inputFile')
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # Never read an external file with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width

    if trace: g.trace(fileName)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        at.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike and at.errors == 0: # Old-style sentinels.
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        # Do *not* set the orphan bit here!
        root.clearOrphan()
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    elif at.errors &gt; 0:
        # 2010/10/22: Dirty bits are *always* cleared.
        # Only the orphan bit is preserved.
        root.setDirty()
        root.setOrphan()
        c.setChanged(True)
    else:
        root.clearOrphan()
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
</t>
<t tx="ekr.20041005105605.210">def putIndent(self,n,s=''):

    """Put tabs and spaces corresponding to n spaces,
    assuming that we are at the start of a line.

    Remove extra blanks if the line starts with the underindentEscapeString"""

    # g.trace(repr(s))
    tag = self.underindentEscapeString

    if s.startswith(tag):
        n2,s2 = self.parseUnderindentTag(s)
        if n2 &gt;= n: return
        elif n &gt; 0: n -= n2
        else:       n += n2

    if n != 0:
        w = self.tab_width
        if w &gt; 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
</t>
<t tx="ekr.20041005105605.211">def putInitialComment (self):

    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = s2.split("\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)&gt; 0:
                self.putSentinel("@comment " + line)
</t>
<t tx="ekr.20041005105605.212">def replaceTargetFileIfDifferent (self,root,ignoreBlankLines=False):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    trace = False and not g.unitTesting
    c = self.c

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if trace: g.trace(
        'ignoreBlankLines',ignoreBlankLines,
        'target exists',g.os_path_exists(self.targetFileName),
        self.outputFileName,self.targetFileName)

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,
            self.targetFileName,
            ignoreLineEndings=not self.explicitLineEnding,
            ignoreBlankLines=ignoreBlankLines):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            if trace: g.trace('files are identical')
            if ok:
                g.es('unchanged:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.
            self.fileChangedFlag = False
            return False
        else:
            # A mismatch.
            self.checkPythonCode(root)
            &lt;&lt; report if the files differ only in line endings &gt;&gt;
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:',self.shortFileName)
            else:
                g.es('error writing',self.shortFileName,color='red')
                g.es('not written:',self.shortFileName)
                if root:
                    root.setDirty() # New in 4.4.8.
                    root.setOrphan() # 2010/10/22.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:',self.targetFileName)
        else:
            # self.rename gives the error.
            if root:
                root.setDirty() # New in 4.4.8.
                root.setOrphan() # 2010/10/22.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
</t>
<t tx="ekr.20041005105605.216"># Called from writeOpenFile.

def warnAboutOrphandAndIgnoredNodes (self):

    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    if at.errors: return # No need to repeat this.

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            at.writeError("Orphan node:  " + p.h)
            if p.hasParent():
                g.es("parent node:",p.parent().h,color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.h)

    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.h)
                p.moveToThreadNext()
</t>
<t tx="ekr.20041005105605.217">def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)
        # g.trace(g.callers(5))

    self.error(message)
    self.root.setDirty()
    self.root.setOrphan()
</t>
<t tx="ekr.20041005105605.218">def writeException (self,root=None): # changed 11.

    g.es("exception writing:",self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None

    if self.outputFileName:
        self.remove(self.outputFileName)

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()
</t>
<t tx="ekr.20041005105605.219"></t>
<t tx="ekr.20041005105605.22">def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "&lt;string-file&gt;"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
</t>
<t tx="ekr.20041005105605.220">def error(self,*args):

    at = self
    if True: # args:
        at.printError(*args)
    at.errors += 1

def printError (self,*args):

    '''Print an error message that may contain non-ascii characters.'''

    at = self
    keys = {'color': g.choose(at.errors,'blue','red')}
    g.es_print_error(*args,**keys)
</t>
<t tx="ekr.20041005105605.221">def exception (self,message):

    self.error(message)
    g.es_exception()
</t>
<t tx="ekr.20041005105605.236">def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory = g.setDefaultDirectory(c,p,importing)
</t>
<t tx="ekr.20041005105605.242">def scanForClonedSibs (self,parent_v,v):

    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        for sib in parent_v.children:
            if sib == v:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs

    return clonedSibs,thisClonedSibIndex
</t>
<t tx="ekr.20041005105605.243"># Returns the name of the sentinel for warnings.

def sentinelName(self, kind):

    at = self

    sentinelNameDict = {
        at.endAll:        "@-all", # 4.x
        at.endAt:         "@-at",
        at.endBody:       "@-body", # 3.x only.
        at.endDoc:        "@-doc",
        at.endLeo:        "@-leo",
        at.endMiddle:     "@-middle", # 4.x
        at.endNode:       "@-node",
        at.endOthers:     "@-others",
        at.endRef:        "@-&lt;&lt;", # 4.8
        at.noSentinel:    "&lt;no sentinel&gt;",
        at.startAt:       "@+at",
        at.startBody:     "@+body",
        at.startDoc:      "@+doc",
        at.startLeo:      "@+leo",
        at.startNode:     "@+node",
        at.startOthers:   "@+others",
        at.startAll:      "@+all",    
        at.startMiddle:   "@+middle", 
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@&lt;&lt;",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef", # 3.x only.
    } 

    return sentinelNameDict.get(kind,"&lt;unknown sentinel: %s&gt;" % kind)
</t>
<t tx="ekr.20041005105605.25">def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
</t>
<t tx="ekr.20041005105605.26">def readAll(self,root,partialFlag=False):

    """Scan vnodes, looking for @&lt;file&gt; nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    force = partialFlag
    if partialFlag:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()

    scanned_tnodes = set()

    if partialFlag: after = p.nodeAfterTree()    
    else: after = c.nullPosition()

    while p and p != after:
        gnx = p.gnx
        #skip clones
        if gnx in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(gnx)

        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,force=force)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p,force=force)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                # However, the dirty bit gets cleared.
                p.setDirty() # Expensive, but it can't be helped.
                p.setOrphan() # 2010/10/22: the dirty bit gets cleared.
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            # 2010/7/28: set v.at_read bit if the @asis or @nosent
            # **node** exists.  We'll prompt for dangerous writes
            # if a) this bit is clear and b) the file exists.
            if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
                p.v.at_read = True # Remember that we have seen this node.
            p.moveToThreadNext()

    # 2010/10/22: Preserve the orphan bits: the dirty bits will be cleared!
    ### Clear all orphan bits.
    #for v in c.all_unique_nodes():
    #    v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @&lt;file&gt; nodes in the selected tree")

    if use_tracer: tt.stop()
</t>
<t tx="ekr.20041005105605.27">def readOpenFile(self,root,theFile,fileName,deleteNodes=False):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self

    firstLines,read_new,thinFile = at.scanHeader(theFile,fileName)
    at.thinFile = thinFile
        # 2010/01/22: use *only* the header to set self.thinFile.

    if deleteNodes and at.shouldDeleteChildren(root,thinFile):
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        firstLines = [] ; lastLines = []
        if at.atShadow:
            g.trace(g.callers())
            g.trace('invalid @shadow private file',fileName)
            at.error('invalid @shadow private file',fileName)
        else:
            at.error('can not read 3.x derived file',fileName)
            g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
            g.trace('root',root and root.h,fileName)

    if root:
        root.v.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;

    return thinFile
</t>
<t tx="ekr.20041005105605.28"># The code below only deals with the root node!
# We terminate the root's body text if it exists.
# This is a hack to allow us to handle @first and @last.
v = root.v
tempString = hasattr(v,'tempBodyString') and v.tempBodyString or ''
tempList = hasattr(v,'tempBodyList') and ''.join(v.tempBodyList) or ''

if at.readVersion5:
    if hasattr(v,'tempBodyList'):
        body = tempList
        delattr(v,'tempBodyList') # So the change below "takes".
    elif hasattr(v,'tempBodyString'):
        body = tempString
        delattr(v,'tempBodyString')
    else:
        body = ''
else:
    body = tempString

lines = body.split('\n')

at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)

s = '\n'.join(lines).replace('\r', '')

# *Always* put the temp body text into at.v.tempBodyString.
v.tempBodyString = s
</t>
<t tx="ekr.20041005105605.5"># These constants must be global to this module
# because they are shared by several classes.

# The kind of at_directives.
noDirective     =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective    =  3 # @doc.
atDirective     =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective   =  5 # @code
cDirective      =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective =  7 # at-others
miscDirective   =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel   = 20 # Not a sentinel
endAt        = 21 # @-at
endBody      = 22 # @-body
# not used   = 23
endDoc       = 24 # @-doc
endLeo       = 25 # @-leo
endNode      = 26 # @-node
endOthers    = 27 # @-others

# not used     = 40
startAt        = 41 # @+at
startBody      = 42 # @+body
startDoc       = 43 # @+doc
startLeo       = 44 # @+leo
startNode      = 45 # @+node
startOthers    = 46 # @+others

startComment   = 60 # @comment
startDelims    = 61 # @delims
startDirective = 62 # @@
startRef       = 63 # @&lt; &lt; ... &gt; &gt;
startVerbatim  = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)

# New in 4.8.
endRef         = 84 # @-&lt;&lt;
</t>
<t tx="ekr.20041005105605.6">sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}
</t>
<t tx="ekr.20041005105605.7"></t>
<t tx="ekr.20041005105605.71"></t>
<t tx="ekr.20041005105605.72">def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees."""

    trace = False and not g.unitTesting
    verbose = False
    at = self ; c = at.c ; indices = g.app.nodeIndices
    parent = last = at.lastThinNode # A vnode.
    lastIndex = last.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last,gnxString,headline))

    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(parent,child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies,headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace:g.trace('found last',last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child',child)
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the vnode only if it does not already exist.
        gnxDict = c.fileCommands.gnxDict
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.trace('can not happen: v.fileIndex: %s gnx: %s' % (
                    v.fileIndex,gnx))
        else:
            v = leoNodes.vnode(context=c)
            v._headString = headline # Allowed use of v._headString.
            v.fileIndex = gnx
            gnxDict[gnxString] = v

        child = v
        child._linkAsNthChild(parent,parent.numberOfChildren())

    if trace: g.trace('new node: %s' % child)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
</t>
<t tx="ekr.20041005105605.73">def findChild4 (self,headline):

    """Return the next vnode in at.root.tnodeLisft.
    This is called only for @file nodes"""

    # tnodeLists are used *only* when reading @file (not @thin) nodes.
    # tnodeLists compensate for not having gnx's in derived files! 

    trace = False and not g.unitTesting
    at = self ; v = at.root.v

    # if not g.unitTesting:
        # if headline.startswith('@file'):
            # g.es_print('Warning: @file logic',headline)

    if trace: g.trace('%s %s %s' % (
        at.tnodeListIndex,
        v.tnodeList[at.tnodeListIndex],headline))

    if not hasattr(v,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v,g.callers())
        return None

    if at.tnodeListIndex &gt;= len(v.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (
            at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",
            at.tnodeListIndex,len(v.tnodeList),v)
        return None

    v = v.tnodeList[at.tnodeListIndex]
    assert(v)
    at.tnodeListIndex += 1

    # Don't check the headline.  It simply causes problems.
    v.setVisited() # Supress warning/deletion of unvisited nodes.
    return v
</t>
<t tx="ekr.20041005105605.74">def scanText4 (self,theFile,fileName,p,verbose=False):

    """Scan a 4.x derived file non-recursively."""

    at = self
    trace = False and at.readVersion5 and not g.unitTesting
    verbose = False
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    if trace: g.trace('filename:',fileName)
    try:
        while at.errors == 0 and not at.done:
            s = at.readLine(theFile)
            if trace and verbose: g.trace(repr(s))
            at.lineNumber += 1
            if len(s) == 0:
                # An error.  We expect readEndLeo to set at.done.
                break
            kind = at.sentinelKind4(s)
            if kind == at.noSentinel:
                i = 0
            else:
                i = at.skipSentinelStart4(s,0)
            func = at.dispatch_dict[kind]
            if trace: g.trace('%15s %16s %s' % (
                at.sentinelName(kind),func.__name__,repr(s)))
            func(s,i)
    except AssertionError:
        junk, message, junk = sys.exc_info()
        at.error('scanText4: unexpected assertion failure in',
            g.choose(at.fromString,'fromString',fileName),
            '\n',message)
        g.trace(g.callers(5))
        if g.unitTesting:
            raise

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20041005105605.75"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.lineNumber = 0
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.endSentinelNodeStack = [None]
at.out = [] ; at.outStack = []
at.v = p.v
at.vStack = []
# New code: always identify root @thin node with self.root:
at.lastThinNode = None
at.thinNodeStack = []
</t>
<t tx="ekr.20041005105605.76">assert at.endSentinelStack,'empty sentinel stack'

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
</t>
<t tx="ekr.20041005105605.77">def readNormalLine (self,s,i=0): # i not used.

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.appendToOut(s)
    else:
        at.appendToDocPart(s)
</t>
<t tx="ekr.20041005105605.8">def __init__(self,c):

    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.errors = 0 # Make sure at.error() works even when not inited.

    # User options.
    self.checkPythonCodeOnWrite = c.config.getBool(
        'check-python-code-on-write',default=True)
    self.underindentEscapeString = c.config.getString(
        'underindent-escape-string') or '\\-'
    self.new_write = new_write and c.config.getBool(
        'simplified-sentinels-4-8',default=True)

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;
</t>
<t tx="ekr.20041005105605.80"></t>
<t tx="ekr.20041005105605.81">def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]

    if leadingWs:
        assert g.match(s,j,"@+all"),'missing @+all'
    else:
        assert g.match(s,j,"+all"),'missing +all'

    # Make sure that the generated at-all is properly indented.
    # New code (for both old and new sentinels).
    # Regularize the whitespace preceding the @all directive.
    junk_i,w = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    lws2 = g.computeLeadingWhitespace(max(0,w-at.indent),at.tab_width)
    at.appendToOut(lws2 + "@all\n")

    at.endSentinelStack.append(at.endAll)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
</t>
<t tx="ekr.20041005105605.82"></t>
<t tx="ekr.20041005105605.83">def readStartLeo (self,s,i):

    """Read an unexpected @+leo sentinel."""

    at = self
    assert g.match(s,i,"+leo"),'missing +leo sentinel'
    at.readError("Ignoring unexpected @+leo sentinel")
</t>
<t tx="ekr.20041005105605.84">def readStartMiddle (self,s,i):

    """Read an @+middle sentinel."""

    at = self

    at.readStartNode(s,i,middle=True)
</t>
<t tx="ekr.20041005105605.85">def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    at = self
    gnx,headline,i,level,ok = at.parseNodeSentinel(s,i,middle)
    if not ok: return
    at.root_seen = True

    # Switch context.
    if at.readVersion5:
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
        # Important: with new sentinels we *never*
        # terminate nodes until the post-pass.
    else:
        assert not at.docOut,'not at.docOut' # Cleared by @-node sentinel.
        at.outStack.append(at.out)
        at.out = []

    at.inCode = True
    at.raw = False # End raw mode.

    at.vStack.append(at.v)

    at.indentStack.append(at.indent)
    i,at.indent = g.skip_leading_ws_with_indent(s,0,at.tab_width)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        at.v = at.createNewThinNode(gnx,headline,level)
    else:
        at.v = at.findChild4(headline)

    if not at.v:
        return # 2010/08/02: This can happen when reading strange files.

    at.v.setVisited()
        # Indicate that the vnode has been set in the external file.

    if not at.readVersion5:
        at.endSentinelStack.append(at.endNode)
</t>
<t tx="ekr.20041005105605.89">def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self

    j = g.skip_ws(s,i)
    leadingWs = s[i:j]

    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    # New code (for both old and new sentinels).
    # Regularize the whitespace preceding the @others directive.
    junk_i,w = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    lws2 = g.computeLeadingWhitespace(max(0,w-at.indent),at.tab_width)
    at.appendToOut(lws2 + "@others\n")

    if at.readVersion5:
        at.endSentinelIndentStack.append(at.indent)
        at.endSentinelStack.append(at.endOthers)
        at.endSentinelNodeStack.append(at.v)
        at.endSentinelLevelStack.append(len(at.thinNodeStack))
    else:
        at.endSentinelStack.append(at.endOthers)
</t>
<t tx="ekr.20041005105605.9">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel,
    # New 4.8 sentinels
    self.endRef: self.readEndRef,
}
</t>
<t tx="ekr.20041005105605.90"></t>
<t tx="ekr.20041005105605.91">def readEndAll (self,unused_s,unused_i):

    """Read an @-all sentinel."""

    at = self
    at.popSentinelStack(at.endAll)

    if at.readVersion5 and at.thinNodeStack:

        # Restore the node containing the @all directive.
        # *Never* terminate new-sentinel nodes until the post-pass.
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel,newLevel)
</t>
<t tx="ekr.20041005105605.92">def readEndAt (self,unused_s,unused_i):

    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,unused_s,unused_i):

    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
</t>
<t tx="ekr.20041005105605.93">def readEndLeo (self,unused_s,unused_i):

    """Read an @-leo sentinel."""

    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
</t>
<t tx="ekr.20041005105605.94">def readEndMiddle (self,s,i):

    """Read an @-middle sentinel."""

    at = self

    at.readEndNode(s,i,middle=True)
</t>
<t tx="ekr.20041005105605.95">def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle @-node sentinels."""

    at = self ; c = at.c

    assert not at.readVersion5,'not at.readVersion5'
        # Must not be called for new sentinels.

    at.raw = False # End raw mode.

    at.terminateNode(middle)
        # Set the body text and warn about changed text.
        # This must not be called when handling new sentinels!

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.docOut = []
    at.v = at.vStack.pop()

    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
</t>
<t tx="ekr.20041005105605.98">def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self

    at.popSentinelStack(at.endOthers)

    if at.readVersion5:
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
            at.inCode = True

        # Restore the node continain the @others directive.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode.
        at.v = at.endSentinelNodeStack.pop()
        at.indent = at.endSentinelIndentStack.pop()
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel,newLevel)

</t>
<t tx="ekr.20041005105605.99">def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @.

    Not used when reading new sentinels.
    """

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.appendToOut(tag + s)
    at.docOut = []
</t>
<t tx="ekr.20041012082437">def __init__ (self):

    self.old = None
    self.encoding = 'utf-8' # 2019/03/29 For pdb.
</t>
<t tx="ekr.20041012082437.1">def isRedirected (self):

    return self.old != None
</t>
<t tx="ekr.20041012082437.2"># For LeoN: just for compatibility.

def flush(self, *args):
    return
</t>
<t tx="ekr.20041012082437.3">def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
</t>
<t tx="ekr.20041012082437.4">def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
</t>
<t tx="ekr.20041012082437.5">def write(self,s):

    trace = False

    if self.old:
        if app.log:
            if trace: self.old.write(
                'redirectClass: to log: %s\n' % repr(s))
            app.log.put(s)
        else:
            self.old.write(s +'\n')
    else:
        # Can happen when g.batchMode is True.
        g.pr(s)
</t>
<t tx="ekr.20041012083237">def __init__ (self,frame=None,parentFrame=None):

    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)

    self.isNull = True
    self.logNumber = 0
    self.logCtrl = self.createControl(parentFrame)
</t>
<t tx="ekr.20041012083237.1">def createControl (self,parentFrame):

    return self.createTextWidget(parentFrame)
</t>
<t tx="ekr.20041012083237.2">def oops(self):

    g.trace("nullLog:", g.callers(4))
</t>
<t tx="ekr.20041012083237.3">def put (self,s,color=None,tabName='Log'):
    # print('(nullGui) print',s)
    if self.enabled:
        # g.rawPrint(s)
        try:
            g.pr(s,newline=False)
        except UnicodeError:
            s = s.encode('ascii','replace')
            g.pr(s,newline=False)

def putnl (self,tabName='Log'):
    if self.enabled:
        # g.rawPrint("")
        g.pr('')
</t>
<t tx="ekr.20041012090942"># Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
</t>
<t tx="ekr.20041012090942.1"># Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)

def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
</t>
<t tx="ekr.20041012090942.2">def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()

def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
</t>
<t tx="ekr.20041012090942.3"># Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
</t>
<t tx="ekr.20041012091252">def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        g.pr(s)
</t>
<t tx="ekr.20041016134312.1">@killcolor

Treat @language like @color: ambiguous nodes (nodes containing more than one
@language directive) should not affect descendent nodes.
</t>
<t tx="ekr.20041016134312.2">Use noweb and TeX, or maybe Pyx.
</t>
<t tx="ekr.20041019090322">if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
</t>
<t tx="ekr.20041021100850">self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
</t>
<t tx="ekr.20041021101911.1">def oops(self):

    g.pr("unknown PrettyPrinting code: %s" % (self.name))
</t>
<t tx="ekr.20041021101911.2">def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val))
        ))
</t>
<t tx="ekr.20041021101911.3">def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
</t>
<t tx="ekr.20041021101911.5">def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=&lt;&gt;*-+&amp;|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
</t>
<t tx="ekr.20041021101911.6">def doNumber (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20041021102340">def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
</t>
<t tx="ekr.20041021102340.1">def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
</t>
<t tx="ekr.20041021102340.2">def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20041021102938">def doEndMarker (self):

    self.putArray()
</t>
<t tx="ekr.20041021104237">def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
</t>
<t tx="ekr.20041021112219">def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
</t>
<t tx="ekr.20041022070154"></t>
<t tx="ekr.20041022070154.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2815599
By: Antonio Pala

All plugins I have tried (notably @run and the @rst variants) have their working
directory set to my home directory, regardless of the position of the Leo file
and all @path directives. This renders most of them useless, since I would have
to use absolute pathnames. Is this the way they were meant to work, or is there
a bug somewhere? Or maybe I have missed some configuration parameter?

I am using Leo 4.2 with Python 2.3 on Linux.

&gt; All plugins I have tried (notably @run and the @rst variants) have their working directory set to my home directory, regardless of the position of the Leo file and all @path directives.

Directory issues are different on different platforms.

I would welcome specific proposals for setting directories during startup.  Early in the startup process Leo sets g.app.loadDir to the directory from which Leo was loaded.  Plugins can use this directory to set the working directory as they choose.

@path directives will have no effect on plugins:  they are loaded before the outline.

&gt; This renders most [plugins] useless, since I would have to use absolute pathnames.

No, it means you might have to add a few lines of code to your plugin to make it work just as you would like it to work.

&gt; Is this the way they were meant to work?

I don't have much control over how plugins were "meant" to work.  However, an improved plugin manager might have facilities for setting the working directory.

This is a non-trivial issue;   Leo uses and sets paths in many places in the code.  It seems dubious to have plugins change the working directory at random times.  Perhaps an option that inits the working directory would be good.  The new config system will allow per-outline options as well as global option. I believe such options could be loaded before plugins.

Edward
</t>
<t tx="ekr.20041022083005.2"></t>
<t tx="ekr.20041022083226"></t>
<t tx="ekr.20041022083833.1"></t>
<t tx="ekr.20041105091148">def pdb (message=''):

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    if message:
        print(message)
    pdb.set_trace()
</t>
<t tx="ekr.20041113113140">def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.startswith('@'):
        if trace: g.trace('ignoring Leo directive')
        return False # Allow Leo directives in @enabled-plugins nodes.

    if moduleOrFileName.endswith('.py'):
        moduleName = 'leo.plugins.' + moduleOrFileName [:-3]
    elif moduleOrFileName.startswith('leo.plugins.'):
        moduleName = moduleOrFileName
    else:
        moduleName = 'leo.plugins.' + moduleOrFileName

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    moduleName = g.toUnicode(moduleName)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)

    try:
        toplevel = __import__(moduleName)
        # need to look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]

    except g.UiTypeException:
        if not g.unitTesting and not g.app.batchMode:
            g.es_print('Plugin %s does not support %s gui' % (
                moduleName,g.app.gui.guiName()))
        result = None

    except ImportError:
        if trace or tag == 'open0': # Just give the warning once.
            g.es_print('plugin does not exist:',moduleName,color='red')
        result = None

    except Exception as e:
        g.es_print('exception importing plugin ' + moduleName,color='red')
        g.es_exception()
        result = None

    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
</t>
<t tx="ekr.20041117062700">@language python
@tabwidth -4
@pagewidth 70

&lt;&lt; imports &gt;&gt;

&lt;&lt; class parserBaseClass &gt;&gt;

@others
</t>
<t tx="ekr.20041117062717.1">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultMenuFontSize = g.choose(sys.platform=="win32",9,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    # ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
</t>
<t tx="ekr.20041117062717.11">def getRecentFiles (self):

    '''Return the list of recently opened files.'''

    return self.recentFiles
</t>
<t tx="ekr.20041117062717.13">def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
</t>
<t tx="ekr.20041117062717.14">def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.

    bunchList = self.get(c,key,"shortcut")
    # g.trace('bunchList',bunchList)
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
</t>
<t tx="ekr.20041117062717.2">def __init__ (self):

    # g.trace('g.app.config')
    self.atCommonButtonsList = [] # List of info for common @buttons nodes.
    self.atCommonCommandsList = [] # List of info for common @commands nodes.
    self.buttonsFileName = ''
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.enabledPluginsFileName = None
    self.enabledPluginsString = '' 
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.menusList = []
    self.menusFileName = ''
    self.modeCommandsDict = {}
        # For use by @mode logic. Keys are command names, values are g.Bunches.
        # A special key: *mode-prompt* it the prompt to be given.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.machineConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    self.silent = g.app.silentMode
    # g.trace('c.config.silent',self.silent)

    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
</t>
<t tx="ekr.20041117065611">def initIvar(self,key):

    '''Init g.app.config ivars during initialization.

    This does NOT init the corresponding commander ivars.

    Such initing must be done in setIvarsFromSettings.'''

    trace = False and not g.unitTesting

    # N.B. The key is munged.
    bunch = self.ivarsDict.get(key)
    ivar = bunch.ivar # The actual name of the ivar.
    val = bunch.val

    if trace: g.trace('g.app.config',ivar,key,val)
    setattr(self,ivar,val)
</t>
<t tx="ekr.20041117065611.1">def initEncoding (self,key):

    '''Init g.app.config encoding ivars during initialization.'''

    # N.B. The key is munged.
    bunch = self.encodingIvarsDict.get(key)
    encoding = bunch.encoding
    ivar = bunch.ivar
    # g.trace('g.app.config',ivar,encoding)
    setattr(self,ivar,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
</t>
<t tx="ekr.20041117065611.2">def initIvarsFromSettings (self):

    trace = False and not g.unitTesting
    if trace: g.trace('-' * 20,g.callers())

    for ivar in self.encodingIvarsDict:
        if ivar != '_hash':
            self.initEncoding(ivar)

    for ivar in self.ivarsDict:
        if ivar != '_hash':
            self.initIvar(ivar)
</t>
<t tx="ekr.20041117072055"># Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
</t>
<t tx="ekr.20041117081009"></t>
<t tx="ekr.20041117081009.3">def getBool (self,c,setting,default=None):

    '''Return the value of @bool setting, or the default if the setting is not found.'''

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
</t>
<t tx="ekr.20041117081009.4">def getString (self,c,setting):

    '''Return the value of @string setting.'''

    return self.get(c,setting,"string")
</t>
<t tx="ekr.20041117081513">def getInt (self,c,setting):

    '''Return the value of @int setting.'''

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20041117082135">def getFloat (self,c,setting):

    '''Return the value of @float setting.'''

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20041117083141">def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    trace = False and not g.unitTesting and setting == 'create_nonexistent_directories'
    if trace: g.pdb()

    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and not isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    return None
</t>
<t tx="ekr.20041117083202"></t>
<t tx="ekr.20041117083202.2">def initRecentFiles (self):

    self.recentFiles = []
</t>
<t tx="ekr.20041117083857">def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.myGlobalConfigFile,
    self.myHomeConfigFile, and self.machineConfigFile."""

    trace = False and not g.unitTesting
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = g.computeMachineName() + 'LeoSettings.leo'

    # New in Leo 4.5 b4: change homeDir to homeLeoDir
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeLeoDir,       settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        #non-prefixed names take priority over prefixed names
        ('myHomeConfigFile',    g.app.homeLeoDir,   g.app.homeSettingsPrefix + mySettingsFile),
        ('myHomeConfigFile',    g.app.homeLeoDir,   mySettingsFile),
        ('machineConfigFile',   g.app.homeLeoDir,   g.app.homeSettingsPrefix + machineConfigFile),
        ('machineConfigFile',   g.app.homeLeoDir,   machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        #else:
            #if the path does not exist, only set to None if the ivar isn't already set.
            #dan: IMO, it's better to set the defaults to None in configClass.__init__().
            #     This avoids the creation of ivars in odd (non __init__) places.
            #setattr(self,ivar, getattr(self,ivar,None))
    if trace:
        g.trace('global file:  ',self.globalConfigFile)
        g.trace('home file:    ',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:  ',self.myHomeConfigFile)
</t>
<t tx="ekr.20041117083857.1"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    trace = False and not g.unitTesting
    if trace: g.trace('=' * 20, c and c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
</t>
<t tx="ekr.20041117085625">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20041117093009.1">def getDirectory (self,c,setting):

    '''Return the value of @directory setting, or None if the directory does not exist.'''

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
</t>
<t tx="ekr.20041117093009.2">def getLanguage (self,c,setting):

    '''Return the setting whose value should be a language known to Leo.'''

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
</t>
<t tx="ekr.20041117093246"></t>
<t tx="ekr.20041117151301">def computeHomeDir():

    """Returns the user's home directory."""

    import leo.core.leoGlobals as g

    home = os.path.expanduser("~")
        # Windows searches the HOME, HOMEPATH and HOMEDRIVE environment vars, then gives up.

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # Important: This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_finalize(home)
        if (
            not g.os_path_exists(home) or
            not g.os_path_isdir(home)
        ):
            home = None

    return home
</t>
<t tx="ekr.20041117155521">def computeGlobalConfigDir():

    import leo.core.leoGlobals as g

    # To avoid pylint complaints that sys.leo_config_directory does not exist.
    leo_config_dir = (
        hasattr(sys,'leo_config_directory') and
        getattr(sys,'leo_config_directory'))

    if leo_config_dir:
        theDir = leo_config_dir
    else:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_finalize(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir) or
        not g.os_path_isdir(theDir)
    ):
        theDir = None

    return theDir
</t>
<t tx="ekr.20041118053731">def get (self,setting,theType):
    '''A helper function: return the commander's setting, checking the type.'''
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict (self):
    '''return the commander's abbreviation dictionary.'''
    return g.app.config.getAbbrevDict(self.c)

def getBool (self,setting,default=None):
    '''Return the value of @bool setting, or the default if the setting is not found.'''
    return g.app.config.getBool(self.c,setting,default=default)

def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getColor (self,setting):
    '''Return the value of @color setting.'''
    return g.app.config.getColor(self.c,setting)

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.

def getData (self,setting):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    return g.app.config.getData(self.c,setting)

def getDirectory (self,setting):
    '''Return the value of @directory setting, or None if the directory does not exist.'''
    return g.app.config.getDirectory(self.c,setting)

def getFloat (self,setting):
    '''Return the value of @float setting.'''
    return g.app.config.getFloat(self.c,setting)

def getFontFromParams (self,family,size,slant,weight,defaultSize=12):

    '''Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.'''

    return g.app.config.getFontFromParams(self.c,
        family, size, slant, weight, defaultSize = defaultSize)

def getInt (self,setting):
    '''Return the value of @int setting.'''
    return g.app.config.getInt(self.c,setting)

def getLanguage (self,setting):
    '''Return the value of @string setting.

    The value of this setting should be a language known to Leo.'''
    return g.app.config.getLanguage(self.c,setting)

def getMenusList (self):
    '''Return the list of entries for the @menus tree.'''
    return g.app.config.getMenusList(self.c) # Changed in Leo 4.5.

def getOpenWith (self):
    '''Return a list of dictionaries corresponding to @openwith nodes.'''
    return g.app.config.getOpenWith(self.c)

def getRatio (self,setting):
    '''Return the value of @float setting.
    Warn if the value is less than 0.0 or greater than 1.0.'''
    return g.app.config.getRatio(self.c,setting)

def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles()

def getShortcut (self,shortcutName):
    '''Return the tuple (rawKey,accel) for shortcutName in @shortcuts tree.'''
    return g.app.config.getShortcut(self.c,shortcutName)

def getSettingSource(self,setting):
    '''return the name of the file responsible for setting.'''
    return g.app.config.getSettingSource(self.c,setting)

def getString (self,setting):
    '''Return the value of @string setting.'''
    return g.app.config.getString(self.c,setting)
</t>
<t tx="ekr.20041118062709">encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_at_auto_file_encoding","string","utf-8"),
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("defaultEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
</t>
<t tx="ekr.20041118084146"></t>
<t tx="ekr.20041118084146.1">def set (self,c,setting,kind,val):

    '''Set the setting.  Not called during initialization.'''

    trace = False and not g.unitTesting # and setting == 'create_nonexistent_directories'
    # if trace: g.pdb()

    found = False ;  key = self.munge(setting)
    if trace: g.trace(setting,kind,val)

    if c:
        d = self.localOptionsDict.get(c.hash())
        found = True # Bug fix: 2010/08/30.

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')

    if 0:
        dkind = d.get('_hash','&lt;no hash: %s&gt;' % c.hash())
        g.trace(dkind,setting,kind,val)
</t>
<t tx="ekr.20041118084241">def setString (self,c,setting,val):

    self.set(c,setting,"string",val)
</t>
<t tx="ekr.20041118104240">def initIvar(self,key):

    trace = False and not g.unitTesting
    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        if trace: g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
</t>
<t tx="ekr.20041118104414">def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad", "%s: %s" % (encodingName,encoding))
</t>
<t tx="ekr.20041118104831">class baseCommands (object):
    """The base class for Leo's main commander."""
    @others

class Commands (baseCommands):
    """A class that implements most of Leo's commands."""
    pass
</t>
<t tx="ekr.20041118104831.1">class configSettings:

    """A class to hold config settings for commanders."""

    @others
</t>
<t tx="ekr.20041118104831.2">def __init__ (self,c):

    trace = False and not g.unitTesting
    self.c = c

    if trace: g.trace('+' * 20,'(c.configSettings)',
        c and c.shortFileName(),g.callers(5))

    # Init these here to keep pylint happy.
    self.default_derived_file_encoding = None
    self.new_leo_file_encoding = None
    self.redirect_execute_script_output_to_log_pane = None

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict:
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict:
        if key != '_hash':
            self.initIvar(key)
</t>
<t tx="ekr.20041118195812">def setRecentFiles (self,files):
    '''Update the recent files list.'''
    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
</t>
<t tx="ekr.20041119203941">class configClass:
    """A class to manage configuration settings."""
    &lt;&lt; class data &gt;&gt;
    @others
</t>
<t tx="ekr.20041119203941.2">class parserBaseClass:

    """The base class for settings parsers."""

    &lt;&lt; parserBaseClass data &gt;&gt;

    @others
</t>
<t tx="ekr.20041119203941.3">class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
</t>
<t tx="ekr.20041119204103">def __init__ (self,c,localFlag=True):

    # Init the base class.
    parserBaseClass.__init__(self,c,localFlag)
</t>
<t tx="ekr.20041119204700">def __init__ (self,c,localFlag):

    self.c = c
    self.localFlag = localFlag
        # True if this is the .leo file being opened,
        # as opposed to myLeoSettings.leo or leoSettings.leo.
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'buttons':      self.doButtons, # New in 4.4.4
        'color':        self.doColor,
        'commands':     self.doCommands, # New in 4.4.8.
        'data':         self.doData, # New in 4.4.6
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifhostname':   self.doIfHostname,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'menus':        self.doMenus, # New in 4.4.4
        'menuat':       self.doMenuat,
        'popup': self.doPopup, # New in 4.4.8

        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }

    self.debug_count = 0
</t>
<t tx="ekr.20041119204700.1">def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.h)
            # if p.h == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.h,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
</t>
<t tx="ekr.20041119204700.2">def oops (self):
    g.pr("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
</t>
<t tx="ekr.20041119204700.3">def visitNode (self,p):

    self.oops()
</t>
<t tx="ekr.20041119204714">def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.h)

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.h)
    kind = munge(kind)

    if g.isPython3:
        isNone = val in ('None','none','',None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','',None)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    # elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
    elif kind in self.basic_types and isNone:
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p,kind,name,val)
            except Exception:
                g.es_exception()
        else:
            g.pr("*** no handler",kind)

    return None
</t>
<t tx="ekr.20041119205148">def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
</t>
<t tx="ekr.20041120064303">def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file or the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose or trace
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    if trace: g.trace(fileName,g.callers())
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            if giveMessage:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.es_print(s,color='blue')
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20041120073824">def destroySelf (self):

    pass
</t>
<t tx="ekr.20041120074536">def settingsRoot (self,c):

    '''Return the position of the @settings tree.'''

    # g.trace(c,c.rootPosition())

    for p in c.all_unique_positions():
        if p.h.rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
</t>
<t tx="ekr.20041120094940"></t>
<t tx="ekr.20041120094940.1">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20041120094940.10">def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    self.error("%s is not a valid %s for %s" % (val,kind,name))
</t>
<t tx="ekr.20041120094940.2">def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
</t>
<t tx="ekr.20041120094940.3">def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
</t>
<t tx="ekr.20041120094940.4">def doFont (self,p,kind,name,val):

    trace = False

    if trace: g.trace(p and p.h,kind,name,self.c.mFileName)

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
            if trace and val not in (None,'none','None'): g.trace(key,val)
</t>
<t tx="ekr.20041120094940.5">def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20041120094940.6">def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20041120094940.8">def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20041120094940.9">def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    trace = False and not g.unitTesting
    if trace: g.trace(kind,name,val)

    c = self.c ; key = self.munge(name)

    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
            g.es("over-riding setting:",name,"from",path)

    # N.B.  We can't use c here: it may be destroyed!
    # if key == 'shortcut':
        # g.trace('*****',key,val)

    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
</t>
<t tx="ekr.20041120103012">def error (self,s):

    g.pr(s)

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
</t>
<t tx="ekr.20041120103933">def doIf(self,p,kind,name,val):

    g.trace("'if' not supported yet")
    return None
</t>
<t tx="ekr.20041120104215">def doIfPlatform (self,p,kind,name,val):

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
</t>
<t tx="ekr.20041120104215.1">def doIgnore(self,p,kind,name,val):

    return "skip"
</t>
<t tx="ekr.20041120104215.2">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
</t>
<t tx="ekr.20041120105609">def doShortcuts(self,p,kind,name,val,s=None):

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    munge = k.shortcutFromSetting
    if s is None: s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # if name in ('save-file','enter-tree-save-file-mode'): g.pdb()
            if bunch is not None:
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace: g.trace('****** killing binding:',bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace: g.trace('%6s %20s %s' % (bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
</t>
<t tx="ekr.20041120112043">def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --&gt; entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -&gt; mode-name = binding
    command-name -&gt; same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'--&gt;'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'-&gt;'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
</t>
<t tx="ekr.20041121125416">@
Alas, @if-gui can't be made to work. The problem is that plugins can
set g.app.gui, but plugins need settings so the leoSettings.leo files
must be parsed before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
</t>
<t tx="ekr.20041121125741">def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20041121130043"># These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','buttons','commands','data','enabledplugins','font',
    'if','ifgui','ifhostname','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts',
    'buttons','menus', # New in Leo 4.4.4.
    'menuat', 'popup', # New in Leo 4.4.8.
    ]

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
</t>
<t tx="ekr.20041121143823">def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val

    if g.isPython3:
        isNone = val in ('None','none','',None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','',None)

    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
</t>
<t tx="ekr.20041121145452">if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
</t>
<t tx="ekr.20041122070339">def getColor (self,c,setting):

    '''Return the value of @color setting.'''

    return self.get(c,setting,"color")
</t>
<t tx="ekr.20041122070752">def getRatio (self,c,setting):

    '''Return the value of @float setting.

    Warn if the value is less than 0.0 or greater than 1.0.'''

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
</t>
<t tx="ekr.20041122094813">@others

# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []

# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
</t>
<t tx="ekr.20041122153823">def print_stack():

    traceback.print_stack()

printStack = print_stack
</t>
<t tx="ekr.20041123070429">def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
</t>
<t tx="ekr.20041123092357"># This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree():
        #BJ munge will return None if a headstring is empty
        h = munge(p.h) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
</t>
<t tx="ekr.20041123094807">def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents():
        h = p.h
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
</t>
<t tx="ekr.20041124063257">def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
</t>
<t tx="ekr.20041124083125">def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName
</t>
<t tx="ekr.20041126042730">def getTabWidth (self,p=None):

    c = self.c
    if 1:
        # Faster, more self-contained.
        val = g.scanAllAtTabWidthDirectives(c,p)
        return val
    else:
        d = c.scanAllDirectives(p)
        w = d.get("tabwidth")
        if w not in (0,None):
            return w
        else:
            return self.c.tab_width
</t>
<t tx="ekr.20041126060136">def print_list(aList,tag=None,sort=False,indent=''):

    if not aList:
        if tag: g.pr('%s...[]' % tag)
        else:   g.pr('[]')
        return
    if sort:
        bList = aList[:] # Sort a copy!
        bList.sort()
    else:
        bList = aList
    if tag: g.pr('%s...[' % tag)
    else:   g.pr('[')
    for e in bList:
        g.pr('%s%s' % (indent,repr(e).strip()))
    g.pr(']')

printList = print_list

def listToString(aList,tag=None,sort=False,indent='',toRepr=False):

    if not aList:
        if tag: return '%s...{}' % tag
        else:   return '[]'
    if sort:
        bList = aList[:] # Sort a copy!
        bList.sort()
    else:
        bList = aList
    lines = ["%s%s" % (indent,repr(e).strip()) for e in bList]
    s = '\n'.join(lines)
    if toRepr: s = repr(s)
    if tag:
        return '[%s...\n%s\n]' % (tag,s)
    else:
        return '[%s]' % s
</t>
<t tx="ekr.20041130065718.1">def setTopGeometry (self,w,h,x,y,adjustSize=True):

    self.w = w
    self.h = h
    self.x = x
    self.y = y
</t>
<t tx="ekr.20041130065921">def bringToFront (self):    pass
def deiconify (self):       pass
def get_window_info(self):
    # Set w,h,x,y to a reasonable size and position.
    return 600,500,20,20
def lift (self):            pass
def setWrap (self,flag):    pass
def update (self):          pass
</t>
<t tx="ekr.20041130093254">def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
</t>
<t tx="ekr.20041130104552">@killcolor

By: Guenther Enthaler - genthaler
RE: Haskell support  
2004-11-18 22:55

There's a literate programming mode in Haskell (and in a number of other functional programming languages such as Clean &amp; Curry), where the program is in a comment, usually where the line starts with "&gt;" (bird track style, I think it's called), and the comments/documentation are freeform. It would be difficult but cool if Leo could support it, if only because the sentinels in the derived files wouldn't make whole file look so busy. 

Günther 
</t>
<t tx="ekr.20041130123243">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2859273
e

theres a config option to clear undo on save.
can that be a menu choice as well? 
clear undo now.
enable clear undo on save.
moot as it will be with the new config options
and any undo changes on the table.
maybe there is a single point to involke clear 
undo that could be run from a button?

with py2.3 after allot of small edits on an open leo after a few hours gc can
hit unexpectedly and last several minutes
and return at any time lasting several more minutes.
I think its gc related because the memory use and disk grinding demanding I
free up memory or kill python.

I have no idea if undo is the cause,
 just guessing.
using cvs of last week. I just updated, 
will let you know if it happens again.
(new error reporting jump to error is great)

usually I don't edit in the same process that long.
I have run scripts from leo that run 6, 12 
or 24 hours no problem. 
maybe I can turn on some internals reporting and
get some feedback on whats going on from python if it happens again. 
or run the gc script before and after.

 win98 128meg w/maxmem memory defrager that works well.
but I go from 50% free to 10% when this starts happening.
I haven't noticed this problem yet in py2.4, and it is peppier,
but don't use py2.4 enough. it doesn't happen every day.
I reboot at least once a day for various reasons.
so it isn't that either. 
you do need to reboot and or exit python once it starts.
this was never an issue with py2.2 and Leo 4.1 or less with only 64 megs.
I don't really have any other long running python processes to compare to Leo. 
can't say what it is.
Aha, progress. 
this started sometime early in 4.2 or late 4.1
but I can still be persuaded something in my 
local system is to blame, some install or dll update. or script, psyco or plugin
related.

nonwithstanding, I should be taking better advantage Moore's law in my CPU and
memory.
I only notice this when I'm running the same leo over a few hours of constant
editing and running scrips.
and when I exit python and restart leo everything returns to normal.
more a supporting anomaly report 
than a bug report or feature request.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return c.os_path_finalize(c.mFileName).lower()
    else:
        return 0
</t>
<t tx="ekr.20041201071145">http://sourceforge.net/forum/message.php?msg_id=2876797
By: skal

By: Grossé Pascal - skal
RE: Leo freezing up  
2004-12-01 06:15

The freezing problem on debian sid (which is also my current OS) is caused by a bug in Tkinter: Tkinter does not work when libtk is compiled with thread support, which is the case on debian sid for tk8.4 
I compiled my own non-threaded libtk with the corresponding python/tkinter, and the freeze magically vanished.  

This is a known bug in debian bugtrack: 

http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=171353 

Skal
</t>
<t tx="ekr.20041201080436">def appendToRecentFiles (self,files):

    files = [theFile.strip() for theFile in files]

    # g.trace(files)

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles[:]:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
</t>
<t tx="ekr.20041201084142">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2877106

By: Paul Paterson - paulpaterson
RE: Can I color the headline text ?  
2004-12-01 08:01

The cleo plugin makes a permanent change to the headline appearance (using node attributes) while the footprints plugin makes a temporary change in the current session. Footprints was derived from cleo, although you might not be able to tell from looking at it! 

Cleo: http://sourceforge.net/forum/message.php?msg_id=2617221 

Footprints: http://sourceforge.net/forum/message.php?msg_id=2813450 

Between the two of them there should be enough information to help you achieve what you want. 

It is possible to do pretty much anything you want but you will have to provide the infrastructure yourself because Leo doesn't natively support it.  
</t>
<t tx="ekr.20041213082558"></t>
<t tx="ekr.20041213082558.1">def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.b
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
</t>
<t tx="ekr.20041213082558.2">def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
</t>
<t tx="ekr.20041213083651">def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
</t>
<t tx="ekr.20041214135556">@nocolor
https://sourceforge.net/forum/message.php?msg_id=2882718
By: nobody

if anyone is interested here is some code that Tilefied my Leo instance, its
does some patching in the LeoGui program.

@color

def createRootWindow(self):

    """Create a hidden Tk root window."""
    #import Tix
    self.root = root = Tk.Tk()
    root.tk.call( 'package', 'require', 'tile' )
    #root.tk.call( 'namespace', 'import', '-force', 'ttk::*' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::scrollbar' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::label' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::entry' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menu' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::button' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::frame' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menubutton' )
    root.tk.call( 'tile::setTheme', 'clam' )
    #self.root = root = Tix.Tk()
    root.title("Leo Main Window")
    root.withdraw()

    self.setDefaultIcon()
    self.getDefaultConfigFont(g.app.config)
    self.createGlobalWindows()

    return root
</t>
<t tx="ekr.20041217041016">def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bold_font:
        self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    self.image_references = []
</t>
<t tx="ekr.20041217132028">def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20041217132253">def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20041219071407">def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''

    # g.trace(verbose,moduleName,pluginName)

    import os

    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    # this is basically only used for Pmw these days - we'll prevent plugins 
    # from killing all of Leo by returning None here instead
    if not module:
        g.pr("Warning: plugin '%s' failed to import '%s'" % (pluginName, moduleName))

    return module
</t>
<t tx="ekr.20041219095213">@
1/6/05: The problem with Tkinter is that imp.load_module is equivalent
to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if
moduleName is in sys.modules!
</t>
<t tx="ekr.20041219095213.1">def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''

    trace = False and not g.unitTesting
    module = sys.modules.get(moduleName)
    if module:  return module

    try:
        theFile = None
        import imp
        try:
            # New in Leo 4.7. We no longer add Leo directories to sys.path,
            # so search extensions and external directories here explicitly.
            for findPath in (None,'extensions','external'):
                if findPath:
                    findPath2 = g.os_path_finalize_join(
                        g.app.loadDir,'..',findPath)
                    findPath = [findPath2]
                if trace: g.trace('findPath',findPath)
                try:
                    data = imp.find_module(moduleName,findPath) # This can open the file.
                    theFile,pathname,description = data
                    if trace: g.trace(theFile,moduleName,pathname)
                    module = imp.load_module(moduleName,theFile,pathname,description)
                    if module: break
                # except ImportError:
                    # if trace: g.trace('not found',moduleName,findPath)
                except Exception:
                    g.es('Exception loading %s module' % (moduleName),color='blue')
        except Exception: # Importing a module can throw exceptions other than ImportError.
            g.es_exception()
    finally:
        if theFile: theFile.close()

    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
    return module
</t>
<t tx="ekr.20041219162724">http://sourceforge.net/forum/message.php?msg_id=2903742
By: nobody

In the multifile plugin there is an option to insert a directory string.  I
use it alot for the @path directive.  What happens is that when executed a FileDialog
opens up and the user selects the directory he wants to use as a directory string.
When chosen the directory string is inserted into the text editor.

The good of this:
1. It makes using path simpler, you dont have to type out the directory path
yourself, just use the tkFileDialog to select it and have Leo insert the string.
For long directories this saves a lot of typing.

simple, short and quite helpful.  Thoughts? :)

-----------

Time to create a directory class??

</t>
<t tx="ekr.20041223105114.1">def createStatusLine (self):
    if not self.statusLine:
        self.statusLine = self.statusLineClass(self.c,self.outerFrame)
    return self.statusLine

def clearStatusLine (self):
    if self.statusLine: self.statusLine.clear()

def disableStatusLine (self,background=None):
    if self.statusLine: self.statusLine.disable(background)

def enableStatusLine (self,background="white"):
    if self.statusLine: self.statusLine.enable(background)

def getStatusLine (self):
    return self.statusLine

getStatusObject = getStatusLine

def putStatusLine (self,s,color=None):
    if self.statusLine: self.statusLine.put(s,color)

def setFocusStatusLine (self):
    if self.statusLine: self.statusLine.setFocus()

def statusLineIsEnabled(self):
    if self.statusLine: return self.statusLine.isEnabled()
    else: return False

def updateStatusLine(self):
    if self.statusLine: self.statusLine.update()
</t>
<t tx="ekr.20041224080039">def print_dict(d,tag='',verbose=True,indent=''):

    if not d:
        if tag: g.pr('%s...{}' % tag)
        else:   g.pr('{}')
        return

    n = 6
    for key in sorted(d):
        if type(key) == type(''):
            n = max(n,len(key))
    if tag: g.es('%s...{\n' % tag)
    else:   g.es('{\n')
    for key in sorted(d):
        g.pr("%s%*s: %s" % (indent,n,key,repr(d.get(key)).strip()))
    g.pr('}')

printDict = print_dict

def dictToString(d,tag=None,verbose=True,indent=''):

    if not d:
        if tag: return '%s...{}' % tag
        else:   return '{}'
    n = 6
    for key in sorted(d):
        if g.isString(key):
            n = max(n,len(key))
    lines = ["%s%*s: %s" % (indent,n,key,repr(d.get(key)).strip())
        for key in sorted(d)]
    s = '\n'.join(lines)
    if tag:
        return '%s...{\n%s}\n' % (tag,s)
    else:
        return '{\n%s}\n' % s
</t>
<t tx="ekr.20041227063801">import leo.core.leoGlobals as g
import leo.core.leoGui as leoGui

import sys
import zipfile
</t>
<t tx="ekr.20041227063801.2">def initDicts (self):

    # Only the settings parser needs to search all dicts.
    self.dictList = [self.defaultsDict]

    for key,kind,val in self.defaultsData:
        self.defaultsDict[self.munge(key)] = g.Bunch(
            setting=key,kind=kind,val=val,tag='defaults')

    for key,kind,val in self.ivarsData:
        self.ivarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,val=val,tag='ivars')

    for key,kind,val in self.encodingIvarsData:
        self.encodingIvarsDict[self.munge(key)] = g.Bunch(
            ivar=key,kind=kind,encoding=val,tag='encodings')
</t>
<t tx="ekr.20041227071423">def setShortcut (self,name,bunchList):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunchList)

    if 0:
        for b in bunchList:
            g.trace('%20s %45s %s' % (b.val,rawKey,b.pane))
</t>
<t tx="ekr.20041228042224">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.

    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''

    trace = False and not g.unitTesting
    verbose = False

    if not self.inited: return

    # Ignore temporary commanders created by readSettingsFiles.
    if trace and verbose: g.trace('*' * 10)
    if trace: g.trace(
        'inited',self.inited,
        c and c.shortFileName() or '&lt;no c&gt;',g.callers(2))

    d = self.ivarsDict
    keys = list(d.keys())
    keys.sort()
    for key in keys:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    if trace and verbose: g.trace("%20s %s = %s" % (
                        g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    if trace and verbose: g.trace("%20s %s = %s" % (
                        'g.app.config',ivar,val))
                    setattr(self,ivar,val)
</t>
<t tx="ekr.20041228084143"></t>
<t tx="ekr.20041228085245"></t>
<t tx="ekr.20041228091154"></t>
<t tx="ekr.20041228092223">http://sourceforge.net/forum/message.php?msg_id=2205285
From: Rich

Color ''and'' italic/bold characters with @markup. One thing I'd like to
''not'' see are the markup characters in @file-nosent files.  "~~red:NOTE:~~"
does nothing for readability in plain text.
</t>
<t tx="ekr.20041228092223.4"></t>
<t tx="ekr.20050103163224"># Note: Import code uses this.

def scanHeaderForThin (self,theFile,fileName):

    '''Scan the header of a derived file and return True if it is a thin file.

    N.B. We are not interested in @first lines, so any encoding will do.'''

    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding

    junk,junk,isThin = at.scanHeader(theFile,fileName)

    return isThin
</t>
<t tx="ekr.20050104094029">def oops (self):

    # g.trace("leoMenu", g.callers())
    pass
</t>
<t tx="ekr.20050104094308">def __init__ (self,frame):

    # Init the base class.
    leoMenu.__init__(self,frame)
</t>
<t tx="ekr.20050104123726.3">def utils_remove (fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            g.es("exception removing:",fileName)
            g.es_exception()
        return False
</t>
<t tx="ekr.20050104123726.4">def utils_stat (fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    try:
        mode = (os.stat(fileName))[0] &amp; (7*8*8 + 7*8 + 7) # 0777
    except Exception:
        mode = None

    return mode
</t>
<t tx="ekr.20050104124903">def utils_chmod (fileName,mode,verbose=True):

    if mode is None:
        return

    try:
        os.chmod(fileName,mode)
    except Exception:
        if verbose:
            g.es("exception in os.chmod",fileName)
            g.es_exception()
</t>
<t tx="ekr.20050104131820">def chmod (self,fileName,mode):

    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
</t>
<t tx="ekr.20050104131929">@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
</t>
<t tx="ekr.20050104131929.1">&lt;&lt; about os.rename &gt;&gt;

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.

    Change the mode of the renamed file if mode is given.

    Return True if all went well.'''

    c = self.c
    head,junk=g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
</t>
<t tx="ekr.20050104131929.2">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
</t>
<t tx="ekr.20050104132018">def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
            g.trace(g.callers(5))
        return False
</t>
<t tx="ekr.20050104132026">def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
</t>
<t tx="ekr.20050104135720"></t>
<t tx="ekr.20050108051818">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2928436
By: jasonic

&gt; I really do want and need to be able to embed basic links throughout out my Leo outlines in a natural 2005 fashion. 

This should be fairly easy to do.

At present, the use_hyperlinks configuration option controls whether Leo generates 'live' hyperlinks for section names.  I don't enable this be default because I dislike jumping around the outline.  Instead, I use clones.

The code to do these kinds of hyperlinks is pretty straightforward.  There is a little code in the colorizer and callbacks in the leoTkinterTree, iirc.

Supporting hyperlinks to urls would be similar.  They could appear in the following situations:

- Anywhere where @language plain is in effect.
- In comments where @language (a programming language) is in effect.
- Anywhere (except in comments?) where @language html is in effect.

This would make a straightforward plugin.  Mind you, this should be in Leo's core, but a plugin would get my attention :-)  Perhaps the reason I haven't done this is that I keep thinking a generalized syntax colorer is near ;-)

Edward
</t>
<t tx="ekr.20050123160215.1">print '-' * 20
d = []

for p in c.all_positions():
    s = p.h
    if s.startswith('@thin'):
        d.append(s[5:].strip())

d.sort()

for s in d:
    print s



</t>
<t tx="ekr.20050123161408">0 leo.py
1 leoApp.py
2 leoAtFile.py
3 leoColor.py
4 leoCommands.py
5 leoCompare.py
6 leoConfig.py
7 leoFileCommands.py
8 leoFind.py
9 leoFrame.py
10 leoGlobals.py
11 leoGui.py
12 leoImport.py
13 leoKeys.py
14 leoMenu.py
15 leoNodes.py
16 leoPlugins.py
17 leoTangle.py
18 leoTkinterComparePanel.py
19 leoTkinterDialog.py
20 leoTkinterFind.py
21 leoTkinterFontPanel.py
22 leoTkinterFrame.py
23 leoTkinterGui.py
24 leoTkinterKeys.py
25 leoTkinterMenu.py
26 leoTkinterTree.py
27 leoUndo.py
</t>
<t tx="ekr.20050123164539">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
</t>
<t tx="ekr.20050125203937">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
</t>
<t tx="ekr.20050125220613">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20050126081529">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20050127110221">@killcolor
https://sourceforge.net/forum/message.php?msg_id=2962825
By: jasonic

-- pdf -- 
yes I know what you mean, PDF has it uses.  If nicely embedded into Leo via
'reportwriter'  and some export scripts {and clear useinterfance} would stillbe
a good thing.


As I start to think about how to print Leo, I become more aware of the differneces
between Leo structures and linear [print] layouts.

Different kinds of outlines obviously will need different kinds of printing.
I don't yet have enough experience or overview.

--xslt--
Seems a natural way to go for printing Leo, but yet another langauge and syntax
to wrassle with. Last time I looked I went from being horrified to very impressed
to be being exhausted.

--htmlize--
thanks I'll check into that

"print to web"  should definitely be on Leo's missing PRINT MENU.

--swf [flash]--
This printing topic pushes me harder to get FLC  [my FlashLeoClient project]
into the Leosphere.

Flash has*limited*  CSS handling, but enough to do some nice and useful typographic
formatting in a pretty clean object-oriented manner.

FLC parses .leo files into a Flash object. Flash Textformat instances are created
using CSS and can be applied then to rendering any parts of  the deserialized
Leo object.. The beauty is it can be very fast and ynamic so I can imagine a
real-time WYSIWYG laytou tool for printing Leo to web and at the same making
it suitable at the same time for print-to-paper.

Since FLC is in the very first instance a READ-ONLY client tool for Leo, it
makes it a natural Leo printing service.

To complete full service, it woudl be good if Leo could create SWF files directly
itself, just like using PDF reportwriter.
There are a couple of libraries to help this 
- Ming [with PHP, Perl, Python and Ruby wrappers]
http://ming.sourceforge.net/

- makeswf.r [interesting REBOL/Flash dialect by David Oldes]
http://sweb.cz/oliva.david/swf/

These could also be both configured as web-services.
So Leo print-to-web would include by default rendering a flash swf file versoin
of itself either using locally installed libraries or by passing a view of itself
to a chosen client or server-based tool.

But even without those extra 'services' and libraries a single flash file in
the form of FLC could become an effective Leo printing kit. Using a standalone
desktop  version [not embedded in the browser, out of the sandbox] much more
is possible - remote control, peer-peer editing, file writing etc.

-- flashpaper2--
btw, Lately I've been using Flashpaper2 a lot to print all kinds of stuff, Often
from web pages to my local adhoc home filebase. It's a very fast lighweight
alternative to PDF, saves paper, has excellent zooming and nice search features
built-in.
Flashpaper renders a very litteral snapshot, but as I am discovering that turns
out to be extremely useful.
For example you visit a page and click on some links. Flashpaper saves teh pages
exactly as it looks, viisted links disntinguished.  In the era of info-overload,
even that crude mnemonic is valuable.

Alas, Flashpaper2 is not free nor open in the way Leo is. But worth to play
with it if only for for the experience.
30 day trial downlaod from
http://www.macromedia.com/software/flashpaper/

And of course the flash _players_ is free, so can send people flashpaper documents
just like PDF.
Brilliant when you have a big Excel spreadsheet or CAD document which would
normally get all messy printing across pages, confusing people.
Instead adjust and print to a generous 'piece' of flashpaper - letting your
coleagues pan and zoom to their comfort.

I've not quite figured out the place where  Leo meets Flashpaper, because Leo
needs to preserve its full pane contents. Flashpaper works fine with long web
pages, automatically reading the full window contents and cutting into a paginated
sequence, ready for paper printing.
Leo's does not have aprint menu, so it's off the sytem's print-devices map,
which Flash paper appearing just  like any phtycial printer.

I imagine is possible to fix that in Leo, but I do not where to begin and woudl
not be surprised to learn its a major heachche to write adn debug for multiple
operating systems.

An immediate alternative are screencapture tools like vnc2swf or MDM Capture.

[vnc2swf uses Ming-0.2a]
http://www.unixuser.org/~euske/vnc2swf/

http://www.multidmedia.com/software/capture/index.php

But much is hidden or lost from view. 
Still very vauable for creating dynamic narrative tutorials [aka screencasting]

AS you know I am very excited about what flash can do for Leo, and vice versa.
But I am concerned that there is not yet a 100% Leo means which supports people's
standard print needs and habits.

-- PRINT MENU-- 
Leo deserves good friendly printing features which anyone can use. At the moment
we have a confusing patchwork of choices. Printing Leo seems to be both harder
and easier than  first meets the eye.

Having a little library of export scripts - well named, documented and intended
to aid printing woudl go a long way. Thesse scripts anyone coiuld be called
by onayone given a Leo Outline, accessing a navabr button. PRINT MENU or list.
Or they can just insert the appropriate script  into an outline giving finer
grained print control on the fly.
</t>
<t tx="ekr.20050130152008">def openLeoPlugins (self,event=None):

    '''Open leoPlugins.leo in a new Leo window.'''

    names =  ('leoPlugins.leo','leoPluginsRef.leo')

    c = self ; name = "leoPlugins.leo"

    for name in names:
        fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
        ok,frame = g.openWithFileName(fileName,c)
        if ok: return

    g.es('not found:', ', '.join(names))
</t>
<t tx="ekr.20050201175325.1"></t>
<t tx="ekr.20050201175325.2"></t>
<t tx="ekr.20050202052911.1"></t>
<t tx="ekr.20050202073944"></t>
<t tx="ekr.20050208093800">def toEncodedString (s,encoding='utf-8',reportErrors=False):

    if encoding is None:
        encoding = 'utf-8'

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
</t>
<t tx="ekr.20050208093800.1">def toUnicode (s,encoding='utf-8',reportErrors=False):

    # The encoding is usually 'utf-8'
    # but is may be different while importing or reading files.
    if encoding is None:
        encoding = 'utf-8'

    if isPython3:
        f,mustConvert = str,g.isBytes
    else:
        f = unicode
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = g.u('')
    elif mustConvert(s):
        try:
            s = f(s,encoding,'strict')
        except (UnicodeError,Exception):
            s = f(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
</t>
<t tx="ekr.20050208101229">if 0:
    # This is now done in run.
    import leoGlobals as g # So code can use g below.

# Don't import this here: it messes up Leo's startup code.
# import leo.core.leoTest as leoTest

try:
    import gc
except ImportError:
    gc = None

try:
    import filecmp
except ImportError: # does not exist in jython.
    filecmp = None

try:
    import gettext
except ImportError: # does not exist in jython.
    gettext = None

# Do NOT import pdb here!  We shall define pdb as a _function_ below.
# import pdb

if isPython3:
    from functools import reduce

if isPython3:
    import io
    StringIO = io.StringIO
else:
    import cStringIO
    StringIO = cStringIO.StringIO

import operator
import re
import shutil
import subprocess
# import sys
import time
import zipfile

# These do not exist in IronPython.
# However, it *is* valid for IronPython to use the Python 2.4 libs!
import os
import string
import tempfile
import traceback
import types
</t>
<t tx="ekr.20050211120242.2">def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
</t>
<t tx="ekr.20050214055018"></t>
<t tx="ekr.20050214055018.4"></t>
<t tx="ekr.20050214055018.5"></t>
<t tx="ekr.20050221054932"> @killcolor
http://sourceforge.net/forum/message.php?msg_id=3007062
By: jgleeson

Sorry to take so long to reply.  I've been buried in work and haven't kept up
with some email.

Here's the link to the site where I posted the folder you have:
&lt;http://homepage.mac.com/jdgleeson/&gt;  It's the small file named "Leo.zip" (23
KB), not the large file "Leo-4.3-alpha-2.dmg" (20 MB).

I agree that I did not write very clear instructions, beginnng with the first
step, where I should have also said:  "It is important to use version 1.1.8
of py2app, which is only available through svn.  The version on the py2app website
is 1.1.7, which creates buggy Tkinter apps. If you try to use version 1.1.7,
the Leo app it creates will give you a message saying that Tkinter is not properly
installed.  Your installation is fine; otherwise you could not have even built
Leo.app with py2app, because py2app copies the essential parts of Tcl/Tk into
the application bundle to make the app completely standalone."

I haven't tried intalling the Fink subversion -- I'm using DarwinPorts
&lt;http://darwinports.opendarwin.org/&gt;.  But there's a simpler alternative than
DarwinPorts. Metissian releases OS X packages of Subversion clients
&lt;http://metissian.com/projects/macosx/subversion/&gt;

AFAIK, the command "python setup.py bdist_mpkg --open" only applies to the py2app
1.1.8 distribution.  By the way, bdist_mpkg is distributed with py2app. It creates
a package around the setup.py script (more specialized than Platypus).  I don't
have any experience with bdist_mpkg yet.

'Copy the leo folder into this directory' is horrible. I'm glad you figured
it out -- I'm not sure I could have.

"python setup.py py2app -a" should be run in the folder with the readme file,
which also contains the setup.py file that the command refers to.  Most importantly,
the folder in which this command is run must contain the leo folder -- which
it does only if you are brilliant enough to decode my instructions.   ;) 

HTH

-John
</t>
<t tx="ekr.20050301105854">def copyAllTempBodyStringsToVnodes (self,root,thinFile):

    trace = False and not g.unitTesting
    if trace: g.trace('*****',root.h)
    at = self ; c = at.c
    for p in root.self_and_subtree():
        hasList = hasattr(p.v,'tempBodyList')
        hasString = hasattr(p.v,'tempBodyString')
        if not hasString and not hasList:
            continue # Bug fix 2010/07/06: do nothing!
        # Terminate the node if v.tempBodyList exists.
        if hasList:
            at.terminateNode(v=p.v)
                # Sets v.tempBodyString and clears v.tempBodyList.
            assert not hasattr(p.v,'tempBodyList'),'copyAllTempBodyStringsToVnodes 1'
            assert hasattr(p.v,'tempBodyString'),'copyAllTempBodyStringsToVnodes 2'
        s = p.v.tempBodyString
        delattr(p.v,'tempBodyString') # essential.
        old_body = p.b
        if s != old_body:
            if thinFile:
                p.v.setBodyString(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                c.setBodyString(p,s) # Sets c and p dirty.

            if p.v.isDirty():
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                # This warning is given elsewhere.
                # g.es("changed:",p.h,color="blue")
</t>
<t tx="ekr.20050304072744"></t>
<t tx="ekr.20050306070535">@killcolor
</t>
<t tx="ekr.20050306070535.3">http://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:

&gt;This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to &lt;Alt-KeyPress&gt;,
&lt;Shift-KeyPress&gt;, etc.  Tk chooses the most specific event it can find, so the
more general &lt;KeyPress&gt; handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

Brian Theado
</t>
<t tx="ekr.20050312114529"></t>
<t tx="ekr.20050312114529.1">def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20050312114529.2">def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in range(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es('',"'%s'" % (d2),"not found",color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es('',"'%s'" % (d3),"not found",color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20050314140957">def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i &lt;= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
</t>
<t tx="ekr.20050315071727">def convertRowColToPythonIndex (s,row,col,lines=None):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row &lt; 0: return 0

    if lines is None:
        lines = g.splitLines(s)

    if row &gt;= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    # A big bottleneck
    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
</t>
<t tx="ekr.20050315073003"></t>
<t tx="ekr.20050315133212.2">def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
</t>
<t tx="ekr.20050315134017.2">def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
</t>
<t tx="ekr.20050315134017.3">def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
</t>
<t tx="ekr.20050315134017.4">def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types &amp; helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
</t>
<t tx="ekr.20050315134017.6">def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
</t>
<t tx="ekr.20050315134017.7">def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
</t>
<t tx="ekr.20050316092232">- Unpack the .zip file, placing the result somewhere, say in c:\prog\jyleo-Jan-11-06

- Edit jleo.bat so it refers to jyleo-Jan-11-06.  For example:

rem open jyLeo
set ARGS= 
:loop 
if [%1] == [] goto end 
set ARGS=%ARGS% %1 
shift 
goto loop 
:end 

cd c:\prog\jyleo-Jan-11-06
java -jar c:\jython-2.2a1\jython.jar src\leo.py
</t>
<t tx="ekr.20050317153447">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053534
By: paulpaterson

Very interesting indeed - great work! 

I didn't have Java/Jython installed so for others in the same boat here's what I had to do to get it work on my platform (Win2k). Some of this is in the README but I had to do some extra but I'm not sure why. 

1. Install 1.5 JDK  
http://java.sun.com/j2se/1.5.0/download.jsp 

2. Install Jython 
http://www.jython.org/jython22a1.zip 

3. Edit Jython.bat file - the part that calls Java.exe to ... 
"C:\Program Files\Java\jdk1.5.0_02\jre\bin\java" -cp "C:\Program Files\Java\jdk1.5.0_02\jre\lib";"c:\Apps\Python23\Jython";"C:\Apps\jLeo\j-leo-MAR15\Icons";"C:\Apps\jLeo\j-leo-MAR15\skins";"C:\Apps\jLeo\j-leo-MAR15\src";"C:\Apps\jLeo\j-leo-MAR15\skinimages" -Dpython.home="c:\Apps\Python23\Jython" -jar jython.jar %ARGS% 

Where  
- Java installed at C:\Program Files\Java\jdk1.5.0_02 
- Jython at c:\Apps\Python23\Jython 
- jLeo at C:\Apps\jLeo\j-leo-MAR15 

Change your paths as appropriate! There must be a better way to do this - Java confuses me! 

4. Edit leo.py in jleo/src directory to fix failure to find HOME env variable. 

line 241 becomes ... 

....try:home = os.getenv('HOME' )#,default=dotDir) 
....except KeyError:home="" 


Then, from the Jython install directory ... 

Jython " 
C:\Apps\jLeo\j-leo-MAR15\src\leo.py" 

Works a treat!  

Paul
</t>
<t tx="ekr.20050318085432.2">def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
</t>
<t tx="ekr.20050318085432.3"></t>
<t tx="ekr.20050318085432.4"></t>
<t tx="ekr.20050318085432.6">def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
</t>
<t tx="ekr.20050318085432.7">def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
</t>
<t tx="ekr.20050318085432.8">def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
</t>
<t tx="ekr.20050318085713">def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
</t>
<t tx="ekr.20050318085713.1">def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
</t>
<t tx="ekr.20050318085713.2">def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
</t>
<t tx="ekr.20050328093147.1">@killcolor
http://sourceforge.net/forum/message.php?msg_id=3064212
By: djsg

The following applies to Leo 4.3, which is in alpha as I write this. It describes
the LeoSetup routine that I submitted to Edward to solve the "can't find Python"
problem, and which Edward cleaned up for distribution.

I think a few further issues need attention. I noticed them while working on
the "can't find Python" problem, and deferred dealing with them. This appears
to me to be a good time to pick them up.

Before I start work on them, I would like to lay them out for your comment.
Are they pains in the first place? Are my proposals good enough, and do they
make sense?

Issue 1. LeoSetup still thinks Leo's user is an Administrator who owns the whole
machine.

For explanation, let's say that I log on as David to Windows 2000 or Windows
XP and install Leo 4.3. You then log out. You log in as Edward, and click Start,
pick Programs... you have no visible entry for Leo!

The current Setup routine allows no one but David to use Leo on this computer.
To make things worse, when I go to use Leo, I have to log in to Windows using
the account under which I installed it, which has Administrator rights to the
computer. In other words, I can't use Leo without operating the computer in
a mode that leaves it needlessly vulnerable to security violations.

Issue 2. LeoSetup allows only one copy of Leo on a given computer. 

LeoSetup assumes that you want Leo in C:\Program Files\Leo. The installer can
override that already. LeoSetup also goes to some trouble to set up the usual
click-to-open behavior for .leo files. That behavior is tied to the copy of
Python that was current when I ran LeoSetup, and tied to the copy of Leo that
was installed most recently.

Proposal: While LeoSetup should allow all accounts to share the Python code
for core Leo and its plug-ins, my guess is that we don't want to enforce that,
since Leo is a programmer's tool and the individual programmer will wish to
modify Leo and its pieces for the programmer's use.

Proposal Option 1. Setup should ask whether to install Leo for everyone or for
the installer's account only. If the answer to that question is "yes," Setup
should give the user a private copy of everything that comes with Leo -- the
only application shared should be the current Python, assuming that it is installed
for all users.

Python.org's installer for Python 2.4 allows the installed Python to work only
for the account that installed it. I found this in December and wrote code to
handle it, which I then commented out since the issue wasn't critical. I can
check a computer with a single-account installation of Python in order to figure
out how a single-account installation of Leo would have to handle the click-to-open
behavior.

Proposal Option 2. When LeoSetup finds Python installed for that single user,
it should ask whether to install Leo for the installer's account only. If the
answer to that question is "yes," Setup should give the user a private copy
of everything that comes with Leo and use the single-user installation of Python.
Why does this matter. If you need to test your plug-ins with different versions
of Python, this would make that easier.

Issue 3. LeoSetup always installs Python MegaWidgets ("Pmw"), even on computers
whose installed Python installation already includes it.

Proposal: put up a dialog box and ask whether Setup should install Pmw  I do
not know whether doing this is a good idea.

Issue 4. LeoSetup does not run without human intervention. This complicates
deploying Leo in multi-computer sites.

The message box that displays the path of the Python installation found is one
issue. I put it in to allow the installer to cross-check Setup's behavior. Since
nobody has complained about problems with the code I wrote to fix the problem
installing with Python 2.4 and Active Python, Setup need no longer force the
installer to review the message box's contents.

Proposal: The message box needs to time out after, say, 15 seconds. 

I last looked at the installer three months ago so I would have to look at the
rest of it for other barriers to automated installation.

Let me know what you think. I won't be able to start work for a week or so,
so there's no rush.

-- David
</t>
<t tx="ekr.20050328133058"># This must be defined in leoGlobals: g.app.gui doesn't exist yet.

def createStandAloneTkApp(pluginName=''):

    '''Create a Tk version of the g.app object for 'stand-alone' plugins.'''

    if not g.app:
        # Important: these references do not make Leo's core gui-dependent.
        # In other words, this function is called only when Tkinter should be the gui.
        import Tkinter as Tk
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leo.core.leoApp as leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('&lt;stand-alone app gui&gt;')
            g.computeStandardDirectories()
    return g.app
</t>
<t tx="ekr.20050328133444">def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir, g.app.homeLeoDir and g.app.globalConfigDir.'''

    g.app.loadDir = g.computeLoadDir()
    g.app.leoDir = g.computeLeoDir()
    g.app.homeDir = g.computeHomeDir()

    g.app.homeLeoDir = homeLeoDir = g.os_path_finalize(
        g.os_path_join(g.app.homeDir,'.leo'))

    if not g.os_path_exists(homeLeoDir):
        g.makeAllNonExistentDirectories(homeLeoDir,force=True)

    g.app.extensionsDir = g.os_path_finalize(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_finalize(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(
        g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20050404151753">def __init__(self,encoding='utf-8',fromString=None):

    # g.trace('g.fileLikeObject:__init__','fromString',fromString)

    # New in 4.2.1: allow the file to be inited from string s.

    self.encoding = encoding or 'utf-8'

    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
</t>
<t tx="ekr.20050404151753.1">def clear (self):

    self.list = []
</t>
<t tx="ekr.20050404151753.2">def close (self):

    pass

    # The StringIo version free's the memory buffer.
</t>
<t tx="ekr.20050404151753.3">def flush (self):

    pass
</t>
<t tx="ekr.20050404151753.4">def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
</t>
<t tx="ekr.20050404151753.5">def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr &lt; len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
</t>
<t tx="ekr.20050404151753.6">def write (self,s):

    if s:
        if g.isBytes(s):
            s = g.toUnicode(s,self.encoding)

        self.list.append(s)
</t>
<t tx="ekr.20050404190914.2">def deleteFileWithMessage(self,fileName,unused_kind):

    try:
        os.remove(fileName)

    except Exception:
        if self.read_only:
            g.es("read only",color="red")
        if not g.unitTesting:
            g.es("exception deleting backup file:",fileName)
            g.es_exception(full=False)
        return False
</t>
<t tx="ekr.20050405141130">import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import leo.core.leoNodes as leoNodes

import binascii
import difflib

if g.isPython3:
    import io # Python 3.x
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    import cStringIO # Python 2.x
    StringIO = cStringIO.StringIO

import os
import pickle
import string
import sys
import tempfile
import types
import zipfile

try:
    # IronPython has problems with this.
    import xml.sax
    import xml.sax.saxutils
except Exception:
    pass

# The following is sometimes used.
# import time
</t>
<t tx="ekr.20050408100042">def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
</t>
<t tx="ekr.20050410095424">def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    marked = g.choose(isOld,u.oldMarked, u.newMarked)

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    # Bug fix: Leo 4.4.6: Undo/redo always set changed/dirty bits
    # because the file may have been saved.
    u.p.setDirty(setDescendentsDirty=False)
    u.p.setAllAncestorAtFileNodesDirty(setDescendentsDirty=False) # Bug fix: Leo 4.4.6
    u.c.setChanged(True)
</t>
<t tx="ekr.20050410110215">def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
</t>
<t tx="ekr.20050410110343">def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
</t>
<t tx="ekr.20050411111847">def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050411112033">def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20050411193627.3">def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
</t>
<t tx="ekr.20050411193627.4">def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
</t>
<t tx="ekr.20050411193627.5">def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.6">def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.7">def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.8">def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.9">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v.h[:],body=v.b[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
</t>
<t tx="ekr.20050412080354">def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
</t>
<t tx="ekr.20050412083057">def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412083057.1">def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
</t>
<t tx="ekr.20050412083244">def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
</t>
<t tx="ekr.20050412084055">def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
</t>
<t tx="ekr.20050412084532">def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412085112">def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
</t>
<t tx="ekr.20050412085138.1">def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
</t>
<t tx="ekr.20050415134809"># New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortChildren (self,event=None,key=None):

    '''Sort the children of a node.'''

    c = self ; p = c.p

    if p and p.hasChildren():
        c.sortSiblings(p=p.firstChild(),sortChildren=True,key=key)
</t>
<t tx="ekr.20050415134809.1"># New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self,event=None,key=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
</t>
<t tx="ekr.20050415165731">def clearUndoState (self):
    pass

def canRedo (self):
    return False

def canUndo (self):
    return False

def enableMenuItems (self):
    pass

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    pass

def setUndoTypes (self):
    pass
</t>
<t tx="ekr.20050415165731.1">def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):
    pass
def beforeChangeTree (self,p):
    pass
def beforeChangeGroup (self,p,command):
    pass
def beforeClearRecentFiles (self):
    pass
def beforeCloneNode (self,p):
    pass
def beforeDeleteNode (self,p):
    pass
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    pass
def beforeMark (self,p,command):
    pass
def beforeMoveNode (self,p):
    pass
</t>
<t tx="ekr.20050415170018">def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):
    pass
def afterChangeTree (self,p,command,bunch):
    pass
def afterChangeGroup (self,p,command,reportFlag=False,dirtyVnodeList=[]):
    pass
def afterClearRecentFiles (self,bunch):
    pass
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):
    pass
def afterDehoist (self,p,command):
    pass
def afterHoist (self,p,command):
    pass
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):
    pass
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    pass

def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    pass

def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):
    pass
</t>
<t tx="ekr.20050415170737.1">def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
</t>
<t tx="ekr.20050415170737.2">def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
</t>
<t tx="ekr.20050415170812.1">def createTnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        v = v,
        headString = v.h,
        bodyString = v.b,
        statusBits = v.statusBits,
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
</t>
<t tx="ekr.20050415170812.2">def restoreTnodeUndoInfo (self,bunch):

    v = bunch.v
    v.h  = bunch.headString
    v.b  = bunch.bodyString
    v.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
</t>
<t tx="ekr.20050416092908.1"></t>
<t tx="ekr.20050418084539">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_nodes():
    if v not in vnodeInfoDict:
        vnodeInfoDict[v] = g.Bunch(
            v=v,head=v.headString(),body=v.b)
</t>
<t tx="ekr.20050418084539.2"># Create a dict containing only copied tnodes.
copiedVnodeDict = {}
for p in pasted.self_and_subtree():
    if p.v not in copiedVnodeDict:
        copiedVnodeDict[p.v] = p.v

# g.trace(list(copiedVnodeDict.keys()))

for v in vnodeInfoDict:
    bunch = vnodeInfoDict.get(v)
    if copiedVnodeDict.get(v):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
</t>
<t tx="ekr.20050418161620.2">def putUaHelper (self,torv,key,val):

    '''Put attribute whose name is key and value is val to the output stream.'''

    # g.trace(key,repr(val),g.callers())

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute",key,"in",torv,color="blue")
            return ''
    else:
        return self.pickle(torv=torv,val=val,tag=key)
</t>
<t tx="ekr.20050420083821">def disable (self):

    # g.pr("disabling all syntax coloring")
    self.enabled=False

def enable (self):

    self.enabled=True
</t>
<t tx="ekr.20050424114937.1"></t>
<t tx="ekr.20050424114937.2">recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    seen = []
    for path in (localPath,g.app.globalConfigDir,g.app.homeLeoDir): # homeLeoDir was homeDir.
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName) and not fileName.lower() in seen:
                seen.append(fileName.lower())
                ok = self.writeRecentFilesFileHelper(fileName)
                if not self.recentFileMessageWritten:
                    if ok:
                        g.pr('wrote recent file: %s' % fileName)
                        written = True
                    else:
                        g.pr('failed to recent file: %s' % (fileName),color='red')
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
</t>
<t tx="ekr.20050424115658">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        try:
            if g.isPython3:
                f = open(fileName,encoding='utf-8',mode='r')
            else:
                f = open(fileName,'r')
        except IOError:
            g.trace('can not open',fileName)
            return False
        if 0:
            if not g.unitTesting and not self.silent:
                g.pr(('reading %s' % fileName))
        lines = f.readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line)) for line in lines]
            self.appendToRecentFiles(lines)

    return ok
</t>
<t tx="ekr.20050424131051">def writeRecentFilesFileHelper (self,fileName):

    # g.trace(g.toUnicode(fileName))

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = open(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return False
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        if g.isPython3:
            theFile = open(fileName,encoding='utf-8',mode='w')
        else:
            theFile = open(fileName,mode='w')
        if self.recentFiles:
            s = '\n'.join(self.recentFiles)
        else:
            s = '\n'
        if not g.isPython3:
            s = g.toEncodedString(s,reportErrors=True)
        theFile.write(s)

    except IOError:
        if 1: # The user may have erased a file.  Not an error.
            g.es_print('error writing',fileName,color='red')
            g.es_exception()
            return False

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()
        if g.unitTesting: raise
        return False

    if theFile:
        theFile.close()
        return True
    else:
        return False
</t>
<t tx="ekr.20050424161505">def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
</t>
<t tx="ekr.20050424161505.1">def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
</t>
<t tx="ekr.20050424170219">def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20050424170219.1">def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20050503112513.7">def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return

    subprocess = g.importExtension('subprocess',None,verbose=False)

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)

    if subprocess: # Only exists in Python 2.4.
        &lt;&lt; define subprocess_wrapper &gt;&gt;
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
            g.pr('return code', rc)
        g.pr(so, se)
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        # execfile(fname, d)
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)
</t>
<t tx="ekr.20050503112513.8">def subprocess_wrapper(cmdlst):

    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde
</t>
<t tx="ekr.20050506084734"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True,useSentinels=True):

    """Write a 4.x derived file from a string.

    This is used by the scripting logic."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=not useSentinels,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        ok = at.openFileForWriting(root,at.targetFileName,toString=True)
        if g.app.unitTesting: assert ok,'writeFromString' # string writes never fail.
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=not useSentinels,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root:
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
    except Exception:
        at.exception("exception preprocessing script")

    return at.stringOutput
</t>
<t tx="ekr.20050506090446.1">def putAtFirstLines (self,s):

    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''

    at = self ; tag = "@first"

    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)
</t>
<t tx="ekr.20050506090955">def putAtLastLines (self,s):

    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''

    at = self ; tag = "@last"

    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines) ; j = k = n - 1

    # Scan backwards for @last directives.
    while j &gt;= 0:
        line = lines[j]
        if g.match(line,0,tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break

    # Write the @last lines.
    for line in lines[j+1:k+1]:
        if g.match(line,0,tag):
            i = len(tag) ; i = g.skip_ws(line,i)
            at.os(line[i:])
</t>
<t tx="ekr.20050509085713"></t>
<t tx="ekr.20050510071834">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3137690
By: nobody

I dont know if anyone has solved this for regular Leo, but in the JyLeo JythonShell,
when the user executes a script with Pdb it:
1. dumps the script in a tmp file system's tmp directory.
2. Executes pdb based off of that tmp file.

that way you get all the goodness that pdb can offer.
</t>
<t tx="ekr.20050512031131"></t>
<t tx="ekr.20050513164506">@killcolor

Jon Schull &lt;jschull@softlock.com&gt;  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 

I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations:
- Leo runs under X11 as well as under OS X.
- My X11 python configuration was created using the recipe at XXX (which enables vpython).
- The OS X configuration is vanilla MacPython from MacPython.org, along with AquaTclTk batteries included XXX.

In both environments I can run leo under python leo.py and under idle.
Under OS X we get font smoothing, but we can't run visual python programs (python crashes;  this is a known incompatibility with  MacPython.)

- Under X11 we can run visual python programs like this one
    #box.py
    from visual import *
    box()

And we can even run them under leo (under X11). HOWEVER, when the visual python program is terminated, leo vanishes (leo and the vp program apparently run in the same space)

Under x11, we can keep leo alive by putting the vp program in its own space:

    os.popen3('/sw/bin/python /Users/jis/box.py')

However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...

    def do(cmd='ls'):
        from os import popen3
        pIn,pOut,pErr=0,1,2
        popenResults=popen3(cmd)
        print popenResults[pOut].read()
        print popenResults[pErr].read()

    import os
    do('/sw/bin/python /Users/jis/box.py')

...but only when the vpython program terminates.

Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).

    import os
    os.chdir('/sw/lib/python2.3/idlelib')
    os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')

#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.

Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.

It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
</t>
<t tx="ekr.20050514171429">
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3152036
By: ngirard

Hi again,

Leo has IMHO a slight inconsistency as when a new node is created and has to
be given a name.

When the new node is created, the string "NewHeadline" appears and is selected.
Then there are 2 ways of setting a new name:

1. by typing the new name character by character using the keyboard. This way,
"NewHeadline" disappears as the first character of the new name is typed. Here
the implicit idea is that "NewHeadline" is very unlikely to be the final node
name -- which makes sense to me ;-)

2. by pasting the contents of the clipboard, with Ctrl-v. This way, "NewHeadline"
*remains* and the contents of the clipboard is appended to it.


I find leo's behaviour in case #2 inconsistent with #1 and suggest that the
first approach should be preferred.

Cheers,
Nicolas


______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

</t>
<t tx="ekr.20050525151449">def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        g.pr(ivar, getattr(self,ivar))
</t>
<t tx="ekr.20050526124257">def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20050526124906">def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
</t>
<t tx="ekr.20050526125801">def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
</t>
<t tx="ekr.20050526131252">def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
</t>
<t tx="ekr.20050618052653">self.plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
</t>
<t tx="ekr.20050707064040"># see: http://www.diveintopython.org/xml_processing/unicode.html

def es_print(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    g.pr(*args,**keys)

    if not g.app.unitTesting:
        g.es(*args,**keys)
</t>
<t tx="ekr.20050707065530">def es_trace(*args,**keys):

    if args:
        try:
            s = args[0]
            g.trace(g.toEncodedString(s,'ascii'))
        except Exception:
            pass

    g.es(*args,**keys)
</t>
<t tx="ekr.20050710142719">@first # -*- coding: utf-8 -*-

'''Basic editor commands for Leo.

Modelled after Emacs and Vim commands.'''

&lt;&lt; imports &gt;&gt;

&lt;&lt; define class baseEditCommandsClass &gt;&gt;

@others

&lt;&lt; define classesList &gt;&gt;
</t>
<t tx="ekr.20050710151017">import leo.core.leoGlobals as g
import leo.core.leoFind as leoFind
import leo.core.leoKeys as leoKeys
import leo.core.leoPlugins as leoPlugins
import leo.core.leoTest as leoTest

try:
    import enchant
except ImportError:
    enchant = None

import ctypes
import ctypes.util
import difflib
import os
import re
import string
import subprocess # Always exists in Python 2.6 and above.
import sys

if g.isPython3:
    import pickle # Only pickle exists in Python 3.x.
else:
    import cPickle as pickle 

if g.isPython3:
    from functools import reduce

# subprocess = g.importExtension('subprocess',pluginName=None,verbose=False)
</t>
<t tx="ekr.20050711153537">def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20050716104357">@nocolor

- put the jyleo-nnn.jar file in c:\prog

- Execute the following command in a console window
    cd c:\prog
    jar xvf j-leo-nnn.jar

This creates a folder called j-leo-nnn

- Do the following, or execute jleo.bat

cd c:\prog\j-leo-nnn\src
java -jar c:\jython22a0\jython.jar leo.py

Note:  at present this gives KeyError: HOME

In leo.py, in computeHomeDir, I changed:
@color

home = os.getenv('HOME' )#,default=dotDir)

to:

try:
    home = os.getenv('HOME' )#,default=dotDir)
except Exception:
    home = ''
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050729211526">def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.p

    pp = c.prettyPrinter(c)

    # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
</t>
<t tx="ekr.20050819064157">def print_obj (obj,tag=None,sort=False,verbose=True,indent=''):

    if type(obj) in (type(()),type([])):
        g.print_list(obj,tag,sort,indent)
    elif type(obj) == type({}):
        g.print_dict(obj,tag,verbose,indent)
    else:
        g.pr('%s%s' % (indent,repr(obj).strip()))

def toString (obj,tag=None,sort=False,verbose=True,indent=''):

    if type(obj) in (type(()),type([])):
        return g.listToString(obj,tag,sort,indent)
    elif type(obj) == type({}):
        return g.dictToString(obj,tag,verbose,indent)
    else:
        return '%s%s' % (indent,repr(obj).strip())
</t>
<t tx="ekr.20050920084036.1">class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
</t>
<t tx="ekr.20050920084036.100">def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''

    # New in Leo 4.4.4: just use reformat-paragraph logic.

    c = self.c ; p = c.p ; undoType = 'fill-region'
    w = self.editWidget(event)
    i,j = w.getSelectionRange()
    c.undoer.beforeChangeGroup(p,undoType)
    while 1:
        self.c.reformatParagraph(event,undoType='reformat-paragraph')
        ins = w.getInsertPoint()
        s = w.getAllText()
        if ins &gt;= j or ins &gt;= len(s):
            break
    c.undoer.afterChangeGroup(p,undoType)
</t>
<t tx="ekr.20050920084036.102">def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
</t>
<t tx="ekr.20050920084036.103">def fillParagraph( self, event ):

    '''Fill the selected paragraph'''

    w = self.editWidget(event)
    if not w: return

    # Clear the selection range.
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,i,insert=i)

    self.c.reformatParagraph(event)
</t>
<t tx="ekr.20050920084036.104">def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.105">@others
</t>
<t tx="ekr.20050920084036.108">def tabIndentRegion (self,event):

    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='indent-rigidly')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    lines = g.splitlines(s[i:j])
    n = len(lines)
    lines = g.joinLines(['\t' + line for line in lines])
    s = s[:i] + lines + s[j:]
    w.setAllText(s)

    # Retain original row/col selection.
    w.setSelectionRange(i1,j1+n,insert=j1+n)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.109">def countRegion (self,event):

    '''Print the number of lines and characters in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.getSelectedText()
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
</t>
<t tx="ekr.20050920084036.110">def reverseRegion (self,event):

    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    txt = s[i:j]
    aList = txt.split('\n')
    aList.reverse()
    txt = '\n'.join(aList) + '\n'

    w.setAllText(s[:i1] + txt + s[j1:])
    ins = i1 + len(txt) - 1
    w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.111">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=undoType)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    sel = g.choose(way=='low',s[i:j].lower(),s[i:j].upper())
    s2 = s[:i] + sel + s[j:]
    # g.trace('sel',repr(sel),'s2',repr(s2))
    changed = s2 != s
    if changed:
        w.setAllText(s2)
        w.setSelectionRange(i,j,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20050920084036.116">def scrollDownHalfPage (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'down','half-page')

def scrollDownLine (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'down','line')

def scrollDownPage (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down','page')

def scrollUpHalfPage (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'up','half-page')

def scrollUpLine (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up','line')

def scrollUpPage (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up','page')
</t>
<t tx="ekr.20050920084036.117">@nocolor
@color
@
XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

</t>
<t tx="ekr.20050920084036.118">def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.119">def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in range(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = list(zip(columns,aList))
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.120">def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete(i,j)
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.121"></t>
<t tx="ekr.20050920084036.122">def transposeLines (self,event):

    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]

    self.beginCommand(undoType='transpose-lines')

    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.123">def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    ### txt = w.get('insert wordstart','insert wordend') ###
    txt = ''
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i &gt; swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i &lt; swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.124">def swapCharacters (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='swap-characters')

    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 &lt; i &lt; len(s):
        w.setAllText(s[:i-1] + s[i] + s[i-1] + s[i+1:])
        w.setSelectionRange(i,i,insert=i)

    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
</t>
<t tx="ekr.20050920084036.126">def tabify (self,event):
    '''Convert 4 spaces to tabs in the selected text.'''
    self.tabifyHelper (event,which='tabify')

def untabify (self,event):
    '''Convert tabs to 4 spaces in the selected text.'''
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=which)

    i,end = w.getSelectionRange()
    txt = w.getSelectedText()
    if which == 'tabify':
        pattern = re.compile(' {4,4}') # Huh?
        ntxt = pattern.sub('\t',txt)
    else:
        pattern = re.compile('\t')
        ntxt = pattern.sub('    ',txt)
    w.delete(i,end)
    w.insert(i,ntxt)
    n = i + len(ntxt)
    w.setSelectionRange(n,n,insert=n)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.128">def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        g.app.gui.replaceClipboardWith(s[ins:i]) # Support for proper yank.
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.13">class abbrevCommandsClass (baseEditCommandsClass):

    '''A class to handle user-defined abbreviations.

    See apropos-abbreviations for details.'''

    @others
</t>
<t tx="ekr.20050920084036.131">def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
</t>
<t tx="ekr.20050920084036.132"></t>
<t tx="ekr.20050920084036.133">def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col
</t>
<t tx="ekr.20050920084036.134">def indentToCommentColumn (self,event):

    '''Insert whitespace to indent the line containing the insert point to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    c1 = int(self.ccolumn)
    line2 = ' ' * c1 + line.lstrip()
    if line2 != line:
        w.delete(i,j)
        w.insert(i,line2)
    w.setInsertPoint(i+c1)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.135">def deleteSpaces (self,event,insertspace=False):

    '''Delete all whitespace surrounding the cursor.'''

    c = self.c ; w = self.editWidget(event)
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    w1 = ins-1
    while w1 &gt;= i and s[w1].isspace():
        w1 -= 1
    w1 += 1
    w2 = ins
    while w2 &lt;= j and s[w2].isspace():
        w2 += 1
    spaces = s[w1:w2]
    if spaces:
        self.beginCommand(undoType=undoType)
        if insertspace: s = s[:w1] + ' ' + s[w2:]
        else:           s = s[:w1] + s[w2:]
        w.setAllText(s)
        w.setInsertPoint(w1)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.136">def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
</t>
<t tx="ekr.20050920084036.137">def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20050920084036.138">def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    oldSel = w.getSelectionRange()
    # g.trace('oldSel',oldSel)

    self.beginCommand(undoType='newline')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand()

insertNewline = insertNewLine
</t>
<t tx="ekr.20050920084036.139">def insertParentheses (self,event):

    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')

    i = w.getInsertPoint()
    w.insert(i,'()')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)
</t>
<t tx="ekr.20050920084036.140">def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
</t>
<t tx="ekr.20050920084036.141">def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20050920084036.145">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
        self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.147">def measure (self,w):

    if hasattr(w,'linesPerPage'):
        # Preferred.  Qt implements this.
        n = w.linesPerPage()
        return max(2,n-3)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        start, junk = g.convertPythonIndexToRowCol(s,ins)
        start += 1 ; delta = 0
        ustart = start - 1
        while ustart &gt;= 1 and w.indexIsVisible('%s.0' % ustart):
            delta += 1 ; ustart -= 1

        ustart = start + 1
        while w.indexIsVisible('%s.0' % ustart):
            delta += 1 ; ustart += 1

        return delta
</t>
<t tx="ekr.20050920084036.148">def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=True)
</t>
<t tx="ekr.20050920084036.149">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20050920084036.15">def getPublicCommands (self):

    return {
        'apropos-abbreviations':        self.aproposAbbreviations,
        # 'expand-abbrev':              self.expandAbbrev, # Not a command.

        # Dynamic...
        'dabbrev-completion':           self.dynamicCompletion,
        'dabbrev-expands':              self.dynamicExpansion,

        # Static...
        'abbrev-mode':                  self.toggleAbbrevMode,
        'add-global-abbrev':            self.addAbbreviation,
        # 'expand-region-abbrevs':        self.regionalExpandAbbrev,
        'inverse-add-global-abbrev':    self.addInverseAbbreviation,
        'kill-all-abbrevs':             self.killAllAbbrevs,
        'list-abbrevs':                 self.listAbbrevs,
        'read-abbrev-file':             self.readAbbreviations,
        'write-abbrev-file':            self.writeAbbreviations,
    }
</t>
<t tx="ekr.20050920084036.150">class controlCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20050920084036.151">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.payload = None
</t>
<t tx="ekr.20050920084036.152">def getPublicCommands (self):

    k = self.c.k

    return {
        'advertised-undo':              self.advertizedUndo,
        'iconify-frame':                self.iconifyFrame, # Same as suspend.
        'keyboard-quit':                k and k.keyboardQuit,
        'save-buffers-kill-leo':        self.saveBuffersKillLeo,
        'set-silent-mode':              self.setSilentMode,
        # 'print-plugins':                self.printPlugins,
        'print-plugin-handlers':        self.printPluginHandlers,
        'print-plugins-info':           self.printPluginsInfo,
        'shell-command':                self.shellCommand,
        'shell-command-on-region':      self.shellCommandOnRegion,
        'suspend':                      self.suspend,
        'act-on-node':                  self.actOnNode
    }
</t>
<t tx="ekr.20050920084036.153">def suspend (self,event):

    '''Minimize the present Leo window.'''

    w = self.editWidget(event)
    if not w: return
    self.c.frame.top.iconify()

# Must be a separate function so that k.inverseCommandsDict will be a true inverse.

def iconifyFrame (self,event):

    '''Minimize the present Leo window.'''

    self.suspend(event)
</t>
<t tx="ekr.20050920084036.155">def shutdown (self,event):

    '''Quit Leo, prompting to save any unsaved files first.'''

    g.app.onQuit()

saveBuffersKillLeo = shutdown
</t>
<t tx="ekr.20050920084036.158">def shellCommand (self,event):

    '''Execute a shell command.'''

    if subprocess:
        k = self.k ; state = k.getState('shell-command')

        if state == 0:
            k.setLabelBlue('shell-command: ',protect=True)
            k.getArg(event,'shell-command',1,self.shellCommand)
        else:
            command = k.arg
            k.commandName = 'shell-command: %s' % command
            k.clearState()
            self.executeSubprocess(event,command)
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
</t>
<t tx="ekr.20050920084036.160">def executeSubprocess (self,event,command,theInput=None):

    '''Execute a command in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    k.setLabelBlue('started  shell-command: %s' % command)
    try:
        ofile = os.tmpfile()
        efile = os.tmpfile()
        process = subprocess.Popen(command,bufsize=-1,
            stdout = ofile.fileno(), stderr = ofile.fileno(),
            stdin = subprocess.PIPE, shell = True)
        if theInput: process.communicate(theInput)
        process.wait()
        efile.seek(0)
        errinfo = efile.read()
        if errinfo:
            i = w.getInsertPoint()
            w.insert(i,errinfo)
        ofile.seek(0)
        okout = ofile.read()
        if okout:
            i = w.getInsertPoint()
            w.insert(i,okout)
    except Exception:
        junk, x, junk = sys.exc_info()
        i = w.getInsertPoint()
        w.insert(i,x)

    k.setLabelGrey('finished shell-command: %s' % command)
</t>
<t tx="ekr.20050920084036.161">class editFileCommandsClass (baseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
</t>
<t tx="ekr.20050920084036.162">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20050920084036.163">def getPublicCommands (self):

    return {
        'compare-leo-files':    self.compareLeoFiles,
        'delete-file':          self.deleteFile,
        'diff':                 self.diff, 
        'insert-file':          self.insertFile,
        'make-directory':       self.makeDirectory,
        'open-outline-by-name': self.openOutlineByName,
        'remove-directory':     self.removeDirectory,
        'save-file':            self.saveFile
    }
</t>
<t tx="ekr.20050920084036.164">def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        prefix = 'Delete File: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'delete_file',1,self.deleteFile,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.remove(k.arg)
            k.setLabel('Deleted: %s' % k.arg)
        except Exception:
            k.setLabel('Not Deleted: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.165">def diff (self,event):

    '''Creates a node and puts the diff between 2 files into it.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    fn = self.getReadableTextFile()
    if not fn: return
    fn2 = self.getReadableTextFile()
    if not fn2: return
    s1,e = g.readFileIntoString(fn)
    if s1 is None: return
    s2,e = g.readFileIntoString(fn2)
    if s2 is None: return

    ### self.switchToBuffer(event,"*diff* of ( %s , %s )" % (name,name2))
    data = difflib.ndiff(s1,s2)
    idata = []
    for z in data:
        idata.append(z)
    w.delete(0,'end')
    w.insert(0,''.join(idata))
</t>
<t tx="ekr.20050920084036.166">def getReadableTextFile (self):

    fn = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    return fn
</t>
<t tx="ekr.20050920084036.167">def insertFile (self,event):

    '''Prompt for the name of a file and put the selected text into it.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    fn = self.getReadableTextFile()
    if not fn: return

    s,e = g.readFileIntoString(fn)
    if s is None: return

    self.beginCommand(undoType='insert-file')
    i = w.getInsertPoint()
    w.insert(i,s)
    w.seeInsertPoint()
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.168">def makeDirectory (self,event):

    '''Prompt for the name of a directory and create it.'''

    k = self.k ; state = k.getState('make_directory')

    if state == 0:
        prefix = 'Make Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'make_directory',1,self.makeDirectory,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setLabel("Created: %s" % k.arg)
        except Exception:
            k.setLabel("Not Create: %s" % k.arg)
</t>
<t tx="ekr.20050920084036.169">def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        prefix = 'Remove Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'remove_directory',1,self.removeDirectory,prefix=prefix)
    else:
        k.keyboardQuit(event)
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setLabel('Removed: %s' % k.arg)
        except Exception:
            k.setLabel('Not Remove: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.170">def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        s = w.getAllText()
        if not g.isPython3: # 2010/08/27
             s = g.toEncodedString(s,self.encoding,reportErrors=True)
        f.write(s)
        f.close()
    except IOError:
        g.es('can not create',fileName)
</t>
<t tx="ekr.20050920084036.171">class keyHandlerCommandsClass (baseEditCommandsClass):

    '''User commands to access the keyHandler class.'''

    @others
</t>
<t tx="ekr.20050920084036.172">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20050920084036.173">def getPublicCommands (self):

    k = self.k

    if k:
        return {
            'auto-complete':            k.autoCompleter.autoComplete,
            'auto-complete-force':      k.autoCompleter.autoCompleteForce,
            'digit-argument':           k.digitArgument,
            'disable-autocompleter':    k.autoCompleter.disableAutocompleter,
            'disable-calltips':         k.autoCompleter.disableCalltips,
            'enable-autocompleter':     k.autoCompleter.enableAutocompleter,
            'enable-calltips':          k.autoCompleter.enableCalltips,
            'exit-named-mode':          k.exitNamedMode,
            'full-command':             k.fullCommand, # For menu.
            'hide-mini-buffer':         k.hideMinibuffer,
            'mode-help':                k.modeHelp,
            'negative-argument':        k.negativeArgument,
            'number-command':           k.numberCommand,
            'number-command-0':         k.numberCommand0,
            'number-command-1':         k.numberCommand1,
            'number-command-2':         k.numberCommand2,
            'number-command-3':         k.numberCommand3,
            'number-command-4':         k.numberCommand4,
            'number-command-5':         k.numberCommand5,
            'number-command-6':         k.numberCommand6,
            'number-command-7':         k.numberCommand7,
            'number-command-8':         k.numberCommand8,
            'number-command-9':         k.numberCommand9,
            'print-bindings':           k.printBindings,
            'print-commands':           k.printCommands,
            'propagate-key-event':      k.propagateKeyEvent,
            'repeat-complex-command':   k.repeatComplexCommand,
            # 'scan-for-autocompleter':   k.autoCompleter.scan,
            'set-command-state':        k.setCommandState,
            'set-insert-state':         k.setInsertState,
            'set-overwrite-state':      k.setOverwriteState,
            'show-calltips':            k.autoCompleter.showCalltips,
            'show-calltips-force':      k.autoCompleter.showCalltipsForce,
            'show-mini-buffer':         k.showMinibuffer,
            'toggle-autocompleter':     k.autoCompleter.toggleAutocompleter,
            'toggle-calltips':          k.autoCompleter.toggleCalltips,
            'toggle-mini-buffer':       k.toggleMinibuffer,
            'toggle-input-state':       k.toggleInputState,
            'universal-argument':       k.universalArgument,
        }
    else:
        return {}
</t>
<t tx="ekr.20050920084036.174">class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20050920084036.175">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.addWsToKillRing = c.config.getBool('add-ws-to-kill-ring')
    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.lastYankP = None # The position of the last item returned by iterateKillBuffer.
    self.reset = None
        # None, or the index of the next item to be returned in killBuffer by iterateKillBuffer.

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k and self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20050920084036.176">def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'kill-ws':                  self.killWs,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20050920084036.178">def kill (self,event,frm,to,undoType=None):

    '''A helper method for all kill commands.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.18">def killAllAbbrevs (self,event):

    '''Delete all abbreviations.'''

    self.abbrevs = {}
</t>
<t tx="ekr.20050920084036.180">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c ; e = c.editCommands
    self.beginCommand(undoType='backward-kill-word')
    e.backwardWord(event)
    self.killWordHelper(event,'back')

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    self.beginCommand(undoType='kill-word')
    self.killWordHelper(event,'forward')

def killWordHelper(self,event,direction):
    c = self.c ; e = c.editCommands ; w = e.editWidget(event)
    # self.killWs(event)
    e.extendToWord(event,direction)
    i,j = w.getSelectionRange()
    self.kill(event,i,j,undoType = None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.181">def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.182">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    i,j = w.getSelectionRange()
    if i == j: return
    s = w.getSelectedText()
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(i,j)
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20050920084036.183">def addToKillBuffer (self,text):

    '''Insert the text into the kill buffer if force is True or
    the text contains something other than whitespace.'''

    if self.addWsToKillRing or text.strip():
        self.killBuffer = [z for z in self.killBuffer if z != text]
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20050920084036.184">class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
</t>
<t tx="ekr.20050920084036.185">def getClipboard (self):

    '''Return the contents of the clipboard.'''

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except Exception:
        g.es_exception()

    return None
</t>
<t tx="ekr.20050920084036.186">class leoCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20050920084036.187">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20050920084036.188">def getPublicCommands (self):

    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''

    k = self.k ; d2 = {}

    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;

    # Create a callback for each item in d.
    for name in sorted(d):
        f = d.get(name)
        d2 [name] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))

    return d2
</t>
<t tx="ekr.20050920084036.189">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify':                     c.beautifyPythonCode,
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'cascade-windows':              f.cascade,
    # 'check-all-python-code':      c.checkAllPythonCode,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'check-outline':                c.checkOutline,
    # 'check-python-code':          c.checkPythonCode,
    'clean-recent-files':           c.cleanRecentFiles,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-window':                 c.close,
    'contract-all':                 c.contractAllHeadlines,
    'contract-all-other-nodes':     c.contractAllOtherNodes,
    'contract-node':                c.contractNode,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-all-subheads':          c.expandAllSubheads,
        # Fixes bug 604037 Status of expandAllSubheads
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-body-time':             c.insertBodyTime,
    'insert-child':                 c.insertChild,
    'insert-headline-time':         f.insertHeadlineTime,
    'insert-node':                  c.insertHeadline,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    # 'mark-clones':                c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-offline-tutorial':        f.leoHelp,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-quickstart-leo':          c.leoQuickStart,
    'open-scripts-leo':             c.openLeoScripts,
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-file-into-node':          c.readFileIntoNode,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'settings':                     c.preferences,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-recent-files':            c.sortRecentFiles,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparse-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-file-from-node':         c.writeFileFromNode,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
</t>
<t tx="ekr.20050920084036.19">def listAbbrevs (self,event=None):

    '''List all abbreviations.'''

    k = self.k ; d = self.abbrevs

    if self.abbrevs:
        g.es('Abbreviations...')
        keys = list(d.keys())
        keys.sort()
        for name in keys:
            val,tag = self.abbrevs.get(name)
            val = val.replace('\n','\\n')
            tag = tag or ''
            tag = g.choose(tag,tag+': ','')
            g.es('','%s%s=%s' % (tag,name,val))
    else:
        g.es('No present abbreviations')
</t>
<t tx="ekr.20050920084036.190">class macroCommandsClass (baseEditCommandsClass):

    '''Define the following commands:

    call-kbd-macro
    call-last-kbd-macro
    load-kbd-macros
    name-last-kbd-macro
    print-macros
    save-kbd-macros
    start-kbd-macro
    '''

    @others
</t>
<t tx="ekr.20050920084036.191">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.lastMacro = None
    self.macros = []
    self.macro = []
    self.namedMacros = {}

    # Important: we must not interfere with k.state in startKbdMacro!
    self.recordingMacro = False
</t>
<t tx="ekr.20050920084036.192">def getPublicCommands (self):

    return {
        'call-last-kbd-macro':  self.callLastKeyboardMacro,
        'call-kbd-macro':       self.callNamedMacro,
        'print-macros':         self.printMacros,
        'name-last-kbd-macro':  self.nameLastKbdMacro,
        'load-kbd-macros':      self.loadFile,
        'save-kbd-macros':      self.saveMacros,
        'start-kbd-macro':      self.startKbdMacro,
    }
</t>
<t tx="ekr.20050920084036.194">def callNamedMacro (self,event):

    '''Prompts for a macro name to save, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt,protect=True)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

</t>
<t tx="ekr.20050920084036.196">def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        self.loadMacros(f)
    except IOError:
        g.es('can not open',fileName)
</t>
<t tx="ekr.20050920084036.197">def loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    c = self.c ; w = c.frame.body.bodyCtrl
    try:
        d = pickle.load(f)
    except pickle.UnpicklingError:
        g.es('error unpickling %s' % f.name)
        return

    # g.trace(f.name,d)

    for name in d:
        aList = d.get(name)
        macro = []
        for stroke in aList:
            # Create a dummy event with just enough attribute
            # to keep k.masterKeyHandler happy
            actualEvent = g.Bunch(stroke=stroke,char=stroke,widget=w)
            event = g.app.gui.leoKeyEvent(actualEvent,c)
            macro.append(event)
        self.addToDoAltX(name,macro)
            # sets self.namedMacros[name]=macro


</t>
<t tx="ekr.20050920084036.198">def nameLastKbdMacro (self,event):

    '''Prompt for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ',protect=True)
        k.getArg(event,'name-macro',1,self.nameLastKbdMacro)
    else:
        k.clearState()
        name = k.arg
        self.addToDoAltX(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
</t>
<t tx="ekr.20050920084036.199">def saveMacros (self,event=None):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'a+')
        f.seek(0)
        if f:
            self.saveMacrosHelper(f)
    except IOError:
        g.es('can not create',fileName)

</t>
<t tx="ekr.20050920084036.2">def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
</t>
<t tx="ekr.20050920084036.20">def readAbbreviations (self,event=None):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if fileName:
        self.readAbbreviationsFromFile(fileName)
</t>
<t tx="ekr.20050920084036.200">def saveMacrosHelper( self,f):

    '''Saves all named macros.'''

    # fname = f.name
    # try:
        # macros = pickle.load( f )
    # except Exception:
        # macros = {}
    # f.close()

    d = {}
    for name in self.namedMacros:
        macro = self.namedMacros.get(name)
        # Just save the essential part of the event.
        # It must be picklable.
        aList = [event.stroke for event in macro]
        g.trace(name,aList)
        d[name] = aList
        # f = open( fname, 'w' )
        pickle.dump(d, f )
        f.close()
</t>
<t tx="ekr.20050920084036.202"># Called from universal-command.

def callLastKeyboardMacro (self,event=None):

    g.trace(self.lastMacro)

    '''Call the last recorded keyboard macro.'''

    if self.lastMacro:
        self.executeMacro(self.lastMacro)
</t>
<t tx="ekr.20050920084036.203">def executeMacro (self,macro):

    c = self.c ; k = self.k

    c.bodyWantsFocusNow()

    for event in macro:
        # New in Leo 4.6: macro entries are leoKeyEvents.
        g.trace(event.stroke)
        k.masterKeyHandler(event,stroke=event.stroke)
</t>
<t tx="ekr.20050920084036.204">def startKbdMacro (self,event=None):

    '''Start recording a keyboard macro.'''

    g.trace(self.recordingMacro)

    k = self.k

    if not self.recordingMacro:
        self.recordingMacro = True
            # A flag for k.masterCommandHandler &amp; k.masterKeyHandler.
        k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
    else:
        g.trace(event)
        self.macro.append(event)
</t>
<t tx="ekr.20050920084036.206">def endKbdMacro (self,event=None):

    '''Stop recording a keyboard macro.'''

    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and masterCommandHandler we are done.

    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
</t>
<t tx="ekr.20050920084036.207">class queryReplaceCommandsClass (baseEditCommandsClass):

    '''A class to handle query replace commands.'''

    @others
</t>
<t tx="ekr.20050920084036.208">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    self.regexp = False # True: do query-replace-regexp.  Set in stateHandler.

def init (self):

    self.qQ = None
    self.qR = None
    self.replaced = 0 # The number of replacements.
</t>
<t tx="ekr.20050920084036.209">def getPublicCommands (self):

    return {
        'query-replace':        self.queryReplace,
        'query-replace-regex':  self.queryReplaceRegex,
    }
</t>
<t tx="ekr.20050920084036.210">def queryReplace (self,event):

    '''Interactively find and replace text.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = False
    self.stateHandler(event)

def queryReplaceRegex (self,event):
    '''Interactively find and replace text using regular expressions.
    This is not recommended: Leo's other find and change commands are more capable.'''
    self.regexp = True
    self.stateHandler(event)
</t>
<t tx="ekr.20050920084036.211">def getUserResponse (self,event):

    w = self.editWidget(event)
    if not w or not hasattr(event,'keysym'): return

    # g.trace(event.keysym)
    if event.keysym == 'y':
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif event.keysym in ('q','Return'):
        self.quitSearch(event)
    elif event.keysym == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif event.keysym in ('n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
</t>
<t tx="ekr.20050920084036.212">def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return

    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    ins = w.getInsertPoint()
    w.insert(ins,self.qR)
    self.replaced += 1
</t>
<t tx="ekr.20050920084036.215">def stateHandler (self,event):

    k = self.k ; state = k.getState('query-replace')

    prompt = g.choose(self.regexp,'Query replace regexp','Query replace')

    if state == 0: # Get the first arg.
        self.init()
        k.setLabelBlue(prompt + ': ',protect=True)
        k.getArg(event,'query-replace',1,self.stateHandler)
    elif state == 1: # Get the second arg.
        self.qQ = k.arg
        if len(k.arg) &gt; 0:
            prompt = '%s %s with: ' % (prompt,k.arg)
            k.setLabelBlue(prompt)
            k.getArg(event,'query-replace',2,self.stateHandler)
        else:
            k.resetLabel()
            k.clearState()
    elif state == 2: # Set the prompt and find the first match.
        self.qR = k.arg # Null replacement arg is ok.
        k.setLabelBlue('Query replacing %s with %s\n' % (self.qQ,self.qR) +
            'y: replace, (n or Delete): skip, !: replace all, (q or Return): quit',
            protect=True)
        k.setState('query-replace',3,self.stateHandler)
        self.findNextMatch(event)
    elif state == 3:
        self.getUserResponse(event)
</t>
<t tx="ekr.20050920084036.219">def findNextMatch (self,event):

    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    w.tag_delete('qR')
    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;
</t>
<t tx="ekr.20050920084036.220">def quitSearch (self,event,message=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_delete('qR')
    k.clearState()
    if message is None:
        message = 'Replaced %d occurences' % self.replaced
    k.setLabelGrey(message)
</t>
<t tx="ekr.20050920084036.221">class rectangleCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20050920084036.222">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.theKillRectangle = [] # Do not re-init this!
    self.stringRect = None

def finishCreate(self):

    baseEditCommandsClass.finishCreate(self)

    self.commandsDict = {
        'c': ('clear-rectangle',    self.clearRectangle),
        'd': ('delete-rectangle',   self.deleteRectangle),
        'k': ('kill-rectangle',     self.killRectangle),
        'o': ('open-rectangle',     self.openRectangle),
        'r': ('copy-rectangle-to-register',
            self.c.registerCommands.copyRectangleToRegister),
        't': ('string-rectangle',   self.stringRectangle),
        'y': ('yank-rectangle',     self.yankRectangle),
    }
</t>
<t tx="ekr.20050920084036.223">def getPublicCommands (self):

    return {
        'clear-rectangle':  self.clearRectangle,
        'close-rectangle':  self.closeRectangle,
        'delete-rectangle': self.deleteRectangle,
        'kill-rectangle':   self.killRectangle,
        'open-rectangle':   self.openRectangle,
        'string-rectangle': self.stringRectangle,
        'yank-rectangle':   self.yankRectangle,
    }
</t>
<t tx="ekr.20050920084036.224"></t>
<t tx="ekr.20050920084036.225">def clearRectangle (self,event):

    '''Clear the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('clear-rectangle')

    # Change the text.
    fill = ' ' *(r4-r2)
    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2),fill)

    w.setSelectionRange('%s.%s'%(r1,r2),'%s.%s'%(r3,r2+len(fill)))

    self.endCommand()
</t>
<t tx="ekr.20050920084036.226">def closeRectangle (self,event):

    '''Delete the rectangle if it contains nothing but whitespace..'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('close-rectangle')

    # Return if any part of the selection contains something other than whitespace.
    for r in range(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        if s.strip(): return

    # Change the text.
    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
</t>
<t tx="ekr.20050920084036.227">def deleteRectangle (self,event):

    '''Delete the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('delete-rectangle')

    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
</t>
<t tx="ekr.20050920084036.228">def killRectangle (self,event):

    '''Kill the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('kill-rectangle')

    self.theKillRectangle = []

    for r in range(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        self.theKillRectangle.append(s)
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    # g.trace('killRect',repr(self.theKillRectangle))

    if self.theKillRectangle:
        ins = '%s.%s' % (r,r2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand()
</t>
<t tx="ekr.20050920084036.229">def yankRectangle (self,event,killRect=None):

    '''Yank into the rectangle defined by the start and end of selected text.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    killRect = killRect or self.theKillRectangle
    if g.app.unitTesting:
        # This value is used by the unit test.
        killRect = ['Y1Y','Y2Y','Y3Y','Y4Y']
    elif not killRect:
        k.setLabelGrey('No kill rect') ; return

    w,r1,r2,r3,r4 = self.beginCommand('yank-rectangle')

    n = 0
    for r in range(r1,r3+1):
        # g.trace(n,r,killRect[n])
        if n &gt;= len(killRect): break
        w.delete('%s.%s' % (r,r2), '%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2), killRect[n])
        n += 1

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(killRect[n-1]))
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
</t>
<t tx="ekr.20050920084036.23">def toggleAbbrevMode (self,event):

    '''Toggle abbreviation mode.'''

    k = self.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit(event)
    # k.setLabel('Abbreviations are ' + g.choose(k.abbrevOn,'On','Off'))
    if not g.unitTesting and not g.app.batchMode:
        g.es('Abbreviations are ' + g.choose(k.abbrevOn,'on','off'))
</t>
<t tx="ekr.20050920084036.230">def openRectangle (self,event):

    '''Insert blanks in the rectangle defined by the start and end of selected text.
    This pushes the previous contents of the rectangle rightward.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('open-rectangle')

    fill = ' ' * (r4-r2)
    for r in range(r1,r3+1):
        w.insert('%s.%s' % (r,r2),fill)

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(fill))
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
</t>
<t tx="ekr.20050920084036.232">def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

</t>
<t tx="ekr.20050920084036.233">def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
</t>
<t tx="ekr.20050920084036.234">class registerCommandsClass (baseEditCommandsClass):

    '''A class to represent registers a-z and the corresponding Emacs commands.'''

    @others
</t>
<t tx="ekr.20050920084036.235">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.methodDict, self.helpDict = self.addRegisterItems()
    self.init()

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self) # finish the base class.

    if self.k.useGlobalRegisters:
        self.registers = leoKeys.keyHandlerClass.global_registers
    else:
        self.registers = {}

def init (self):

    self.method = None 
    self.registerMode = 0 # Must be an int.
</t>
<t tx="ekr.20050920084036.236"></t>
<t tx="ekr.20050920084036.237">def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')

    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val ###
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.238">def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')

    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last') ###
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.239">def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.24">def writeAbbreviations (self,event):

    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        d = self.abbrevs
        f = open(fileName,'w')
        keys = list(d.keys)
        keys.sort()
        for name in keys:
            val,tag = self.abbrevs.get(name)
            val=val.replace('\n','\\n')
            s = '%s=%s\n' % (x,val)
            if not g.isPython3:
                s = g.toEncodedString(s,reportErrors=True)
            f.write(s)
        f.close()
    except IOError:
        g.es('can not create',fileName)
</t>
<t tx="ekr.20050920084036.240">def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')

    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last') ###
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.241">def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')

    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.242">def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    i = w.getInsertPoint()
                    w.insert(i,val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.243">def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.244">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    k = self.k ; state = k.getState('number-to-reg')

    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20050920084036.245">def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.246">def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.247">def getPublicCommands (self):

    return {
        'append-to-register':           self.appendToRegister,
        'copy-rectangle-to-register':   self.copyRectangleToRegister,
        'copy-to-register':             self.copyToRegister,
        'increment-register':           self.incrementRegister,
        'insert-register':              self.insertRegister,
        'jump-to-register':             self.jumpToRegister,
        # 'number-to-register':           self.numberToRegister,
        'point-to-register':            self.pointToRegister,
        'prepend-to-register':          self.prependToRegister,
        'view-register':                self.viewRegister,
    }
</t>
<t tx="ekr.20050920084036.249">def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
</t>
<t tx="ekr.20050920084036.25">def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        value = k.argSelectedText # 2010/09/01.
        if k.arg.strip():
            self.abbrevs [k.arg] = value,'dynamic'
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviation (on): '%s' = '%s'" % (
                    k.arg,value))
</t>
<t tx="ekr.20050920084036.250">def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
</t>
<t tx="ekr.20050920084036.252">def addRegisterItems( self ):

    methodDict = {
        '+':        self.incrementRegister,
        ' ':        self.pointToRegister,
        'a':        self.appendToRegister,
        'i':        self.insertRegister,
        'j':        self.jumpToRegister,
        # 'n':        self.numberToRegister,
        'p':        self.prependToRegister,
        'r':        self.copyRectangleToRegister,
        's':        self.copyToRegister,
        'v' :       self.viewRegister,
    }    

    helpDict = {
        's':    'copy to register',
        'i':    'insert from register',
        '+':    'increment register',
        'n':    'number to register',
        'p':    'prepend to register',
        'a':    'append to register',
        ' ':    'point to register',
        'j':    'jump to register',
        'r':    'rectangle to register',
        'v':    'view register',
    }

    return methodDict, helpDict
</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c)
        # init the base class.
        # sets self.c

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    # For isearch commands.
    self.ifinder = None
    self.stack = [] # Entries are (p,sel)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-clone-all':                       self.cloneFindAll, # Synonym.

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses-nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,'isearch-forward',
        forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,'isearch-backward',
        forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,'isearch-forward-regexp',
        forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,'isearch-backward-regexp',
        forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using find panel options.'''
    self.startIncremental(event,'isearch-with-present-options',
        forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,commandName,forward,ignoreCase,regexp):

    c = self.c ; k = self.k

    # None is a signal to get the option from the find tab.

    if forward is None or not self.findTabHandler:
        self.openFindTab(show=False)

    self.ifinder = self.findTabHandler

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    getOption = self.minibufferFindHandler.getOption

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.w = w = c.frame.body.bodyCtrl
    self.p1 = c.p.copy()
    self.sel1 = w.getSelectionRange(sort=False)
    i,j = self.sel1
    self.push(c.p,i,j,self.ifinder.in_headline)
    self.inverseBindingDict = k.computeInverseBindingDict()
    self.iSearchStrokes = self.getStrokes(commandName)

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)

    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20050920084036.264"># Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()
</t>
<t tx="ekr.20050920084036.27">def expandAbbrev (self,event):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return
    if w.hasSelection(): return

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 &lt;= i &lt; len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 &lt;= i &lt; len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    if ch: word = word + ch
    if trace: g.trace(i,j,repr(word))
    if not word: return

    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    if val:
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
</t>
<t tx="ekr.20050920084036.31">@
An Emacs instance does not have knowledge of what is considered a
buffer in the environment.

The call to setBufferInteractionMethods calls the buffer configuration methods.
@c

class bufferCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20050920084036.32">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.fromName = '' # Saved name from getBufferName.
    self.nameList = [] # [n: &lt;headline&gt;]
    self.names = {}
    self.tnodes = {} # Keys are n: &lt;headline&gt;, values are tnodes.

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
</t>
<t tx="ekr.20050920084036.33">def getPublicCommands (self):

    return {

        # These do not seem useful.
            # 'copy-to-buffer':               self.copyToBuffer,
            # 'insert-to-buffer':             self.insertToBuffer,

        'append-to-buffer':             self.appendToBuffer,
        'kill-buffer' :                 self.killBuffer,
        'list-buffers' :                self.listBuffers,
        'list-buffers-alphabetically':  self.listBuffersAlphabetically,
        'prepend-to-buffer':            self.prependToBuffer,
        'rename-buffer':                self.renameBuffer,
        'switch-to-buffer':             self.switchToBuffer,
    }
</t>
<t tx="ekr.20050920084036.34"></t>
<t tx="ekr.20050920084036.35">def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Append to buffer: ')
    self.getBufferName(self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        w = self.w
        c.selectPosition(p)
        self.beginCommand('append-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.36">def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Copy to buffer: ')
    self.getBufferName(self.copyToBufferFinisher)

def copyToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('copy-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.37">def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('insert-to-buffer: %s' % p.h)
        i = w.getInsertPoint()
        w.insert(i,s)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20050920084036.38">def killBuffer (self,event):

    '''Delete a buffer (node) and all its descendants.'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Kill buffer: ')
    self.getBufferName(self.killBufferFinisher)

def killBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        h = p.h
        current = c.p
        c.selectPosition(p)
        c.deleteOutline (op_name='kill-buffer: %s' % h)
        c.selectPosition(current)
        self.k.setLabelBlue('Killed buffer: %s' % h)
        c.redraw(current)
</t>
<t tx="ekr.20050920084036.39">def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('prepend-to-buffer: %s' % p.h)
        w.insert(0,s)
        w.setInsertPoint(0)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.4">def longestCommonPrefix (s1,s2):

    '''Find the longest prefix common to strings s1 and s2.'''

    prefix = ''
    for ch in s1:
        if s2.startswith(prefix + ch):
            prefix = prefix + ch
        else:
            return prefix
    return prefix

def itemsMatchingPrefixInList (s,aList,matchEmptyPrefix=False):

    '''This method returns a sorted list items of aList whose prefix is s.

    It also returns the longest common prefix of all the matches.'''

    if s:
        pmatches = [a for a in aList if a.startswith(s)]
    elif matchEmptyPrefix:
        pmatches = aList[:]
    else: pmatches = []

    if pmatches:
        pmatches.sort()
        common_prefix = reduce(g.longestCommonPrefix,pmatches)
    else:
        common_prefix = ''

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix
</t>
<t tx="ekr.20050920084036.40">def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

</t>
<t tx="ekr.20050920084036.42">def listBuffers (self,event):

    '''List all buffers (node headlines), in outline order.
    Nodes with the same headline are disambiguated by giving their parent or child index.
    '''

    self.computeData()
    g.es('buffers...')
    for name in self.nameList:
        g.es('',name)

def listBuffersAlphabetically (self,event):

    '''List all buffers (node headlines), in alphabetical order.
    Nodes with the same headline are disambiguated by giving their parent or child index.'''

    self.computeData()
    names = self.nameList[:] ; names.sort()

    g.es('buffers...')
    for name in names:
        g.es('',name)
</t>
<t tx="ekr.20050920084036.43">def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.setHeadString(p,name)
        c.redraw(p)
</t>
<t tx="ekr.20050920084036.5">def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
</t>
<t tx="ekr.20050920084036.53">class editCommandsClass (baseEditCommandsClass):

    '''Contains editing commands with little or no state.'''

    @others
</t>
<t tx="ekr.20050920084036.54">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.ccolumn = '0'   # For comment column functions.
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A vnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.

    # Settings...
    cf = c.config
    self.autocompleteBrackets   = cf.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = cf.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = cf.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = cf.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = cf.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = cf.getBool('flash-matching-brackets')
    self.smartAutoIndent        = cf.getBool('smart_auto_indent')
    self.openBracketsList       = cf.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList      = cf.getString('close_flash_brackets') or ')]}'

    self.initBracketMatcher(c)
</t>
<t tx="ekr.20050920084036.55">def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-to-home':                         self.backToHome,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-page':                            self.backPage,
        'back-page-extend-selection':           self.backPageExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-delete-word':                 self.backwardDeleteWord,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-all-caches':                     self.clearAllCaches,
        'clear-cache':                          self.clearCache,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'clone-marked':                         c.cloneMarked,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'delete-word':                          self.deleteWord,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-page':                         self.forwardPage,
        'forward-page-extend-selection':        self.forwardPageExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-icon':                          self.insertIcon,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,
        'scroll-down-half-page':                self.scrollDownHalfPage,                
        'scroll-down-line':                     self.scrollDownLine,
        'scroll-down-page':                     self.scrollDownPage,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up-half-page':                  self.scrollUpHalfPage,                        
        'scroll-up-line':                       self.scrollUpLine,
        'scroll-up-page':                       self.scrollUpPage,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20050920084036.57"></t>
<t tx="ekr.20050920084036.58"></t>
<t tx="ekr.20050920084036.59">def dynamicExpansion (self,event=None):

    '''Expand the word in the buffer before point as a dynamic abbrev,
    by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    This corresponds to M-/ in Emacs.'''

    c = self.c ; k = c.k ; p = c.p ; u = c.undoer
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if 0 &lt; ins &lt; len(s) and not g.isWordChar(s[ins]): ins -= 1
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if not rlist: return
    prefix = reduce(g.longestCommonPrefix,rlist)
    if prefix and prefix != txt:
        b = c.undoer.beforeChangeNodeContents(c.p,oldBody=p.b,oldHead=p.h)
        w.delete(i,j)
        w.insert(i,prefix)
        p.b = w.getAllText()
        c.undoer.afterChangeNodeContents(p,
            command='dabbrev-expands',bunch=b,dirtyVnodeList=[])
    else:
        self.dynamicExpandHelper(prefix,rlist,w)
</t>
<t tx="ekr.20050920084036.6">def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
</t>
<t tx="ekr.20050920084036.60">def dynamicCompletion (self,event=None):

    '''Insert the common prefix of all dynamic abbrev's matching the present word.
    This corresponds to C-M-/ in Emacs.'''

    c = self.c ; k = c.k ; p = c.p ; u = c.undoer
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if 0 &lt; ins &lt; len(s) and not g.isWordChar(s[ins]): ins -= 1
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        prefix = reduce(g.longestCommonPrefix,rlist)
        if prefix:
            b = c.undoer.beforeChangeNodeContents(c.p,oldBody=p.b,oldHead=p.h)
            w.delete(i,j)
            w.insert(i,prefix)
            p.b = w.getAllText()
            c.undoer.afterChangeNodeContents(p,
                command='dabbrev-completion',bunch=b,dirtyVnodeList=[]) 
</t>
<t tx="ekr.20050920084036.61">def getDynamicList (self,w,txt,rlist):

    items = []
    if self.globalDynamicAbbrevs:
        for p in self.c.all_positions():
            s = p.b
            if s:
                items.extend(self.dynaregex.findall(s))
    else:
        # Make a big list of what we are considering a 'word'
        s = w.getAllText()
        items.append(self.dynaregex.findall(s))

    # g.trace('txt',repr(txt),'len(items)',len(items))

    if items:
        for word in items:
            if not word.startswith(txt) or word == txt:
                continue
                # dont need words that dont match or == the pattern
            if word not in rlist:
                rlist.append(word)
            else:
                rlist.remove(word)
                rlist.append(word)

    # g.trace('rlist',rlist)
</t>
<t tx="ekr.20050920084036.62"></t>
<t tx="ekr.20050920084036.63">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and event.keysym == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
</t>
<t tx="ekr.20050920084036.64">def escEvaluate (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
</t>
<t tx="ekr.20050920084036.65">def evalExpression (self,event):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')

    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
</t>
<t tx="ekr.20050920084036.66">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
</t>
<t tx="ekr.20050920084036.67">def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) &gt;= self.fillColumn: return

    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k &gt; i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.68">def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
</t>
<t tx="ekr.20050920084036.69">def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind &lt; end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) &gt;= self.fillColumn:
            ind = j
        else:
            n = int((self.fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k &gt; i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.7">def oops (self):

    g.pr("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
</t>
<t tx="ekr.20050920084036.70">def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
</t>
<t tx="ekr.20050920084036.71">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
</t>
<t tx="ekr.20050920084036.72"></t>
<t tx="ekr.20050920084036.74"></t>
<t tx="ekr.20050920084036.75">def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.76">def deleteIndentation (self,event):

    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return


    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    line2 = s[i:j].lstrip()
    delta = len(line) - len(line2)
    if delta:
        self.beginCommand(undoType='delete-indentation')

        w.delete(i,j)
        w.insert(i,line2)
        ins -= delta
        w.setSelectionRange(ins,ins,insert=ins)

        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.77">def splitLine (self,event):

    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='split-line')

    s = w.getAllText()
    ins = w.getInsertPoint()
    w.setAllText(s[:ins] + '\n' + s[ins:])
    w.setInsertPoint(ins+1)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.78">def indentRelative (self,event):

    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''

    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.getYScrollPosition()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i &lt;= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.79"></t>
<t tx="ekr.20050920084036.80">def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
</t>
<t tx="ekr.20050920084036.81">def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
</t>
<t tx="ekr.20050920084036.83">def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
</t>
<t tx="ekr.20050920084036.84">def whatLine (self,event):

    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
</t>
<t tx="ekr.20050920084036.85"></t>
<t tx="ekr.20050920084036.86">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    c = self.c ; k = c.k
    w = self.editWidget(event) ; p = c.p
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    self.updateTab(p,w,smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand(changed=True,setLabel=False)
</t>
<t tx="ekr.20050920084036.87">def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()

    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j &lt; len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False

    self.endCommand(changed=changed,setLabel=False)
</t>
<t tx="ekr.20050920084036.88"></t>
<t tx="ekr.20050920084036.90">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
</t>
<t tx="ekr.20050920084036.92">def linesHelper (self,event,pattern,which):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType=which+'-lines')
    if w.hasSelection():
        i,end = w.getSelectionRange()
    else:
        i = w.getInsertPoint()
        end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.setInsertPoint(i)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.95">@others
</t>
<t tx="ekr.20050920084036.96">def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i &gt; 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j &lt; len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
</t>
<t tx="ekr.20050920084036.97">def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j &lt; len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
</t>
<t tx="ekr.20050920084036.98">def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.99">def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i &gt; 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084720">def createEditCommanders (c):

    '''Create edit classes in the commander.'''

    global classesList

    for name, theClass in classesList:
        theInstance = theClass(c)# Create the class.
        setattr(c,name,theInstance)
        # g.trace(name,theInstance)
</t>
<t tx="ekr.20050920085536.15"># Called from loadFile and nameLastKbdMacro.

def addToDoAltX (self,name,macro):

    '''Adds macro to Alt-X commands.'''

    k= self ; c = k.c

    g.trace(name,macro)

    if name in c.commandsDict:
        return False

    def func (event,macro=macro):
        return self.executeMacro(macro)

    c.commandsDict [name] = func
    self.namedMacros [name] = macro
    return True
</t>
<t tx="ekr.20050920093543">def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.p
    c.miniBufferWidget = c.frame.miniBufferWidget
    # print('Commands.finishCreate',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders:
        # A 'real' .leo file.
        import leo.core.leoEditCommands as leoEditCommands
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        self.rstCommands.finishCreate()

        # copy global commands to this controller    

        for name,f in g.app.global_commands_dict.items():
            k.registerCommand(name,shortcut = None, func = f, pane='all',verbose=False)        

        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20050921103230">def defineCmdsMenuTables (self):

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
</t>
<t tx="ekr.20050921103736">def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&amp;Cmds')

    # Now in the minibuffer table.
        # Used in top table: q,u,x
        # self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Chapters...',        self.cmdsMenuChaptersTable),
        ('C&amp;ursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        #('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('&amp;Pickers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('R&amp;un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)
</t>
<t tx="ekr.20050922104213">classesList = [
    ('abbrevCommands',      abbrevCommandsClass),
    ('bufferCommands',      bufferCommandsClass),
    ('editCommands',        editCommandsClass),
    ('chapterCommands',     chapterCommandsClass),
    ('controlCommands',     controlCommandsClass),
    ('debugCommands',       debugCommandsClass),
    ('editFileCommands',    editFileCommandsClass),
    ('helpCommands',        helpCommandsClass),
    ('keyHandlerCommands',  keyHandlerCommandsClass),
    ('killBufferCommands',  killBufferCommandsClass),
    ('leoCommands',         leoCommandsClass),
    ('macroCommands',       macroCommandsClass),
    # ('queryReplaceCommands',queryReplaceCommandsClass),
    ('rectangleCommands',   rectangleCommandsClass),
    ('registerCommands',    registerCommandsClass),
    ('searchCommands',      searchCommandsClass),
    ('spellCommands',       spellCommandsClass),
]
</t>
<t tx="ekr.20050922104731">def finishCreateEditCommanders (c):

    '''Finish creating edit classes in the commander.

    Return the commands dictionary for all the classes.'''

    global classesList

    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                g.pr('----- %s' % name)
                for key in sorted(d2): g.pr(key)

    return d
</t>
<t tx="ekr.20050922110030">def advertizedUndo (self,event):

    '''Undo the previous command.'''

    self.c.undoer.undo()
</t>
<t tx="ekr.20050924100713"></t>
<t tx="ekr.20050924100713.1">def initAllEditCommanders (c):

    '''Re-init classes in the commander.'''

    global classesList

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.init()
</t>
<t tx="ekr.20050927093851">def getBufferName (self,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    k = self.k ; c = k.c ; state = k.getState('getBufferName')

    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel() ; event = None
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
</t>
<t tx="ekr.20050927102133.1"></t>
<t tx="ekr.20050929114218"></t>
<t tx="ekr.20050929115226">def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n &gt;= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20050929124234">def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20050929155208"></t>
<t tx="ekr.20050929161635"></t>
<t tx="ekr.20050930091642.1">def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.p
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard()
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 &lt; i &lt;= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050930091642.2">def yankPop (self,event):

    '''Insert the next entry of the kill ring.'''

    self.yank(event,pop=True)

</t>
<t tx="ekr.20050930095323.1">def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050930100733">def killWs (self,event,undoType='kill-ws'):

    '''Kill whitespace.'''

    ws = ''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = j = ins = w.getInsertPoint()

    while i &gt;= 0 and s[i] in (' ','\t'):
        i-= 1
    if i &lt; ins: i += 1

    while j &lt; len(s) and s[j] in (' ','\t'):
        j += 1

    if j &gt; i:
        ws = s[i:j]
        # g.trace(i,j,repr(ws))
        w.delete(i,j)
        if undoType: self.beginCommand(undoType=undoType)
        if self.addWsToKillRing:
            self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050930112126">def shellCommandOnRegion (self,event):

    '''Execute a command taken from the selected text in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if subprocess:
        if w.hasSelection():
            command = w.getSelectedText()
            k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command)
        else:
            k.clearState()
            k.resetLabel()
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
</t>
<t tx="ekr.20051002090441">def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
</t>
<t tx="ekr.20051002095724">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
</t>
<t tx="ekr.20051004080550">def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg,'add-inverse-abbr'
</t>
<t tx="ekr.20051004095209"></t>
<t tx="ekr.20051004112630">def check (self,event,warning='No rectangle selected'):

    '''Return True if there is a selection.
    Otherwise, return False and issue a warning.'''

    return self._chckSel(event,warning)
</t>
<t tx="ekr.20051004123217">def checkBodySelection (self,warning='No text selected'):

    return self._chckSel(event=None,warning=warning)
</t>
<t tx="ekr.20051005151838"></t>
<t tx="ekr.20051005155611">try:
    regex = re.compile(self.qQ)
except Exception:
    self.quitSearch(event,'Illegal regular expression')
    return False

i = w.getInsertPoint()
txt = w.get(i,'end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    i = w.getInsertPoint()
    txt = w.get(i,i+length)
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20051005160923">i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):

    c = self

    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print('%30s = %s' % (
            key,g.choose(command,command.__name__,'&lt;None&gt;')))
    print('')
</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):

    f = self ; c = f.c

    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
</t>
<t tx="ekr.20051011105014">def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
</t>
<t tx="ekr.20051012092453">def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20051012092847.1">def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.p

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20051013083241">def replaceAll (self,event=None):

    c = self

    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
</t>
<t tx="ekr.20051013084200">def dismissFindPanel (self,event=None):

    c = self

    if c.frame.findPanel:
        c.frame.findPanel.dismiss()
</t>
<t tx="ekr.20051013084200.1">def dismiss (self):
    pass
</t>
<t tx="ekr.20051013161232">def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
</t>
<t tx="ekr.20051014170754">def helpForMinibuffer (self,event=None):

    '''Print a messages telling you how to get started with Leo.'''

    # A bug in Leo: triple quotes puts indentation before each line.
    c = self.c
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not yet for file names.

quick-command-mode (default shortcut: Alt-x). Like Emacs Control-C. This mode is
defined in leoSettings.leo. It is useful for commonly-used commands.

universal-argument (default shortcut: Alt-u). Like Emacs Ctrl-u. Adds a repeat
count for later command. Ctrl-u 999 a adds 999 a's. Many features remain
unfinished.

keyboard-quit (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
the focus in the body pane.

Use the help-for-command command to see documentation for a particular command.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    # s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])

    if not g.app.unitTesting:
        g.es_print('',s)
</t>
<t tx="ekr.20051014175117">def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) &lt; w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
</t>
<t tx="ekr.20051015093141">def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
</t>
<t tx="ekr.20051015114221">def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
</t>
<t tx="ekr.20051015114221.1">def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20051019183105"></t>
<t tx="ekr.20051019183105.1">def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
</t>
<t tx="ekr.20051019201809">def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    g.trace(g.callers(4))

    c.widgetWantsFocusNow(w)
    # g.app.gui.selectAllText(w)
    w.selectAllText()
    c.widgetWantsFocus(w)
</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021091958">if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20051022043608.1">def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;
        # g.trace(label,accelerator)
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        callback = self.defineOpenWithMenuCallback(openWithData)

        c.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
</t>
<t tx="ekr.20051022043713.1">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)

if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
</t>
<t tx="ekr.20051022044950">def computeOldStyleShortcutKey (self,s):

    '''Compute the old-style shortcut key for @shortcuts entries.'''

    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
</t>
<t tx="ekr.20051022053758.1"></t>
<t tx="ekr.20051022142249"></t>
<t tx="ekr.20051022144825">def focusToBody (self,event):
    '''Put the keyboard focus in Leo's body pane.'''
    c = self.c ; k = c.k
    c.bodyWantsFocusNow()
    if k:
        k.setDefaultInputState()
        k.showStateAndMode()

def focusToLog (self,event):
    '''Put the keyboard focus in Leo's log pane.'''
    self.c.logWantsFocusNow()

def focusToMinibuffer (self,event):
    '''Put the keyboard focus in Leo's minibuffer.'''
    self.c.minibufferWantsFocusNow()

def focusToTree (self,event):
    '''Put the keyboard focus in Leo's outline pane.'''
    self.c.treeWantsFocusNow()
</t>
<t tx="ekr.20051022144825.1">def cycleFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ; k = c.k ; w = event.widget

    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    # A hack for the Qt gui.
    if hasattr(w,'logCtrl'):
        w = w.logCtrl

    panes = [body,log,tree]

    # g.trace(w in panes,event.widget,panes)

    if w in panes:
        i = panes.index(w) + 1
        if i &gt;= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body

    # Warning: traces mess up the focus
    # g.pr(g.app.gui.widget_name(w),g.app.gui.widget_name(pane))

    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    k.newMinibufferWidget = pane
    k.showStateAndMode()
</t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20051023083258">def callers (n=4,count=0,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callerList.

    If the excludeCaller keyword is True (the default), g.callers is not on the list.

    If the files keyword argument is True, filenames are included in the list.
    '''

    # sys._getframe throws ValueError in both cpython and jython if there are less than i entries.
    # The jython stack often has less than 8 entries,
    # so we must be careful to call g._callerName with smaller values of i first.
    result = []
    i = g.choose(excludeCaller,3,2)
    while 1:
        s = g._callerName(i,files=files)
        if s:
            result.append(s)
        if not s or len(result) &gt;= n: break
        i += 1

    result.reverse()
    if count &gt; 0: result = result[:count]
    sep = g.choose(files,'\n',',')
    return sep.join(result)
</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
</t>
<t tx="ekr.20051025071455">@others
</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20051025071455.18">class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    if enchant:
        self.spellController = EnchantClass(c)
        # self.controller = self.spellController 
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
        self.loaded = True
    else:
        self.spellController = None
        self.tab = None
        self.loaded = False
</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    w = self.currentWord

    if w:
        self.spellController.add(w)
        # self.dictionary[w] = 0
        self.tab.onFindButton()
</t>
<t tx="ekr.20051025071455.38">def change(self,event=None):
    """Make the selected change to the text"""

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        if hasattr(self.tab,'change_i') and self.tab.change_i is not None:
            start,end = oldSel = self.tab.change_i,self.tab.change_j
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start is not None:
            if start &gt; end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20051025071455.40">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20051025071455.41">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    w = self.currentWord

    if w:
        self.spellController.ignore(w)
        self.tab.onFindButton()
</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    w = c.frame.body.bodyCtrl
    sc = self.spellController
    alts = None ; word = None
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '&lt;no p&gt;')
            if not p or not word:
                alts = None
                break
            alts = sc.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if c.sparse_spell and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents():
                        p2.contract()
                        redraw = True
                for p2 in p.parents():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20051025071455.47">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'--&gt;',p.h)

    return None,None,None,None
</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.
# self.handler is a spellTabHandler object (inited by openSpellTab)

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        # A workaround for a pylint warning:
        # self.handler.changeThenFind()
        f = getattr(self.handler,'changeThenFind')
        f()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
</t>
<t tx="ekr.20051025121408">def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    # for message in self.messages:
        # g.es(message,color='blue')

    # self.messages = []
</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20051026083733.6">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
</t>
<t tx="ekr.20051026083733.7">
redraw_flag = False
# Update dirty bits.
# p.setDirty() sets all cloned and @file dirty bits.
if not p.isDirty() and p.setDirty():
    redraw_flag = True

# Update icons. p.v.iconVal may not exist during unit tests.
val = p.computeIcon()
# g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '&lt;None&gt;')
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

if redraw_flag:
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
</t>
<t tx="ekr.20051026092433.1">def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.p
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = c.scanAllDirectives(p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20051026092746">s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
</t>
<t tx="ekr.20051026171121">def insertNewlineHelper (self,w,oldSel,undoType):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'
    if trace:
        s = w.widget.toPlainText()
        g.trace(i,j,len(s),w)

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
</t>
<t tx="ekr.20051026171121.1">def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051104051733">FocusIn does nothing for Label widgets.

http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the &lt;FocusIn&gt; binding on the minibuffer widget were equivilent
to Alt-x.
</t>
<t tx="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e">'''Classes for Leo's unit testing. 

Run the unit tests in test.leo using the Execute Script command.'''

@language python
@tabwidth -4

&lt;&lt; leoTest imports &gt;&gt;

if g.app: # Make sure we can import this module stand-alone.
    newAtFile = g.app.pluginsController.isLoaded("___proto_atFile")
else:
    newAtFile = False

@others
</t>
<t tx="ekr.20051104075904.1">import leo.core.leoGlobals as g

import leo.core.leoColor as leoColor
import leo.core.leoCommands as leoCommands
import leo.core.leoFrame as leoFrame
import leo.core.leoGui as leoGui
import leo.core.leoNodes as leoNodes

import doctest
import gc
import glob
import os
import cProfile as profile
# import pstats
import sys
import timeit
import tokenize
import unittest

try:
    import tabnanny # Does not exist in jython.
except ImportError:
    tabnanny = None
</t>
<t tx="ekr.20051104075904.10">def runTest (self,define_g = True):

    trace = False
    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)
    writeScriptFile = c.config.getBool('write_script_file')

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p and p.copy(),'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    if trace: g.trace('p',p and p.h,'\n',script)

    # Execute the script. Let unit test handle any errors!
    if writeScriptFile:
        scriptFile = c.writeScriptFile(script)

    exec(script,d)
</t>
<t tx="ekr.20051104075904.100">def findAllAtFileNodes(c):

    paths = []

    for p in c.all_unique_positions():
        name = p.anyAtFileNodeName()
        if name:
            head,tail = g.os_path_split(name)
            filename,ext = g.os_path_splitext(tail)
            if ext == ".py":
                path = g.os_path_finalize_join(g.app.loadDir,name)
                paths.append(path)

    return paths
</t>
<t tx="ekr.20051104075904.101">def importAllModulesInPathList(paths):

    paths = list(paths)
    modules = []

    for path in paths:
        module = safeImportModule(path)
        if module:
            modules.append(module)

    return modules
</t>
<t tx="ekr.20051104075904.102">def importAllModulesInPath (path,exclude=[]):

    path = g.os_path_finalize(path)

    if not g.os_path_exists(path):
        g.es("path does not exist:",path)
        return []

    path2 = g.os_path_join(path,"leo*.py")
    files = glob.glob(path2)
    files2 = []
    for theFile in files:
        for z in exclude:
            if theFile.endswith(z):
                break
        else:
            files2.append(theFile)
    modules = []

    for theFile in files2:
        module = safeImportModule(theFile)
        if module:
            modules.append(module)

    # g.trace(modules)
    return modules
</t>
<t tx="ekr.20051104075904.103">@ Warning: do NOT use g.importFromPath here!

g.importFromPath uses imp.load_module, and that is equivalent to reload!
reloading Leo files while running will crash Leo.
@c

def safeImportModule (fileName):

    fileName = g.os_path_finalize(fileName)
    head,tail = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(tail)
    oldUnitTesting = g.unitTesting

    if ext == ".py":
        try:
            # g.trace(moduleName)
            g.unitTesting = False # Disable @test nodes!
            g.app.unitTesting = False
            try:
                # for base in ('leo.core','leo.plugins','leo.external',):
                    # fullName = '%s.%s' % (base,moduleName)
                    # m = __import__(fullName) # 'leo.core.%s' % moduleName)
                    # if m is not None:
                        # return sys.modules.get(fullName)
                fullName = 'leo.core.%s' % (moduleName)
                __import__(fullName)
                return sys.modules.get(fullName)
            finally:
                g.unitTesting = oldUnitTesting
                g.app.unitTesting = oldUnitTesting
        except Exception:
            # g.trace('can not import',moduleName,fileName)
            # leoScriptModule.py, for example, can throw other exceptions.
            return None
    else:
        g.pr("Not a .py file:",fileName)
        return None
</t>
<t tx="ekr.20051104075904.11">def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
</t>
<t tx="ekr.20051104075904.12">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    script = g.getScript(c,p).strip()
    if not script:
        print("no script in %s" % h)
        return None
    try:
        if 0: #debugging
            n,lines = 0,g.splitLines(script)
            for line in lines:
                print(n,line)
                n += 1
        exec(script + '\n',{'c':c,'g':g,'p':p})
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("makeTestSuite: %s script did not set g.app.scriptDict" % p.h)
        return suite
    except Exception:
        print('makeTestSuite: exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
</t>
<t tx="ekr.20051104075904.13">def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
</t>
<t tx="ekr.20051104075904.14"># A utility for use by script buttons.

def runProfileOnNode (p,outputPath=None):

    s = p.b.rstrip() + '\n'

    if outputPath is None:
        outputPath = g.os_path_finalize_join(
            g.app.loadDir,'..','test','profileStats')

    profile.run(s,outputPath)

    if 1:
        stats = pstats.Stats(outputPath)
        stats.strip_dirs()
        stats.sort_stats('cum','file','name')
        stats.print_stats()
</t>
<t tx="ekr.20051104075904.15"># A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.b.rstrip() + '\n'

    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p and p.copy()}

    # This looks like the best we can do.
    setup = 'import leo.core.leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        ratio = "%f" % (float(result)/float(count))
        g.es_print("count:",count,"time/count:",ratio,'',p.h)
    except Exception:
        t.print_exc()
</t>
<t tx="ekr.20051104075904.16"></t>
<t tx="ekr.20051104075904.17">lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

# Adapted from similar code in leoGlobals.g.
def runGc(disable=False):

    message = "runGC"

    if gc is None:
        g.pr("@gc: can not import gc")
        return

    gc.enable()
    set_debugGc()
    gc.collect()
    printGc(message=message)
    if disable:
        gc.disable()
    # makeObjectList(message)

runGC = runGc
</t>
<t tx="ekr.20051104075904.18">def set_debugGc ():

    gc.set_debug(
        gc.DEBUG_STATS | # prints statistics.
        # gc.DEBUG_LEAK | # Same as all below.
        # gc.DEBUG_COLLECTABLE
        # gc.DEBUG_UNCOLLECTABLE
        gc.DEBUG_INSTANCES |
        gc.DEBUG_OBJECTS
        # gc.DEBUG_SAVEALL
    )
</t>
<t tx="ekr.20051104075904.19">def makeObjectList(message):

    # WARNING: this id trick is not proper: newly allocated objects can have the same address as old objects.
    global lastObjectsDict
    objects = gc.get_objects()

    newObjects = [o for o in objects if not id(o) in lastObjectsDict]

    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    g.pr("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))
</t>
<t tx="ekr.20051104075904.2"></t>
<t tx="ekr.20051104075904.20">def printGc(message=None):

    '''Called from unit tests.'''

    if not message:
        message = g.callers(2)

    global lastObjectCount

    n = len(gc.garbage)
    n2 = len(gc.get_objects())
    delta = n2-lastObjectCount

    g.pr('-' * 30)
    g.pr("garbage: %d" % n)
    g.pr("%6d =%7d %s" % (delta,n2,"totals"))

    &lt;&lt; print number of each type of object &gt;&gt;
    if 0:
        &lt;&lt; print added functions &gt;&gt;

    lastObjectCount = n2
    return delta
</t>
<t tx="ekr.20051104075904.21">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    typesDict[type(obj)] = n + 1

# Create the union of all the keys.
keys = {}
for key in lastTypesDict:
    if key not in typesDict:
        keys[key]=None

for key in sorted(keys):
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.pr("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
</t>
<t tx="ekr.20051104075904.22">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if key not in lastFunctionsDict:
            g.pr('\n',obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.pr("args", args)
            if varargs: g.pr("varargs",varargs)
            if varkw: g.pr("varkw",varkw)
            if defaults:
                g.pr("defaults...")
                for s in defaults: g.pr(s)

lastFunctionsDict = funcDict
funcDict = {}
</t>
<t tx="ekr.20051104075904.23">def printGcRefs (verbose=True):

    refs = gc.get_referrers(g.app.windowList[0])
    g.pr('-' * 30)

    if verbose:
        g.pr("refs of", g.app.windowList[0])
        for ref in refs:
            g.pr(type(ref))
    else:
        g.pr("%d referrers" % len(refs))
</t>
<t tx="ekr.20051104075904.24">class testUtils:

    """Common utility routines used by unit tests."""

    @others
</t>
<t tx="ekr.20051104075904.25">def compareOutlines (self,root1,root2,compareHeadlines=True,tag='',report=True):

    """Compares two outlines, making sure that their topologies,
    content and join lists are equivalent"""

    p2 = root2.copy() ; ok = True
    for p1 in root1.self_and_subtree():
        ok = (
            p1 and p2 and
            p1.numberOfChildren() == p2.numberOfChildren() and
            (not compareHeadlines or (p1.h == p2.h)) and
            p1.b == p2.b and
            p1.isCloned()   == p2.isCloned()
        )
        if not ok: break
        p2.moveToThreadNext()

    if not report:
        return ok

    if ok:
        if 0:
            g.pr('compareOutlines ok',newline=False)
            if tag: g.pr('tag:',tag)
            else: g.pr('')
            if p1: g.pr('p1',p1,p1.v)
            if p2: g.pr('p2',p2,p2.v)
    else:
        g.pr('compareOutlines failed',newline=False)
        if tag: g.pr('tag:',tag)
        else: g.pr('')
        if p1: g.pr('p1',p1,p1.v)
        if p2: g.pr('p2',p2,p2.v)
        if not p1 or not p2:
            g.pr('p1 and p2')
        if p1.numberOfChildren() != p2.numberOfChildren():
            g.pr('p1.numberOfChildren()=%d, p2.numberOfChildren()=%d' % (
                p1.numberOfChildren(),p2.numberOfChildren()))
        if compareHeadlines and (p1.h != p2.h):
            g.pr('p1.head', p1.h)
            g.pr('p2.head', p2.h)
        if p1.b != p2.b:
            self.showTwoBodies(p1.h,p1.b,p2.b)
        if p1.isCloned() != p2.isCloned():
            g.pr('p1.isCloned() == p2.isCloned()')

    return ok
</t>
<t tx="ekr.20051104075904.26"></t>
<t tx="ekr.20051104075904.27">def findChildrenOf (self,root):

    return [p.copy() for p in root.children()]
</t>
<t tx="ekr.20051104075904.28">def findSubnodesOf (self,root):

    return [p.copy() for p in root.subtree()]
</t>
<t tx="ekr.20051104075904.29">def findRootNode (self,p):

    """Return the root of p's tree."""

    while p and p.hasParent():
        p.moveToParent()
    return p
</t>
<t tx="ekr.20051104075904.3">def isSuiteNode (p):
    h = p.h.lower()
    return g.match_word(h,0,"@suite")

def isTestNode (p):
    h = p.h.lower()
    return g.match_word(h,0,"@test")

# def isTestCaseNode (p):
    # h = p.h.lower()
    # return g.match_word(h,0,"@testcase") or g.match_word(h,0,"@test-case")
</t>
<t tx="ekr.20051104075904.30">def findNodeInTree(self,p,headline,startswith=False):

    """Search for a node in p's tree matching the given headline."""

    c = self.c
    h = headline.strip().lower()
    for p in p.subtree():
        h2 = p.h.strip().lower()
        if h2 == h or startswith and h2.startswith(h):
            return p.copy()
    return c.nullPosition()

</t>
<t tx="ekr.20051104075904.31">def findNodeAnywhere(self,headline,breakOnError=False):

    c = self.c
    for p in c.all_unique_positions():
        h = headline.strip().lower()
        if p.h.strip().lower() == h:
            return p.copy()

    if False and breakOnError: # useful for debugging.
        aList = [repr(z.copy()) for z in c.p.parent().self_and_siblings()]
        print('\n'.join(aList))

    return c.nullPosition()
</t>
<t tx="ekr.20051104075904.33">def numberOfClonesInOutline (self):

    """Returns the number of cloned nodes in an outline"""

    c = self.c ; n = 0
    for p in c.all_positions():
        if p.isCloned():
            n += 1
    return n
</t>
<t tx="ekr.20051104075904.34">def numberOfNodesInOutline (self):

    """Returns the total number of nodes in an outline"""

    return len([p for p in self.c.all_positions()])
</t>
<t tx="ekr.20051104075904.36"></t>
<t tx="ekr.20051104075904.37">def writeNodesToNode (self,c,input,output,sentinels=True):

    result = []
    for p in input.self_and_subtree():
        s = self.writeNodeToString(c,p,sentinels)
        result.append(s)
    result = ''.join(result)
    output.scriptSetBodyString (result)
</t>
<t tx="ekr.20051104075904.38">def writeNodeToNode (self,c,input,output,sentinels=True):

    """Do an atFile.write the input tree to the body text of the output node."""

    s = self.writeNodeToString(c,input,sentinels)

    output.scriptSetBodyString (s)
</t>
<t tx="ekr.20051104075904.39">def writeNodeToString (self,c,input,sentinels):

    """Return an atFile.write of the input tree to a string."""

    df = c.atFileCommands
    nodeIndices = g.app.nodeIndices

    for p in input.self_and_subtree():
        try:
            theId,time,n = p.v.fileIndex
        except TypeError:
            p.v.fileIndex = nodeIndices.getNewIndex()

    # Write the file to a string.
    df.write(input,thinFile=True,nosentinels= not sentinels,toString=True)
    s = df.stringOutput

    return s
</t>
<t tx="ekr.20051104075904.4">def doTests(c,all=None,p=None,verbosity=1):

    trace = False ; verbose = False
    if all:
        p = c.rootPosition()
    elif not p:
        p = c.p
    p1 = p.copy()

    try:
        found = False
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        if all: last = None
        else:   last = p.nodeAfterTree()
        if trace: g.trace('all',all,'root',p.h)
        while p and p != last:
            if g.match_word(p.h,0,'@ignore'):
                if trace: g.trace('ignoring tree',p.h)
                p.moveToNodeAfterTree()
            elif isTestNode(p): # @test
                if trace: g.trace('adding',p.h)
                test = makeTestCase(c,p)
                if test:
                    suite.addTest(test) ; found = True
                p.moveToThreadNext()
            elif isSuiteNode(p): # @suite
                if trace: g.trace('adding',p.h)
                test = makeTestSuite(c,p)
                if test:
                    suite.addTest(test) ; found = True
                p.moveToThreadNext()
            else:
                if trace and verbose: g.trace('skipping',p.h)
                p.moveToThreadNext()

        # Verbosity: 1: print just dots.
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            if g.enableDB:
                key = 'unittest/cur/fail'
                archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
                c.cacher.db[key] = archive
        else:
            g.es_print('no @test or @suite nodes in %s outline' % (
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
</t>
<t tx="ekr.20051104075904.40">def compareIgnoringNodeNames (self,s1,s2,delims,verbose=False):

    # Compare text containing sentinels, but ignore differences in @+-nodes.
    delim1,delim2,delim3 = delims

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    if len(lines1) != len(lines2):
        if verbose: g.trace("Different number of lines")
        return False

    for i in range(len(lines2)):
        line1 = lines1[i]
        line2 = lines2[i]
        if line1 == line2:
            continue
        else:
            n1 = g.skip_ws(line1,0)
            n2 = g.skip_ws(line2,0)
            if (
                not g.match(line1,n1,delim1) or
                not g.match(line2,n2,delim1)
            ):
                if verbose: g.trace("Mismatched non-sentinel lines")
                return False
            n1 += len(delim1)
            n2 += len(delim1)
            if g.match(line1,n1,"@+node") and g.match(line2,n2,"@+node"):
                continue
            if g.match(line1,n1,"@-node") and g.match(line2,n2,"@-node"):
                continue
            else:
                if verbose:
                    g.trace("Mismatched sentinel lines",delim1)
                    g.trace("line1:",repr(line1))
                    g.trace("line2:",repr(line2))
                return False
    return True
</t>
<t tx="ekr.20051104075904.41">def fail ():

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20051104075904.42">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    # Do not set or clear g.app.unitTesting: that is only done in leoTest.runTest.

    assert g.app.unitTesting

    try:
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            frame.c.setChanged(False)
            g.app.closeLeoWindow(frame)
        c.frame.update() # Restored in Leo 4.4.8.
</t>
<t tx="ekr.20051104075904.43"></t>
<t tx="ekr.20051104075904.44">def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in (
        "@auto","@edit","@file","@thin","@nosent",
        "@asis",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@auto":
        at.writeOneAtAutoNode(child1,toString=True,force=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput)
        assert result == expected
    except AssertionError:
        &lt;&lt; dump result and expected &gt;&gt;
        raise
</t>
<t tx="ekr.20051104075904.45">print('\n','-' * 20)
print("result...")
for line in g.splitLines(result):
    print("%3d" % len(line),repr(line))
print('-' * 20)
print("expected...")
for line in g.splitLines(expected):
    print("%3d" % len(line),repr(line))
print('-' * 20)
</t>
<t tx="ekr.20051104075904.46"># DTHEIN 2004.01.11: Added unit tests for reformatParagraph
</t>
<t tx="ekr.20051104075904.47">class reformatParagraphTest:

    '''A class to work around stupidities of the Unittest classes.'''

    @others
</t>
<t tx="ekr.20051104075904.48">def __init__ (self,c,p):

    self.c = c
    self.p = p.copy()

    self.go()
</t>
<t tx="ekr.20051104075904.49">def go (self):

    try:
        self.setUp()
        self.runTest()
    finally:
        self.tearDown()
</t>
<t tx="ekr.20051104075904.5">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20051104075904.50">def checkPosition(self,expRow,expCol):

    row,col = self.getRowCol()

    assert expCol == col, "Got column %d.  Expected %d" % (col,expCol)

    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
</t>
<t tx="ekr.20051104075904.51">def checkText(self):

    new_text = self.tempChild.b
    ref_text = self.after.b
    newLines = new_text.splitlines(1)
    refLines = ref_text.splitlines(1)
    newLinesCount = len(newLines)
    refLinesCount = len(refLines)
    for i in range(min(newLinesCount,refLinesCount)):
        assert newLines[i] == refLines[i], \
            "Mismatch on line " + str(i) + "." \
            + "\nExpected text: " + repr(refLines[i]) \
            + "\n  Actual text: " + repr(newLines[i])

    assert newLinesCount == refLinesCount, \
        "Expected " + str(refLinesCount) + " lines, but " \
        + "received " + str(newLinesCount) + " lines."
</t>
<t tx="ekr.20051104075904.52"># Used in a unit test.

def copyBeforeToTemp(self):

    c = self.c ; tempNode = self.tempNode

    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()

    # Copy the before node text to the temp node.
    text = self.before.b
    tempNode.setBodyString(text)

    # create the child node that holds the text.
    self.tempChild = self.tempNode.insertAsNthChild(0)
    self.tempChild.setHeadString('tempChildNode')

    # copy the before text to the temp text.
    text = self.before.b
    self.tempChild.setBodyString(text)

    # Make the temp child node current, and put the cursor at the beginning.
    c.selectPosition(self.tempChild)
    w = c.frame.body.bodyCtrl
    w.setSelectionRange(0,0)
</t>
<t tx="ekr.20051104075904.53">def getRowCol(self):

    c = self.c ; w = c.frame.body.bodyCtrl
    tab_width = c.frame.tab_width

    # Get the Tkinter row col position of the insert cursor.
    s = w.getAllText()
    index = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    row += 1
    # g.trace(index,row,col)

    # Adjust col position for tabs.
    if col &gt; 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2)
        col = g.computeWidth(s2,tab_width)

    return row,col
</t>
<t tx="ekr.20051104075904.54">def runTest(self):

    g.trace('must be overridden in subclasses')
</t>
<t tx="ekr.20051104075904.55">def setUp(self):

    c = self.c ; p = self.p
    u = self.u = testUtils(c)

    # self.undoMark = c.undoer.getMark()
    c.undoer.clearUndoState()

    assert(c.positionExists(p))
    self.before = u.findNodeInTree(p,"before")
    self.after  = u.findNodeInTree(p,"after")
    self.tempNode = u.findNodeInTree(p,"tempNode")

    assert self.tempNode,'no tempNode: ' + p
    assert c.positionExists(self.tempNode),'tempNode does not exist'
    self.tempChild = None

    self.copyBeforeToTemp()
</t>
<t tx="ekr.20051104075904.56">def tearDown(self):

    c = self.c ; tempNode = self.tempNode

    # clear the temp node and mark it unchanged
    tempNode.setBodyString("")
    tempNode.clearDirty()

    if 1: # Disabling this is good for debugging.
        # Delete all children of temp node.
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()

    # c.undoer.rollbackToMark(self.undoMark)
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20051104075904.57">class singleParagraphTest (reformatParagraphTest):

    '''A class to work around stupidities of the Unittest classes.'''

    @others
</t>
<t tx="ekr.20051104075904.58">def __init__ (self,c,p,finalRow,finalCol):

    self.finalCol = finalCol
    self.finalRow = finalRow

    # Call the base class.
    reformatParagraphTest.__init__(self,c,p)
</t>
<t tx="ekr.20051104075904.59">def runTest(self):

    # Reformat the paragraph
    self.c.reformatParagraph()

    # Compare the computed result to the reference result.
    self.checkText()
    self.checkPosition(self.finalRow,self.finalCol)
</t>
<t tx="ekr.20051104075904.6">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20051104075904.60">class multiParagraphTest (reformatParagraphTest):

    @others
</t>
<t tx="ekr.20051104075904.61">def runTest(self):

    self.c.reformatParagraph()
    self.checkPosition(13,0)

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(25,0)
    self.c.reformatParagraph()
    self.checkPosition(32,11)

    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20051104075904.62">class multiParagraphWithListTest (reformatParagraphTest):

    @others
</t>
<t tx="ekr.20051104075904.63">def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(4,0)

    # Keep going, in the same manner.
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)

    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20051104075904.64">class leadingWSOnEmptyLinesTest (reformatParagraphTest):

    @others
</t>
<t tx="ekr.20051104075904.65">def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(4,0)

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)

    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20051104075904.66">class directiveBreaksParagraphTest (reformatParagraphTest):

    @others
</t>
<t tx="ekr.20051104075904.67">def runTest(self):

    # reformat the paragraph and check insertion cursor position
    self.c.reformatParagraph()
    self.checkPosition(13,0) # at next paragraph

    # Keep going, in the same manner
    self.c.reformatParagraph()
    self.checkPosition(25,0) # at next paragraph
    self.c.reformatParagraph()
    self.checkPosition(32,11)

    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20051104075904.68"></t>
<t tx="ekr.20051104075904.69">def makeEditBodySuite(c,p):

    """Create an Edit Body test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    assert c.positionExists(p)
    data_p = u.findNodeInTree(p,"editBodyTests")   
    assert data_p,'%s %s' % (p and p.h,g.callers())
    temp_p = u.findNodeInTree(data_p,"tempNode")
    assert temp_p,'not found %s in tree %s %s' % (
        p and p.h,data_p and data_p.h, g.callers())

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in data_p.children():
        if p.h=="tempNode": continue # TempNode now in data tree.
        before = u.findNodeInTree(p,"before")
        after  = u.findNodeInTree(p,"after")
        sel    = u.findNodeInTree(p,"selection")
        ins    = u.findNodeInTree(p,"insert")
        if before and after:
            test = editBodyTestCase(c,p,before,after,sel,ins,temp_p)
            suite.addTest(test)
        else:
            g.pr('missing "before" or "after" for', p.h)

    return suite
</t>
<t tx="ekr.20051104075904.7">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20051104075904.70">class editBodyTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
</t>
<t tx="ekr.20051104075904.71">def __init__ (self,c,parent,before,after,sel,ins,tempNode):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.u = testUtils(c)
    self.c = c
    self.failFlag = False
    self.parent = parent.copy()
    self.before = before.copy()
    self.after  = after.copy()
    self.sel    = sel.copy() # Two lines giving the selection range in tk coordinates.
    self.ins    = ins.copy() # One line giving the insert point in tk coordinate.
    self.tempNode = tempNode.copy()

    if 0:
        g.trace('parent',parent)
        g.trace('before',before)
        g.trace('after',after)
</t>
<t tx="ekr.20051104075904.72">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
    self.failFlag = True
</t>
<t tx="ekr.20051104075904.73">def editBody (self):

    c = self.c ; u = self.u

    if not g.app.enableUnitTest: return

    # Blank stops the command name.
    commandName = self.parent.h
    i = commandName.find(' ')
    if i &gt; -1:
        commandName = commandName[:i] 
    # g.trace(commandName)

    # Compute the result in tempNode.b
    command = getattr(c,commandName)
    command()

    try:

        # Don't call the undoer if we expect no change.
        if not u.compareOutlines(self.before,self.after,compareHeadlines=False,report=False):
            assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
            c.undoer.undo()
            assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo1' % commandName
            c.undoer.redo()
            assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: after redo' % commandName
            c.undoer.undo()
            assert u.compareOutlines(self.tempNode,self.before,compareHeadlines=False),'%s: after undo2' % commandName
    except Exception:
        self.fail()
        raise
</t>
<t tx="ekr.20051104075904.74">def runTest(self):

    self.editBody()
</t>
<t tx="ekr.20051104075904.75">def setUp(self):

    c = self.c ; tempNode = self.tempNode

    if not g.app.enableUnitTest: return

    # self.undoMark = c.undoer.getMark()
    c.undoer.clearUndoState()

    # Delete all children of temp node.
    while tempNode.firstChild():
        tempNode.firstChild().doDelete()

    text = self.before.b

    tempNode.setBodyString(text)
    c.selectPosition(self.tempNode)

    w = c.frame.body.bodyCtrl
    if self.sel:
        s = str(self.sel.b) # Can't be unicode.
        lines = s.split('\n')
        w.setSelectionRange(lines[0],lines[1])

    if self.ins:
        s = str(self.ins.b) # Can't be unicode.
        lines = s.split('\n')
        g.trace(lines)
        w.setInsertPoint(lines[0])

    if not self.sel and not self.ins: # self.sel is a **tk** index.
        w.setInsertPoint(0)
        w.setSelectionRange(0,0)
</t>
<t tx="ekr.20051104075904.76">def tearDown (self):

    c = self.c ; tempNode = self.tempNode

    c.selectVnode(tempNode)

    if not self.failFlag:
        tempNode.setBodyString("")

        # Delete all children of temp node.
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()

    tempNode.clearDirty()

    # c.undoer.rollbackToMark(self.undoMark)
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20051104075904.77"></t>
<t tx="ekr.20051104075904.78">def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert parent,'node not found: %s' % (parentHeadline)
    temp = u.findNodeInTree(parent,"tempNode")
    assert temp,'node not found: tempNode'

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children():
        if p != temp:
            # 2009/10/02: avoid copy arg to iter
            p2 = p.copy()
            dialog = u.findNodeInTree(p2,"dialog")
            assert(dialog)
            test = importExportTestCase(c,p2,dialog,temp,doImport)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20051104075904.79">class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
</t>
<t tx="ekr.20051104075904.8">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p.copy()) # 2010/02/03
</t>
<t tx="ekr.20051104075904.80">def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.p
</t>
<t tx="ekr.20051104075904.81">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20051104075904.82">def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.h
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
</t>
<t tx="ekr.20051104075904.83">def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
</t>
<t tx="ekr.20051104075904.84">def setUp(self):

    c = self.c ; temp_p = self.temp_p ; d = self.dialog

    temp_p.setBodyString('')

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import test: " + self.p.h)
    c.selectPosition(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
</t>
<t tx="ekr.20051104075904.85">def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.h,self.fileName)
    except Exception:
        return "ImportExportTestCase"
</t>
<t tx="ekr.20051104075904.86">def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("")
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
</t>
<t tx="ekr.20051104075904.9">def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
</t>
<t tx="ekr.20051104075904.90"></t>
<t tx="ekr.20051104075904.91">def getAllPluginFilenames ():

    path = g.os_path_join(g.app.loadDir,"..","plugins")

    files = glob.glob(g.os_path_join(path,"*.py"))
    files = [g.os_path_finalize(f) for f in files]
    files.sort()
    return files
</t>
<t tx="ekr.20051104075904.92">def oldTestPlugin (fileName,verbose=False):

    path = g.os.path_finalize_join(g.app.loadDir,"..","plugins")

    module = g.importFromPath(fileName,path)
    assert module, "Can not import %s" % path

    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        if verbose:
            g.trace("Executing unitTest in plugins/%s..." % fileName)

        module.unitTest(verbose=verbose)
</t>
<t tx="ekr.20051104075904.93">def checkFileSyntax (fileName,s,reraise=True,suppress=False):

    '''Called by a unit test to check the syntax of a file.'''

    try:
        if not g.isPython3:
            s = g.toEncodedString(s)
        s = s.replace('\r','')
        compile(s+'\n',fileName,'exec')
        return True
    except SyntaxError:
        if not suppress:
            g.es("syntax error in:",fileName,color="blue")
            g.es_exception(full=True,color="black")
        if reraise: raise
        return False
    except Exception:
        if not suppress:
            g.es("unexpected error in:",fileName,color="blue")
            # g.es_exception(full=False,color="black")
        if reraise: raise
        return False
</t>
<t tx="ekr.20051104075904.94">def checkFileTabs (fileName,s):

    try:
        readline = g.readLinesClass(s).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError(msg):
        g.es_print("Token error in",fileName,color="blue")
        g.es_print('',msg)
        assert 0, "test failed"

    except tabnanny.NannyNag(nag):
        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()
        g.es_print("Indentation error in",fileName,"line",badline,color="blue")
        g.es_print('',message)
        g.es_print("offending line...")
        g.es_print('',line)
        assert 0, "test failed"

    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        assert 0, "test failed"
</t>
<t tx="ekr.20051104075904.95">def throwAssertionError():

    assert 0, 'assert(0) as a test of catching assertions'
</t>
<t tx="ekr.20051104075904.96"></t>
<t tx="ekr.20051104075904.97"># Some of these will fail now for Python 2.x.
def factorial(n):
    """Return the factorial of n, an exact integer &gt;= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    &gt;&gt;&gt; [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    &gt;&gt;&gt; factorial(30)
    265252859812191058636308480000000
    &gt;&gt;&gt; factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0

    Factorials of floats are OK, but the float must be an exact integer:
    &gt;&gt;&gt; factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    &gt;&gt;&gt; factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    &gt;&gt;&gt; factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """

    import math
    if not n &gt;= 0:
        raise ValueError("n must be &gt;= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n+1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor &lt;= n:
        try:
            result *= factor
        except OverflowError:
            result *= long(factor)
        factor += 1
    return result
</t>
<t tx="ekr.20051104075904.98"></t>
<t tx="ekr.20051104075904.99">def createUnitTestsFromDoctests (modules,verbose=True):

    created = False # True if suite is non-empty.

    suite = unittest.makeSuite(unittest.TestCase)

    for module in list(modules):
        # New in Python 4.2: n may be zero.
        try:
            test = doctest.DocTestSuite(module)
            n = test.countTestCases()
            if n &gt; 0:
                suite.addTest(test)
                created = True
                if verbose:
                    g.pr("found %2d doctests for %s" % (n,module.__name__))
        except ValueError:
            g.pr('no doctests in %s' % module.__name__)
            pass # No tests found.

    return g.choose(created,suite,None)
</t>
<t tx="ekr.20051106040126">def executeMinibufferCommand (self,commandName):

    c = self ; k = c.k

    func = c.commandsDict.get(commandName)

    if func:
        event = g.Bunch(c=c,char='',keysym=None,widget=c.frame.body.bodyCtrl)
        stroke = None
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no such command: %s' % (commandName),color='red')
        return None
</t>
<t tx="ekr.20051110155735.1">@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
</t>
<t tx="ekr.20051113110735">oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
</t>
<t tx="ekr.20051113110851">q = self.p.clone()
q.moveToLastChildOf(found)
</t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = True
    w = self.editWidget(event)
    if not w: return 'break'
    &lt;&lt; set local vars &gt;&gt;
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
</t>
<t tx="ekr.20051129084430">@nocolor

- Download jython_Release_2_2alpha1.jar and put it anywhere (say on the desktop)

- Double-click the file.  This brings up an installer.  Follow the direction.
  (I installed to c:\jython-2.2a1

- Using the Control Panel, System, Advanced tab, environment variables,
  add c:\jython-2.2a1\jython.jar to CLASSPATH (in user variables)
</t>
<t tx="ekr.20051129084430.1"></t>
<t tx="ekr.20051203084725">- Put whatever.jar in c:\prog
- cd: c:\prog
- jar xvf whatever.jar
</t>
<t tx="ekr.20051203084725.1">Install:

Put JythonShellEA.jar in c:\prog\JythonShell

(optional) Expand the jar so you can see the code:

jar xvf JythonShellEA.jar

Run:

Here is the contents of jythonShell.bat:

cd c:\prog\jythonShell
java -cp c:\jython-2.2a1\jython.jar;c:\prog\jythonShell\JythonShellEA2.1.jar org.leo.shell.JythonShell
</t>
<t tx="ekr.20051206103652">def widget_name (self,w):

    # First try the widget's getName method.
    if not 'w':
        return '&lt;no widget&gt;'
    elif hasattr(w,'getName'):
        return w.getName()
    elif hasattr(w,'_name'):
        return w._name
    else:
        return repr(w)
</t>
<t tx="ekr.20051207130144">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3460955
By: nobody

I found this link:
http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
TkinterDnD

so if Edward is interested in adding drag and drop support for regular leo,
this might be a path to do so.  It looks like an active project.

leouser
</t>
<t tx="ekr.20051207130144.1"></t>
<t tx="ekr.20051213080533">def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'left',extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    self.moveToCharacterHelper(event,'left',extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'right',extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    self.moveToCharacterHelper(event,'right',extend=True)
</t>
<t tx="ekr.20051213094517">def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i &gt;= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j &gt;= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j &lt; i and s[j].isspace():
        j += 1

    if j &lt; i:
        self.moveToHelper(event,j,extend)
</t>
<t tx="ekr.20051214132256"></t>
<t tx="ekr.20051214133130">def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20051214133130.1"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20051215102349"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.p
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.b
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch=ch
        b.name=name
        b.oldSel=oldSel
        b.oldText=oldText
        b.w=w
        b.undoType=undoType
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20051215103053">def beginCommand (self,undoType='Typing'):

    w = baseEditCommandsClass.beginCommand(self,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4


def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    w = baseEditCommandsClass.beginCommandWithEvent(self,event,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4
</t>
<t tx="ekr.20051215121416">def computeData (self):

    self.nameList = []
    self.names = {} ; self.tnodes = {}

    for p in self.c.all_unique_positions():
        h = p.h.strip()
        v = p.v
        nameList = self.names.get(h,[])
        if nameList:
            if p.parent():
                key = '%s, parent: %s' % (h,p.parent().h)
            else:
                key = '%s, child index: %d' % (h,p.childIndex())
        else:
            key = h
        self.nameList.append(key)
        self.tnodes[key] = v
        nameList.append(key)
        self.names[h] = nameList
</t>
<t tx="ekr.20051215164823">def findBuffer (self,name):

    v = self.tnodes.get(name)

    for p in self.c.all_unique_positions():
        if p.v == v:
            return p

    g.trace("Can't happen",name)
    return None
</t>
<t tx="ekr.20051216151811">def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
</t>
<t tx="ekr.20051218121447">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20051218122116">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot &lt; i: spot = i
        elif spot &gt; j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
</t>
<t tx="ekr.20051218133207">def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20051218133207.1">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20051218141237">def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20051218170358"></t>
<t tx="ekr.20051218171457">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return

    self.moveToHelper(event,i2+1,extend)
</t>
<t tx="ekr.20051218174113">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    if not g.unitTesting:
        g.es('extend mode',g.choose(val,'on','off'),color='red')
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20060102103625">def createModeCommand (self,modeName,name,modeDict):

    modeName = 'enter-' + modeName.replace(' ','-')

    i = name.find('::')
    if i &gt; -1:
        # The prompt is everything after the '::'
        prompt = name[i+2:].strip()
        modeDict ['*command-prompt*'] = prompt
        # g.trace('modeName',modeName,'*command-prompt*',prompt)

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [modeName] = modeDict
</t>
<t tx="ekr.20060102103625.1">def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''

    c = self.c ; k = c.k ; name1 = name

    # g.trace('%20s' % (name),c.fileName())
    modeName = self.computeModeName(name)

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,name1,d)
</t>
<t tx="ekr.20060106114716.1">def __init__ (self,c):

    self.c = c
</t>
<t tx="ekr.20060109164136">def setLog (self):

    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass
</t>
<t tx="ekr.20060111112513.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3516227
By: nobody

Some highlights:
* simpler startup:
jyleo leo.py
should be sufficient to start it up.
* new editor colorization
* the JythonShell is much more powerful and cooler
* new plugins
* Chapters support
* mod_script is in place.
* dyna-menu was converted.  I guess 'e' will have to judge the conversion.
* multi-language script support.
* drag and drop
* some powerful new editor commands.  Try keyword completing on the language
in effect.  Say if it is python:
se(Tab)
becomes
self

Some warnings:
1. Be careful about reading your regular leo files into jyleo and saving them.
Its quite conceivable that jyleo will write it out to an XML format that regular
leo can't handle.  Why?  Well jyleo is using an XML library to spit its XML
out while leo uses a home grown method.  The library can handle leo's XML, but
Ive seen regular leo not be able to handle jyleo's XML.  Its based around &lt;tag/&gt;
I believe.

2. If you move jyleo after executing it you will need to clear out your compiled
py files as the __file__ attribute is hard compiled into the resulting objects.
Not what we want.  We want it to be set at runtime.  Ive been waiting a long
time for jython to release again and hopefully fix this, but Im not holding
my breath anymore.

----------
Its hard to give this thing a number, I want to call it jyleo2, but jyleo is
sufficient.  Dependent upon bug reports the next release could be much sooner
than before, maybe even weeks.  I hope one thing, that the dreaded "I can't
get it to start" problems are gone.  I took the snapshot and expanded it in
Windows XP.  Went to the src directory and typed: jython leo.py
and it started.  That's what I wanted to see.  I didn't have to mess with the
CLASSPATH or anything.

things needed:
java 5
a jython2.2a1 or beyond.  jython2.2a1 is the most recent snapshot.

Beyond bug fixing, I will be planning to add more SwingMacs command as time
goes along.  But I think most major features are in place.  Of course the 3D
experiments in the future could change that... :D

A NOTE ON STARTUP TIMES: In my experience it takes awhile for jyleo to start.
It will take much longer the first time you execute it because the py files
are being compiled.  Ive haven't been able to figure out what eats the time,
it may just have a slow startup in the aggregate.  So don't think its not doing
anything, it probably is.

leouser
</t>
<t tx="ekr.20060113082917">def scrollHelper (self,event,direction,distance):

    '''Scroll the present pane up or down one page
    kind is in ('up/down-half-page/line/page)'''

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)

    if not w: return

    if hasattr(w,'scrollDelegate'):
        kind = direction + '-' + distance
        w.scrollDelegate(kind)
    else:
        self.tkScrollHelper(event,direction,distance)

def tkScrollHelper (self,event,direction,distance,extend=None):
    #Scroll body pane up/down (direction) by page/half-page/line (distance)
    #Note: Currently moves cursor, scrolls if needed to keep cursor visible
    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        # assume scroll by "page"
        delta = self.measure(w)
        if distance == 'half-page':
            delta = delta / 2
        elif distance == 'line':
            delta = 1
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
</t>
<t tx="ekr.20060113105246.1">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
</t>
<t tx="ekr.20060113130510">def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 &lt; len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
</t>
<t tx="ekr.20060116074839.2">def extendToWord (self,event,direction='forward'):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if direction == 'forward':
        while i &lt; n and not g.isWordChar(s[i]):
            i += 1
    else:
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1

    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i -= 1
    i += 1
    i1 = i

    # Move to the end of the word.
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)


</t>
<t tx="ekr.20060116083043.1"></t>
<t tx="ekr.20060116090428"></t>
<t tx="ekr.20060117094955.1">def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        # '-',
        # 'expand-abbrev', # Not a command
        # '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20060117095212">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20060117095212.1">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20060117095212.2">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20060117095212.7">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20060117114315">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        # '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-kbd-macro',
        # '&amp;insert-kbd-macro',
    ]
</t>
<t tx="ekr.20060123065756.1"></t>
<t tx="ekr.20060123091352"></t>
<t tx="ekr.20060123115459">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')
def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')
def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()
def toggleFindCollapesNodes(self,event):
    '''Toggle the 'Collapse Nodes' checkbox in the find tab.'''
    c = self.c
    c.sparse_find = not c.sparse_find
    if not g.unitTesting:
        g.es('sparse_find',c.sparse_find)
def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')
def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')
def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')
def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')
def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')
def setFindScope (self, where):
    self.getHandler().setFindScope(where)
def toggleOption (self, ivar):
    self.getHandler().toggleOption(ivar)
</t>
<t tx="ekr.20060123125256">class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
</t>
<t tx="ekr.20060123125317.2">def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    # g.trace('replaceStringShortcut',s)
    self.replaceStringShortcut = s
</t>
<t tx="ekr.20060123131421"></t>
<t tx="ekr.20060123151617">'''Leo's gui-independent find classes.'''

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import re

&lt;&lt; Theory of operation of find/change &gt;&gt;

@others
</t>
<t tx="ekr.20060124085830">def clearTab        (self,tabName,wrap='none'):             pass
def createCanvas    (self,tabName):                         pass
def createTab (self,tabName,createText=True,widget=None,wrap='none'):   pass
def deleteTab       (self,tabName,force=False):             pass
def getSelectedTab  (self):                                 return None
def lowerTab        (self,tabName):                         pass
def raiseTab        (self,tabName):                         pass
def renameTab (self,oldName,newName):                       pass
def selectTab (self,tabName,createText=True,wrap='none'):   pass
def setTabBindings  (self,tabName):                         pass
</t>
<t tx="ekr.20060124093828">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20060124115801">def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
</t>
<t tx="ekr.20060124122844"># This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
</t>
<t tx="ekr.20060124123133">def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
</t>
<t tx="ekr.20060124134356">def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.p
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
</t>
<t tx="ekr.20060124140114"></t>
<t tx="ekr.20060124140224.1">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060124140224.2">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060124140224.3">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060124181213.4">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20060125074939">def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
</t>
<t tx="ekr.20060125091234">def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    # g.trace(pattern,g.callers(4))

    s = g.toUnicode(pattern)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20060125093807">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060127052111.1">def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n &gt; 0 and u.bead &gt;= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i &gt;= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
</t>
<t tx="ekr.20060127070008">def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        g.pr('-' * 40)
        for key in sorted(bunch):
            g.trace(key,bunch.get(key))
        g.pr('-' * 20)

    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()): 
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
</t>
<t tx="ekr.20060127113243">def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead &gt;= 0 and u.bead &lt; len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads),g.callers())

        # Recalculate the menu labels.
        u.setUndoTypes()
</t>
<t tx="ekr.20060127162818">no_gc_message = False

def enable_gc_debug(event=None):

    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
        # else:
            # gc.set_debug(gc.DEBUG_STATS)
    elif not g.no_gc_message:
        g.no_gc_message = True
        g.es('can not import gc module',color='blue')
</t>
<t tx="ekr.20060127162818.1">class debugCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20060127162921">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20060127163325">def getPublicCommands (self):

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'pdb':                          self.pdb,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
</t>
<t tx="ekr.20060127163325.1">def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
</t>
<t tx="ekr.20060127164729.1">def printGcObjects(tag=''):

    '''Print newly allocated objects.'''

    tag = tag or g._callerName(n=2)
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        if delta == 0: return
        lastObjectCount = n2

        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except Exception:
        traceback.print_exc()

printNewObjects = pno = printGcObjects

</t>
<t tx="ekr.20060127165509"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):

    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if id(o) not in lastObjectsDict]
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    dicts = 0 ; seqs = 0

    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            #g.pr(id(o),repr(o))
            seqs += 1
        #else:
        #    g.pr(o)
        i += 1
    g.pr('=' * 40)
    g.pr('dicts: %d, sequences: %d' % (dicts,seqs))
    g.pr("%s: %d new, %d total objects" % (tag,len(newObjects),len(objects)))
    g.pr('-' * 40)
</t>
<t tx="ekr.20060128075225">def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060128080201">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
</t>
<t tx="ekr.20060201161901.2">@nocolor

By: Edward K. Ream - edream RE: Dividing The Undo: doing w/o v.uA 2005-09-09
   14:17 &gt; If we can open up how [Leo] reads xml, it may make it simpler to
   start developing a stash scheme.

I agree that reading xml more properly would be A Good Thing (tm). As we shall
see, however, it is not the main issue.

&gt; DOM seems like a good path to start out on.

This is not the path I would have chosen. The new colorizer at in leoPlugins.leo
at:

Plugins--&gt;Experimental/unfinished--&gt;New colorizer--&gt;@thin __jEdit_colorizer__.py

uses sax. I like the light-weight approach. I would rather do a bit more work in
the initial parsing and create the data structures myself then relying on DOM.

But parsing is irrelevant. The problem is the design of *thin* derived files and
the code that reads such files. Let us consider how we can "do without"
v.unknownAttributes in thin derived files. I **shall not** change the format of
thin derived files, so some trickery is required. The first step is read this
section of Leo's new docs:

http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attributes-to-nodes-and-leo-files
/&gt; The key here is the so-called 'hidden machinery'. This is an essential
feature of the code that reads and writes thin derived files and it **will not**
change. **Note**: Leo has two sets of read code: the code that reads .leo files
has no trouble whatever recreating vnodes. It is only vnodes in thin derived
files that may not have attributes.

**Important**: for @thin trees (in the outline) Leo saves *only* the &lt;v&gt; element
corresponding to the @thin node itself. It is this &lt;v&gt; element that contains the
'hidden machinery'. Don't even think about having Leo write the whole tree of
&lt;v&gt; elements: the 4.0 read code is made possible because these &lt;v&gt; elements do
*not* exist. This eliminates all the error 'recovery' schemes that can not, if
fact, be robust enough.

So the only real alternative is to add uA's sufficient to recreate elements in
the *reconstituted* vnodes that Leo creates in the leoAtFile read logic.
Happily, we can do this as follows. When writing, a plugin (or an extended Leo)
would 'piggyback' the vnode attributes in the corresponding
**t**.unknownAttributes field. When reading, the plugin (or Leo) would put the
vnode attributes "where they belong" in the appropriate vnode. We associate a
'vnode traversal index' with each vnode. This is simply how many previous "same"
vnodes appeared in the traversal before getting to the desired vnode. Something
like this::

vx = {} # traversal indices for vnodes. for p in c.all_positions(): ....n =
vx.get(p.v.t,0) # n is the traversal index for vnode p.v. ....vx[p.v.t] = n+1 #
bump the index for the next v such that v.t == p.v.t

We store attributes for vnode v in v.t.unknownAttributes, along with the
traversal index. The read code uses the traversal index to copy vnode attributes
from t.unknownAttributes to v.unknownAttrutes. Rather than forcing each plugin
to do this, Leo should probably have support for this in the leoFileCommands
read/write code. In short, the t.unknownAttributes machinery suffices in theory,
and in practice a bit of support code would be good.

Glad you asked :-) . I have been willing to live without v.uA's in thin derived
files. I never thought much about this until you asked, but necessity is the
mother... So this is good. A way exists to treat all vnodes as first-class
citizens.

Edward
</t>
<t tx="ekr.20060202133313">def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
</t>
<t tx="ekr.20060202154734">def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw()
</t>
<t tx="ekr.20060202160523">def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
</t>
<t tx="ekr.20060202161935">def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    if not g.unitTesting:
        g.pr('-' * 30)
        g.pr('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except Exception: pass
        # if type(obj) == type(()):
            # g.pr(id(obj),repr(obj))
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = list(d.items())
        items.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        if not g.unitTesting:
            for z in items:
                g.pr('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        for t in sorted(d):
            g.pr('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20060203072636">def endSearch (self):

    c,k = self.c,self.k

    k.clearState()
    k.resetLabel()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20060204120158">def findAgain (self,event):

    f = self.finder

    f.p = self.c.p
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
</t>
<t tx="ekr.20060204120158.1">def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20060204120158.2">def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
</t>
<t tx="ekr.20060205043324.1">def printGcSummary (tag=''):

    tag = tag or g._callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = '%s: printGCSummary: garbage: %d, objects: %d' % (tag,n,n2)
        g.pr(s)
    except Exception:
        traceback.print_exc()
</t>
<t tx="ekr.20060205043324.3">def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
</t>
<t tx="ekr.20060205050659">def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
</t>
<t tx="ekr.20060205105950">def setupChangePattern (self,pattern):

    # g.trace('pattern',g.callers(4))

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20060205105950.1">def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    # Bug fix: 2007-12-14: remove call to self.finder.findNextCommand.
    # This was the cause of replaces not starting in the right place!

    if changeAll:
        self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20060205164707">class helpCommandsClass (baseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
</t>
<t tx="ekr.20060205165501">def getPublicCommands (self):

    return {
        'help-for-minibuffer':      self.helpForMinibuffer,
        'help-for-command':         self.helpForCommand,
        'apropos-autocompletion':   self.aproposAutocompletion,
        'apropos-bindings':         self.aproposBindings,
        'apropos-debugging-commands': self.aproposDebuggingCommands,
        'apropos-find-commands':    self.aproposFindCommands,
        'print-settings':           self.printSettings,
        'python-help':              self.pythonHelp,
    }
</t>
<t tx="ekr.20060205170335"># @pagewidth 40

def aproposBindings (self,event=None):

    '''Prints a discussion of keyboard bindings.'''

    c = self.c
    s = '''

A shortcut specification has the form:

command-name = shortcutSpecifier

or

command-name ! pane = shortcutSpecifier

The first form creates a binding for all
panes except the minibuffer. The second
form creates a binding for one or more
panes. The possible values for 'pane'
are:

pane    bound panes
----    -----------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree

You may use None as the specifier.
Otherwise, a shortcut specifier consists
of a head followed by a tail. The head
may be empty, or may be a concatenation
of the following: (All entries in each
row are equivalent).

Shift+ Shift-
Alt+ or Alt-
Control+, Control-, Ctrl+ or Ctrl-

Notes:

1. The case of plain letters is significant:
   a is not A.

2. The Shift- (or Shift+) prefix can be
   applied *only* to letters or
   multi-letter tails. Leo will ignore
   (with a warning) the shift prefix
   applied to other single letters,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by
   Ctrl-, Alt-, Key- or Shift- is *not*
   significant.

The following table illustrates these
rules. In each row, the first entry is
the key (for k.bindingsDict) and the
other entries are equivalents that the
user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.

    if not g.app.unitTesting:
        g.es('',s)
</t>
<t tx="ekr.20060205170335.1">def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    &lt;&lt; define s &gt;&gt;

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es('',s)
</t>
<t tx="ekr.20060206093313"># For compatibility with old scripts.
# Using the commander methods directly is recommended.

def getFocus(self):
    return g.app.gui.get_focus(self.c) # Used by wxGui plugin.

def bodyWantsFocus(self):
    return self.c.bodyWantsFocus()

def logWantsFocus(self):
    return self.c.logWantsFocus()

def minibufferWantsFocus(self):
    return self.c.minibufferWantsFocus()
</t>
<t tx="ekr.20060207133601">@all
</t>
<t tx="ekr.20060208112908"></t>
<t tx="ekr.20060208112908.1">The Tortoise cvs params:

:ext:edream@cvs.sourceforge.net:/cvsroot/leo

That is...

Protocol: pserver
Server: cvs.sourceforge.net
Repository folder: /cvsroot/leo
User name: your cvs name

### :pserver:anonymous@cvs.sourceforge.net:/cvsroot/leo
</t>
<t tx="ekr.20060209064140">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
</t>
<t tx="ekr.20060209064832">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
</t>
<t tx="ekr.20060209082023.1">@pagewidth 40

s = '''
Note: all bindings shown are the default
bindings for these commands. You may
change any of these bindings using
@shortcuts nodes in leoSettings.leo.

=== Settings

leoSettings.leo now contains several
settings related to the Find tab:

@bool show_only_find_tab_options = True

  When True (recommended), the Find tab
  does not show the 'Find', 'Change',
  'Change, Then Find', 'Find All' and
  'Change All' buttons.

@bool minibufferSearchesShowFindTab = True

  When True, Leo shows the Find tab when
  executing most of the commands
  discussed below.

=== Basic find commands

open-find-tab

  Makes the Find tab visible. The Find
  tab does **not** need to be visible to
  execute any search command discussed
  below.

hide-find-tab

  Hides the Find tab, but retains all
  the present settings.

search-with-present-options (Ctrl-F)

  Prompts for a search string. Typing
  the &lt;Return&gt; key puts the search
  string in the Find tab and executes a
  search based on all the settings in
  the Find tab. This is a recommended
  default search command.

show-search-options

  Shows the present search options in
  the status line. This command also
  makes the Find tab visible.

find-next (F3)

  Like search-with-present-options,
  except that it uses the search string
  in the find-tab. Recommended as the
  default 'search again' command.

find-previous (F2)

  Repeats the command specified by the
  Find tab, but in reverse.

find-again

  Like find-next if a search pattern is
  not '&lt;find pattern here&gt;'. Otherwise,
  like search-with-present-options.

=== Setting find options

Several minibuffer commands toggle the
checkboxes and radio buttons in the Find
tab, and thus affect the operation of
the search-with-present-options command.
You may bind these commands to keys or
toggle these options in a mode.

These commands toggle checkboxes:

toggle-find-ignore-case-option
toggle-find-in-body-option
toggle-find-in-headline-option
toggle-find-mark-changes-option
toggle-find-mark-finds-option
toggle-find-regex-option
toggle-find-reverse-option
toggle-find-word-option
toggle-find-wrap-around-option

These commands set radio buttons:

set-find-everywhere,
set-find-node-only, and
set-find-suboutline-only.

enter-find-options-mode (Ctrl-Shift-F)

enters a mode in which you may change
all checkboxes and radio buttons in the
Find tab with plain keys. As always, you
can use the mode-help (Tab) command to
see a list of key bindings in effect for
the mode.

=== Search commands with side effects

The following commands set an option in
the Find tab, then work exactly like the
search-with-present-options command.

- search-backward and search-forward set
  the 'Whole Word' checkbox to False.

- word-search-backward and
  word-search-forward set the 'Whole
  Word' checkbox to True.

- re-search-forward and re-search-backward
  set the 'Regexp' checkbox to True.

=== Find all commands

find-all

  Prints all matches in the log pane.

clone-find-all

  Replaces the previous 'Clone Find'
  checkbox. It prints all matches in the
  log pane, and creates a node at the
  beginning of the outline containing
  clones of all nodes containing the
  'find' string. Only one clone is made
  of each node, regardless of how many
  clones the node has, or of how many
  matches are found in each node.

Note: the radio buttons in the Find tab
(Entire Outline, Suboutline Only and
Node only) control how much of the
outline is affected by the find-all and
clone-find-all commands.

=== Search and replace commands

replace-string

  Prompts for a search string. Type
  &lt;Return&gt; to end the search string. The
  command will then prompt for the
  replacement string. Typing a second
  &lt;Return&gt; key will place both strings
  in the Find tab and executes a
  **find** command, that is,
  search-with-present-options.

So the only difference between
replace-string and
search-with-present-options is that
replace-string has the side effect of
setting 'change' string in the Find tab.
However, this is an extremely useful
side effect, because of the following
commands...

change (Ctrl-=)

  Replaces the selected text with the
  'change' text in the Find tab.

change-then-find (Ctrl--)

  Replaces the selected text with the
  'change' text in the Find tab, then
  executes the find command again.

find-next, change and change-then-find
can simulate any kind of query-replace
command.

change-all

  Changes all occurrences of the 'find'
  text with the 'change' text.
  Important: the radio buttons in the
  Find tab (Entire Outline, Suboutline
  Only and Node only) control how much
  of the outline is affected by this
  command.

=== Incremental search commands

Here are Leo's incremental find commands:

isearch-backward (Alt-R)
isearch-backward-regexp
isearch-forward (Alt-S)
isearch-forward-regexp

You may use backspace to backtrack. To
repeat an incremental search, type the
shortcut for that command again.'''
</t>
<t tx="ekr.20060209095101">def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.p

    i,row,col = w.toPythonIndexRowCol(spot)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v

    # g.trace('moveSpot',i)
</t>
<t tx="ekr.20060210100432"># Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus:',c.widget_name(c.get_focus()))
</t>
<t tx="ekr.20060210164421">def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060210173041">def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
</t>
<t tx="ekr.20060210174441">def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
</t>
<t tx="ekr.20060210180352">def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060211055455"># These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):
    '''Simulate a click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):
    '''Simulate a double-click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxRightClick(event,p=p)
</t>
<t tx="ekr.20060211062025"># Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected node.'''

    c = self.c ; p = c.p
    c.frame.tree.onClickBoxClick(event,p=p)
</t>
<t tx="ekr.20060211063744.1"># These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):
    '''Simulate a click in the headline of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onHeadlineClick(event,p=p)

def doubleClickHeadline (self,event=None):
    '''Simulate a double click in headline of the presently selected node.'''
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):
    '''Simulate a right click in the headline of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onHeadlineRightClick(event,p=p)
</t>
<t tx="ekr.20060211063744.2"># These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected node.'''
    c = self.c

    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
</t>
<t tx="ekr.20060211100905">def activateCmdsMenu    (self,event=None):
    '''Activate Leo's Cmnds menu.'''
    self.activateMenu('Cmds')

def activateEditMenu    (self,event=None):
    '''Activate Leo's Edit menu.'''
    self.activateMenu('Edit')

def activateFileMenu    (self,event=None):
    '''Activate Leo's File menu.'''
    self.activateMenu('File')

def activateHelpMenu    (self,event=None):
    '''Activate Leo's Help menu.'''
    self.activateMenu('Help')

def activateOutlineMenu (self,event=None):
    '''Activate Leo's Outline menu.'''
    self.activateMenu('Outline')

def activatePluginsMenu (self,event=None):
    '''Activate Leo's Plugins menu.'''
    self.activateMenu('Plugins')

def activateWindowMenu  (self,event=None):
    '''Activate Leo's Window menu.'''
    self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
</t>
<t tx="ekr.20060211140947.1">try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("setting leoID from os.getenv('USER'):",
                repr(theId),color='blue')
        g.app.leoID = theId
        # Careful: periods in the id field of a gnx
        # will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
</t>
<t tx="ekr.20060212125650">def createBalloon (tab,sv):

    'Create a balloon for a widget.' ''

    balloon = Pmw.Balloon(tab,initwait=100)
    balloon.bind(tab,'')
    hull = balloon.component('hull')
    def blockExpose (event):
        if sv.get() == '':
             hull.withdraw()
    hull.bind('&lt;Expose&gt;',blockExpose,'+')
    balloon._label.configure(textvariable=sv)
</t>
<t tx="ekr.20060213151918"></t>
<t tx="ekr.20060216110502">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20060217111834"></t>
<t tx="ekr.20060221074900"></t>
<t tx="ekr.20060221074900.1">def findButtonCallback(self,event=None):

    self.findButton()
    return 'break'
</t>
<t tx="ekr.20060221081328">def maxStringListLength(aList):

    '''Return the maximum string length in a list of strings.'''

    n = 0
    for z in aList:
        if g.isString():
            n = max(n,len(z))

    return n
</t>
<t tx="ekr.20060221083356">def prettyPrintType (obj):

    if g.isPython3:
        if type(obj) in (types.MethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif g.isString(obj):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("&lt;type '"): theType = theType[7:]
            if theType.endswith("'&gt;"): theType = theType[:-2]
            return theType
    else:
        if type(obj) in (
            types.MethodType,types.UnboundMethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif type(obj) == types.InstanceType:
            return 'object'
        elif type(obj) in (types.UnicodeType,types.StringType):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("&lt;type '"): theType = theType[7:]
            if theType.endswith("'&gt;"): theType = theType[:-2]
            return theType
</t>
<t tx="ekr.20060224171851">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20060226131603.1"># @pagewidth 40

def aproposAutocompletion (self,event=None):

    '''Prints a discussion of autocompletion.'''

    c = self.c ; s = '''

This documentation describes both
autocompletion and calltips.

Typing a period when @language python is
in effect starts autocompletion. Typing
'(' during autocompletion shows the
calltip. Typing Return or Control-g
(keyboard-quit) exits autocompletion or
calltips.

=== Autocompletion

Autocompletion shows what may follow a
period in code. For example, after
typing g. Leo will show a list of all
the global functions in leoGlobals.py.
Autocompletion works much like tab
completion in the minibuffer. Unlike the
minibuffer, the presently selected
completion appears directly in the body
pane.

A leading period brings up 'Autocomplete
Modules'. (The period goes away.) You
can also get any module by typing its
name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only
the valid starting characters. At this
point, typing an exclamation mark shows
the complete list. Thereafter, typing
further exclamation marks toggles
between full and abbreviated modes.

If x is a list 'x.!' shows all its
elements, and if x is a Python
dictionary, 'x.!' shows list(x.keys()).
For example, 'sys.modules.!' Again,
further exclamation marks toggles
between full and abbreviated modes.

During autocompletion, typing a question
mark shows the docstring for the object.
For example: 'g.app?' shows the
docstring for g.app. This doesn't work
(yet) directly for Python globals, but
'__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring
for pow.

Autocompletion works in the Find tab;
you can use &lt;Tab&gt; to cycle through the
choices. The 'Completion' tab appears
while you are doing this; the Find tab
reappears once the completion is
finished.

=== Calltips

Calltips appear after you type an open
parenthesis in code. Calltips shows the
expected arguments to a function or
method. Calltips work for any Python
function or method, including Python's
global function. Examples:

a) g.toUnicode(
   gives:
   g.toUnicode(s,encoding, reportErrors=False

b) c.widgetWantsFocusNow
   gives:
   c.widgetWantsFocusNow(w

c) reduce(
   gives:
   reduce(function, sequence[,initial]) -&gt; value

The calltips appear directly in the text
and the argument list is highlighted so
you can just type to replace it. The
calltips appear also in the status line
for reference after you have started to
replace the args.

Options

Both autocompletion and calltips are
initially enabled or disabled by the
enable_autocompleter_initially and
enable_calltips_initially settings in
leoSettings.leo. You may enable or
disable these features at any time with
these commands: enable-autocompleter,
enable-calltips, disable-autocompleter
and disable-calltips. '''

    if not g.app.unitTesting:
        # Remove indentation from indentation of this function.
        s = g.adjustTripleString(s,c.tab_width)
        g.es('',s)
</t>
<t tx="ekr.20060227123536">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
</t>
<t tx="ekr.20060227124411">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3583737
By: Offray

I was previously thinking in the relation between Leo and Wikis, and I think
that may be a thing that would help to make Leo more visible in Wiki space could
be if Leo can export/import to/from a Wiki (something limilar to th @file or
@url directives). Let me explain a little better the scenary where this idea
come.

We have a local wiki for colombian Free Software Community related issues, and
I have used Leo for writing the migration scripts from Mediawiki to MoinMoin
(wich I think is more flexible and extensible that the popular wiki behind
wikipedia). I was probing also the idea of a Wiki like environment for solving
colaborative problems, so I was posting the scripts I made on Leo in a Wiki
page, and republishing them in the moment they changed. This keeps me pasting
all the time the script and in some moments I was thinking what about if someone
make a change in the Wiki page. Would be nice then to have the same capability
to detect and sincronize that change as Leo make with the hard disk files.

But this doesnt end here. Another Wiki-Leo interaction is to use outlines as
a way to organice Wiki content. For example "= Title =" in a Wiki would be a
Outline Node in Leo and "== Subtitle ==" Would become a outline subnode all
arranged in the proper hierarchy.

Somekind of Wisiwyg display would be nice, but this must be a plugin or something
like that, so Leo could become a "Layered" front end to some kind of data.

About and article on Wikipedia. That would be nice, but I'm a little tired of
fighting with some wikipedians ignorance on certain matters combined with power
(a pretty bad combination). I think that a Wiki page is nice because its live
comes from the community knowledge, but I'm not interested in that fighting,
so I have made a Leo wiki page in our local Wiki:

http://www.el-directorio.org:8080/Leo

and when I have enough knowledge about Leo (and time) I hope to start making
contribs in the spanish documentation (for the moment I'm only workind in the
evangelism here).
</t>
<t tx="ekr.20060227131611">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3593116
By: ktenney

This work may or may not be related to a couple
things which have been on my mind lately.

When I have a traceback in the log pane, I'd love
to be able to select an item and cause the file
to appear in a node.
It would be cool to have 'Next' and 'Prev' 
capability while in this mode, effortlessly 
traversing views of the source of the stack items.

Also; 
Zope3, with it's component based architecture,
has machinery which hooks components together ..
Interfaces, Adapters and ZCML, the configuration
language.

It sounds like the autocompleter code is able
to build indexes of classes and methods. It would
be cool if that capability could be extensible,
allowing building indexes of the couplings between
components.

I think this might look like some kind of automatic
hyperlinking, providing access to related code,
as defined for that application.

I really don't know if this makes sense, but
I see you moving in the direction of making Leo
capable of doing some _explaining_ of the code 
being written.

I think this holds lots of promise.

Thanks,
Kent
</t>
<t tx="ekr.20060227142119"></t>
<t tx="ekr.20060228072202"></t>
<t tx="ekr.20060306194040">@nocolor

The curse of knowledge
http://groups.google.com/group/leo-editor/browse_thread/thread/3e75787223ee9303

(Rich) I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
</t>
<t tx="ekr.20060309060654"></t>
<t tx="ekr.20060309060654.1">def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b &lt; 1.0: tree.canvas.yview_scroll(1,"unit")

def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b &lt; 1.0: tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a &gt; 0.0: tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a &gt; 0.0: tree.canvas.yview_scroll(-1,"page")
</t>
<t tx="ekr.20060328110802"># ddm 13/02/06
self.lua_keywords = [
    "and", "break", "do", "else", "elseif", "end",
    "false", "for", "function", "if", "in", "local",
    "nil", "not", "or", "repeat", "return", "then",
    "true", "until", "while",
]
</t>
<t tx="ekr.20060328121145">def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
</t>
<t tx="ekr.20060328150113">def setGlobalOpenDir (fileName):

    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory:',g.app.globalOpenDir)
</t>
<t tx="ekr.20060329083310.1">def createDialogFrame(Tk,root,title,message):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    def okButton(top=top):
        top.destroy()

    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)

    center(top)
    top.lift()
    top.focus_force()

    if not g.app.unitTesting: # Attach the icon at idle time.
        def attachIconCallback(top=top):
            g.app.gui.attachLeoIcon(top)
        top.after_idle(attachIconCallback)

    return top
</t>
<t tx="ekr.20060329083310.2">def createDialogButtons (Tk,top,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
</t>
<t tx="ekr.20060329083657">def cantImportDialog (pluginName,moduleName):

    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''

    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if g.app.killed:
        return

    if g.app.unitTesting:
        g.pr('g.importExtension: can not import %s' % moduleName)
        return

    # Requires minimal further imports.
    try:
        import Tkinter as Tk
        root = g.app.root or Tk.Tk()
        title = 'Can not import %s' % moduleName
        top = createDialogFrame(Tk,root,title,message)
        root.wait_window(top)
    except ImportError:
        g.pr('Can not import %s' % moduleName)
        g.pr('Can not import Tkinter')
        g.pr('Leo must now exit')
        g.pr(g.callers())
</t>
<t tx="ekr.20060329085417.1">def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = g.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
</t>
<t tx="ekr.20060329085612"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):

    # This is an emergency measure: this call is NOT a major Tk-dependency.
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = geom.split('+')
    w,h = dim.split('x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
</t>
<t tx="ekr.20060329102951">@nocolor

The graph world is a better solution.
</t>
<t tx="ekr.20060329102951.1">http://sourceforge.net/forum/message.php?msg_id=3598136

&gt; It appears that @ref nodes introduce a flexibility that can not be simulated (at all?) with clones.  

Now that something like @ref appears necessary, it is so much easier to see how @ref is useful :-) 

1. @ref is an explicit link (arc) that creates the links of a general graph structure explictily. 

The simplest cycle is: 

- root 
..- a 
.... - @ref b 
..- b 
.... - @ref a 

This is not possible with clones! No more mumbling about being able to represent such links in uA's! 

2. @ref allows users to compose documents from 'atomic' pieces of text properly. That is, adding a 'virtual' child to a piece of text does not add it to all other uses of that text in (possibly unrelated) documents. This vastly increases the flexibility of rst3 plugin. 

I suspect other essential uses of @ref will appear. I am sure we can declare the 'post-leo LP tool' project a great success already :-) 

Edward 
</t>
<t tx="ekr.20060329102951.2">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3650005
By: itsme213

Imho ...

There will not be any "arbitrary graph" from @ref. Instead there is a forest
of trees, and across trees, some nodes are same_as some other nodes (caused
by @ref). same_as is transitive. Quite likely the roots of all trees are same_as.
There may need to be some rules to ensure things make structural sense. Children
of a node are just that -- children of that node.

There will be a totally separate Merge node whose children will be the union
of the children of all the nodes it merges. A Merge node is, itself, the ordinary child of some
node.

Tree traversals will be tree traversals.

Hope that did not muddy the waters even more ... 
</t>
<t tx="ekr.20060331094112">To generate a SSH key using PuTTY:

Execute c:\"Program Files"\tortoiseCVS\PUTTYGEN.EXE

Select "SSH2 DSA", within the "Parameters" section.

Click on the "Generate" button. Follow the instruction to move the mouse over
the blank area of the program in order to create random data used by PUTTYGEN to
generate secure keys. Key generation will occur once PUTTYGEN has collected
sufficient random data.

Enter edream@cvs.sourceforge.net for the key comment (depends on what host the
key is for)

(Omit) Enter the desired passphrase in the "Key passphrase" and "Confirm passphrase"
fields. If the key will be used for automation of operations (i.e. as part of a
script), you may choose to omit this step from the key generation process.

Click on the "Save private key" button. Use the resulting dialog to save your
private key data for future use. You may use a filename such as
"SourceForge-Shell.ppk" or "SourceForge-CF.ppk". The .ppk extension is used for
PuTTY Private Key files.

Go to the SSH key posting page on the SourceForge.net site: http://sourceforge.net/account/

Copy your public key data from the "Public key for pasting into OpenSSH
authorized_keys2 file" section of the PuTTY Key Generator, and paste the key
data to the provided form on the SourceForge.net site. Click on the "Update"
button to complete the posting process.

Exit the PuTTY Key Generator (PUTTYGEN).

Key data sync to hosts from the SourceForge.net site occurs on regular
intervals. Your key data will be synchronized to the designated servers (either
shell and CVS, or the Compile Farm) after a short delay.
</t>
<t tx="ekr.20060410112600">def stripBrackets (s):

    '''Same as s.lstrip('&lt;').rstrip('&gt;') except it works for Python 2.2.1.'''

    if s.startswith('&lt;'):
        s = s[1:]
    if s.endswith('&gt;'):
        s = s[:-1]
    return s
</t>
<t tx="ekr.20060414085834">def clearSelectedText (self,event):

    '''Delete the selected text.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')

    w.delete(i,j)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20060415112257">def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20060416113431">def computeLeoDir ():

    loadDir = g.app.loadDir
    theDir = g.os_path_dirname(loadDir)

    # xxx remove this, we don't want to have this in sys.path
    if theDir not in sys.path:
        sys.path.append(theDir)

    return theDir
</t>
<t tx="ekr.20060417171125">def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')

def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')

def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')

def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
</t>
<t tx="ekr.20060417172056">def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():s = w.getSelectedText()
    else:               s = w.getAllText()
    if not s: return

    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = c.scanAllDirectives() ; width = d.get('tabwidth')
    if ch == '\t' and width &lt; 0: ch = ' ' * abs(width)

    self.beginCommand(undoType=undoType)

    lines = g.splitLines(s)

    if add:
        result = [ch + line for line in lines]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in lines]

    result = ''.join(result)

    # g.trace('add',add,'hasSelection',w.hasSelection(),'result',repr(result))

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,i+len(result))
    else:
        w.setAllText(result)
        w.setSelectionRange(0,len(s))

    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20060417181052">def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    c = self.c
    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            c.goToLineNumber(c).go(n=int(n))
</t>
<t tx="ekr.20060417183606">def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j &lt; len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.p
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.redraw(p)

            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20060417183606.1">def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i &gt; 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.p
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()

            c.redraw(p)

            s = w.getAllText()
            if not s.endswith('\n'):
                i = w.getInsertPoint()
                w.insert(i,'\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20060417194232"></t>
<t tx="ekr.20060417194232.1">def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' &amp; extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20060417194232.2">def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

</t>
<t tx="ekr.20060417203717">def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
</t>
<t tx="ekr.20060419123128">def openOutlineByName (self,event):

    '''Prompt for the name of a Leo outline and open it.'''

    c = self.c ; k = self.k ; fileName = ''.join(k.givenArgs)

    if fileName:
        g.openWithFileName(fileName,c)
    else:
        k.setLabelBlue('Open Leo Outline: ',protect=True)
        k.getFileName(event,handler=self.openOutlineByNameFinisher)

def openOutlineByNameFinisher (self,event):

    c = self.c ; k = self.k ; fileName = k.arg

    k.resetLabel()
    if fileName and g.os_path_exists(fileName) and not g.os_path_isdir(fileName):
        g.openWithFileName(fileName,c)
</t>
<t tx="ekr.20060519003651">def debug (self,event=None):

    '''Start an external debugger in another process to debug a script.
    The script is the presently selected text or then entire tree's script.'''

    c = self.c ; p = c.p
    python = sys.executable
    script = g.getScript(c,p)
    winpdb = self.findDebugger()
    if not winpdb: return

    #check for doctest examples
    try:
        import doctest
        parser = doctest.DocTestParser()
        examples = parser.get_examples(script)

        # if this is doctest, extract the examples as a script
        if len(examples) &gt; 0:
            script = doctest.script_from_examples(script)
    except ImportError:
        pass

    # special case; debug code may include g.es("info string").
    # insert code fragment to make this expression legal outside Leo.
    hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
    script = hide_ges + script

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    os.chdir(g.app.loadDir)
    if False and subprocess:
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    else:
        args = [sys.executable, winpdb, '-t', filename]
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20060521140213">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = c.os_path_finalize(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('debugger does not exist:',debugger,color='blue')
    else:
        g.es('no debugger found.')
        return None
</t>
<t tx="ekr.20060526081931">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    trace = self.trace

    if swapij and backwards: i,j = j,i

    if trace: g.trace('back,nocase,regexp,word,',
        backwards,nocase,regexp,word,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        if trace: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    if trace: g.trace('returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20060526092203">def regexHelper (self,s,i,j,pattern,backwards,nocase):

    re_obj = self.re_obj # Use the pre-compiled object
    if not re_obj:
        g.trace('can not happen: no re_obj')
        return -1,-1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 &lt;= i &lt; len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20060526093531">def plainHelper (self,s,i,j,pattern,nocase,word):

    trace = self.trace

    # if trace: g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if trace: g.trace(i,j,repr(s[i:i+20]))

    if nocase:
        s = s.lower() ; pattern = pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1:
                if trace: g.trace('no match word',i)
                return -1, -1
            elif self.matchWord(s,k,pattern):
                if trace: g.trace('match word',k)
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            if trace: g.trace('no match word',i)
            return -1, -1
        else:
            if trace: g.trace('match', k)
            return k, k + n
</t>
<t tx="ekr.20060526140328">if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos &lt; self.wrapPos:
        if trace: g.trace("** reverse wrap done",pos,newpos)
        return None, None

    if not self.reverse and newpos &gt; self.wrapPos:
        if trace: g.trace('** wrap done',pos,newpos)
        return None, None
</t>
<t tx="ekr.20060526140744">debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i &lt; 0 or i &gt; len(s) or j &lt; 0 or j &gt; len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount &lt; 50:
                g.trace(i,j,'len(s)',len(s),self.p.h)
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -&gt; %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -&gt; %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.h))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20060526140744.1">def matchWord(self,s,i,pattern):

    trace = self.trace

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        if trace: g.trace('empty')
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    if trace: g.trace('returns',not inWord)
    return not inWord

</t>
<t tx="ekr.20060526201951">def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
</t>
<t tx="ekr.20060527184335"></t>
<t tx="ekr.20060528100747"># This code uses self.pb, a paned body widget, created by tkBody.finishCreate.


</t>
<t tx="ekr.20060528100747.1">def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    c = self.c ; p = c.p

    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # Bug fix: Leo 4.4.8 rc1: The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = list(d.keys())
        if len(keys) == 1:
            w_old = d.get(keys[0])
            self.updateInjectedIvars(w_old,p)
            self.selectLabel(w_old) # Immediately create the label in the old editor.
        else:
            g.trace('can not happen: unexpected editorWidgets',d)

    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    f = self.createEditorFrame(pane)
    &lt;&lt; create text widget w &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    self.pb.updatelayout()
    c.frame.body.bodyCtrl = w

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20060528110922">w = self.createTextWidget(f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.b)
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(p,w)
</t>
<t tx="ekr.20060528113806">def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

    if len(list(d.keys())) == 1: return

    name = w.leo_name

    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    # Select another editor.
    w = list(d.values())[0]
    # c.frame.body.bodyCtrl = w # Don't do this now?
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20060528131618"># Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.p
    d = self.editorWidgets
    if len(list(d.keys())) &lt; 2: return # There is only the main widget.

    for key in d:
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != c.frame.body.bodyCtrl:
            w.delete(0,'end')
            w.insert('end',p.b)
            # g.trace('update',w,v)
            self.recolorWidget(p,w)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20060528132829">def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = c.frame.body.bodyCtrl

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.h)
</t>
<t tx="ekr.20060528170438">def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
    values = list(d.values())
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = list(d.values())[i]
        assert(w!=w2)
        self.selectEditor(w2)
        c.frame.body.bodyCtrl = w2
        # g.pr('***',g.app.gui.widget_name(w2),id(w2))

    return 'break'
</t>
<t tx="ekr.20060529184652">def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find) ###
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060529184652.1">def transposeWords (self,event):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20060530204135">def recolorWidget (self,p,w):

    c = self.c ; old_w = c.frame.body.bodyCtrl

    # g.trace('w',id(w),p.h,len(w.getAllText()))

    # Save.
    c.frame.body.bodyCtrl = w
    try:
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_w
</t>
<t tx="ekr.20060530210057">def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    if hasattr(w,'leo_label') and w.leo_label:
        w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors &gt; 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        if hasattr(w,'leo_label') and w.leo_label:
            w.leo_label.configure(text=s,bg='white')
    elif hasattr(w,'leo_label') and w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None
</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.

       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others
</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()

    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")
</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.p

    # "Title" is the headline of the current node
    self.title.configure(text=cp.h)

    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)

    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().h
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)

    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)
</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060602154458">def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.frame.minibufferWantsFocus()
        k.setLabelBlue('Python help: ',protect=True)
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            g.redirectStderr()
            g.redirectStdout()
            try: help(str(s))
            except Exception: pass
            g.restoreStderr()
            g.restoreStdout()
</t>
<t tx="ekr.20060603161041">def setSilentMode (self,event=None):

    '''Set the mode to be run silently, without the minibuffer.
    The only use for this command is to put the following in an @mode node::

        --&gt; set-silent-mode'''

    self.c.k.silentMode = True
</t>
<t tx="ekr.20060608221203">def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
</t>
<t tx="ekr.20060608222828">def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i &gt; -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
</t>
<t tx="ekr.20060608224112">def getAbbrevDict (self,c):

    """Search all dictionaries for the setting &amp; check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
</t>
<t tx="ekr.20060610193837">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3771068
By: leouser

The open python window does not appear to work on Solaris.

http://sourceforge.net/forum/message.php?msg_id=3771167
By: nobody

from what I could see it looked like it was trying to start the shell up with
a location that pointed to a nonexistent path.

@color
</t>
<t tx="ekr.20060613082924">def leoUsersGuide (self,event=None):

    '''Open Leo's users guide in a web browser.'''

    import webbrowser
    c = self

    theFile = c.os_path_finalize_join(
        g.app.loadDir,'..','doc','html','_build','html','leo_toc.html')

    if os.path.isfile(theFile):
        url = 'file:%s' % theFile
        webbrowser.open_new(url)
        return

    try:
        url = 'http://webpages.charter.net/edreamleo/leo_toc.html'
        webbrowser.open_new(url)
        return
    except:
        g.es("not found:",url)
</t>
<t tx="ekr.20060613090701">editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace:
        g.pr(
            '---- w',w_name(w),id(w),
            '#tabs',c.frame.log.numberOfVisibleTabs(),
            'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n &gt; 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount &gt; n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n &gt; 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount &gt; n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
                # Use this to skip the tree pane.
                #pane = c.frame.body.bodyCtrl
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
            # Use this to skip the tree pane.
            # pane = c.frame.body.bodyCtrl
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0

    if trace: g.pr('old: %10s new: %10s' % (w_name(w),w_name(pane)))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
        k.showStateAndMode()
</t>
<t tx="ekr.20060624085200">def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    full = c.config.getBool('show_full_tracebacks_in_scripts')

    fileName, n = g.es_exception(full=full)

    if p and not script1 and fileName == "&lt;string&gt;":
        c.goToScriptLineNumber(p,script,n)

    &lt;&lt; dump the lines near the error &gt;&gt;
</t>
<t tx="ekr.20060627080947">def skip_matching_python_parens(s,i):

    '''Skip from the opening ( to the matching ).

    Return the index of the matching ')', or -1'''

    return skip_matching_python_delims(s,i,'(',')')
</t>
<t tx="ekr.20060627083506">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20060627091557">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20060628094329.2"></t>
<t tx="ekr.20060628103226.2"></t>
<t tx="ekr.20060628103226.3"></t>
<t tx="ekr.20060726154531">def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('left')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(1,"unit")

def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('right')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(-1,"unit")
</t>
<t tx="ekr.20060804095512">def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20060810095921">def translateString (s):

    '''Return the translated text of s.'''

    if g.isPython3:
        if not g.isString(s):
            s = str(s,'utf-8')
        if g.app.translateToUpperCase:
            s = s.upper()
        else:
            s = gettext.gettext(s)
        return s
    else:
        if g.app.translateToUpperCase:
            return s.upper()
        else:
            return gettext.gettext(s)

tr = translateString
</t>
<t tx="ekr.20060813121814"></t>
<t tx="ekr.20060822162521">Limit the with of the headline to the width of the outline pane.
</t>
<t tx="ekr.20060824103837">@nocolor

Renamed pl-sql.* to plsql.* (This required rerunning jEdit2py.)

Forth is going to be a problem, because keywords can be extensible.
Perhaps the user should be responsible for updating forth.xml.
</t>
<t tx="ekr.20060824110846"></t>
<t tx="ekr.20060829084924"># Get the default body font.
defaultBodyfont = self.fonts.get('default_body_font')
if not defaultBodyfont:
    defaultBodyfont = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.fonts['default_body_font'] = defaultBodyfont

# Configure fonts.
w = c.frame.body.bodyCtrl
keys = sorted(default_font_dict)
for key in keys:
    option_name = default_font_dict[key]
    # First, look for the language-specific setting, then the general setting.
    for name in ('%s_%s' % (self.language,option_name),(option_name)):
        font = self.fonts.get(name)
        if font:
            # g.trace('found',name,id(font))
            w.tag_config(key,font=font)
            break
        else:
            family = c.config.get(name + '_family','family')
            size   = c.config.get(name + '_size',  'size')   
            slant  = c.config.get(name + '_slant', 'slant')
            weight = c.config.get(name + '_weight','weight')
            if family or slant or weight or size:
                family = family or g.app.config.defaultFontFamily
                size   = size or str(c.config.defaultBodyFontSize)
                slant  = slant or 'roman'
                weight = weight or 'normal'
                font = c.config.getFontFromParams(family,size,slant,weight)
                # Save a reference to the font so it 'sticks'.
                self.fonts[name] = font 
                # g.trace(key,name,family,size,slant,weight,id(font))
                w.tag_config(key,font=font)
                break
    else: # Neither the general setting nor the language-specific setting exists.
        if len(list(self.fonts.keys())) &gt; 1: # Restore the default font.
            # g.trace('default',key)
            w.tag_config(key,font=defaultBodyfont)
</t>
<t tx="ekr.20060904165452.1">if use_zodb:
    # It may be important to import ZODB first.
    try:
        import ZODB
        import ZODB.FileStorage
    except ImportError:
        ZODB = None
else:
    ZODB = None

import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import time
import re
import itertools
</t>
<t tx="ekr.20060906131836">def setRootVnode (self, v):

    c = self
    newRoot = leoNodes.position(v)
    c.setRootPosition(newRoot)
</t>
<t tx="ekr.20060906134053">@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):

    '''Return the root position of the outline containing p.'''

    c = self ; p = p.copy()

    while p and p.hasParent():
        p.moveToParent()
        # g.trace(p.h,g.callers())

    while p and p.hasBack():
        p.moveToBack()

    # g.trace(p and p.h)

    return p
</t>
<t tx="ekr.20060906211138">def clearMarked  (self,p):

    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)
</t>
<t tx="ekr.20060906211138.1">def setMarked (self,p):

    c = self
    p.v.setMarked()
    g.doHook("set-mark",c=c,p=p,v=p)
</t>
<t tx="ekr.20060906211747"></t>
<t tx="ekr.20060906211747.1"></t>
<t tx="ekr.20060910100316">if use_zodb and ZODB:
    def __hash__(self):
        return self.__hash__()
</t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060912093104">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]
</t>
<t tx="ekr.20060913090832.1">init_zodb_import_failed = False
init_zodb_failed = {} # Keys are paths, values are True.
init_zodb_db = {} # Keys are paths, values are ZODB.DB instances.

def init_zodb (pathToZodbStorage,verbose=True):

    '''Return an ZODB.DB instance from ZODB.FileStorage.FileStorage(pathToZodbStorage)
    return None on any error.'''

    global init_zodb_db, init_zodb_failed, init_zodb_import_failed

    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db

    if init_zodb_import_failed: return None

    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None

    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None

    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db [pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed [pathToZodbStorage] = True
        return None
</t>
<t tx="ekr.20060913091602"></t>
<t tx="ekr.20060917120951">def es_dump (s,n = 30,title=None):

    if title:
        g.es_print('',title)

    i = 0
    while i &lt; len(s):
        aList = ''.join(['%2x ' % (ord(ch)) for ch in s[i:i+n]])
        g.es_print('',aList)
        i += n
</t>
<t tx="ekr.20060918164811">class BadLeoFile(Exception):
    def __init__(self, message):
        self.message = message
        Exception.__init__(self,message) # Init the base class.
    def __str__(self):
        return "Bad Leo File:" + self.message

class invalidPaste(Exception):
    pass
</t>
<t tx="ekr.20060919064401"># All elements and attributes prefixed by ':' are leo-specific.
# All other elements and attributes are specified by the OPML 1 spec.

def putToOPML (self):

    '''Should be overridden by the opml plugin.'''

    return None
</t>
<t tx="ekr.20060919104530"></t>
<t tx="ekr.20060919104836"></t>
<t tx="ekr.20060919110638.11">def resolveTnodeLists (self):

    trace = False and not g.unitTesting
    c = self.c

    for p in c.all_unique_positions():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                v = self.gnxDict.get(index)
                if v:
                    if trace: g.trace(tnx,v)
                    result.append(v)
                else:
                    g.trace('*** No vnode for %s' % tnx)
            if result:
                p.v.tnodeList = result
                # g.trace('*** tnodeList for',p.h,result)
            delattr(p.v,'tempTnodeList')
</t>
<t tx="ekr.20060919110638.13">def setPositionsFromVnodes (self):

    trace = False and not g.unitTesting
    c = self.c ; p = c.rootPosition()
    current,str_pos = None,None

    use_db = g.enableDB and c.mFileName
    if use_db:
        str_pos = c.cacher.getCachedStringPosition()

    if not str_pos:
        d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
        if d: str_pos = d.get('str_leo_pos')
        if trace: g.trace('from p.v.u',str_pos)

    if str_pos:
        current = self.archivedPositionToPosition(str_pos)

    c.setCurrentPosition(current or c.rootPosition())
</t>
<t tx="ekr.20060919110638.14">def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the &lt;?xml&gt; element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
</t>
<t tx="ekr.20060919110638.15">class saxNodeClass:

    '''A class representing one &lt;v&gt; element.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
</t>
<t tx="ekr.20060919110638.16">def __init__ (self):

    self.attributes = {}
    self.bodyString = ''
    self.headString = ''
    self.children = []
    self.tnodeAttributes = {}
    self.tnodeList = []
    self.tnx = None
</t>
<t tx="ekr.20060919110638.17">def __str__ (self):

    return '&lt;v:%s %s %s&gt;' % (id(self),self.headString,len(self.bodyString))

__repr__ = __str__
</t>
<t tx="ekr.20060919110638.18">def dump (self):

    g.pr('\nnode: %s tnx: %s len(body): %d %s' % (
        id(self),self.tnx,len(self.bodyString),self.headString))
    g.pr('children:',g.listToString(self.children))
    g.pr('attrs:',list(self.attributes.values()))
</t>
<t tx="ekr.20060919110638.19">class saxContentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that reads Leo files.'''

    @others
</t>
<t tx="ekr.20060919110638.2">def dumpSaxTree (self,root,dummy):

    if not root:
        g.pr('dumpSaxTree: empty tree')
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)
</t>
<t tx="ekr.20060919110638.20">def __init__ (self,c,fileName,silent,inClipboard):

    self.c = c
    self.fileName = fileName
    self.silent = silent
    self.inClipboard = inClipboard

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    &lt;&lt; define dispatch dict &gt;&gt;

    self.printElements = [] # 'all', 'v'

    # Global attributes of the .leo file...
    # self.body_outline_ratio = '0.5'
    self.global_window_position = {}
    self.encoding = 'utf-8' 

    # Semantics...
    self.content = None
    self.elementStack = []
    self.errors = 0
    self.tnxToListDict = {}
        # Keys are tnx's (strings)
        # Values are *lists* of saxNodeClass objects.
    self.level = 0
    self.node = None
    self.nodeList = [] # List of saxNodeClass objects with the present vnode.
    self.nodeStack = []
    self.rootNode = None # a sax node.
    self.trace = False # True and g.unitTesting
</t>
<t tx="ekr.20060919110638.21"># There is no need for an 'end' method if all info is carried in attributes.

self.dispatchDict = {
    'change_string':               (None,None),
    'find_panel_settings':         (None,None),
    'find_string':                 (None,None),
    'globals':                     (self.startGlobals,None),
    'global_log_window_position':  (None,None), # The position of the log window is no longer used.
    'global_window_position':      (self.startWinPos,None),
    'leo_file':                    (None,None),
    'leo_header':                  (self.startLeoHeader,None),
    'preferences':                 (None,None),
    't':                           (self.startTnode,self.endTnode),
    'tnodes':                      (None,None),
    'v':                           (self.startVnode,self.endVnode),
    'vh':                          (self.startVH,self.endVH),
    'vnodes':                      (self.startVnodes,None), # Causes window to appear.
}
</t>
<t tx="ekr.20060919110638.23">def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.'''

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()]
</t>
<t tx="ekr.20060919110638.24">def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
</t>
<t tx="ekr.20060919110638.25">def clean(self,s):

    return g.toEncodedString(s,"ascii")
</t>
<t tx="ekr.20060919110638.26">def error (self, message):

    g.pr('\n\nXML error: %s\n' % (message))

    self.errors += 1
</t>
<t tx="ekr.20060919110638.27">def inElement (self,name):

    return self.elementStack and name in self.elementStack
</t>
<t tx="ekr.20060919110638.28">def printStartElement(self,name,attrs):

    indent = '\t' * self.level or ''

    if attrs.getLength() &gt; 0:
        g.pr('%s&lt;%s %s&gt;' % (
            indent,
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' ')),
            newline=False)
    else:
        g.pr('%s&lt;%s&gt;' % (
            indent,
            self.clean(name).strip()),
            newline=False)

    if name.lower() in ['v','t','vnodes','tnodes',]:
        g.pr('')
</t>
<t tx="ekr.20060919110638.29">def endElementNS(self,unused_name,unused_qname):
    g.trace(unused_name)

def endDocument(self):
    pass

def ignorableWhitespace(self,unused_whitespace):
    pass

def skippedEntity(self,name):
    g.trace(name)

def startElementNS(self,unused_name,unused_qname,unused_attrs):
    g.trace(unused_name)

def startDocument(self):
    pass
</t>
<t tx="ekr.20060919110638.3">def readSaxFile (self,theFile,fileName,silent,inClipboard,reassignIndices,s=None):

    dump = False and not g.unitTesting
    fc = self ; c = fc.c

    # Pass one: create the intermediate nodes.
    saxRoot = fc.parse_leo_file(theFile,fileName,
        silent=silent,inClipboard=inClipboard,s=s)

    if dump: fc.dumpSaxTree(saxRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if saxRoot:
        parent_v = c.hiddenRootNode
        children = fc.createSaxChildren(saxRoot,parent_v)
        assert c.hiddenRootNode.children == children
        v = children and children[0] or None
        return v
    else:
        return None
</t>
<t tx="ekr.20060919110638.30">def characters(self,content):

    if g.isPython3:
        if content and type(content) != type('a'):
            g.trace('Non-unicode content',repr(content))
    else:
        if content and type(content) != types.UnicodeType:
            g.trace('Non-unicode content',repr(content))

    content = content.replace('\r','')

    if not content: return

    elementName = self.elementStack and self.elementStack[-1].lower() or '&lt;no element name&gt;'

    # if self.trace: g.trace(elementName,content.strip())

    if elementName in ('t','vh'):
        # if elementName == 'vh': g.trace(elementName,repr(content))
        self.content.append(content)

    elif content.strip():
        g.pr('unexpected content:',elementName,repr(content))
</t>
<t tx="ekr.20060919110638.31">def endElement(self,name):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        indent = '\t' * (self.level-1) or ''
        g.pr('%s&lt;/%s&gt;' % (indent,self.clean(name).strip()))

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown end element',name)
    else:
        junk,func = data
        if func:
            func()

    name2 = self.elementStack.pop()
    assert name == name2
    # if self.trace: g.trace('** pop',name2)
</t>
<t tx="ekr.20060919110638.32">def endTnode (self):

    for sax_node in self.nodeList:
        sax_node.bodyString = ''.join(self.content)
        # if self.trace: g.trace(repr(sax_node))

    self.content = []
</t>
<t tx="ekr.20060919110638.33">def endVnode (self):

    self.level -= 1
    self.node = self.nodeStack.pop()
    # if self.trace: g.trace(repr(self.node))
</t>
<t tx="ekr.20060919110638.34">def endVH (self):

    if self.node:
        self.node.headString = ''.join(self.content)
        # if self.trace: g.trace(repr(self.node))

    self.content = []
</t>
<t tx="ekr.20060919110638.35">def startElement(self,name,attrs):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        self.printStartElement(name,attrs)

    self.elementStack.append(name)
    # if self.trace: g.trace('**push',name)

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown start element',name)
    else:
        func,junk = data
        if func:
            func(attrs)
</t>
<t tx="ekr.20060919110638.36">def getWindowPositionAttributes (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(c.mFileName)

    d = {}

    if g.enableDB and c.mFileName:
        d = c.cacher.getCachedWindowPositionDict(c.mFileName)

    if not d and c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}

    if not d:
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    # if trace: g.trace(d)
    return d
</t>
<t tx="ekr.20060919110638.37">def startGlobals (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if self.inClipboard:
        return

    c.frame.ratio,c.frame.secondary_ratio = 0.5,0.5 # Set defaults.

    if trace: g.trace(c.mFileName)

    use_db = g.enableDB and c.mFileName
    if use_db:
        ratio,ratio2 = c.cacher.getCachedGlobalFileRatios()
        c.frame.ratio,c.frame.secondary_ratio = ratio,ratio2
    else:
        try:
            for bunch in self.attrsToList(attrs):
                name = bunch.name ; val = bunch.val
                if name == 'body_outline_ratio':
                    c.frame.ratio = float(val) # 2010/01/11
                elif name == 'body_secondary_ratio':
                    c.frame.secondary_ratio = float(val) # 2010/01/11
            if trace: g.trace('** not cached:','%1.2f %1.2f' % (
                c.frame.ratio,c.frame.secondary_ratio))
        except Exception:
            pass
</t>
<t tx="ekr.20060919110638.38">def startWinPos (self,attrs):

    self.global_window_position = self.getWindowPositionAttributes(attrs)
</t>
<t tx="ekr.20060919110638.39">def startLeoHeader (self,unused_attrs):

    self.tnxToListDict = {}
</t>
<t tx="ekr.20060919110638.40">def startVH (self,unused_attrs):

    self.content = []
</t>
<t tx="ekr.20060919110638.41">def startTnode (self,attrs):

    if not self.inElement('tnodes'):
        self.error('&lt;t&gt; outside &lt;tnodes&gt;')

    self.content = []

    self.tnodeAttributes(attrs)
</t>
<t tx="ekr.20060919110638.42">def tnodeAttributes (self,attrs):

    # The vnode must have a tx attribute to associate content
    # with the proper node.

    trace = False and not g.unitTesting
    verbose = False
    node = self.node
    self.nodeList = []
    val = None

    # Step one: find the tx attribute
    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 'tx':
            # 2010/02/03: This code formerly did something
            # different when unit testing just to support a unit test.
            # Hahaha.  The unit test *caused* the bug!
            self.nodeList = self.tnxToListDict.get(val,[])
            if trace and verbose: g.trace('tx',self.nodeList)
            break

    if not self.nodeList:
        self.error('Bad leo file: no node for &lt;t tx=%s&gt;' % (val))
        return

    # Step two: find all the other attributes:
    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name != 'tx':
            # Huge bug fix: 2009/7/1: was node == self.node.
            for node in self.nodeList:
                if trace: g.trace('%s %s=%s...' % (node,name,val[:20]))
                node.tnodeAttributes[name] = val

    # if not self.nodeList:
        # self.error('Bad leo file: no tx attribute for vnode')
</t>
<t tx="ekr.20060919110638.43">def startVnode (self,attrs):

    if not self.inElement('vnodes'):
        self.error('&lt;v&gt; outside &lt;vnodes&gt;')

    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = saxNodeClass() # The dummy parent node.
        parent.headString = 'dummyNode'

    self.node = saxNodeClass()

    parent.children.append(self.node)
    self.vnodeAttributes(attrs)
    self.nodeStack.append(parent)

    return parent
</t>
<t tx="ekr.20060919110638.44"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def vnodeAttributes (self,attrs):

    node = self.node

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 't':
            aList = self.tnxToListDict.get(val,[])
            aList.append(self.node)
            self.tnxToListDict[val] = aList
            node.tnx = str(val) # nodeIndices.toString returns a string.
        else:
            node.attributes[name] = val
</t>
<t tx="ekr.20060919110638.45">def getRootNode (self):
    if self.trace:
        g.trace()
        self.rootNode.dump()
        for child in self.rootNode.children:
            child.dump()
    return self.rootNode
</t>
<t tx="ekr.20060919110638.5">def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') &gt; -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
</t>
<t tx="ekr.20060919110638.7">def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') &gt; -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
</t>
<t tx="ekr.20060919110638.8">def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20060919112118">def startVnodes (self,unused_attrs):

    if self.inClipboard:
        return # No need to do anything to the main window.

    c = self.c ; d = self.global_window_position

    w = d.get('width',700)
    h = d.get('height',500)
    x = d.get('left',50)
    y = d.get('top',50)
    # g.trace(d,w,h,x,y)

    # Redraw the window before writing into it.
    c.frame.setTopGeometry(w,h,x,y)
    c.frame.deiconify()
    c.frame.lift()
    c.frame.update()

    # Causes window to appear.
    # g.trace('ratio',c.frame.ratio,c)
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not self.silent and not g.unitTesting:
        g.es("reading:",self.fileName)
</t>
<t tx="ekr.20060919133249"># Methods common to both the sax and non-sax code.
</t>
<t tx="ekr.20060919134313"></t>
<t tx="ekr.20060919142200.1">def initReadIvars (self):

    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.gnxDict = {}
    self.c.nodeConflictList = [] # 2010/01/05
    self.c.nodeConflictFileName = None # 2010/01/05
</t>
<t tx="ekr.20060919145406">@others
</t>
<t tx="ekr.20060920203352">def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
</t>
<t tx="ekr.20060921100435"># Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition="&gt;=",stringCompare=None,delimiter='.',trace=False):

    # CheckVersion is called early in the startup process.
    # import leo.core.leoGlobals as g

    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 &lt; n: vals1.extend([0 for i in range(n - n1)])
    if n2 &lt; n: vals2.extend([0 for i in range(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;',  vals1 &lt;  vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;',  vals1 &gt;  vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError("condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='.")

    if trace:
        # g.pr('%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result)
        g.pr('%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result)
    return result
</t>
<t tx="ekr.20060921100435.1">@ g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def oldCheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):

    # tokenize the stringCompare flags
    compareFlag = stringCompare.split('.')

    # tokenize the version strings
    testVersion = version.split(delimiter)
    testAgainst = againstVersion.split(delimiter)

    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount &gt; len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount &gt; len(testVersion):
        tokenCount = len(testVersion)

    # Apply the stringCompare flags
    justInteger = re.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError(errMsg)

    # Compare the versions
    if condition == "&gt;=":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == "&gt;":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "&lt;":
        for i in range(tokenCount):
            if testVersion[i] &gt;= testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "&lt;=":
        for i in range(tokenCount):
            if testVersion[i] &gt; testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal

    # didn't find a condition that we expected.
    raise EnvironmentError("condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='.")
</t>
<t tx="ekr.20060923060822">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20060923060822.1">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-&amp;down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-&amp;up-page',
    ]
</t>
<t tx="ekr.20060923202156">def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    # g.trace(event and event.char)

    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.p ; p1 = p.copy()
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event.char
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        c.selectPosition(p)
        c.redraw_after_select(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.h)
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
</t>
<t tx="ekr.20060924124119">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]

    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]
</t>
<t tx="ekr.20060924161901">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]
</t>
<t tx="ekr.20060925151926">def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
</t>
<t tx="ekr.20060926161940">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20060926213642">def capitalizeMinibufferMenuName (self,s,removeHyphens):

    result = []
    for i in range(len(s)):
        ch = s[i]
        prev = i &gt; 0 and s[i-1] or ''
        prevprev = i &gt; 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&amp;' or
            prev == '-' or
            prev == '&amp;' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)
</t>
<t tx="ekr.20060927173836.1">@nocolor

Disabled these binding:

auto-complete-force = None # This command needs work before it is useful. Ctrl-period
show-calltips-force = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
</t>
<t tx="ekr.20060927173836.6"># Or give a better message.
</t>
<t tx="ekr.20060928062431">def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    for p in c.all_unique_positions():
        p.contract()
    for p in c.p.parents():
        p.expand()
        level += 1

    c.redraw(setFocus=True)

    c.expansionLevel = level # Reset expansion level.
</t>
<t tx="ekr.20060930110925">Up/down arrow keys should move straight up/down, but this is difficult with Tk.
Still the present way is very bad.
</t>
<t tx="ekr.20061002093442"></t>
<t tx="ekr.20061002095711">def navHelper (self,p,ch,extend):

    c = self ; h = p.h.lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent',):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n &lt; len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) &lt; len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
</t>
<t tx="ekr.20061002095711.1">def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime &lt; deltaTime
        return nearTime
</t>
<t tx="ekr.20061003093021">def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        val = str(val)
    except UnicodeError:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()

    # g.trace(attr,repr(val))

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
</t>
<t tx="ekr.20061004053644"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes
    # if trace and d: g.trace(d)

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20061004054323">def processingInstruction (self,target,data):

    if target == 'xml-stylesheet':
        self.c.frame.stylesheet = data
        if False and not self.silent:
            g.es('','%s: %s' % (target,data),color='blue')
    else:
        g.trace(target,data)
</t>
<t tx="ekr.20061006092649">def archivedPosition (self,root_p=None):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self

    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents()]
    else:
        aList = []
        for z in p.self_and_parents():
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
        # g.trace(aList)

    aList.reverse()
    return aList
</t>
<t tx="ekr.20061006104837.1">def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level &lt; len(aList):
        i = aList[level]
        while i &gt; 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level &lt; len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
</t>
<t tx="ekr.20061006152327">def isWordChar (ch):

    '''Return True if ch should be considered a letter.'''

    return ch and (ch.isalnum() or ch == '_')

def isWordChar1 (ch):

    return ch and (ch.isalpha() or ch == '_')
</t>
<t tx="ekr.20061006165447">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

&gt;the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
</t>
<t tx="ekr.20061007082956">def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
</t>
<t tx="ekr.20061007105001">def editWidget (self,event):

    c = self.c ; w = event and event.widget

    # g.trace(w,g.app.gui.isTextWidget(w))

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
</t>
<t tx="ekr.20061007214835.4">def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
</t>
<t tx="ekr.20061008140603">def runEditCommandTest (c,p):

    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.h
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.h
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.h[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.selectPosition(work)
    c.setBodyString(work,before.b)
    #g.trace(repr(sel1[0]),repr(sel1[1]))
    w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
    c.k.simulateCommand(commandName)
    s1 = work.b ; s2 = after.b
    assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
    sel3 = w.getSelectionRange()
    ins = w.toGuiIndex(w.getInsertPoint())
    #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    # g.trace(w)
    assert len(sel2) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel2
    i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert len(sel3) == 2,'Bad headline index.  Expected index,index.  got: %s' % sel3
    i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
    assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20061010121944">def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeLeoDir,g.app.globalConfigDir): # homeLeoDir was g.app.homeDir.
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = open(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
</t>
<t tx="ekr.20061011084101.1">def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20061011085641">def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]
</t>
<t tx="ekr.20061011111007">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3957908

&gt; Is there a setting for autmoatically loading most recent file or files.

@color
</t>
<t tx="ekr.20061012113455">def doNothing (self,event):

    '''A placeholder command, useful for testing bindings.'''

    # g.trace()
    pass
</t>
<t tx="ekr.20061015090538">def es_exception_type (c=None,color="red"):

    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]

    g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
</t>
<t tx="ekr.20061016071937">def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)
</t>
<t tx="ekr.20061017083312">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.
    trace = False
    c = self.c

    if self.selectEditorLockout:
        return

    if w and w == self.c.frame.body.bodyCtrl:
        if w.leo_p and w.leo_p != c.p:
            c.selectPosition(w.leo_p)
            c.bodyWantsFocusNow()
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20061017083312.1"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061018094539">def openLeoScripts (self,event=None):

    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found:',fileName)
</t>
<t tx="ekr.20061021131443"></t>
<t tx="ekr.20061023153133">patch -p1 &lt; patchfile
</t>
<t tx="ekr.20061024060248.1">@first # -*- coding: utf-8 -*-

&lt;&lt; docstring&gt;&gt;

@language python
@tabwidth -4

# As in leo.py we must be very careful about imports.
g = None # set by init: do *not* import it here!
inited = False
pymacsFile = __file__
# print('leoPymacs:pymacsFile',pymacsFile)

@others
</t>
<t tx="ekr.20061024060248.2">'''A module to allow the Pymacs bridge to access Leo data.

All code in this module must be called *from* Emacs:
calling Pymacs.lisp in other situations will hang Leo.

Notes:

- The init method adds the parent directory of leoPymacs.py to
  Python's sys.path. This is essential to make imports work from
  inside Emacs.

- As of Leo 4.5, the following code, when executed from an Emacs buffer,
  will open trunk/leo/test.leo::

      (pymacs-load "c:\\leo.repo\\trunk\\leo\\core\\leoPymacs" "leo-")
      (setq c (leo-open "c:\\leo.repo\\trunk\\leo\\test\\test.leo"))

  Note that full path names are required in each case.

'''
</t>
<t tx="ekr.20061024060248.3">def hello():

    init()
    return 'Hello from Leo.  g.app: %s' % g.app
</t>
<t tx="ekr.20061024075542">def init ():

    global inited

    if inited:
        return
    else:
        inited = True # Only try once, no matter what happens.

    # Add the parent path of this file to sys.path
    import os
    import sys

    theDir = os.path.abspath(os.path.join(os.path.dirname(pymacsFile),'..','..'))
    if theDir not in sys.path:
        print ('leoPymacs:adding',theDir,'to sys.path')
        sys.path.append(theDir)

    # Create the dummy app
    try:
        import leo.core.runLeo as leo
    except ImportError:
        print('leoPymacs.init: can not import runLeo')
        print('leoPymacs.init: sys.path:')
        for z in sys.path: print (z)

    leo.run(pymacs=True)

    try:
        import leo.core.leoGlobals as leoGlobals
    except ImportError:
        print('leoPymacs.init: can not import leoGlobals')

    global g ; g = leoGlobals
    # print('leoPymacs:init:g',g)

    if 1: # These traces show up in the pymacs buffer.
        g.trace('app',g.app)
        g.trace('gui',g.app.gui)
</t>
<t tx="ekr.20061024075542.1">def open (fileName=None):

    global g

    init()

    if g.app.unitTesting:
        return

    if not fileName:
        g.es_print('','leoPymacs.open:','no file name')
        return None

    # openWithFileName checks to see if the file is already open.
    ok, frame = g.openWithFileName(
        fileName,
        old_c=None,
        enableLog=False,
        readAtFileNodesFlag=True)

    c = ok and frame.c or None
    if c:
        g.es_print('','leoPymacs.open:',c)
    else:
        g.es_print('','leoPymacs.open:','can not open',fileName)

    return c
</t>
<t tx="ekr.20061024084200">def run_script(c,script,p=None):

    # It is possible to use script=None, in which case p must be defined.

    global g

    init()

    if c is None:
        c,frame = g.app.newLeoCommanderAndFrame(fileName='dummy script file')

    g.app.scriptResult = None

    c.executeScript(
        event=None,
        p=p,
        script=script,
        useSelectedText=False,
        define_g=True,
        define_name='__main__',
        silent=True,  # Don't write to the log.
    )

    # g.trace('script returns: ',repr(g.app.scriptResult))
    return g.app.scriptResult
</t>
<t tx="ekr.20061024130957">def get_app ():
    '''Scripts can use g.app.scriptDict for communication with pymacs.'''
    global g
    init()
    return g.app

def get_g():
    global g
    init()
    return g

def script_result():
    global g
    init()
    return g.app.scriptResult
</t>
<t tx="ekr.20061024131236">def dump (anObject):

    global g

    init()

    return str(g.toEncodedString(repr(anObject),encoding='ascii'))
</t>
<t tx="ekr.20061028082834"># This can't be done in initSettingsFiles because
# the local directory does not yet exist.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
</t>
<t tx="ekr.20061031102333.2">def getWord (s,i):

    '''Return i,j such that s[i:j] is the word surrounding s[i].'''

    if i &gt;= len(s): i = len(s) - 1
    if i &lt; 0: i = 0
    # Scan backwards.
    while 0 &lt;= i &lt; len(s) and g.isWordChar(s[i]):
        i-= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 &lt;= j &lt; len(s) and g.isWordChar(s[j]):
        j += 1
    return i,j

def getLine (s,i):

    '''Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    '''

    if i &gt; len(s): i = len(s) -1 # Bug fix: 10/6/07 (was if i &gt;= len(s))
    if i &lt; 0: i = 0
    j = s.rfind('\n',0,i) # A newline *ends* the line, so look to the left of a newline.
    if j == -1: j = 0
    else:       j += 1
    k = s.find('\n',i)
    if k == -1: k = len(s)
    else:       k = k + 1
    # g.trace('i,j,k',i,j,k,repr(s[j:k]))
    return j,k
</t>
<t tx="ekr.20061031131434">"""Gui-independent keystroke handling for Leo.""" 

@language python
@tabwidth -4
@pagewidth 70

&lt;&lt; imports &gt;&gt;
&lt;&lt; about 'internal' bindings &gt;&gt;
&lt;&lt; about key dicts &gt;&gt;

@others
</t>
<t tx="ekr.20061031131434.1">import leo.core.leoGlobals as g
import leo.core.leoFrame as leoFrame # to access stringTextWidget class.

# This creates a circular dependency.
# We break this by doing the import in k.endCommand.
# import leo.core.leoEditCommands as leoEditCommands

import glob
import inspect
import os
import re
import string
import sys
import time
import types
</t>
<t tx="ekr.20061031131434.10">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20061031131434.100">def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d:

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    # if stroke.lower()=='ctrl+v':
        # g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),'w',repr(w),'\n',g.callers())

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.105">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn and ch == ' ':
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
</t>
<t tx="ekr.20061031131434.106">specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
</t>
<t tx="ekr.20061031131434.107">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20061031131434.108">def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) &lt; 32 or ord(ch) &gt; 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
</t>
<t tx="ekr.20061031131434.109">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
</t>
<t tx="ekr.20061031131434.11">def autoCompleterStateHandler (self,event):

    trace = (False or self.trace) and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    ch = gui.eventChar(event)
    keysym = gui.eventKeysym(event)

    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym in ('\b','BackSpace'): # Horrible hack for qt plugin.
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = list(self.theObject.keys())
        elif type(self.theObject) in (type((),),type([])):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        # if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20061031131434.110">def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') &gt; -1 or stroke.find('Alt') &gt; -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
</t>
<t tx="ekr.20061031131434.111">def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Ins' or k.isFKey(keysym):
        pass
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.113">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            k.commandName = None

            # Do the import here to break a circular dependency at the top level.
            import leo.core.leoEditCommands as leoEditCommands
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.115">def universalArgument (self,event):

    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)

def digitArgument (self,event):

    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
</t>
<t tx="ekr.20061031131434.116">def hideMinibuffer (self,event):
    '''Hide the minibuffer.'''
    k = self ; c = k.c
    c.frame.hideMinibuffer()
    g.es('minibuffer hidden',color='red')
    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('',commandName,'is bound to:',shortcut)

def showMinibuffer (self,event):
    '''Show the minibuffer.'''
    k = self ; c = k.c
    c.frame.showMinibuffer()

def toggleMinibuffer (self,event):
    '''Show or hide the minibuffer.'''
    k = self ; c = k.c
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)
</t>
<t tx="ekr.20061031131434.117">def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'
</t>
<t tx="ekr.20061031131434.118">def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget
    k.universalDispatcher(event)
    g.app.gui.event_generate(w,'&lt;Key&gt;',keysym=number)
    return 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
</t>
<t tx="ekr.20061031131434.119">def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
</t>
<t tx="ekr.20061031131434.12">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
</t>
<t tx="ekr.20061031131434.121">def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()

    data = [] ; n1 = 4 ; n2 = 20
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3) for s1,s2,s3 in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit(event)
</t>
<t tx="ekr.20061031131434.123">def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    # g.trace('stroke',repr(stroke),'commandName',commandName,'w',w,g.callers())

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(w,stroke)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.trace(message,color='red')
</t>
<t tx="ekr.20061031131434.127">def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return


    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.bunch(c=c,keysym='',char='',widget=None)
        k.masterCommand(event,func,stroke)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
</t>
<t tx="ekr.20061031131434.128">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
</t>
<t tx="ekr.20061031131434.129">k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20061031131434.13">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
</t>
<t tx="ekr.20061031131434.130">def keyboardQuit (self,event,hideTabs=True,setDefaultStatus=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    c.endEditing()
    c.bodyWantsFocus()

    if setDefaultStatus:
        # At present, only the auto-completer suppresses this.
        k.setDefaultInputState()
        k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.131">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20061031131434.133">def setInputState (self,state):

    k = self
    k.unboundKeyAction = state



</t>
<t tx="ekr.20061031131434.135">def minibufferWantsFocus(self):

    c = self.c
    c.widgetWantsFocus(c.miniBufferWidget)


def minibufferWantsFocusNow(self):

    c = self.c
    c.widgetWantsFocusNow(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.14">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;
    trace = False and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        done,b = k.doPlainKey(event,stroke,w)
        if b: k.masterCommand(event,b.func,b.stroke,b.commandName)
        if done: return 'break'

    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        return k.handleUnboundKeys(event,char,keysym,stroke)
</t>
<t tx="ekr.20061031131434.147">k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
stroke = event.stroke ### 2010/10/18
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
</t>
<t tx="ekr.20061031131434.15">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    if not g.unitTesting:
        s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
        g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if not g.unitTesting:
        s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
        g.es(s,color='red')
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
</t>
<t tx="ekr.20061031131434.153">def masterClickHandler (self,event,func=None):

    g.app.gui.killPopupMenu()

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i &lt;= x &lt;= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061031131434.154">def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
</t>
<t tx="ekr.20061031131434.155">def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
</t>
<t tx="ekr.20061031131434.158">def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    k = self ; c = k.c

    for commandName in d:
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
</t>
<t tx="ekr.20061031131434.159">def endMode(self,event):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20061031131434.16"></t>
<t tx="ekr.20061031131434.160">def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">def exitNamedMode (self,event):

    k = self

    if k.inState():
        k.endMode(event)

    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.162">def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = False or c.config.getBool('trace_modes')

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode(event)
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.widget = k.modeWidget
            else:
                event = g.Bunch(widget = k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return 'break'

    return 'break'
</t>
<t tx="ekr.20061031131434.163">def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = c.config.getBool('trace_modes')

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        prompt = d.get('*command-prompt*') or modeName
        if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))

    k.inputModeName = modeName
    k.silentMode = False

    entryCommands = d.get('*entry-commands*',[])
    if entryCommands:
        for commandName in entryCommands:
            if trace: g.trace('entry command:',commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode',commandName)
                return

    # Create bindings after we know whether we are in silent mode.
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)
    k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)

</t>
<t tx="ekr.20061031131434.165">def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    g.trace(k.inputModeName)

    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if not k.silentMode:
        c.minibufferWantsFocus()

    return 'break'
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data = [] ; n = 20
    for key in sorted(d):
        if key not in ( '*entry-commands*','*command-prompt*'):
            bunchList = d.get(key)
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut not in (None,'None'):
                    s1 = key ; s2 = k.prettyPrintKey(shortcut,brief=True)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()

    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'): modeName = modeName[:-4].strip()

    g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
</t>
<t tx="ekr.20061031131434.167"></t>
<t tx="ekr.20061031131434.168">def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    keysym = gui.eventKeysym(event)
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocusNow()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif keysym in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return 'break'
</t>
<t tx="ekr.20061031131434.169">k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
</t>
<t tx="ekr.20061031131434.17">def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
</t>
<t tx="ekr.20061031131434.170">def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) &gt; len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) &gt; len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
</t>
<t tx="ekr.20061031131434.171">def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
</t>
<t tx="ekr.20061031131434.172">def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
</t>
<t tx="ekr.20061031131434.173"># This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
</t>
<t tx="ekr.20061031131434.174">def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
</t>
<t tx="ekr.20061031131434.175"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        aList = '\n'.join(
            ['%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3)
                for s1,s2,s3 in data])
        g.es('',aList,tabName=tabName)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict:
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                #pane = g.choose(b.pane=='all','','%s:' % (b.pane))
                pane = '%s:' % (b.pane)
                data = (pane,shortcut)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [b.commandName] = shortcutList

    return d
</t>
<t tx="ekr.20061031131434.177"># Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c ; w = self.widget

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()

    if trace: g.trace('ins',ins,'k.mb_prefix',repr(k.mb_prefix),
        'w',w)

    if ins &lt;= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
</t>
<t tx="ekr.20061031131434.178"># Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex &gt;= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20061031131434.179">def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return k.tkbindingFromStroke(key)
    return ''

def getShortcutForCommand (self,command):

    k = self ; c = k.c

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                     return k.tkbindingFromStroke(key)
    return ''
</t>
<t tx="ekr.20061031131434.18">def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20061031131434.180">def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui

    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')

    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,shortcut,bunch.commandName,gui.widget_name(w))
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('&lt;') and shortcut.endswith('&gt;'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
</t>
<t tx="ekr.20061031131434.184">def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
</t>
<t tx="ekr.20061031131434.185">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0
meta  = s2.find("meta") &gt;= 0
</t>
<t tx="ekr.20061031131434.186">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
</t>
<t tx="ekr.20061031131434.187"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
</t>
<t tx="ekr.20061031131434.188">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20061031131434.189">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
</t>
<t tx="ekr.20061031131434.19">def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
</t>
<t tx="ekr.20061031131434.190">def tkbindingFromStroke (self,stroke):

    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''

    stroke = g.stripBrackets(stroke)

    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl-','Control-'),
        ('Ctrl+','Control-'), # New in Leo 4.5.
        ('Meta+','Meta-'), # New in Leo 4.6
        ('Shift+','Shift-'),
        ('Command+','Command-'),
        ('DnArrow','Down'), # New in Leo 4.5.
        ('LtArrow','Left'), # New in Leo 4.5.
        ('RtArrow','Right'),# New in Leo 4.5.
        ('UpArrow','Up'),   # New in Leo 4.5.
    ):
        stroke = stroke.replace(a,b)

    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey (self,stroke,brief=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    # g.trace(stroke,s)
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState (self):

    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler (self):

    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState (self,kind):

    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind (self):

    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
</t>
<t tx="ekr.20061031131434.199">def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.2">@nocolor
@

Here are the rules for translating key bindings (in leoSettings.leo)
into keys for k.bindingsDict:

1. The case of plain letters is significant: a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore
   (with a warning) the shift prefix applied to any other binding,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is
   *not* significant. Thus, the Shift- prefix is required if you want
   an upper-case letter (with the exception of 'bare' uppercase
   letters.)

The following table illustrates these rules. In each row, the first
entry is the key (for k.bindingsDict) and the other entries are
equivalents that the user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is
consistent with Tk's key-event specifiers). It is also, I think, the
least confusing set of rules.
</t>
<t tx="ekr.20061031131434.20">def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;

    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    # s = s.rstrip(')') # Not so convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20061031131434.200">def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    &lt;&lt; about repeat counts &gt;&gt;

    k = self ; gui = g.app.gui
    state = k.getState('u-arg')

    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        keysym = gui.eventKeysym(event)
        # g.trace(state,keysym)
        if keysym == 'Escape':
            k.keyboardQuit(event)
        elif keysym == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif keysym.isdigit() or keysym == '-':
            k.updateLabel(event)
        elif keysym in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n,stroke=keysym)
            k.keyboardQuit(event)
            # k.clearState()
            # k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
</t>
<t tx="ekr.20061031131434.201">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061031131434.202">def executeNTimes (self,event,n,stroke):

    trace = False and not g.unitTesting
    k = self

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        b = k.getPaneBinding(stroke,event.widget)
        if b:
            if trace: g.trace('repeat',n,'method',b.func.__name__,
                'stroke',stroke,'widget',event.widget)
            for z in range(n):
                # event = g.Bunch(
                    # c = self.c,
                    # widget = event.widget,
                    # keysym = event.keysym,
                    # stroke = event.stroke,
                    # char = event.char,
                # )
                k.masterCommand(event,b.func,'&lt;%s&gt;' % stroke)
        else:
            # This does nothing for Qt gui.
            w = event.widget
            for z in range(n):
                g.app.gui.event_generate(w,'&lt;Key&gt;',keysym=event.keysym)
</t>
<t tx="ekr.20061031131434.203">def doControlU (self,event,stroke):

    k = self ; c = k.c
    ch = g.app.gui.eventChar(event)

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061031131434.21"># The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i &gt; -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
</t>
<t tx="ekr.20061031131434.22">isStringMethod = (
    self.prevObjects and
    # type(self.prevObjects[-1]) == types.StringType
    g.isString(self.prevObjects[-1]))

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
</t>
<t tx="ekr.20061031131434.23">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
</t>
<t tx="ekr.20061031131434.24">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
</t>
<t tx="ekr.20061031131434.25">junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
</t>
<t tx="ekr.20061031131434.26">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
</t>
<t tx="ekr.20061031131434.27">def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
</t>
<t tx="ekr.20061031131434.28">def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        g.es('','\n'.join(self.tabList),tabName=self.tabName)
</t>
<t tx="ekr.20061031131434.29">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(autocompleter)',
        self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 &lt;= i-1 &lt; len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
</t>
<t tx="ekr.20061031131434.3">@nocolor
@
ivars:

c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
</t>
<t tx="ekr.20061031131434.30">def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20061031131434.31">def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20061031131434.33">def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i &gt; 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
</t>
<t tx="ekr.20061031131434.34">def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
</t>
<t tx="ekr.20061031131434.35"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
</t>
<t tx="ekr.20061031131434.36">def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 &lt;= i &lt; start and i &lt;len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
</t>
<t tx="ekr.20061031131434.37">def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
</t>
<t tx="ekr.20061031131434.38">def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
</t>
<t tx="ekr.20061031131434.39">def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20061031131434.4">class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20061031131434.40">def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
</t>
<t tx="ekr.20061031131434.41">def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = list(sys.modules.keys())
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
</t>
<t tx="ekr.20061031131434.42">def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
</t>
<t tx="ekr.20061031131434.43">def completeSelf (self):

    g.trace(g.callers(4))

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfVnodesDict [p.v] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20061031131434.44">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20061031131434.45">def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor(c.p,incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20061031131434.46">def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i &gt; 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
</t>
<t tx="ekr.20061031131434.49">def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
</t>
<t tx="ekr.20061031131434.5">def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfVnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
</t>
<t tx="ekr.20061031131434.57"></t>
<t tx="ekr.20061031131434.58">def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
</t>
<t tx="ekr.20061031131434.59">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) # Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
</t>
<t tx="ekr.20061031131434.6">def defineClassesDict (self):

    trace = False ; verbose = True

    self.allClassesDict = {}

    # gc may not exist.
    try:
        import gc
        # if trace: g.trace(gc)
    except ImportError:
        if trace: g.trace('no gc')
        return

    if g.isPython3:
        count = 0
        for z in gc.get_objects():
            try:
                name = z.__class__.__name__
                if not self.allClassesDict.get(name):
                    self.allClassesDict [name] = z
                    count += 1
            except ReferenceError:
                pass
        if trace:
            g.trace('%s keys in allClassesDict' % (count))
            if verbose:
                keys = list(self.allClassesDict.keys())
                keys.sort()
                for z in keys:
                    print(z)
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('&lt;class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
</t>
<t tx="ekr.20061031131434.60">class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
</t>
<t tx="ekr.20061031131434.61">def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
</t>
<t tx="ekr.20061031131434.62">def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


</t>
<t tx="ekr.20061031131434.63">def forgivingParser (self,p,suppress=False):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            if not g.isPython3:
                s = g.toEncodedString(s)
            compile(s+'\n','&lt;string&gt;','exec')
            break
        except SyntaxError:
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                if not suppress:
                    g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.h)
                self.excludedTnodesList.append(p.v)
                s = g.getScript(c,root,useSelectedText=False)
        except Exception:
            g.trace('unexpected exception')
            g.es_exception()
            break
    return s or ''
</t>
<t tx="ekr.20061031131434.64">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    # vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        # lines, n, root, scriptFind = True)

    goto = goToLineNumber(c)
    vnodeName,junk,junk,junk = goto.findVnode(
        root,lines,n,ignoreSentinels)

    if vnodeName:
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                return p

    return None
</t>
<t tx="ekr.20061031131434.65">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.h)
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
</t>
<t tx="ekr.20061031131434.66">class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
</t>
<t tx="ekr.20061031131434.67">def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
</t>
<t tx="ekr.20061031131434.68">def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.p)
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
</t>
<t tx="ekr.20061031131434.69">def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents():
        obj = autoCompleter.selfVnodesDict.get(p.v)
        if obj:
            # g.trace('found',obj,'in',p.h)
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.h)
            return className,None,p

    return None,None,None
</t>
<t tx="ekr.20061031131434.7">def defineObjectDict (self,table=None):

    trace = False

    c = self.c ; k = c.k ; p = c.p

    if trace: g.trace(g.callers(4))

    if table is None: table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p.copy()), # 2009/12/21
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        # (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if trace: g.trace(z,obj)
            if obj:
                self.objectDict[z]=obj
</t>
<t tx="ekr.20061031131434.70">def findClass (self,p):

    lines = g.splitLines(p.b)
    inDoc = self.start_in_doc
    # g.trace(p.h)
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
</t>
<t tx="ekr.20061031131434.71">def endsDoc (self,s):

    return s.startswith('@c')
</t>
<t tx="ekr.20061031131434.72">def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
</t>
<t tx="ekr.20061031131434.73">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
</t>
<t tx="ekr.20061031131434.74">class keyHandlerClass:

    '''A class to support emacs-style commands.'''

    # Gui-independent class vars.

    global_killbuffer = []
        # Used only if useGlobalKillbuffer arg to Emacs ctor is True.
        # Otherwise, each Emacs instance has its own local kill buffer.

    global_registers = {}
        # Used only if useGlobalRegisters arg to Emacs ctor is True.
        # Otherwise each Emacs instance has its own set of registers.

    lossage = []
        # A case could be made for per-instance lossage, but this is not supported.

    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.widget = c.frame.miniBufferWidget
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
</t>
<t tx="ekr.20061031131434.78">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
</t>
<t tx="ekr.20061031131434.79">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
</t>
<t tx="ekr.20061031131434.8"></t>
<t tx="ekr.20061031131434.80">def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''

    k = self ; c = k.c
    # g.trace('keyHandler')
    k.createInverseCommandsDict()

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    k.command_mode_bg_color = c.config.getColor('command_mode_bg_color') or bg
    k.command_mode_fg_color = c.config.getColor('command_mode_fg_color') or fg
    k.insert_mode_bg_color = c.config.getColor('insert_mode_bg_color') or bg
    k.insert_mode_fg_color = c.config.getColor('insert_mode_fg_color') or fg
    k.overwrite_mode_bg_color = c.config.getColor('overwrite_mode_bg_color') or bg
    k.overwrite_mode_fg_color = c.config.getColor('overwrite_mode_fg_color') or fg
    k.unselected_body_bg_color = c.config.getColor('unselected_body_bg_color') or bg
    k.unselected_body_fg_color = c.config.getColor('unselected_body_fg_color') or bg    

    # g.trace(k.insert_mode_bg_color,k.insert_mode_fg_color)

    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.81">def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    # g.trace(self.unboundKeyAction)

    self.defaultUnboundKeyAction = self.unboundKeyAction

    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    &lt;&lt; give warning and return if we try to bind to Enter or Leave &gt;&gt;
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        &lt;&lt; remove previous conflicting definitions from bunchList &gt;&gt;
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
</t>
<t tx="ekr.20061031131434.9">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return 'break'

    self.language = g.scanForAtLanguage(c,c.p)
    if w and self.language == 'python' and (k.enable_autocompleter or force):
        self.start(event=event,w=w)

    return 'break'
</t>
<t tx="ekr.20061031131434.90">if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
</t>
<t tx="ekr.20061031131434.92">if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict (self,pane,stroke,func,commandName):

    k = self
    d =  k.masterBindingsDict.get(pane,{})

    stroke = g.stripBrackets(stroke)

    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__))

    # New in Leo 4.4.1: Allow redefintions.
    d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
    k.masterBindingsDict [pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
</t>
<t tx="ekr.20061031131434.95">def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,'Alt+Key-4' in d)

    for stroke in d:
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
</t>
<t tx="ekr.20061031132712.1"># g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color # Do not call oops: this method is essential for the config classes.
</t>
<t tx="ekr.20061031132907">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    # g.trace('baseGui','kind',kind,'args,keys',*args,**keys)
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventStroke (self,event,c=None):
    return event and hasattr(event,'stroke') and event.stroke or ''

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
</t>
<t tx="ekr.20061031170011.10">def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.widget
    if not w: return

    w.setBackgroundColor(self.minibuffer_background_color) # 'lightblue')

    if label is not None:
        k.setLabel(label,protect)
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return

    w.setBackgroundColor(self.minibuffer_warning_color) # 'lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange (self):

    k = self ; w = self.widget
    trace = self.trace_minibuffer and not g.app.unitTesting

    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)

    trace and g.trace(i,j)
    return i,j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel (self,ignorePrompt=False):

    k = self ; w = self.widget
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel (self):

    k = self ; w = self.widget
    if not w: return

    k.mb_prefix = w.getAllText()

</t>
<t tx="ekr.20061031170011.7">def resetLabel (self):

    k = self ; w = self.widget
    k.setLabelGrey('')
    k.mb_prefix = ''

    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        k.setLabelBlue(label='%s State' % (state.capitalize()),protect=True)
</t>
<t tx="ekr.20061031170011.8">def setLabel (self,s,protect=False):

    trace = (False or self.trace_minibuffer) and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if trace: g.trace(repr(s),g.callers(4))

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self,s,select=False,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('len(s)',len(s))
    if not s: return

    c.widgetWantsFocusNow(w)
    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061031173016">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    self.oops()

    # import leo.core.leoKeys as leoKeys # Do this here to break a circular dependency.

    # return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
</t>
<t tx="ekr.20061101071425">def oops (self):

    g.trace('Should be defined in subclass:',g.callers(4))
</t>
<t tx="ekr.20061103114242">c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
</t>
<t tx="ekr.20061106105812.1"># Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body)
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
</t>
<t tx="ekr.20061109095450.8">def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if not c.p: return

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
</t>
<t tx="ekr.20061109102912">mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasTextSelection',
    'oops',
    'onBodyChanged',
    'onClick',
    'recolor',
    'recolor_now',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
    # Editors... (These may be overridden)
    # 'addEditor',
    # 'cycleEditorFocus',
    # 'deleteEditor',
    # 'selectEditor',
    # 'selectLabel',
    # 'unselectLabel',
    # 'updateEditors',
)
</t>
<t tx="ekr.20061109120704">mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
</t>
<t tx="ekr.20061109120726">mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
</t>
<t tx="ekr.20061109123828">def resizePanesToRatio (self,ratio,secondary_ratio):    pass
def setInitialWindowGeometry (self):                    pass
def setMinibufferBindings(self):                        pass
</t>
<t tx="ekr.20061109124129"># Expanding and contracting panes.
def contractPane         (self,event=None): pass
def expandPane           (self,event=None): pass
def contractBodyPane     (self,event=None): pass
def contractLogPane      (self,event=None): pass
def contractOutlinePane  (self,event=None): pass
def expandBodyPane       (self,event=None): pass
def expandLogPane        (self,event=None): pass
def expandOutlinePane    (self,event=None): pass
def fullyExpandBodyPane  (self,event=None): pass
def fullyExpandLogPane   (self,event=None): pass
def fullyExpandPane      (self,event=None): pass
def fullyExpandOutlinePane (self,event=None): pass
def hideBodyPane         (self,event=None): pass
def hideLogPane          (self,event=None): pass
def hidePane             (self,event=None): pass
def hideOutlinePane      (self,event=None): pass

# In the Window menu...
def cascade              (self,event=None): pass
def equalSizedPanes      (self,event=None): pass
def hideLogWindow        (self,event=None): pass
def minimizeAll          (self,event=None): pass
def resizeToScreen       (self,event=None): pass
def toggleActivePane     (self,event=None): pass
def toggleSplitDirection (self,event=None): pass

# In help menu...
def leoHelp (self,event=None): pass
</t>
<t tx="ekr.20061109124552"></t>
<t tx="ekr.20061109125528"></t>
<t tx="ekr.20061109125528.1"></t>
<t tx="ekr.20061109164512">mustBeDefinedOnlyInBaseClass = (
    # Getters &amp; setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
</t>
<t tx="ekr.20061109164610">mustBeDefinedInSubclasses = (
    # Colors &amp; fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing &amp; scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
</t>
<t tx="ekr.20061109165848"></t>
<t tx="ekr.20061109173021"></t>
<t tx="ekr.20061109173122"># Birth, death &amp; config
def createBindings (self,w=None):               self.oops()
def createControl (self,parentFrame,p):         self.oops()
def createTextWidget (self,parentFrame,p,name): self.oops() ; return None
def setColorFromConfig (self,w=None):           self.oops()
def setFontFromConfig (self,w=None):            self.oops()

# Editor
def createEditorFrame (self,w):             self.oops() ; return None
def createEditorLabel (self,pane):          self.oops()
def packEditorLabelWidget (self,w):         self.oops()
def setEditorColors (self,bg,fg):           self.oops()

# Events...
def scheduleIdleTimeRoutine (self,function,*args,**keys): self.oops()
</t>
<t tx="ekr.20061109211022">mustBeDefinedInSubclasses = (
    # Startup &amp; shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    'eventChar',
    'eventKeysym',
    'eventWidget',
    'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
</t>
<t tx="ekr.20061109211054">mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
</t>
<t tx="ekr.20061109212618"></t>
<t tx="ekr.20061109212618.1"></t>
<t tx="ekr.20061111084423.1">def oops(self):
    g.pr(("leoFind oops:",
        g.callers(10),"should be overridden in subclass"))
</t>
<t tx="ekr.20061111223516">def selectAllText (self,event):

    c = self.c 

    w = self.editWidget(event)
    if w:
        return w.selectAllText()
</t>
<t tx="ekr.20061113221414"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):

    c = self
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    # g.trace('index',index,'ch',repr(ch),'brackets',brackets)
    for n in range(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    else:
        return None
    # g.trace('index',index,'ch',repr(ch),'match_ch',repr(match_ch))
    level = 0
    while 1:
        if forward and index &gt;= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 &lt;= index &lt; len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level &lt;= 0:
                return index
        if not forward and index &lt;= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20061116054917.6"></t>
<t tx="ekr.20061116060847"></t>
<t tx="ekr.20061119061958">def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &amp;: e,r
    '&amp;execute-script',
    '&amp;run-unit-tests',
    ]
</t>
<t tx="ekr.20061119120006">def addIconButton (self,*args,**keys):
    if self.iconBar: return self.iconBar.add(*args,**keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self,w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar (self):
    if self.iconBar: self.iconBar.clear()

def createIconBar (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar (self):
    if self.iconBar: self.iconBar.hide()

def showIconBar (self):
    if self.iconBar: self.iconBar.show()
</t>
<t tx="ekr.20061212084717">class leoFind:

    """The base class for Leo's Find commands."""

    @others
</t>
<t tx="ekr.20061212092124">def createBindings (self):
    self.oops()

def createFrame (self,parent):
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
</t>
<t tx="ekr.20061212095134.1"></t>
<t tx="ekr.20070105092022.1">class searchWidget:

    '''A class to simulating a hidden Tk Text widget.'''

    def __repr__(self):
        return 'searchWidget id: %s' % (id(self))

    @others
</t>
<t tx="ekr.20070105092022.4">def toPythonIndex (self,i):

    '''Make sure i is a Python index.'''

    if i is None:
        return 0

    if g.isString(i):
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(self.s,row,col)
    elif type(i) == type(9):
        pass
    else:
        g.trace('can not happen: %s' % (i))
        i = 0 # Should never happen.

    return i
</t>
<t tx="ekr.20070105092438">def __init__ (self,*args,**keys):

    # g.trace ('searchWidget',g.callers())

    self.s = ''    # The widget text
    self.i = 0     # The insert point
    self.sel = 0,0 # The selection range
</t>
<t tx="ekr.20070105093138">def getAllText (self):          return self.s
def getInsertPoint (self):      return self.i       # Returns Python index.
def getSelectionRange(self):    return self.sel     # Returns Python indices.

</t>
<t tx="ekr.20070105102419">def delete(self,i,j=None):
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    else: j = self.toPythonIndex(j)
    self.s = self.s[:i] + self.s[j:]

def insert(self,i,s):
    if not s: return
    i = self.toPythonIndex(i)
    self.s = self.s[:i] + s + self.s[i:]
    self.i = i
    self.sel = i,i

def setAllText (self,s,new_p=None):
    self.s = s
    self.i = 0
    self.sel = 0,0

def setInsertPoint (self,i):
    self.i = i

def setSelectionRange (self,i,j,insert=None):
    self.sel = self.toPythonIndex(i),self.toPythonIndex(j)
    if insert is not None:
        self.i = self.toPythonIndex(insert)
</t>
<t tx="ekr.20070105123638">def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
</t>
<t tx="ekr.20070105123800">def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        # Bug fix: 2009-5-31.
        # None denotes that we use the present value of the option.
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)
</t>
<t tx="ekr.20070105165924">def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1

    if self.trace: g.trace(repr(s))
    return s
</t>
<t tx="ekr.20070115135502">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path,encoding='utf-8',mode='w')
        else:
            f = open(path,'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script_file_path'))
        path = None

    return path
</t>
<t tx="ekr.20070120123930">def CheckVersionToInt (s):

    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = ''.join(aList)
            return int(s)
        else:
            return 0
</t>
<t tx="ekr.20070123085931">def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&amp;" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        "&gt;" : "greater",
        "&lt;" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

</t>
<t tx="ekr.20070123092623">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leo.core.leoKeys as leoKeys # Do this here to break a circular dependency.

    return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
</t>
<t tx="ekr.20070123143428">def defineTkNames (self):

    k = self

    # These names are used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        'BackSpace','Begin','Break',
        'Caps_Lock','Clear',
        'Delete','Down',
        'End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'Home',
        'Left','Linefeed',
        'Next','Num_Lock',
        'Prior',
        'Return','Right',
        'Tab',
        'Up',
        # 'space',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace',
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to Tk. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
</t>
<t tx="ekr.20070130115927.4"></t>
<t tx="ekr.20070130115927.5">def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace(w,g.callers(5))
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
</t>
<t tx="ekr.20070130115927.6">def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070130115927.7">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    trace = False
    f = self ; c = f.c ; w = event and event.widget
    if trace: g.trace(w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    s = g.toUnicode(s)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070212070820">def makeScriptButton (self,c,
    args=None,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False, 
):

    self.oops()
</t>
<t tx="ekr.20070212145124">def getFullVersion (self,c=None):

    return 'leoGui: dummy version'
</t>
<t tx="ekr.20070215183046">@nocolor

- IronPython does not accept 'from __future__ import x'
  I could work around this, but perhaps it is time to abandon Python 2.2.2.

- Amazingly, it is possible to add Python24\Lib to IronPython's path!
  Almost all of those modules import correct.

- IronPython has troubles with the xml modules.
  It complains about a missing 'strict' codec.

- IronPython has trouble with the pdb module, so some other way must be found to debug IronPython programs.
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            b = d2.get(key2)
            g.pr('%20s %s' % (key2,b.commandName))
</t>
<t tx="ekr.20070219084912">def finishCreate (self):

    pass
</t>
<t tx="ekr.20070224075914">def doEnabledPlugins (self,p,kind,name,val):

    c = self.c
    s = p.b

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20070224075914.1">def getEnabledPlugins (self):

    '''Return the body text of the @enabled-plugins node.'''

    return g.app.config.enabledPluginsString
</t>
<t tx="ekr.20070224115832">def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeLeoDir, # was homeDir
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
</t>
<t tx="ekr.20070226113916">def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
</t>
<t tx="ekr.20070226121510">def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070227091955.1">@first #! /usr/bin/env python

'''A module to allow full access to Leo commanders from outside Leo.'''

@language python
@tabwidth -4

&lt;&lt; about the leoBridge module &gt;&gt;

gBridgeController = None # The singleton bridge controller.

# This module must import *no* modules at the outer level!

@others
</t>
<t tx="ekr.20070227091955.2">@nocolor
@

A **host** program is a Python program separate from Leo. Host programs may be
created by Leo, but at the time they are run host programs are not part of Leo in
any way. The leoBridge module gives host programs access to all aspects of Leo,
including all of Leo's source code, the contents of any .leo file, all
configuration settings in .leo files, etc.

Host programs will use the leoBridge module like this::
    import leo.core.leoBridge as leoBridge
    bridge = leoBridge.controller(gui='nullGui',verbose=False)
    if bridge.isOpen():
        g = bridge.globals()
        c = bridge.openLeoFile(path)
Notes:

- The leoBridge module imports no modules at the top level.

- leoBridge.controller creates a singleton *bridge controller* that grants
access to Leo's objects, including fully initialized g and c objects. In
particular, the g.app and g.app.gui vars are fully initialized.

- By default, leoBridge.controller creates a null gui so that no Leo windows
appear on the screen.

- As shown above, the host program should gain access to Leo's leoGlobals module
using bridge.globals(). The host program should not import leo.core.leoGlobals as leoGlobals directly.

- bridge.openLeoFile(path) returns a completely standard Leo commander. Host
programs can use these commanders as described in Leo's scripting chapter.
</t>
<t tx="ekr.20070227092442">def controller(gui='nullGui',loadPlugins=True,readSettings=True,verbose=False):

    '''Create an singleton instance of a bridge controller.'''

    global gBridgeController

    if not gBridgeController:
        gBridgeController = bridgeController(gui,loadPlugins,readSettings,verbose)

    return gBridgeController
</t>
<t tx="ekr.20070227092442.2">class bridgeController:

    '''Creates a way for host programs to access Leo.'''

    @others
</t>
<t tx="ekr.20070227092442.3">def __init__ (self,guiName,loadPlugins,readSettings,verbose):

    self.g = None
    self.gui = None
    self.guiName = guiName
    self.loadPlugins = loadPlugins
    self.readSettings = readSettings
    self.verbose = verbose

    self.mainLoop = False # True only if a non-null-gui mainloop is active.

    self.initLeo()
</t>
<t tx="ekr.20070227092442.4">def globals (self):

    '''Return a fully initialized leoGlobals module.'''

    return self.isOpen() and self.g
</t>
<t tx="ekr.20070227092442.5">def openLeoFile (self,fileName):

    '''Open a .leo file, or create a new Leo frame if no fileName is given.'''

    g = self.g

    useLog = True

    if self.isOpen():
        fileName = self.completeFileName(fileName)
        c = self.createFrame(fileName)

        if useLog:
            g.app.gui.log = log = c.frame.log
            log.isNull = False
            log.enabled = True

        # g.pr('createGui:','g.app:',id(g.app),g.app)
        # g.pr('createGui:','g.app.gui',g.app.gui)
        return c
    else:
        return None
</t>
<t tx="ekr.20070227093530">def initLeo (self):

    '''Init the Leo app to which this class gives access.
    This code is based on leo.run().'''

    if not self.isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    # 2010/09/09: create the g.app.pluginsController here.
    import leo.core.leoPlugins as leoPlugins
    leoPlugins.init() # Necessary. Sets g.app.pluginsController.
    g.computeStandardDirectories()
    if not self.getLeoID(): return
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.inBridge = True # Added 2007/10/21: support for g.getScript.
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    if self.readSettings:
        g.app.config.readSettingsFiles(None,verbose=self.verbose)
    self.createGui() # Create the gui *before* loading plugins.
    if self.verbose: self.reportDirectories()
    self.adjustSysPath()
    if self.loadPlugins:
        g.doHook("start1") # Load plugins.
    g.app.computeSignon()
    g.init_sherlock(args=[])
    g.app.initing = False
    g.doHook("start2",c=None,p=None,v=None,fileName=None)
</t>
<t tx="ekr.20070227093629.1"># Import leoGlobals, but do NOT set g.
try:
    import leo.core.leoGlobals as leoGlobals
except ImportError:
    print("Error importing leoGlobals.py")

# Create the application object.
try:
    import leo.core.leoApp as leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print("Error importing leoApp.py")

# NOW we can set g.
self.g = g = leoGlobals
assert(g.app)
g.app.leoID = None

# Set leoGlobals.g here, rather than in leoGlobals.
leoGlobals.g = leoGlobals
</t>
<t tx="ekr.20070227093629.2">try:
    import leo.core.leoNodes as leoNodes
except ImportError:
    print("Error importing leoNodes.py")
    import traceback ; traceback.print_exc()

try:
    import leo.core.leoConfig as leoConfig
except ImportError:
    print("Error importing leoConfig.py")
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20070227093629.4">def isValidPython(self):

    import sys

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leo.core.leoGlobals as g
        # print('leoBridge:isValidPython:g',g)
        # Set leoGlobals.g here, rather than in leoGlobals.py.
        leoGlobals = g # Don't set g.g, it would pollute the autocompleter.
        leoGlobals.g = g
    except ImportError:
        print("isValidPython: can not import leo.core.leoGlobals as leoGlobals")
        return 0
    except:
        print("isValidPytyhon: unexpected exception: import leo.core.leoGlobals as leoGlobals.py as g")
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print(message)
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print("isValidPython: unexpected exception: g.CheckVersion")
        import traceback ; traceback.print_exc()
        return 0
</t>
<t tx="ekr.20070227093629.5">def completeFileName (self,fileName):

    g = self.g

    if not (fileName and fileName.strip()): return ''

    import os

    fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    head,ext = g.os_path_splitext(fileName)
    if not ext: fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20070227093629.6">def createFrame (self,fileName):

    '''Create a commander and frame for the given file.
    Create a new frame if the fileName is empty or non-exisent.'''

    g = self.g

    trace = False

    if fileName.strip():
        if g.os_path_exists(fileName):
            if trace:
                import time ; t1 = time.time()
            # This takes a long time due to imports in c.__init__
            ok, frame = g.openWithFileName(fileName,None)
            if trace:
                t2 = time.time()
                g.trace('g.openWithFileName: %0.2fsec' % (t2-t1))
            if ok: return frame.c
        else:
            g.es_print('file not found', fileName,'creating new window')
    # Create a new frame. Unlike leo.run, this is not a startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)
    return c
</t>
<t tx="ekr.20070227093629.9">def reportDirectories (self):

    g = self.g

    for kind,theDir in (
        ("global config",g.app.globalConfigDir),
        ("home",g.app.homeDir),
    ):
        g.es('',kind,'directory','',':',theDir,color='blue')
</t>
<t tx="ekr.20070227093918">def isOpen (self):

    g = self.g

    return g and g.app and g.app.gui
</t>
<t tx="ekr.20070227094232">def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeLeoDir # Was homeDir.
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    &lt;&lt; try to get leoID from sys.leoID &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;
    return g.app.leoID
</t>
<t tx="ekr.20070227094232.1"># This would be set by in Python's sitecustomize.py file.

# Use hasattr &amp; getattr to suppress pylint warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.silentMode:
        g.es("leoID=",g.app.leoID,spaces=False,color='red')
</t>
<t tx="ekr.20070227094232.2">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s.strip()
                if verbose and not g.app.silentMode:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
</t>
<t tx="ekr.20070227094232.3">try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
</t>
<t tx="ekr.20070227095743">def createGui (self):

    g = self.g

    if self.guiName == 'nullGui':
        import leo.core.leoGui as leoGui
        import leo.core.leoFrame as leoFrame
        g.app.gui = leoGui.nullGui("nullGui")
        g.app.log = g.app.gui.log = log = leoFrame.nullLog()
        log.isNull = False
        log.enabled = True # Allow prints from nullLog.
    elif self.guiName == 'qt':
        import leo.plugins.qtGui as qtGui
        g.app.gui = qtGui.leoQtGui()
        print('qtGui created')
    else:
        assert False,'leoBridge.py: unsupported gui: %s' % self.guiName

</t>
<t tx="ekr.20070228074228">@others
</t>
<t tx="ekr.20070228074228.1">class stringTextWidget (baseTextWidget):

    '''A class that represents text as a Python string.'''

    @others
</t>
<t tx="ekr.20070228074228.2">def __init__ (self,c,name):

    # Init the base class
    baseTextWidget.__init__ (self,c=c,
        baseClassName='stringTextWidget',name=name,widget=None)

    self.ins = 0
    self.sel = 0,0
    self.s = ''
    self.trace = False
</t>
<t tx="ekr.20070228074228.3">def _appendText(self,s):
    #if self.trace: g.trace(self,'len(s)',len(s))
    if self.trace: g.trace(self,'ins',self.ins,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins,self.ins
def _get(self,i,j):                 return self.s[i:j]
def _getAllText(self):              return self.s
def _getFocus(self):                return self
def _getInsertPoint(self):
    # if self.trace: g.trace(self,self.ins)
    return self.ins
def _getLastPosition(self):         return len(self.s)
def _getSelectedText(self):         i,j = self.sel ; return self.s[i:j]
def _getSelectionRange(self):       return self.sel
def _getYScrollPosition(self):      return None # A flag.
def _hitTest(self,pos):             pass
def _insertText(self,i,s):
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    # if self.trace: g.trace(self,'s',repr(s),'self.s',repr(self.s))
    # if self.trace: g.trace(self,'i',i,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'i',i,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    i += len(s1)
    self.ins = i
    self.sel = i,i
def _scrollLines(self,n):           pass
def _see(self,i):                   pass
def _setAllText(self,s,new_p=None):
    if self.trace: g.trace(self,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i,i
def _setBackgroundColor(self,color): pass
def _setForegroundColor(self,color): pass
def _setFocus(self):                pass
def _setInsertPoint(self,i):
    if self.trace: g.trace(self,'i',i)
    self.ins = i
    self.sel = i,i
</t>
<t tx="ekr.20070228074312">class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
</t>
<t tx="ekr.20070228074312.1">def __init__ (self,c,baseClassName,name,widget,highLevelInterface=False):

    self.baseClassName = baseClassName
    self.c = c
    self.highLevelInterface = highLevelInterface
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

    # For unit testing.
    aList = g.choose(highLevelInterface,
        self.mustBeDefinedInHighLevelSubclasses,
        self.mustBeDefinedInLowLevelSubclasses)
    self.mustBeDefinedInSubclasses.extend(aList)
    # g.trace(g.listToString(self.mustBeDefinedInSubclasses))

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))
</t>
<t tx="ekr.20070228074312.10">def appendText (self,s):

    w = self
    w._appendText(s)
</t>
<t tx="ekr.20070228074312.12">def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
</t>
<t tx="ekr.20070228074312.13">def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
</t>
<t tx="ekr.20070228074312.14">def deleteTextSelection (self):

    i,j = self.getSelectionRange()
    self.delete(i,j)
</t>
<t tx="ekr.20070228074312.15">def event_generate(self,stroke):

    trace = False
    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    if trace: g.trace('baseTextWidget','char',char,'stroke',stroke,'w',w)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
    c.outerUpdate()
</t>
<t tx="ekr.20070228074312.17">def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
</t>
<t tx="ekr.20070228074312.18">def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s)
</t>
<t tx="ekr.20070228074312.19">def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s)
</t>
<t tx="ekr.20070228074312.2"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)
        c.outerUpdate()
</t>
<t tx="ekr.20070228074312.20">def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
</t>
<t tx="ekr.20070228074312.21">def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s)
</t>
<t tx="ekr.20070228074312.22">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20070228074312.23">def getYScrollPosition (self):

    w = self
    return w._getYScrollPosition()
</t>
<t tx="ekr.20070228074312.25">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20070228074312.26"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
</t>
<t tx="ekr.20070228074312.28">def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
</t>
<t tx="ekr.20070228074312.29">def scrollLines (self,n):

    w = self
    w._scrollLines(n)
</t>
<t tx="ekr.20070228074312.30">def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
</t>
<t tx="ekr.20070228074312.31">def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
</t>
<t tx="ekr.20070228074312.32">def setAllText (self,s,new_p=None):

    w = self
    w._setAllText(s,new_p=new_p)
</t>
<t tx="ekr.20070228074312.33">def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor
</t>
<t tx="ekr.20070228074312.34">def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
</t>
<t tx="ekr.20070228074312.35">def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
</t>
<t tx="ekr.20070228074312.36">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
</t>
<t tx="ekr.20070228074312.38">def setYScrollPosition (self,i):

    w = self
    w._setYScrollPosition(i)
</t>
<t tx="ekr.20070228074312.5">def oops (self):

    g.pr('baseTextWidget oops:',self,g.callers(4),
        'must be overridden in subclass')
</t>
<t tx="ekr.20070228074312.7">def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex
</t>
<t tx="ekr.20070228074312.8"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
</t>
<t tx="ekr.20070228080627">def getAllText (self):                  return self.bodyCtrl.getAllText()
def getInsertPoint(self):               return self.bodyCtrl.getInsertPoint()
def getSelectedText (self):             return self.bodyCtrl.getSelectedText()
def getSelectionRange (self,sort=True): return self.bodyCtrl.getSelectionRange(sort)
def hasTextSelection (self):            return self.bodyCtrl.hasSelection()
# def scrollDown (self):                g.app.gui.yscroll(self.bodyCtrl,1,'units')
# def scrollUp (self):                  g.app.gui.yscroll(self.bodyCtrl,-1,'units')
def see (self,index):                   self.bodyCtrl.see(index)
def seeInsertPoint (self):              self.bodyCtrl.seeInsertPoint()
def selectAllText (self,event=None): # This is a command.
    return self.bodyCtrl.selectAllText()
def setInsertPoint (self,pos):          return self.bodyCtrl.setInsertPoint(pos) # was getInsertPoint.
def setFocus(self):                     return self.bodyCtrl.setFocus()
def setSelectionRange (self,sel):       i,j = sel ; self.bodyCtrl.setSelectionRange(i,j)
</t>
<t tx="ekr.20070228102413">def GetName(self):

    return self.name

getName = GetName
</t>
<t tx="ekr.20070228111853">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    self.sel = i,j

    if insert is not None: 
        self.ins = w.toPythonIndex(insert)
    else:
        self.ins = j

    if self.trace: g.trace('i',i,'j',j,'insert',repr(insert))
</t>
<t tx="ekr.20070228154059"></t>
<t tx="ekr.20070228155807">def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,leoFrame.baseTextWidget)
</t>
<t tx="ekr.20070228160107">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,stroke=None):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.state  = hasattr(event,'state') and event.state or 0
        self.stroke = hasattr(event,'stroke') and event.stroke or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        if stroke and not self.stroke:
            self.stroke = self.actualEvent.stroke = stroke

        self.widget = self.w

    def __repr__ (self):

        if self.stroke:
            return 'leoGui.leoKeyEvent: stroke: %s' % (repr(self.stroke))
        else:
            return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (
                repr(self.char),repr(self.keysym))
</t>
<t tx="ekr.20070228160345">def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # g.trace('p',p.h,'s',repr(s),g.callers())

    w = self.edit_widget(p)
    if w:
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
</t>
<t tx="ekr.20070228163350">def getFont(self):
    return self.font

# def setColorFromConfig (self):
    # pass

def setBindings (self):
    pass

def setFont(self,font=None,fontName=None):
    self.font,self.fontName = font,fontName

def setFontFromConfig (self):
    pass
</t>
<t tx="ekr.20070228163350.1">def drawIcon(self,p):
    pass

def redraw(self,p=None,scroll=True,forceDraw=False):
    self.redrawCount += 1

def redraw_now(self,p=None,scroll=True,forceDraw=False):
    self.redrawCount += 1

def redraw_after_contract(self,p=None):         self.redraw()
def redraw_after_expand(self,p=None):           self.redraw()
def redraw_after_head_changed(self):            self.redraw()
def redraw_after_icons_changed(self,all=False): self.redraw()
def redraw_after_select(self,p=None):           self.redraw()

def scrollTo(self,p):
    pass

def select (self,p,scroll=True):
    pass
</t>
<t tx="ekr.20070228163350.2">def edit_widget (self,p):
    d = self.editWidgetsDict
    if not p.v:
        return None
    w = d.get(p.v)
    if not w:
        d[p.v] = w = stringTextWidget(
            c=self.c,
            name='head-%d' % (1 + len(list(d.keys()))))
        w.setAllText(p.h)
    # g.trace('w',w,'p',p.h)
    return w

def headWidth(self,p=None,s=''):
    return len(s)

def setEditLabelState(self,v,selectAll=False):
    pass

def setSelectedLabelState(self,p):
    pass

def setUnselectedLabelState(self,p):
    pass
</t>
<t tx="ekr.20070228164730">def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    c = self.c

    self.endEditLabel()
    self.setEditPosition(p)
        # That is, self._editPosition = p

    if p:
        self.revertHeadline = p.h
            # New in 4.4b2: helps undo.
</t>
<t tx="ekr.20070228173611">def printWidgets(self):

    d = self.editWidgetsDict

    for key in d:
        # keys are vnodes, values are stringTextWidgets.
        w = d.get(key)
        g.pr('w',w,'v.h:',key.headString,'s:',repr(w.s))

</t>
<t tx="ekr.20070301164543">class nullIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
</t>
<t tx="ekr.20070301164543.1">def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
    self.w = g.nullObject()
</t>
<t tx="ekr.20070301164543.2">def add(self,*args,**keys):

    '''Add a (virtual) button to the (virtual) icon bar.'''

    command = keys.get('command')
    text = keys.get('text')
    try:    g.app.iconWidgetCount += 1
    except: g.app.iconWidgetCount = 1
    n = g.app.iconWidgetCount
    name = 'nullButtonWidget %d' % n

    if not command:
        def commandCallback(name=name):
            g.pr("command for %s" % (name))
        command = commandCallback

    class nullButtonWidget:
        def __init__ (self,c,command,name,text):
            self.c = c
            self.command = command
            self.name = name
            self.text = text
        def __repr__ (self):
            return self.name
        def bind(self,*args,**keys):
            pass
        def cget(self,*args,**keys):
            pass
        def configure (self,*args,**keys):
            pass
        def pack (self,*args,**keys):
            pass

    b = nullButtonWidget(self.c,command,name,text)
    return b
</t>
<t tx="ekr.20070301165343">def addRow(self,height=None):
    pass

def addWidget (self,w):
    pass

def clear(self):
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []

def deleteButton (self,w):
    pass

def getFrame (self):
    return None

def getNewFrame (self):
    return None

def pack (self):
    pass

def setCommandForButton(self,b,command):
    b.command = command

def unpack (self):
    pass

hide = unpack
show = pack
</t>
<t tx="ekr.20070301171901">def alert (self,message):
    pass

def attachLeoIcon (self,w):
    pass

def createRootWindow(self):
    pass

def destroySelf (self):
    pass

def finishCreate (self):
    pass

def getIconImage (self, name):
    return None

def getTreeImage(self,c,path):
    return None

def getTextFromClipboard (self):
    return self.clipboardContents

def get_focus(self,frame=None):
    if not frame: return None
    return self.focusWidget or (hasattr(frame,'body') and frame.body.bodyCtrl) or None 

def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.defaultFont

def get_window_info (self,window):
    return 0,0,0,0

def replaceClipboardWith (self,s):
    self.clipboardContents = s

def set_focus(self,commander,widget):
    self.focusWidget = widget
</t>
<t tx="ekr.20070301172456">def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a find tab in the indicated frame."""
    return leoFind.nullFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.nullFrame(title,gui)
    return self.lastFrame
</t>
<t tx="ekr.20070302061713">def adjustSysPath (self):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    g = self.g

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test') # 2008/7/30

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070302090616">class nullFindTab (findTab):

    @others
</t>
<t tx="ekr.20070302090616.1"></t>
<t tx="ekr.20070302090616.10">def createFindChangeAreas (self):

    c = self.c

    # A plainTextWidget must be a stringTextWidget
    plainTextWidget = g.app.gui.plainTextWidget

    import leo.core.leoFrame as leoFrame
    assert issubclass(plainTextWidget,leoFrame.stringTextWidget)

    self.find_ctrl   = plainTextWidget(c,name='find-text')
    self.change_ctrl = plainTextWidget(c,name='change-text')
</t>
<t tx="ekr.20070302090616.12">def createBoxes (self):

    '''Create two columns of radio buttons &amp; check boxes.'''

    c = self.c
    # f = self.parentFrame
    self.boxes = []
    self.widgetsDict = {} # Keys are ivars, values are checkboxes or radio buttons.

    data = ( # Leading star denotes a radio button.
        ('Whole &amp;Word', 'whole_word',),
        ('&amp;Ignore Case','ignore_case'),
        ('Wrap &amp;Around','wrap'),
        ('&amp;Reverse',    'reverse'),
        ('Rege&amp;xp',     'pattern_match'),
        ('Mark &amp;Finds', 'mark_finds'),
        ("*&amp;Entire Outline","entire-outline"),
        ("*&amp;Suboutline Only","suboutline-only"),  
        ("*&amp;Node Only","node-only"),
        ('Search &amp;Headline','search_headline'),
        ('Search &amp;Body','search_body'),
        ('Mark &amp;Changes','mark_changes'),
    )

    # Important: changing these controls merely changes entries in self.svarDict.
    # First, leoFind.update_ivars sets the find ivars from self.svarDict.
    # Second, self.init sets the values of widgets from the ivars.
    # inGroup = False
    for label,ivar in data:
        if label.startswith('*'):
            label = label[1:]
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
        else:
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
        self.boxes.append(w)
</t>
<t tx="ekr.20070302090616.14">def createButtons (self):

    '''Create two columns of buttons.'''

    # # Create the alignment panes.
    # buttons  = Tk.Frame(outer,background=bg)
    # buttons1 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons2 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons.pack(side='top',expand=1)
    # buttons1.pack(side='left')
    # buttons2.pack(side='right')

    # width = 15 ; defaultText = 'Find' ; buttons = []

    # for text,boxKind,frame,callback in (
        # # Column 1...
        # ('Find','button',buttons1,self.findButtonCallback),
        # ('Find All','button',buttons1,self.findAllButton),
        # # Column 2...
        # ('Change','button',buttons2,self.changeButton),
        # ('Change, Then Find','button',buttons2,self.changeThenFindButton),
        # ('Change All','button',buttons2,self.changeAllButton),
    # ):
        # w = underlinedTkButton(boxKind,frame,
            # text=text,command=callback)
        # buttons.append(w)
        # if text == defaultText:
            # w.button.configure(width=width-1,bd=4)
        # elif boxKind != 'check':
            # w.button.configure(width=width)
        # w.button.pack(side='top',anchor='w',pady=2,padx=2)
</t>
<t tx="ekr.20070302090616.15">def createBindings (self):
    pass
</t>
<t tx="ekr.20070302090616.16"># This is the same as the Tk code because we simulate Tk svars.
</t>
<t tx="ekr.20070302090616.17">def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20070302090616.18">def setOption (self,ivar,val):

    trace = False and not g.unitTesting

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            if trace: g.trace('nullFindTab: %s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070302090616.19">def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070302090616.2">if 0: # Use the base-class ctor.

    def __init__ (self,c,parentFrame):

        findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings &amp; init(c), in that order.
</t>
<t tx="ekr.20070302090616.3"># Called from findTab.ctor.

def initGui (self):

    self.svarDict = {} # Keys are ivar names, values are svar objects.

    for key in self.intKeys:
        self.svarDict[key] = self.svar() # Was Tk.IntVar.

    for key in self.newStringKeys:
        self.svarDict[key] = self.svar() # Was Tk.StringVar.
</t>
<t tx="ekr.20070302090616.4"># Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;
    &lt;&lt; set checkboxes from ivars &gt;&gt;
</t>
<t tx="ekr.20070302090616.5">self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
</t>
<t tx="ekr.20070302090616.6"># In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        # w = d.get(key)
        # if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = ivar = 'entire-outline'
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
    # self.svarDict["radio-search-scope"].set(key)
    # w = self.widgetsDict.get(key)
    # if w: w.set(True)
</t>
<t tx="ekr.20070302090616.7">for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    svar = self.svarDict[ivar].get()
    if svar:
        svar.set(True)
        # w = self.widgetsDict.get(ivar)
        # if w: w.set(True)
</t>
<t tx="ekr.20070302090616.8">class svar:
    '''A class like Tk's IntVar and StringVar classes.'''
    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.
</t>
<t tx="ekr.20070302090616.9">def createFrame (self,parentFrame):

    self.parentFrame = self.top = parentFrame

    self.createFindChangeAreas()
    self.createBoxes()
</t>
<t tx="ekr.20070302092907">class buttonWidget:

    '''A class to simulate a Tk.Button.'''

    def __init__ (self,label):
        self.label = label
        self.val = False

    def __repr (self):
        return 'nullFindTab.buttonWidget: %s' % self.label

    def get (self):
        return self.val

    def set (self,val):
        self.val = val
</t>
<t tx="ekr.20070302094848.1">def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    if w: w.delete(0,'end')
</t>
<t tx="ekr.20070302094848.10">def renameTab (self,oldName,newName):
    pass
</t>
<t tx="ekr.20070302094848.11">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c
    tabFrame = self.frameDict.get(tabName)
    if not tabFrame:
        self.createTab(tabName,createText=createText)

    # Update the status vars.
    self.tabName = tabName
    self.canvasCtrl = self.canvasDict.get(tabName)
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0:
        # Absolutely do not do this here!
        # It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)

    return tabFrame
</t>
<t tx="ekr.20070302094848.2">def createTab (self,tabName,createText=True,widget=None,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k

    if createText:
        w = self.createTextWidget(self.tabFrame)
        self.canvasDict [tabName] = None
        self.textDict [tabName] = w
    else:
        self.canvasDict [tabName] = None
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabName # tabFrame


</t>
<t tx="ekr.20070302094848.4">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)

    values = list(d.values())
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = list(d.keys())[i]
        self.selectTab(tabName)
        return 
</t>
<t tx="ekr.20070302094848.5">def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass
    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')
    else:
        for d in (self.canvasDict,self.textDict,self.frameDict):
            if tabName in d:
                del d[tabName]
        self.tabName = None
        self.selectTab('Log')

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070302094848.6">def hideTab (self,tabName):

    self.selectTab('Log')
</t>
<t tx="ekr.20070302094848.7">def getSelectedTab (self):

    return self.tabName
</t>
<t tx="ekr.20070302094848.8">def lowerTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070302094848.9">def numberOfVisibleTabs (self):

    return len([val for val in list(self.frameDict.values()) if val != None])
</t>
<t tx="ekr.20070302095121">def createTextWidget (self,parentFrame):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget(
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
</t>
<t tx="ekr.20070302095500"></t>
<t tx="ekr.20070302101023">def configure (self,*args,**keys):              pass
def configureBorder(self,border):               pass
def createControl (self,parentFrame):           pass
def createCanvas (self,tabName):                pass
def createTextWidget (self,parentFrame):        return None
def finishCreate (self):                        pass
def initAfterLoad (self):                       pass
def setColorFromConfig (self):                  pass
def setFontFromConfig (self):                   pass
def setTabBindings  (self,tabName):             pass
</t>
<t tx="ekr.20070302101304"># All output to the log stream eventually comes here.

def put (self,s,color=None,tabName='Log'):
    print (s)

def putnl (self,tabName='Log'):
    pass # print ('')
</t>
<t tx="ekr.20070302101344">def onActivateLog (self,event=None):

    self.c.setLog()

def disable (self):

    self.enabled = False

def enable (self,enabled=True):

    self.enabled = enabled

</t>
<t tx="ekr.20070302171509">class nullStatusLineClass:

    '''A do-nothing status line.'''

    @others
</t>
<t tx="ekr.20070302171509.2">def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
</t>
<t tx="ekr.20070302171917">def disable (self,background=None):
    self.enabled = False
    self.c.bodyWantsFocus()

def enable (self,background="white"):
    self.c.widgetWantsFocus(self.textWidget)
    self.enabled = True

def clear (self):                   self.textWidget.delete(0,'end')
def get (self):                     return self.textWidget.getAllText()
def isEnabled(self):                return self.enabled
def getFrame (self):                return None
def onActivate (self,event=None):   pass 
def pack (self):                    pass
def put(self,s,color=None):         self.textWidget.insert('end',s)
def setFocus (self):                pass
def unpack (self):                  pass
def update (self):                  pass

hide = unpack
show = pack
</t>
<t tx="ekr.20070306085724">def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
</t>
<t tx="ekr.20070308062440"></t>
<t tx="ekr.20070308062440.1">On 2/26/07, Edward Ream &lt;edreamleo@charter.net&gt; wrote:

&gt; threads will swap after sys.getcheckinterval() bytecodes have been
&gt; processed for that thread.

Many thanks for this detailed summary.  I think this is the guarantee I need
a) to experiment with threads and b) to fiddle with settings should that 
appear to be necessary.

Just be careful.  Test your assumptions before you rely on them, especially regarding threads.  Generally threading is seen as a "hard" problem.  If you want to help make them easier, use Queues to handle inter-thread communication. 


&gt; you can use a technique known as 'cooperative multithreading with 
&gt; generators'.

Googling this leads directly to an entry in the Python Cookbook.  The site
is down at present.  I'll study this entry when it's back up.

The basic idea is to have each task be a generator, with each generator giving up control after some amount of work.  Here's a variant of the recipe in the cookbook... 

 - Josiah

import collections

tasks = collections.deque()

def busy():
    while 1:
        yield None

def delay(v):
    import time
    while 1:
        time.sleep(v)
        yield None 

def xpasses(x):
    while x &gt; 0:
        x -= 1
        yield None

def runtasks():
    while 1:
        task = tasks.popleft()
        try:
            task.next()
        except StopIteration: 
            pass
        else:
            tasks.append(task)
</t>
<t tx="ekr.20070317073627">class leoTreeTab:

    '''A class representing a tabbed outline pane.'''

    @others
</t>
<t tx="ekr.20070317073627.1">def __init__ (self,c,chapterController,parentFrame):

    self.c = c
    self.cc = chapterController
    self.nb = None # Created in createControl.
    self.parentFrame = parentFrame

    self.selectedTabBackgroundColor = c.config.getColor(
        'selected_chapter_tab_background_color') or 'LightSteelBlue2'

    self.selectedTabForegroundColor = c.config.getColor(
        'selected_chapter_tab_foreground_color') or 'black'

    self.unselectedTabBackgroundColor = c.config.getColor(
        'unselected_chapter_tab_background_color') or 'lightgrey'

    self.unselectedTabForegroundColor = c.config.getColor(
        'unselected_chapter_tab_foreground_color') or 'black'
</t>
<t tx="ekr.20070317073755">def createControl (self):
    self.oops()

def createTab (self,tabName,select=True):
    self.oops()

def destroyTab (self,tabName):
    self.oops()

def selectTab (self,tabName):
    self.oops()

def setTabLabel(self,tabName):
    self.oops()
</t>
<t tx="ekr.20070317083104">def oops(self):

    g.pr("leoTreeTree oops:", g.callers(4), "should be overridden in subclass")
</t>
<t tx="ekr.20070317085437">class chapterController:

    '''A per-commander controller that manages chapters and related nodes.'''

    @others
</t>
<t tx="ekr.20070317085437.2">def __init__ (self,c):

    self.c = c

    self.chaptersDict = {}
        # Keys are chapter names, values are chapters.
        # Important: chapter names never change, even if their @chapter node changes.

    self.chaptersNode = None # Set later
    self.selectedChapter = None
    self.trace = False
    self.tt = None # May be set in finishCreate.
    self.use_tabs = c.config.getBool('use_chapter_tabs')

    # g.trace('chapterController',g.callers())
</t>
<t tx="ekr.20070317085437.30"></t>
<t tx="ekr.20070317085437.31">def createChapter (self,event=None):

    '''create-chapter command.
    Create a chapter with a dummy first node.'''

    cc = self ; k = cc.c.k ; tag = 'create-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter: ',protect=True)
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,
                undoType='Create Chapter')
</t>
<t tx="ekr.20070317085437.40">def removeChapter (self,event=None):

    cc = self ; c = cc.c

    theChapter = cc.selectedChapter
    if not theChapter: return

    name = theChapter.name

    if name == 'main':
        return cc.error('Can not remove the main chapter')
    else:
        cc.removeChapterByName(name)
</t>
<t tx="ekr.20070317085437.41"># newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = list(cc.chaptersDict.keys())
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw()
</t>
<t tx="ekr.20070317085437.50">def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'clone-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.51">def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'copy-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.52">def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Move Node To Chapter'
    p = c.p
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('chapter "%s" does not exist' % toChapterName)

    if 1: # Defensive code: should never happen.
        if fromChapter.name == 'main' and p.h.startswith('@chapter'):
            return cc.error('can not move @chapter node')

    if toChapter.name == 'main':
        sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
    else:
        sel = p.threadBack() or p.nodeAfterTree()
    if sel:
        # Get 'before' undo data.
        inAtIgnoreRange = p.inAtIgnoreRange()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        # Do the move.
        if toChapter.name == 'main':
            p.moveAfter(toChapter.p)
        else:
            p.moveToLastChildOf(toChapter.root)
        c.redraw(sel)
        c.setChanged(True)
        # Do the 'after' undo operation.
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last node of a chapter.')
</t>
<t tx="ekr.20070317085508.1">'''Classes that manage chapters in Leo's core.'''

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g

# To do later or never: Make body editors persistent. Create @body-editor node?

@others
</t>
<t tx="ekr.20070317085708">class chapter:

    '''A class representing the non-gui data of a single chapter.'''

    @others
</t>
<t tx="ekr.20070317085708.1">def __init__ (self,c,chapterController,name,root):

    self.c = c 
    self.cc = cc = chapterController
    self.hoistStack = []
    self.name = name
    self.selectLockout = False # True: in chapter.select logic.
    self.trace = False

    # State variables: saved/restored when the chapter is unselected/selected.
    if self.name == 'main':
        self.p = c.p or c.rootPosition()
        self.root = None # Not used.
    else:
        self.p = None # Set later.
        self.root = root and root.copy() # The immutable @chapter node.
        bunch = g.Bunch(p=self.root.copy(),expanded=True)
        self.hoistStack.append(bunch)

    if cc.tt:
        cc.tt.createTab(name)
</t>
<t tx="ekr.20070317085708.2">def __str__ (self):

    return '&lt;chapter id: %s name: %s p: %s&gt;' % (
        id(self),
        self.name,
        self.p and self.p.h or '&lt;no p&gt;')

__repr__ = __str__
</t>
<t tx="ekr.20070317130250">def selectChapterByName (self,name,collapse=True):

    '''Select a chapter.  Return True if a redraw is needed.'''

    cc = self ; c = cc.c

    chapter = cc.chaptersDict.get(name)

    if chapter:
        self.selectChapterByNameHelper(chapter,collapse=collapse)
    else:
        cc.error('cc.selectChapter: no such chapter: %s' % name)
        chapter = cc.chaptersDict.get('main')
        if chapter:
            self.selectChapterByNameHelper(chapter,collapse=collapse)
        else:
            cc.error('no main chapter!')
</t>
<t tx="ekr.20070317130648"></t>
<t tx="ekr.20070317131205.1">def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
        if self.cc.tt:
            self.cc.tt.setTabLabel(self.name)
    finally:
        self.selectLockout = False
</t>
<t tx="ekr.20070317131708">def findPositionInChapter (self,p1,strict=False):

    '''Return a valid position p such that p.v == v.'''

    # trace = False and not g.unitTesting

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)

    # if trace:
        # g.trace('searching for: %s in chapter %s' % (p1.h,self.name))
        # g.trace(g.callers(6))

    if p1 and c.positionExists(p1,root=root):
        # if trace: g.trace('using existing position:',p1.h)
        return p1

    if name == 'main':
        for p in self.c.all_unique_positions():
            if p.v == p1.v:
                # if trace: g.trace('*** found in chapter main:',p.h)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree():
            # g.trace('testing',p,p1)
            if p.v == p1.v:
                # if trace: g.trace('*** found in chapter %s: %s' % (self.name,p.h))
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = self.root.copy()

    # if trace:
        # # self.error('***** chapter: %s findPositionInChapter: lost %s' % (
            # # self.name,p1.h))
        # g.trace('fail',g.callers())

    return self.p.copy()
</t>
<t tx="ekr.20070318122708">def getSelectedChapter (self):

    cc = self

    return cc.selectedChapter
</t>
<t tx="ekr.20070318124004">def getChapter(self,name):

    cc = self

    return cc.chaptersDict.get(name)
</t>
<t tx="ekr.20070320085610">def error (self,s):

    g.es_print(s,color='red')
</t>
<t tx="ekr.20070320091806.1">def unselect (self):

    '''Remember chapter info when a chapter is about to be unselected.'''

    c = self.c ; cc = self.cc
    self.hoistStack = c.hoistStack[:]
    self.p = c.p
    if self.trace: g.trace('chapter',self.name,'p',self.p.h)
</t>
<t tx="ekr.20070325063303.2">def createChapterNode (self,chapterName,p=None):

    '''Create an @chapter node for the named chapter.
    Use p for the first child, or create a first child if p is None.'''

    cc = self ; c = cc.c
    current = c.p or c.rootPosition()

    # 2010/06/17: Create an @chapters node if necessary.
    # This is no longer done automatically when creating a new window.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    root = current.insertAsLastChild()
    root.initHeadString('@chapter ' + chapterName)
    root.moveToFirstChildOf(cc.chaptersNode)
    if p:
        # Clone p and move it to the first child of the root.
        clone = p.clone()
        clone.moveToFirstChildOf(root)
    else:
        cc.createChild(root,'%s node 1' % chapterName)
    c.setChanged(True)

    return root
</t>
<t tx="ekr.20070325063303.4">def deleteChapterNode (self,chapterName):

    '''Delete the @chapter with the given name.'''

    cc = self ; c = cc.c

    chapter = cc.chaptersDict.get(chapterName)

    if chapter:
        # Do not involve undo logic.
        c.setCurrentPosition(chapter.root)
        chapter.root.doDelete()
        # The chapter selection logic will select a new node.
        c.setChanged(True)
</t>
<t tx="ekr.20070325093617">def findChapterNode (self,chapterName,giveError=True):

    '''Return the position of the @chapter node with the given name.'''

    cc = self

    if not cc.chaptersNode:
        return # An error has already been given.

    s = '@chapter ' + chapterName
    for p in cc.chaptersNode.children():
        h = p.h
        if h == s:
            return p

    if giveError:
        cc.error('*** findChapterNode: no @chapter node for: %s' % (chapterName))

    return None
</t>
<t tx="ekr.20070325094401">def findChaptersNode (self):

    '''Return the position of the @chapters node.'''

    cc = self ; c = cc.c

    for p in c.all_unique_positions():
        if p.h == '@chapters':
            cc.chaptersNode = p.copy()
            return p

    # This is *not* an error.
    return None
</t>
<t tx="ekr.20070325094935">def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.p
    w = c.frame.body.bodyCtrl
    if not w: return

    for p in current.self_and_subtree():
        c.selectPosition(p)
        w.setSelectionRange(0,0,insert=0)
        c.editCommands.cleanLines(event)
    c.selectPosition(current)
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20070325101652">def createChaptersNode (self):

    cc = self ; c = cc.c ; root = c.rootPosition()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    # g.trace('root',root)
    p = root.insertAsLastChild()
    p.initHeadString('@chapters')
    p.moveToRoot(oldRoot=root)
    c.setRootPosition(p)
    cc.chaptersNode = p.copy()
    v = p.v
    assert(v.fileIndex)
    c.setChanged(True)
</t>
<t tx="ekr.20070325104904">def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    # g.trace('(chapterController)',g.callers(4))

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if 0: # Now done in cc.createChapterNode.
        if not cc.chaptersNode and not cc.findChaptersNode():
            cc.createChaptersNode()

    if cc.findChaptersNode():
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.all_unique_positions():
        h = p.h
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    # Always select the main chapter.
    # It can be alarming to open a small chapter in a large .leo file.
    cc.selectChapterByName('main',collapse=False)
        # 2010/10/09: an important bug fix!
</t>
<t tx="ekr.20070325115102">def getChapterNode (self,chapterName,p=None):

    '''Return the position of the @chapter node with the given name.'''

    cc = self ; c = cc.c

    if chapterName == 'main':
        return c.rootPosition()
    else:
        val = (
            cc.findChapterNode(chapterName,giveError=False) or
            cc.createChapterNode(chapterName,p=p))
        return val
</t>
<t tx="ekr.20070325155208.1">def error (self,s):

    self.cc.error(s)
</t>
<t tx="ekr.20070411101643">def getOpenWith (self,c):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get(c,'openwithtable','openwithtable')

    return val
</t>
<t tx="ekr.20070411101643.1">def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
</t>
<t tx="ekr.20070411101643.2">def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.b
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
</t>
<t tx="ekr.20070411101643.4">def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
</t>
<t tx="ekr.20070412082527"># This is used in several places besides g.openWithFileName.

def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            if not theFile: return None,False
            # Read the file into an StringIO file.
            aList = theFile.namelist()
            name = aList and len(aList) == 1 and aList[0]
            if not name: return None,False
            s = theFile.read(name)
            if g.isPython3:
                theStringFile = StringIO(g.ue(s,'utf-8'))
            else:
                theStringFile =  StringIO(s)
            return theStringFile,True
        else:
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
</t>
<t tx="ekr.20070412095520">def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
</t>
<t tx="ekr.20070413045221">def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
</t>
<t tx="ekr.20070413045221.2"></t>
<t tx="ekr.20070413061552">def putSavedMessage (self,fileName):

    c = self.c

    zipMark = g.choose(c.isZipped,'[zipped] ','')

    g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
</t>
<t tx="ekr.20070417112650"></t>
<t tx="ekr.20070418073400">def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
    legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in self.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    g.es('',''.join(result),tabName='Settings')
</t>
<t tx="ekr.20070418074444">def printSettings (self,event=None):

    g.app.config.printSettings(self.c)
</t>
<t tx="ekr.20070420092425">def cantMoveMessage (self):

    c = self ; h = c.rootPosition().h
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("can't move node out of",kind,color="blue")
</t>
<t tx="ekr.20070422093128">def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
</t>
<t tx="ekr.20070422094710">def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
</t>
<t tx="ekr.20070423101911">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: &lt;none&gt; new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        # 2010/08/01: (qt only) update history when body text gets focus.
        # This is done in qtGui.py: onFocusIn.
        if g.app.gui.guiName() != 'qt':
            c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20070423102603">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.redraw(w.leo_p)
    c.recolor()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'
</t>
<t tx="ekr.20070423102603.1">def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    if name == 'main' and cc.chaptersNode:
        cc.chaptersNode.contract()    
    c.hoistStack = self.hoistStack[:]

    c.selectPosition(p)
    c.redraw_after_select(p)
    g.doHook('hoist-changed',c=c)
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070424053629"></t>
<t tx="ekr.20070424053629.1"></t>
<t tx="ekr.20070424080640">def inactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            return
</t>
<t tx="ekr.20070424084012">def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070424084651">def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_unique_positions():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.p
            return False
</t>
<t tx="ekr.20070424092855"># Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.h

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.h)
</t>
<t tx="ekr.20070425175522">def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w
</t>
<t tx="ekr.20070425180705">def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    c = self.c ; d = self.editorWidgets ; values = list(d.values())

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            ):
                # g.trace('***',id(w),'match chapter and p',p.h)
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.h)
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.h)
    return c.frame.body.bodyCtrl
</t>
<t tx="ekr.20070426092031">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

&gt;&gt;&gt; import os
&gt;&gt;&gt; lin_key, win_key = "home", "Documents"
&gt;&gt;&gt; homedir = os.path.expanduser('~')
&gt;&gt;&gt; if os.name == 'nt': os_key = win_key
&gt;&gt;&gt; if os.name == 'posix': os_key = lin_key
&gt;&gt;&gt; print homedir.find(os_key) &gt; -1
True

</t>
<t tx="ekr.20070429090859">def printPluginHandlers (self,event=None):

    g.app.pluginsController.printHandlers(self.c)

def printPlugins (self,event=None):

    g.app.pluginsController.printPlugins(self.c)

def printPluginsInfo (self,event=None):

    g.app.pluginsController.printPluginsInfo(self.c)
</t>
<t tx="ekr.20070501092655">def aproposDebuggingCommands (self,event=None):

    '''Prints a discussion of of Leo's debugging commands.'''

    c = self.c

    &lt;&lt; define s &gt;&gt;

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es('',s)
</t>
<t tx="ekr.20070501092655.1"># @pagewidth 40

s = '''
The following commands are useful for debugging:

collect-garbage:   Invoke the garbage collector.
debug:             Start an external debugger in another process.
disable-gc-trace:  Disable tracing of the garbage collector.
dump-all-objects:  Print a summary of all existing Python objects.
dump-new-objects:  Print a summary of all newly-created Python objects.
enable-gc-trace:   Enable tracing of the garbage collector.
free-tree-widgets: Free all widgets used in Leo's outline pane.
print-focus:       Print information about the requested focus.
print-stats:       Print statistics about existing Python objects.
print-gc-summary:  Print a brief summary of all Python objects.
run-unit-tests:    Run unit tests in the presently selected tree.
verbose-dump-objects: Print a more verbose listing of all existing Python objects.

Leo also has many debugging settings that enable and disable traces.
For details, see the node: @settings--&gt;Debugging in leoSettings.leo.
'''
</t>
<t tx="ekr.20070509081915.1">def createChild (self,parent,s):

    '''Create a child node of parent without changing the undo stack.
    set the headString of the new node to s.'''

    c = self.c
    p = parent.insertAsLastChild()
    p.initHeadString(s)
    c.setChanged(True)

    return p
</t>
<t tx="ekr.20070510064813">def printChaptersTree(self,tag=''):

    cc = self ; c = cc.c ; root = cc.chaptersNode

    for p in c.rootPosition().self_and_siblings():
        for p2 in p.self_and_subtree():
            if p2 == root:
                inTree = True ; break
    else:
        inTree = False

    g.trace('-'*40)

    full = True

    if root and full:
        g.pr('@chapters tree...','(in main tree: %s)' % inTree)
        for p in root.self_and_subtree():
            g.pr('.'*p.level(),p.v)
</t>
<t tx="ekr.20070510074941">def printEntireTree(c,tag=''):

    g.pr('printEntireTree','=' * 50)
    g.pr('printEntireTree',tag,'root',c.rootPosition())
    for p in c.all_positions():
        g.pr('..'*p.level(),p.v)
</t>
<t tx="ekr.20070511081405"></t>
<t tx="ekr.20070521105645">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
</t>
<t tx="ekr.20070522085324">class chapterCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20070522085340">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # c.chapterController does not exist yet.
</t>
<t tx="ekr.20070522085429">def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    # g.trace('cc',cc,g.callers())

    if cc:
        if 1: # new names
            return {
                'chapter-clone-node-to':    cc.cloneNodeToChapter,
                'chapter-convert-node-to':  cc.convertNodeToChapter,
                'chapter-copy-node-to':     cc.copyNodeToChapter,
                'chapter-create':           cc.createChapter,
                'chapter-create-from-node': cc.createChapterFromNode,
                'chapter-move-node-to':     cc.moveNodeToChapter,
                'chapter-remove':           cc.removeChapter,
                'chapter-rename':           cc.renameChapter,
                'chapter-select':           cc.selectChapter,
            }
        else:
            return {
                'clone-node-to-chapter':    cc.cloneNodeToChapter,
                'convert-node-to-chapter':  cc.convertNodeToChapter,
                'copy-node-to-chapter':     cc.copyNodeToChapter,
                'create-chapter':           cc.createChapter,
                'create-chapter-from-node': cc.createChapterFromNode,
                'move-node-to-chapter':     cc.moveNodeToChapter,
                'remove-chapter':           cc.removeChapter,
                'rename-chapter':           cc.renameChapter,
                'select-chapter':           cc.selectChapter,
            }
    else:
        return {}
</t>
<t tx="ekr.20070524083513"></t>
<t tx="ekr.20070529083836">def cleanLines (self,p,s):

    '''Return a copy of s, with all trailing whitespace removed.
    If a change was made, update p's body text and set c dirty.'''

    c = self.c ; cleanLines = [] ; changed = False
    lines = g.splitLines(s)
    for line in lines:
        if line.strip():
            cleanLines.append(line)
        elif line.endswith('\n'):
            cleanLines.append('\n')
            if line != '\n': changed = True
        else:
            cleanLines.append('')
            if line != '': changed = True
    s = g.joinLines(cleanLines)

    if changed and not g.app.unitTesting:
        p.setBodyString(s)
        c.setChanged(True)

    return s
</t>
<t tx="ekr.20070529171934.1">def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
</t>
<t tx="ekr.20070530075604"></t>
<t tx="ekr.20070531103114"></t>
<t tx="ekr.20070603190617">def createChapterByName (self,name,p,undoType):

    cc = self ; c = cc.c

    if not name:
        return cc.error('No name')

    oldChapter = cc.getSelectedChapter()
    theChapter = cc.chaptersDict.get(name)
    if theChapter:
        return cc.error('Duplicate chapter name: %s' % name)

    bunch = cc.beforeCreateChapter(c.p,oldChapter.name,name,undoType)
    if undoType == 'Convert Node To Chapter':
        root = p.insertAfter()
        root.initHeadString('@chapter %s' % name)
        p.moveToFirstChildOf(root)
    elif undoType in ('Create Chapter From Node','Create Chapter'):
        # Create the @chapter node.
        # If p exists, clone it as the first child, else create a dummy first child.
        root = cc.getChapterNode(name,p=p)
    else:
        return g.trace('Can not happen: bad undoType: %s' % undoType)

    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=root)
    cc.selectChapterByName(name)
    cc.afterCreateChapter(bunch,c.p)

    # g.es('created chapter',name,color='blue')
    return True
</t>
<t tx="ekr.20070604155815.1">def cloneNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ;  u = c.undoer ; undoType = 'Clone Node To Chapter'
    p = c.p ; h = p.h
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('no such chapter: %s' % toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not clone @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter)

    # Open the group undo.
    c.undoer.beforeChangeGroup(p,undoType)
    # Do the clone.  c.clone handles the inner undo.
    clone = c.clone()
    # Do the move.
    undoData2 = u.beforeMoveNode(clone)
    if toChapter.name == 'main':
        clone.moveAfter(toChapter.p)
    else:
        parent = cc.getChapterNode(toChapter.name)
        clone.moveToLastChildOf(parent)
    u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
    c.redraw(clone)
    c.setChanged(True)
    # Close the group undo.
    # Only the ancestors of the moved node get set dirty.
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)

    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.2">def copyNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Copy Node To Chapter'
    p = c.p ; h = p.h
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('no such chapter: %s' % toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not copy @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter.name)

    # For undo, we treat the copy like a pasted (inserted) node.
    # Use parent as the node to select for undo.
    parent = cc.getChapterNode(toChapter.name)
    undoData = u.beforeInsertNode(parent,pasteAsClone=False,copiedBunchList=[])
    s = c.fileCommands.putLeoOutline()
    p2 = c.fileCommands.getLeoOutline(s)
    p2.moveToLastChildOf(parent)
    c.redraw(p2)
    u.afterInsertNode(p2,undoType,undoData)
    c.setChanged(True)

    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.3">def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'move-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        prefix = 'Move node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070604165126">def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'select-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Select chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.selectChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg)
</t>
<t tx="ekr.20070604205927">def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&amp;clone-node-to-chapter',
        'c&amp;opy-node-to-chapter',
        'c&amp;reate-chapter',
        '&amp;move-node-to-chapter',
        '&amp;remove-chapter',
        '&amp;select-chapter',
    ]
</t>
<t tx="ekr.20070605110441">def dynamicExpandHelper (self,prefix=None,rlist=None,w=None):

    k = self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)

    if state == 0:
        self.w = w
        if w:
            names = rlist ; event = None
            prefix2 = 'dabbrev-expand: '
            k.setLabelBlue(prefix2+prefix,protect=True)
            k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)
</t>
<t tx="ekr.20070605124356">def inChapter (self):

    cc = self

    theChapter = cc.getSelectedChapter()
    return theChapter and theChapter.name != 'main'
</t>
<t tx="ekr.20070606074705">def undoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    newChapter = cc.getChapter(u.newChapterName)

    bunch = u.beads[u.bead]
    bunch.savedRoot = root = newChapter.root

    if u.undoType == 'Convert Node To Chapter':
        p = root.firstChild()
        p.moveAfter(root)
    else:
        pass # deleting the chapter will delete the node.

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070606075125">def afterCreateChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'create-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoInsertChapter
    bunch.redoHelper = cc.redoInsertChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070606075434">def removeChapterByName (self,name):

    cc = self ; c = cc.c ; tt = cc.tt

    theChapter = cc.chaptersDict.get(name)
    if not theChapter: return

    savedRoot = theChapter.root
    bunch = cc.beforeRemoveChapter(c.p,name,savedRoot)
    cc.deleteChapterNode(name)
    del cc.chaptersDict[name] # Do this after calling deleteChapterNode.
    if tt:tt.destroyTab(name)
    cc.selectChapterByName('main')
    cc.afterRemoveChapter(bunch,c.p)
    c.redraw()
</t>
<t tx="ekr.20070606081341">def redoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # g.trace(u.newChapterName,u.oldChapterName,u.p)

    cc.createChapterByName(u.newChapterName,p=u.savedRoot,undoType=u.undoType)
    theChapter = cc.getChapter(u.newChapterName)

    if u.undoType == 'Convert Node To Chapter':
        pass
    elif u.undoType in ('Create Chapter From Node','Create Chapter'):
        root = theChapter.root
        firstChild = root.firstChild()
        firstChild._unlink()
        firstChild = u.savedRoot.firstChild()
        firstChild._linkAsNthChild(root,0)
    else:
        return g.trace('Can not happen: bad undoType: %s' % u.undoType)
</t>
<t tx="ekr.20070606082729">def beforeCreateChapter (self,p,oldChapterName,newChapterName,undoType):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.oldChapterName = oldChapterName
    bunch.newChapterName = newChapterName
    bunch.savedRoot = None
    bunch.undoType = undoType

    return bunch
</t>
<t tx="ekr.20070607092909">def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'create-chapter-from-node'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter from node: ',protect=True)
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,
                undoType='Create Chapter From Node')
</t>
<t tx="ekr.20070608072116">def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'convert-node-to-chapter'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Convert node to chapter: ',protect=True)
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=c.p,
                undoType='Convert Node To Chapter')
</t>
<t tx="ekr.20070608165544">def hoistLevel (self):

    c = self ; cc = c.chapterController
    n = len(c.hoistStack)
    if n &gt; 0 and cc and cc.inChapter():
        n -= 1
    return n
</t>
<t tx="ekr.20070609122713">def visLimit (self):

    '''Return the topmost visible node.
    This is affected by chapters and hoists.'''

    c = self ; cc = c.chapterController

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.h.startswith('@chapter')
        return p,limitIsVisible
    else:
        return None,None
</t>
<t tx="ekr.20070610091608">def afterRemoveChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'remove-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoRemoveChapter
    bunch.redoHelper = cc.redoRemoveChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070610091608.1">def beforeRemoveChapter (self,p,newChapterName,savedRoot):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.newChapterName = newChapterName
    bunch.savedRoot = savedRoot
    bunch.undoType = 'Remove Chapter'

    return bunch
</t>
<t tx="ekr.20070610100031"></t>
<t tx="ekr.20070610100555">def redoRemoveChapter (self):

    cc = self ; u = cc.c.undoer

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070610100555.1">def undoRemoveChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # u.savedRoot is the entire @chapter tree.
    # Link it as the last child of the @chapters node.
    parent = cc.findChaptersNode()
    u.savedRoot._linkAsNthChild(parent,parent.numberOfChildren())

    # Now recreate the chapter.
    name = u.newChapterName
    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=u.savedRoot)
    cc.selectChapterByName(name)
</t>
<t tx="ekr.20070613133500">def menuCommandKey (self,event=None):

    # This method must exist, but it never gets called.
    pass 
</t>
<t tx="ekr.20070613190936">def propagateKeyEvent (self,event):

    self.oops() # Should be overridden.
</t>
<t tx="ekr.20070614094933">C:\prog&gt;c:\python25\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.5/s/setuptools/setuptools-0.6c6-py2.5.egg
Processing setuptools-0.6c6-py2.5.egg
Copying setuptools-0.6c6-py2.5.egg to c:\python25\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python25\Scripts
Installing easy_install.exe script to c:\python25\Scripts
Installing easy_install-2.5-script.py script to c:\python25\Scripts
Installing easy_install-2.5.exe script to c:\python25\Scripts

Installed c:\python25\lib\site-packages\setuptools-0.6c6-py2.5.egg
Processing dependencies for setuptools==0.6c6
Finished processing dependencies for setuptools==0.6c6

C:\prog&gt;c:\python24\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.4/s/setuptools/setuptools-0.6c6-py2.4.egg
Processing setuptools-0.6c6-py2.4.egg
creating c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Extracting setuptools-0.6c6-py2.4.egg to c:\python24\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python24\Scripts
Installing easy_install.exe script to c:\python24\Scripts
Installing easy_install-2.4-script.py script to c:\python24\Scripts
Installing easy_install-2.4.exe script to c:\python24\Scripts

Installed c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Processing dependencies for setuptools==0.6c6
</t>
<t tx="ekr.20070615065222">def positionIsInChapter (self,p):

    p2 = self.findPositionInChapter (p,strict=True)

    # g.trace(self.name,'returns',p2)
    return p2
</t>
<t tx="ekr.20070615070925">def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070615070925.1">def firstVisible(self):

    """Move to the first visible node of the present chapter or hoist."""

    c = self ; p = c.p

    while 1:
        back = p.visBack(c)
        if back and back.isVisible(c):
            p = back
        else: break
    return p
</t>
<t tx="ekr.20070615075643">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''

    # trace = False and not g.unitTesting
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter:
        # if trace: g.trace('no chapter')
        return

    # if trace: g.trace('selected:',theChapter.name)

    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        # if trace: g.trace('in chapter:',theChapter.name)
        return

    for name in cc.chaptersDict:
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                # if trace: g.trace('select:',theChapter.name)
                cc.selectChapterByName(name)
                return
    else:
        # if trace: g.trace('select main')
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20070615131604">class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
</t>
<t tx="ekr.20070615131604.1">def __init__ (self,c):

    self.c = c
    self.beadList = []
        # list of (position,chapter) tuples for
        # nav_buttons and nodenavigator plugins.
    self.beadPointer = -1
    self.trace = False
    self.skipBeadUpdate = False
</t>
<t tx="ekr.20070615131604.3">def canGoToNextVisited (self):

    if self.trace:
        g.trace(
            self.beadPointer + 1 &lt; len(self.beadList),
            self.beadPointer,len(self.beadList))

    return self.beadPointer + 1 &lt; len(self.beadList)

def canGoToPrevVisited (self):

    if self.trace:
        g.trace(self.beadPointer &gt; 0,
            self.beadPointer,len(self.beadList))

    return self.beadPointer &gt; 0
</t>
<t tx="ekr.20070615132939">def clear (self):

    self.beadList = []
    self.beadPointer = -1
</t>
<t tx="ekr.20070615132939.1">def remove (self,p):

    '''Remove an item from the nav_buttons list.'''

    c = self.c
    target = self.beadPointer &gt; -1 and self.beadList[self.beadPointer]

    self.beadList = [z for z in self.beadList
                        if z[0] != p and c.positionExists(z[0])]

    try:
        self.beadPointer = self.beadList.index(target)
    except ValueError:
        self.beadPointer = max(0,self.beadPointer-1)

    if self.trace:
        g.trace('bead list',p.h)
        g.pr([z[0].h for z in self.beadList])
</t>
<t tx="ekr.20070615134813">def goNext (self):

    '''Return the next visited node, or None.'''

    c = self.c
    while self.beadPointer + 1 &lt; len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        if c.positionExists(p):
            break
    else:
        return None

    self.selectChapter(chapter)
    return p

def goPrev (self):

    '''Return the previous visited node, or None.'''

    c = self.c
    while self.beadPointer &gt; 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        if c.positionExists(p):
            break
    else:
        return None


    self.selectChapter(chapter)
    return p
</t>
<t tx="ekr.20070615140032">def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController

    if cc and chapter and chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
</t>
<t tx="ekr.20070615140655">def visitedPositions (self):

    return [p.copy() for p,chapter in self.beadList]
</t>
<t tx="ekr.20070619173330">def getTestVars ():

    d = g.app.unitTestDict
    c = d.get('c')
    p = d.get('p')
    # Indicate that getTestVars has run.
    # This is an indirect test that some unit test has run.
    d['getTestVars'] = True
    return c,p and p.copy()
</t>
<t tx="ekr.20070623150151">The chapter commands provide a good example.  In this file, see the node:

Code--&gt;Core classes...--&gt;@thin leoChapters.py--&gt;class chapterController--&gt;Undo

The general plan is this:

1. The command handler calls a **beforeCommand** method before changing the outline.

The beforeCommand method creates a g.Bunch that contains all the information needed to
restore the outline to its previous state. Typically, the beforeCommand method
will call c.undoer.createCommonBunch(p), where p is, as usual, c.p.

2. After changing the outline the command handler calls an **afterCommand** method.

This method should take as one argument the g.Bunch returned by the
beforeCommand method. In the discussion below, denote this bunch by b. The
afterCommand method adds any information required to redo the operation after
the operation has been undone.

The afterCommand method also sets b.undoHelper and b.redoHelper to two method
that actually perform the undo and redo operations. (Actually, the beforeCommand
method could also set these two entries).

When the afterCommand method has 'filled in' all the entries of b, the
afterCommand method must call u.pushBead(b). This pushes all the undo
operation on a stack managed by the Leo's undoer, i.e., c.commands.undoer.

3. The undoer calls the undoHelper and redoHelper methods to perform the actual undo and redo operations.

The undoer handles most of the housekeeping chores related to undo and redo.  All the undoHelper and redoHelper methods have to do is actually alter Leo's outline.

**Note**: the undoer creates an ivar (instance variable) of the *undoer* class for every entry in the bunch b passed as an argument to u.pushBead(b).  For example, suppose u = c.commands.under and that b has ivars 'a','b' and 'c'.  Then, on entry to the undoHelper and the redoHelper the u.a, u.b and u.c ivars will be defined.  This makes it unnecessary for the undoHelper or the redoHelper to 'unpack' b explicitly.

Writing correct undo and redo helpers is usually a bit tricky.  The code is often subtly different from the original code that implements a command.  That just can't be helped.




</t>
<t tx="ekr.20070626132332">def es(*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    if not app or app.killed: return
    log = app.log

    # Compute the effective args.
    d = {'color':'black','commas':False,'newline':True,'spaces':True,'tabName':'Log'}
    d = g.doKeywordArgs(keys,d)
    color = d.get('color')
    if color == 'suppress': return # New in 4.3.
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args,d)
    # print('g.es',app.logInited,log and id(log),args)
    # print('g.es',g.callers())

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # New in Leo 4.5 b4: this is no longer needed.
            # This makes the output of unit tests match the output of scripts.
            # s = g.toEncodedString(s,'ascii')
            g.pr(s,newline=newline)
    else:
        if log and app.logInited:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
</t>
<t tx="ekr.20070627135336.10">def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_finalize_join(g.app.loadDir,'..','test', self.fileName)

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
</t>
<t tx="ekr.20070627135336.8">def searchOutline (self,p):

    c = self.c ; p = c.p
    iter = g.choose(self.all,c.all_unique_positions,p.self_and_subtree)

    # First, look down the tree.
    for p in iter():
        for s in self.tags:
            if p.h.startswith(s):
                self.root = c.p
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.p.parents():
            for s in self.tags:
                if p.h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.all_unique_positions():
        if p.h.startswith('@mark-for-unit-test'):
            return True

    return False
</t>
<t tx="ekr.20070627135336.9">def createOutline (self,c2):

    '''Create a unit test ouline containing

    - all children of any @mark-for-unit-tests node anywhere in the outline.
    - all @test and @suite nodes in p's outline.'''

    trace = False ; verbose = False
    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    &lt;&lt; set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 &gt;&gt;

    if trace: g.trace('all',self.all)
    self.copyRoot.expand()
    for n,p,limit,lookForMark,lookForNodes in (
        (1,p1,limit1,lookForMark1,lookForNodes1),
        (2,p2,limit2,lookForMark2,lookForNodes2),
    ):
        if n == 2 and self.all: return
        if trace and verbose: g.trace(
            'pass %s: mark %s nodes %s root %s limit %s' % (
                n,lookForMark,lookForNodes,
                p and p.h or '&lt;none&gt;',
                limit and limit.h or '&lt;none&gt;'))
        while p and p != limit:
            if g.match_word(p.h,0,'@ignore'):
                if trace: g.trace('ignoring tree',p.h)
                p.moveToNodeAfterTree()
            elif p.v in self.seen:
                if trace: g.trace('seen',p.h)
                p.moveToNodeAfterTree()
            elif lookForMark and p.h.startswith(markTag):
                if trace: g.trace('add mark tree',p.h)
                self.addMarkTree(p)
                p.moveToNodeAfterTree()
            elif lookForNodes and self.isUnitTestNode(p):
                if trace: g.trace('add node',p.h)
                self.addNode(p)
                p.moveToNodeAfterTree()
            else:
                if trace and verbose: g.trace('skip',p.h)
                p.moveToThreadNext()
</t>
<t tx="ekr.20070627135407">def runTestsExternally (c,all):

    runner = runTestExternallyHelperClass(c,all)
    runner.runTests()
</t>
<t tx="ekr.20070627140344">class runTestExternallyHelperClass:

    '''A helper class to run tests externally.'''

    @others
</t>
<t tx="ekr.20070627140344.1">def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
</t>
<t tx="ekr.20070627140344.2">def runTests (self,trace=False):
    # 2010/09/09: removed the gui arg: there is no way to set it.

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo
    in a separate process.
    '''

    trace = False or trace
    import time
    kind = g.choose(self.all,'all ','selected')
    c = self.c ; p = c.p
    t1 = time.time()
    found = self.searchOutline(p.copy())
    if found:
        theGui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=theGui)
        found = self.createOutline(c2)
        self.createFileFromOutline(c2)
        t2 = time.time()
        print('created %s unit tests in %0.2fsec in %s' % (
            kind,t2-t1,self.fileName))
        g.es('created %s unit tests' % (kind),color='blue')
        # 2010/09/09: allow a way to specify the 
        gui = g.app.unitTestGui or 'nullGui'
        runUnitTestLeoFile(gui=gui,path='dynamicUnitTest.leo',silent=True)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in %s outline' % (
            g.choose(self.all,'entire','selected')),color='red')
</t>
<t tx="ekr.20070627151457">@

--runCommand "leo-command-name" runs the command at idle-time after loading the file.

I am not going to do this: this, in conjunction with @command nodes, is a big security hole, equivalent to @script.

The only safe thing would be to disallow user-defined commands from being executed by --runCommand, but then what is the point of --runCommand.
</t>
<t tx="ekr.20070703122141.100">class pythonScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20070703122141.101">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

</t>
<t tx="ekr.20070703122141.102">def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType in (None,'@file'):
        return self.checkTrialWrite()
    else:
        return True
</t>
<t tx="ekr.20070703122141.104">def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
</t>
<t tx="ekr.20070703122141.105">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@root':
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True
    else:
        prefix = ''

    return prefix
</t>
<t tx="ekr.20070703122141.106">def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType in ('@file',None):
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
</t>
<t tx="ekr.20070703122141.65">class baseScannerClass (scanUtility):

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
</t>
<t tx="ekr.20070703122141.66">def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.escapeSectionRefs = True
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in &lt; &lt; x methods &gt; &gt; =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
    self.warnAboutUnderindentedLines = True
</t>
<t tx="ekr.20070703122141.77">def createHeadline (self,parent,body,headline):

    return self.importCommands.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070703122141.78">def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print('',s,color='red')
    else:
        g.es_print('error:',s,color='red')

def oops (self):
    g.pr('baseScannerClass oops: %s must be overridden in subclass' % g.callers())

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning:',s,color='red')
</t>
<t tx="ekr.20070703122141.79">def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
</t>
<t tx="ekr.20070703122141.88">def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    if self.isRst:
        return s # Never unindent rst code.

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result
</t>
<t tx="ekr.20070703122141.99">def scanPythonText (self,s,parent,atAuto=False):

    scanner = pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20070705065154">if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.p
    if p.h.startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
</t>
<t tx="ekr.20070705065154.1">def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-tests tree as the last child of self.copyRoot.
    '''

    # g.trace(p.h)

    p2 = p.copyTreeAfter()
    p2.moveToLastChildOf(self.copyRoot)

    for p2 in p.self_and_subtree():
        self.seen.append(p2.v)
</t>
<t tx="ekr.20070705075604.3">def isUnitTestNode (self,p):

    for tag in self.tags:
        if p.h.startswith(tag):
            return True
    else:
        return False
</t>
<t tx="ekr.20070705080413">def addMarkTree (self,p):

    # Add the entire @mark-for-unit-tests tree.
    self.addNode(p)
</t>
<t tx="ekr.20070705085335">def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
</t>
<t tx="ekr.20070705094630">def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
</t>
<t tx="ekr.20070706084535">@ None of these methods should ever need to be overridden in subclasses.

</t>
<t tx="ekr.20070706084535.1">@ Scan and skipDecls would typically not be overridden.
</t>
<t tx="ekr.20070706101600">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start &lt; len(s):
        self.appendStringToBody(parent,s[start:])

    # Do any language-specific post-processing.
    self.endGen(s)
</t>
<t tx="ekr.20070707072749">def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width &lt; 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
</t>
<t tx="ekr.20070707073044.1">def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.isRst and not self.atAuto:
        return

    if self.treeType in ('@file',None):
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
</t>
<t tx="ekr.20070707073627.2">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20070707073627.4">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
</t>
<t tx="ekr.20070707073859">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    verbose = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace and verbose:
        g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace and verbose: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level &lt;= 0:
                # 2010/09/20
                # Skip a single-line comment if it exists.
                j = g.skip_ws(s,i)
                if (g.match(s,j,self.lineCommentDelim) or
                    g.match(s,j,self.lineCommentDelim2)
                ):
                    i = g.skip_to_end_of_line(s,i)
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress &lt; i

    self.error('no block: %s' % self.root.h)
    if 1:
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
</t>
<t tx="ekr.20070707074541">def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    start = i

    # Skip the opening delim.
    if g.match(s,i,self.blockCommentDelim1):
        delim2 = self.blockCommentDelim2
        i += len(self.blockCommentDelim1)
    elif g.match(s,i,self.blockCommentDelim1_2):
        i += len(self.blockCommentDelim1_2)
        delim2 = self.blockCommentDelim2_2
    else:
        assert False

    # Find the closing delim.
    k = s.find(delim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(delim2)
</t>
<t tx="ekr.20070707080042">def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress &lt; i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
</t>
<t tx="ekr.20070707082432">def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and not g.unitTesting
    verbose = False

    # if trace: g.trace(start,sigStart,self.sigEnd,codeEnd)

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body = self.computeBody(s,start,sigStart,codeEnd)

    if trace:
        g.trace('parent',parent.h)
        if verbose: g.trace('**body...\n',body)

    parent = self.adjustParent(parent,headline)
    self.lastParent = self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20070707085612">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@root':
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True
    else:
        prefix = ''

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20070707094858.1">def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
</t>
<t tx="ekr.20070707094858.2">def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
</t>
<t tx="ekr.20070707113832.1">def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class,
    and a child of c for each def in the class.'''

    trace = False and not g.unitTesting
    if trace:
        # g.trace('tab_width',self.tab_width)
        g.trace('sig',s[i:sigEnd])

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    if trace: g.trace('undentVal',undentVal,'bodyIndent',bodyIndent)

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20070707113839">def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j &lt; len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
</t>
<t tx="ekr.20070707150022">def extendSignature(self,unused_s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
</t>
<t tx="ekr.20070707171329">def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    trace = False and not g.unitTesting

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None
    if trace: g.trace('bodyIndent',bodyIndent)

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
</t>
<t tx="ekr.20070707172732.1">def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
</t>
<t tx="ekr.20070707190351">def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20070709094002">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20070711060107.1">def scanElispText (self,s,parent,atAuto=False):

    scanner = elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20070711060113">class elispScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20070711060113.1">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='lisp')

    # Set the parser delims.
    self.atAutoWarnsAboutLeadingWhitespace = False # 2010/09/29.
    self.warnAboutUnderindentedLines = False # 2010/09/29.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'
    self.strict=False

</t>
<t tx="ekr.20070711060113.2"># skipClass/Function/Signature are defined in the base class.
</t>
<t tx="ekr.20070711060113.3">def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
</t>
<t tx="ekr.20070711063339">def startsString(self,s,i):

    # Single quotes are not strings.
    # ?\x is the universal character escape.
    return g.match(s,i,'"') or g.match(s,i,'?\\')
</t>
<t tx="ekr.20070711090122">def scanPHPText (self,s,parent,atAuto=False):

    scanner = phpScanner(importCommands=self,atAuto=atAuto)
    scanner.run(s,parent)
</t>
<t tx="ekr.20070711104014">def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
</t>
<t tx="ekr.20070711104014.1">def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1) or
        g.match(s,i,self.blockCommentDelim1_2)
    )
</t>
<t tx="ekr.20070711104241.2">def scanPascalText (self,s,parent,atAuto=False):

    scanner = pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20070711104241.3">class pascalScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20070711132314"># We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
</t>
<t tx="ekr.20070711134534">def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    return ids and ids[-1]
</t>
<t tx="ekr.20070711140703">def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i &lt; len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i &lt; len(s) and s[i],ids,classId)
    return i, ids, classId
</t>
<t tx="ekr.20070712075148">def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i &gt;= len(s):
        return start,False
    else:
        return i,True 
</t>
<t tx="ekr.20070712081451">def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
</t>
<t tx="ekr.20070712082913">def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i &lt; len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
</t>
<t tx="ekr.20070712090019.1">def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = True
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    if trace: g.trace('startIndent',startIndent)
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = (i &gt; 0 and g.match(s,i-1,'\\\n'))
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 &lt; i &lt; len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False

    # 2010/02/19: Include all following material
    # until the next 'def' or 'class'
    i = self.skipToTheNextClassOrFunction(s,i,startIndent)

    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
</t>
<t tx="ekr.20070712091019">def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i &gt; start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
</t>
<t tx="ekr.20070712112008">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent &lt; self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20070713075352">def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'):   body += '@language html\n'
    elif ext in ('.txt','.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += '@language %s\n' % language

    self.setBodyString(p,body + self.rootLine + self.escapeFalseSectionReferences(s))
    if atAuto:
        for p in p.self_and_subtree():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
</t>
<t tx="ekr.20070713075450"># atAuto must be False for unit tests: otherwise the test gets wiped out.

def cUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c')

def cSharpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c#')

def elispUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')

def htmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.htm')

def iniUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.ini')

def javaUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')

def javaScriptUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.js')

def pascalUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.pas')

def phpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.php')

def pythonUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.py')

def rstUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.rst')

def textUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.txt')

def xmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.xml')

def defaultImporterUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.xxx')
</t>
<t tx="ekr.20070713082220">def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.h ; old_root = p.copy()
    oldChanged = c.changed
    d = g.app.unitTestDict
    expectedErrors = d.get('expectedErrors')
    expectedErrorMessage = d.get('expectedErrorMessage')
    expectedMismatchLine = d.get('expectedMismatchLine')
    g.app.unitTestDict = {
        'expectedErrors':expectedErrors,
        'expectedErrorMessage':expectedErrorMessage,
        'expectedMismatchLine':expectedMismatchLine,
    }
    if not fileName: fileName = p.h
    if not s: s = self.removeSentinelsCommand([fileName],toString=True)
    title = g.choose(h.startswith('@test'),h[5:],h)
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
    d = g.app.unitTestDict
    ok = ((d.get('result') and expectedErrors in (None,0)) or
        (
            # checkTrialWrite returns *True* if the following match.
            # d.get('result') == False and
            d.get('actualErrors') == d.get('expectedErrors') and
            d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
            (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
        ))
    if not ok:
        g.trace('result',d.get('result'),
            'actualErrors',d.get('actualErrors'),
            'expectedErrors',d.get('expectedErrors'),
            'actualMismatchLine',d.get('actualMismatchLine'),
            'expectedMismatchLine', d.get('expectedMismatchLine'),
            '\nactualErrorMessage  ',d.get('actualErrorMessage'),
            '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
        )
    if not showTree and ok:
        while old_root.hasChildren():
            old_root.firstChild().doDelete()
        c.setChanged(oldChanged)

    c.redraw(old_root)

    if g.app.unitTesting:
        assert ok

    return ok
</t>
<t tx="ekr.20070730093735">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i &gt;= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
</t>
<t tx="ekr.20070730134936">def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i &lt; len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i &gt;= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
</t>
<t tx="ekr.20070801074524">def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    if self.warnAboutUnderindentedLines:
        self.error(
            'underindented line.\n' +
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20070801080447">def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace(
        'startIndent',startIndent,'indent',indent,'parenCount',parenCount,
        'line',repr(g.get_line(s,j)))
    if indent &lt;= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line or (2008/9/1) the end of a triple-quoted string.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent &lt;= startIndent:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('breakFlag',breakFlag,'returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
</t>
<t tx="ekr.20070803101619"># This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    while i &lt; len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
</t>
<t tx="ekr.20070806105721.1">def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    c.endEditing()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
</t>
<t tx="ekr.20070806105859">def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
</t>
<t tx="ekr.20070806111212">def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

</t>
<t tx="ekr.20070806140208">def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.p ; after = p.nodeAfterTree()
    found = False

    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = at.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
</t>
<t tx="ekr.20070806141607">def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)
    if not toString and exists and not hasattr(root.v,'at_read') and exists:
        # Prompt if writing a new @auto node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            root.v.at_read = True # Create the attribute for all clones.
        else:
            g.es("not written:",fileName)
            return

    # Prompt if writing a new @auto node would overwrite an existing file.
    if (not toString and not hasattr(p.v,'at_read') and
        g.os_path_exists(fileName)
    ):
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            p.v.at_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)

    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        # g.trace('at.errors',at.errors)
        if at.errors == 0:
            # g.trace('toString',toString,'force',force,'isAtAutoRst',isAtAutoRst)
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",fileName)
            root.setDirty() # New in Leo 4.4.8.
            root.setOrphan() # 2010/10/22.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        root.setOrphan() # 2010/10/22.
        g.es("not written:",fileName)

    return ok
</t>
<t tx="ekr.20070807084545">def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # 2010/01/15: Remember that we have read this file.
    # http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
    # Important: createOutline usually sets the bit in the wrong node.
    p.v.at_read = True # Create the attribute

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
</t>
<t tx="ekr.20070808115837"></t>
<t tx="ekr.20070808115837.1">def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width &lt; 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width &lt; 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # 2010/7/28: Remember that we have seen the @auto node.
    p.v.at_read = True # Create the attribute

    s,ok,fileKey = c.cacher.readFile(fileName,p)
    if ok: return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        c.cacher.writeFile(p,fileKey)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
</t>
<t tx="ekr.20070909103844">def isSignificantTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    trace = False and not g.unitTesting
    s = p.b

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    val = p.hasChildren() or len(s2.strip()) &gt;= 10
    if trace: g.trace(val,p.h)
    return val
</t>
<t tx="ekr.20070910105044">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedVnodes = {}
    for ancestor in parent.self_and_parents():
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v

    if not clonedVnodes:
        return True

    for p in root.self_and_subtree():
        if p.isCloned() and clonedVnodes.get(p.v):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20070910105044.1">def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.h,'target',target.h)

    for z in root.subtree():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20070911110507">def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i &lt; n: line = repr(lines[i])
            else: line = '&lt;eof&gt;'
            aList.append('%4d %s' % (i,line))

    if not g.unitTesting:
        g.es_print('\n'.join(aList),color='blue')

    return False
</t>
<t tx="ekr.20070915134101">def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    c.endEditing()

    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)
    if not fileName:return
    s,e = g.readFileIntoString(fileName)
    if s is None: return

    g.chdir(fileName)
    s = '@nocolor\n' + s
    w = c.frame.body.bodyCtrl
    p = c.insertHeadline(op_name=undoType)
    p.setHeadString('@read-file-into-node ' + fileName)
    p.setBodyString(s)
    w.setAllText(s)
    c.redraw(p)
</t>
<t tx="ekr.20070915142635">def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.p
    c.endEditing()

    h = p.h.rstrip()
    s = p.b
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
            g.chdir(fileName)
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,reportErrors=True)
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote:',fileName,color='blue')
            theFile.close()
        else:
            g.es('can not write %s',fileName,color='red')
</t>
<t tx="ekr.20070919133659">def checkDerivedFile (self, event=None):

    at = self ; c = at.c ; p = c.p

    if not p.isAtFileNode() and not p.isAtThinFileNode():
        return g.es('Please select an @thin or @file node',color='red')

    fn = p.anyAtFileNodeName()
    path = g.os_path_dirname(c.mFileName)
    fn = g.os_path_finalize_join(g.app.loadDir,path,fn)
    if not g.os_path_exists(fn):
        return g.es_print('file not found: %s' % (fn),color='red')

    s,e = g.readFileIntoString(fn)
    if s is None: return

    # Create a dummy, unconnected, vnode as the root.
    root_v = leoNodes.vnode(context=c)
    root = leoNodes.position(root_v)
    theFile = g.fileLikeObject(fromString=s)
    # 2010/01/22: readOpenFiles now determines whether a file is thin or not.
    at.initReadIvars(root,fn)
    if at.errors: return
    at.openFileForReading(fromString=s)
    if not at.inputFile: return
    at.readOpenFile(root,at.inputFile,fn)
    at.inputFile.close()
    if at.errors == 0:
        g.es_print('check-derived-file passed',color='blue')
</t>
<t tx="ekr.20070919133659.1">def checkLeoFile (self,event=None):

    '''The check-leo-file command.'''

    fc = self ; c = fc.c ; p = c.p

    # Put the body (minus the @nocolor) into the file buffer.
    s = p.b ; tag = '@nocolor\n'
    if s.startswith(tag): s = s[len(tag):]

    # Do a trial read.
    self.checking = True
    self.initReadIvars()
    c.loading = True # disable c.changed
    try:
        try:
            # self.getAllLeoElements(fileName='check-leo-file',silent=False)
            theFile,isZipped = g.openLeoOrZipFile(c.mFileName)
            self.readSaxFile(
                theFile,fileName='check-leo-file',
                silent=False,inClipboard=False,reassignIndices=False)
            g.es_print('check-leo-file passed',color='blue')
        except Exception:
            junk, message, junk = sys.exc_info()
            # g.es_exception()
            g.es_print('check-leo-file failed:',str(message),color='red')
    finally:
        self.checking = False
        c.loading = False # reenable c.changed
</t>
<t tx="ekr.20070920104110">def compareLeoFiles (self,event):

    c = c1 = self.c ; w = c.frame.body.bodyCtrl

    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return

    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return

    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)

    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(inserted,deleted,changed)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)


</t>
<t tx="ekr.20070921070101">def createHiddenCommander(self,fileName):

    # Read the file into a hidden commander (Similar to g.openWithFileName).
    import leo.core.leoGui as leoGui
    import leo.core.leoFrame as leoFrame
    import leo.core.leoCommands as leoCommands

    nullGui = leoGui.nullGui('nullGui')
    frame = leoFrame.nullFrame('nullFrame',nullGui,useNullUndoer=True)
    c2 = leoCommands.Commands(frame,fileName)
    frame.c = c2
    frame.tree.c = c2
    theFile,c2.isZipped = g.openLeoOrZipFile(fileName)
    if theFile:
        c2.fileCommands.open(theFile,fileName,readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
</t>
<t tx="ekr.20070921070101.1">def createFileDict (self,c):

    '''Create a dictionary of all relevant positions in commander c.'''

    d = {}
    for p in c.all_positions():
        try:
            # fileIndices for pre-4.x versions of .leo files have a different format.
            i,j,k = p.v.fileIndex
            d[str(i),str(j),str(k)] = p.copy()
        except Exception:
            pass
    return d
</t>
<t tx="ekr.20070921072608">def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.'''

    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)

    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)

    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p1

    return inserted, deleted, changed
</t>
<t tx="ekr.20070921072608.1">def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n',kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key,p.h))
            else:
                g.pr('%-32s %s' % (key,g.toEncodedString(p.h,'ascii')))
</t>
<t tx="ekr.20070921072910">def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.p,undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    c.redraw()
</t>
<t tx="ekr.20070921074410">def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d:
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)

        for key in d:
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
</t>
<t tx="ekr.20070925144337">def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.unique_subtree():
        h = p.h
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.h,script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonButtonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'

</t>
<t tx="ekr.20070925144337.2">def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if False and not g.app.unitTesting and not g.app.silentMode:
            s = 'using menus from: %s' % c.shortFileName()
            g.es_print(s,color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20070926070412">def getMenusList (self,c):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get(c,'menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
</t>
<t tx="ekr.20070926082018">def getButtons (self):

    '''Return a list of tuples (x,y) for common @button nodes.'''

    return g.app.config.atCommonButtonsList
</t>
<t tx="ekr.20070926135612">def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))
</t>
<t tx="ekr.20070926141716">def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.h)
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        # if trace:
            # if p.h==after.h:
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count &gt;= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.b
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.h)
            p.moveToThreadNext()
</t>
<t tx="ekr.20070926142312">def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
</t>
<t tx="ekr.20070927082205">def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
</t>
<t tx="ekr.20070927172712">def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&amp;','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.  createRecentFilesMenuItems will be called later.
        self.createNewMenu(name,parentName)
        c.recentFiles = c.config.getRecentFiles()
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
</t>
<t tx="ekr.20070929125944">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4543089
By: billp9619

from the download page:

If it's the first time you hear about Python, this is the installation for you.
The packages includes complete Orange, Python, Windows Extensions for Python
(PythonWin), Numeric Python, Qt 2.2 non-commercial, PyQt, PyQwt and GraphViz.

Leo should copy this download philosophy.



</t>
<t tx="ekr.20071001052501">@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.b
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071001075704">def prettyPrintPythonTree (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; p = c.p ; pp = c.prettyPrinter(c)

    for p in p.self_and_subtree():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonTree (self,event=None,dump=False):
    return self.prettyPrintPythonTree (event,dump)
</t>
<t tx="ekr.20071003104917">xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"
</t>
<t tx="ekr.20071003160252.1">def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
</t>
<t tx="ekr.20071003160252.2">def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i &lt; 0 or i &gt;= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val

__next__ = next
</t>
<t tx="ekr.20071003183657">def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins &gt;= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j &gt; i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071004120359.2">See: regionalExpandAbbrev.
</t>
<t tx="ekr.20071005173203.1">def insertChild (self,event=None):

    '''Insert a node after the presently selected node.'''

    c = self

    return c.insertHeadline(event=event,op_name='Insert Child',as_child=True)
</t>
<t tx="ekr.20071008130845.1">def scanCSharpText (self,s,parent,atAuto=False):

    scanner = cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071008130845.2">class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
</t>
<t tx="ekr.20071009094150">def isSameColorState (self):

    return False
</t>
<t tx="ekr.20071017132056">def getIndent (self,s,i):

    j,junk = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    return indent
</t>
<t tx="ekr.20071018084830">def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
</t>
<t tx="ekr.20071019170943">def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return ids and ids[-1]
</t>
<t tx="ekr.20071019171430">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
</t>
<t tx="ekr.20071024101611">@nocolor
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20071027111225.1">def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071027111225.2"># The syntax for patterns causes all kinds of problems...

class javaScriptScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071027111225.3">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='javascript')
        # The langauge is used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
</t>
<t tx="ekr.20071027150501">def OnBodyClick (self,event=None):
    pass

def OnBodyRClick(self,event=None):
    pass
</t>
<t tx="ekr.20071028091719">def findChapterNameForPosition (self,p):

    '''
    Return the name of a chapter containing p or None if p does not exist.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return None

    for name in cc.chaptersDict:
        if name != 'main':
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                return name
    else:
        return 'main'
</t>
<t tx="ekr.20071102150937">def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j &gt;= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    elif g.match(s,i,'//'):
        # Neither of these are valid in regexp literals.
        return False
    elif g.match(s,i,'/'):
        # could be a division operator or regexp literal.
        while i &gt;= 0 and s[i-1] in ' \t\n':
            i -= 1
        if i == 0: return True
        return s[i-1] in (',([{=')
    else:
        return False
</t>
<t tx="ekr.20071102161115">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    if s[i] in ('"',"'"):
        return g.skip_string(s,i,verbose=False)
    else:
        # Match a regexp pattern.
        delim = '/'
        assert(s[i] == delim)
        i += 1
        n = len(s)
        while i &lt; n:
            if s[i] == delim and s[i-1] != '\\':
                # This ignores flags, but does that matter?
                return i + 1
            else:
                i += 1
        return i
</t>
<t tx="ekr.20071102191642.1">@nocolor

Added the following line to setup.py and setup files.

# -*- coding: utf-8 -*-

The second installation script installs the Emacs Lisp part only.
[snip]
I couldn't get this script to work.  Instead, I just created a pymacs folder at::

    C:\XEmacs\xemacs-packages\lisp\pymacs

For Win32 systems, I created create c:\Windows\pymacs-services.bat containing::

    c:\Python25\python C:\prog\Pymacs-0.22\scripts\pymacs-services

To check that pymacs.el is properly installed, start Emacs and do::

    M-x load-library RET pymacs

You should not receive any error.
(works)

To check that pymacs.py is properly installed, start an interactive Python session and type::

    from Pymacs import lisp

you should not receive any error.
(works)

To check that pymacs-services is properly installed, type the following in a console::

    pymacs-services &lt;/dev/null

You should then get a line ending with (pymacs-version version), and another saying : Protocol error : `&gt;' expected..
(works, mostly: I omitted the &lt;/dev/null

The rest is from Leo's Chapter 18::

    ; Step 1: load leoPymacs if it has not already been loaded.
    (setq reload nil)
    (if (or reload (not (boundp 'leoPymacs)))
        (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
        (message "leoPymacs already loaded")
    )

    ; Step 2: compute the path to leo/test/ut.leo using a Leo script.
    (setq script
        "g.app.scriptResult = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..','test','ut.leo'))"
    )
    (setq fileName (leo-run-script nil script))

    ; Step 3: execute a script in ut.leo.
    (setq c (leo-open fileName))
    (setq script "print 'c',c.shortFileName() ,'current:',c.p.h")
    (leo-run-script c script)
</t>
<t tx="ekr.20071103090504">@killcolor
</t>
<t tx="ekr.20071103090504.1"></t>
<t tx="ekr.20071103090504.10">pymacs-load

Function (pymacs-load module prefix) imports the Python module into Emacs Lisp space.

module is the name of the file containing the module, without any .py or .pyc extension. If the directory part is omitted in module, the module will be looked into the current Python search path. Dot notation may be used when the module is part of a package. Each top-level function in the module produces a trampoline function in Emacs Lisp having the same name, except that underlines in Python names are turned into dashes in Emacs Lisp, and that prefix is uniformly added before the Emacs Lisp name (as a way to avoid name clashes).

prefix may be omitted, in which case it defaults to base name of module with underlines turned into dashes, and followed by a dash.

Whenever pymacs_load_hook is defined in the loaded Python module, pymacs-load calls it without arguments, but before creating the Emacs view for that module. So, the pymacs_load_hook function may create new definitions or even add interaction attributes to functions.

The return value of a successful pymacs-load is the module object. An optional third argument, noerror, when given and not nil, will have pymacs-load to return nil instead of raising an error, if the Python module could not be found.

When later calling one of these trampoline functions, all provided arguments are converted to Python and transmitted, and the function return value is later converted back to Emacs Lisp. It is left to the Python side to check for argument consistency. However, for an interactive function, the interaction specification drives some checking on the Emacs Lisp side. Currently, there is no provision for collecting keyword arguments in Emacs Lisp.
</t>
<t tx="ekr.20071103090504.2">Conversions

Whenever Emacs Lisp calls Python functions giving them arguments, these arguments are Emacs Lisp structures that should be converted into Python objects in some way. Conversely, whenever Python calls Emacs Lisp functions, the arguments are Python objects that should be received as Emacs Lisp structures. We need some conventions for doing such conversions.

Conversions generally transmit mutable Emacs Lisp structures as mutable objects on the Python side, in such a way that transforming the object in Python will effectively transform the structure on the Emacs Lisp side (strings are handled a bit specially however, see below). The other way around, Python objects transmitted to Emacs Lisp often loose their mutability, so transforming the Emacs Lisp structure is not reflected on the Python side.

Pymacs sticks to standard Emacs Lisp, it explicitly avoids various Emacs Lisp extensions. One goal for many Pymacs users is taking some distance from Emacs Lisp, so Pymacs is not overly pushing users deeper into it.
</t>
<t tx="ekr.20071103090504.3">Simple objects

Emacs Lisp nil and the equivalent Emacs Lisp () yield Python None. Python None and the Python empty list [] are returned as nil in Emacs Lisp.

Emacs Lisp numbers, either integer or floating, are converted in equivalent Python numbers. Emacs Lisp characters are really numbers and yield Python numbers. In the other direction, Python numbers are converted into Emacs Lisp numbers, with the exception of long Python integers and complex numbers.

Emacs Lisp strings are usually converted into equivalent Python narrow strings. As Python strings do not have text properties, these are not reflected. This may be changed by setting the pymacs-mutable-strings option : if this variable is not nil, Emacs Lisp strings are then transmitted opaquely. Python strings, except Unicode, are always converted into Emacs Lisp strings.

Emacs Lisp symbols yield the special lisp.symbol or lisp[string] notations on the Python side. The first notation is used when the Emacs Lisp symbol starts with a letter, and contains only letters, digits and hyphens, in which case Emacs Lisp hyphens get replaced by Python underscores. This convention is welcome, as Emacs Lisp programmers commonly prefer using dashes, where Python programmers use underlines. Otherwise, the second notation is used. Conversely, lisp.symbol on the Python side yields an Emacs Lisp symbol with underscores replaced with hyphens, while lisp[string] corresponds to an Emacs Lisp symbol printed with that string which, of course, should then be a valid Emacs Lisp symbol name.
</t>
<t tx="ekr.20071103090504.4">Sequences

The case of strings has been discussed in the previous section.

Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are normally transmitted opaquely to Python. If pymacs-forget-mutability is set, or if Python later asks for these to be expanded, proper Emacs Lisp lists get converted into Python lists, if we except the empty list, which is always converted as Python None. In the other direction, Python lists are always converted into proper Emacs Lisp lists.

Emacs Lisp vectors are normally transmitted opaquely to Python. However, if pymacs-forget-mutability is set, or if Python later asks for these to be expanded, Emacs Lisp vectors get converted into Python tuples. In the other direction, Python tuples are always converted into Emacs Lisp vectors.

Remember the rule : Round parentheses correspond to square brackets!. It works for lists, vectors, tuples, seen from either Emacs Lisp or Python.

The above choices were debatable. Since Emacs Lisp proper lists and Python lists are the bread-and-butter of algorithms modifying structures, at least in my experience, I guess they are more naturally mapped into one another, this spares many casts in practice. While in Python, the most usual idiom for growing lists is appending to their end, the most usual idiom in Emacs Lisp to grow a list is by cons'ing new items at its beginning :

     (setq accumulator (cons 'new-item accumulator))


or more simply :

     (push 'new-item accumulator)


So, in case speed is especially important and many modifications happen in a row on the same side, while order of elements ought to be preserved, some (nreverse ...) on the Emacs Lisp side or .reverse() on the Python side side might be needed. Surely, proper lists in Emacs Lisp and lists in Python are the normal structure for which length is easily modified.

We cannot so easily change the size of a vector, the same as it is a bit more of a stunt to modify a tuple. The shape of these objects is fixed. Mapping vectors to tuples, which is admittedly strange, will only be done if the Python side requests an expanded copy, otherwise an opaque Emacs Lisp object is seen in Python. In the other direction, whenever an Emacs Lisp vector is needed, one has to write tuple(python_list) while transmitting the object. Such transmissions are most probably to be unusual, as people are not going to blindly transmit whole big structures back and forth between Emacs and Python, they would rather do it once in a while only, and do only local modifications afterwards. The infrequent casting to tuple for getting an Emacs Lisp vector seems to suggest that we did a reasonable compromise.

In Python, both tuples and lists have O(1) access, so there is no real speed consideration there. Emacs Lisp is different : vectors have O(1) access while lists have O(N) access. The rigidity of Emacs Lisp vectors is such that people do not resort to vectors unless there is a speed issue, so in real Emacs Lisp practice, vectors are used rather parsimoniously. So much, in fact, that Emacs Lisp vectors are overloaded for what they are not meant : for example, very small vectors are used to represent X events in key-maps, programmers only want to test vectors for their type, or users just like bracketed syntax. The speed of access is hardly an issue then.
</t>
<t tx="ekr.20071103090504.5"></t>
<t tx="ekr.20071103090504.6">Emacs Lisp handles

When a Python function is called from Emacs Lisp, the function arguments have already been converted to Python types from Emacs Lisp types and the function result is going to be converted back to Emacs Lisp.

Several Emacs Lisp objects do not have Python equivalents, like for Emacs windows, buffers, markers, overlays, etc. It is nevertheless useful to pass them to Python functions, hoping that these Python functions will operate on these Emacs Lisp objects. Of course, the Python side may not itself modify such objects, it has to call for Emacs services to do so. Emacs Lisp handles are a mean to ease this communication.

Whenever an Emacs Lisp object may not be converted to a Python object, an Emacs Lisp handle is created and used instead. Whenever that Emacs Lisp handle is returned into Emacs Lisp from a Python function, or is used as an argument to an Emacs Lisp function from Python, the original Emacs Lisp object behind the Emacs Lisp handle is automatically retrieved.

Emacs Lisp handles are either instances of the internal Lisp class, or of one of its subclasses. If object is an Emacs Lisp handle, and if the underlying Emacs Lisp object is an Emacs Lisp sequence, then whenever object[index], object[index] = value and len(object) are meaningful, these may be used to fetch or alter an element of the sequence directly in Emacs Lisp space. Also, if object corresponds to an Emacs Lisp function, object(arguments) may be used to apply the Emacs Lisp function over the given arguments. Since arguments have been evaluated the Python way on the Python side, it would be conceptual overkill evaluating them again the Emacs Lisp way on the Emacs Lisp side, so Pymacs manage to quote arguments for defeating Emacs Lisp evaluation. The same logic applies the other way around.

Emacs Lisp handles have a value() method, which merely returns self. They also have a copy() method, which tries to open the box if possible. Emacs Lisp proper lists are turned into Python lists, Emacs Lisp vectors are turned into Python tuples. Then, modifying the structure of the copy on the Python side has no effect on the Emacs Lisp side.

For Emacs Lisp handles, str() returns an Emacs Lisp representation of the handle which should be eq to the original object if read back and evaluated in Emacs Lisp. repr() returns a Python representation of the expanded Emacs Lisp object. If that Emacs Lisp object has an Emacs Lisp representation which Emacs Lisp could read back, then repr() value is such that it could be read back and evaluated in Python as well, this would result in another object which is equal to the original, but not neccessarily eq.
</t>
<t tx="ekr.20071103090504.7">Python handles

The same as Emacs Lisp handles are useful for handling Emacs Lisp objects on the Python side, Python handles are useful for handling Python objects on the Emacs Lisp side.

Many Python objects do not have direct Emacs Lisp equivalents, including long integers, complex numbers, Unicode strings, modules, classes, instances and surely a lot of others. When such are being transmitted to the Emacs Lisp side, Pymacs use Python handles. These are automatically recovered into the original Python objects whenever transmitted back to Python, either as arguments to a Python function, as the Python function itself, or as the return value of an Emacs Lisp function called from Python.

The objects represented by these Python handles may be inspected or modified using the basic library of Python functions. For example, in :

     (setq matcher (pymacs-eval "re.compile('pattern').match"))
     (pymacs-call matcher argument)


the initial setq above could be decomposed into :

           (setq compiled (pymacs-eval "re.compile('pattern')")
            matcher (pymacs-call "getattr" compiled "match"))


This example shows that one may use pymacs-call with getattr as the function, to get a wanted attribute for a Python object.
</t>
<t tx="ekr.20071103090504.8"></t>
<t tx="ekr.20071103090504.9">
pymacs-eval

Function (pymacs-eval text) gets text evaluated as a Python expression, and returns the value of that expression converted back to Emacs Lisp.

pymacs-call

Function (pymacs-call function argument...) will get Python to apply the given function over zero or more argument. function is either a string holding Python source code for a function (like a mere name, or even an expression), or else, a Python handle previously received from Python, and hopefully holding a callable Python object. Each argument gets separately converted to Python before the function is called. pymacs-call returns the resulting value of the function call, converted back to Emacs Lisp.

pymacs-apply

Function (pymacs-apply function arguments) will get Python to apply the given function over the given arguments. arguments is a list containing all arguments, or nil if there is none. Besides arguments being bundled together instead of given separately, the function acts pretty much like pymacs-call.

We do not expect that pymacs-eval, pymacs-call or pymacs-apply will be much used, if ever. In practice, the Emacs Lisp side of a Pymacs application might call pymacs-load a few times for linking into the Python modules, with the indirect effect of defining trampoline functions for these modules on the Emacs Lisp side, which can later be called like usual Emacs Lisp functions.
</t>
<t tx="ekr.20071103091052"></t>
<t tx="ekr.20071103091052.1">Python setup

Pymacs requires little or no setup in the Python modules which are meant to be used from Emacs, for the simple situations where these modules receive nothing but Emacs nil, numbers or strings, or return nothing but Python None, numbers or strings.

Otherwise, use from Pymacs import lisp. If you need more Pymacs features, like the Let class, write from Pymacs import lisp, Let.
</t>
<t tx="ekr.20071103091052.2">Response mode

When Python receives a request from Emacs in the context of Pymacs, and until it returns the reply, Emacs keeps listening to serve Python requests. Emacs is not listening otherwise. Other Python threads, if any, may not call Emacs without very careful synchronisation.
</t>
<t tx="ekr.20071103091052.3">Emacs Lisp symbols

lisp is a special object which has useful built-in magic. Its attributes do nothing but represent Emacs Lisp symbols, created on the fly as needed (symbols also have their built-in magic).

lisp.nil or lisp["nil"], are the same as None.

Otherwise, lisp.symbol and lisp[string] yield objects of the internal Symbol type. These are genuine Python objects, that could be referred to by simple Python variables. One may write quote = lisp.quote, for example, and use quote afterwards to mean that Emacs Lisp symbol. If a Python function received an Emacs Lisp symbol as an argument, it can check with == if that argument is lisp.never or lisp.ask, say. A Python function may well choose to return lisp.t.

In Python, writing lisp.symbol = value or lisp[string] = value does assign value to the corresponding symbol in Emacs Lisp space. Beware that in such cases, the lisp. prefix may not be [omitted] spared. After result = lisp.result, one cannot hope that a later result = 3 will have any effect in the Emacs Lisp space : this would merely change the Python variable result, which was a reference to a Symbol instance, so it is now a reference to the number 3.

The Symbol class has value() and copy() methods. One can use either lisp.symbol.value() or lisp.symbol.copy() to access the Emacs Lisp value of a symbol, after conversion to some Python object, of course. However, if value() would have given an Emacs Lisp handle, lisp.symbol.copy() has the effect of lisp.symbol.value().copy(), that is, it returns the value of the symbol as opened as possible.

A symbol may also be used as if it was a Python function, in which case it really names an Emacs Lisp function that should be applied over the following function arguments. The result of the Emacs Lisp function becomes the value of the call, with all due conversions of course.
</t>
<t tx="ekr.20071103091052.4">Dynamic bindings

As Emacs Lisp uses dynamic bindings, it is common that Emacs Lisp programs use
let for temporarily setting new values for some Emacs Lisp variables having
global scope. These variables recover their previous value automatically when
the let gets completed, even if an error occurs which interrupts the normal flow
of execution.

Pymacs has a Let class to represent such temporary settings. Suppose for example
that you want to recover the value of lisp.mark() when the transient mark mode
is active on the Emacs Lisp side. One could surely use lisp.mark(lisp.t) to
force reading the mark in such cases, but for the sake of illustration, let's
ignore that, and temporarily deactivate transient mark mode instead. This could
be done this way :

        try :
        let = Let()
        let.push(transient_mark_mode=None)
        ... user code ...
        finally :
        let.pop()

let.push() accepts any number of keywords arguments. Each keyword name is
interpreted as an Emacs Lisp symbol written the Pymacs way, with underlines. The
value of that Emacs Lisp symbol is saved on the Python side, and the value of
the keyword becomes the new temporary value for this Emacs Lisp symbol. A later
let.pop() restores the previous value for all symbols which were saved together
at the time of the corresponding let.push(). There may be more than one
let.push() call for a single Let instance, they stack within that instance. Each
let.pop() will undo one and only one let.push() from the stack, in the reverse
order or the pushes.

When the Let instance disappears, either because the programmer does del let or
let = None, or just because the Python let variable goes out of scope, all
remaining let.pop() get automatically executed, so the try/finally statement may
be omitted in practice. For this omission to work flawlessly, the programmer
should be careful at not keeping extra references to the Let instance.

The constructor call let = Let() also has an implied initial .push() over all
given arguments, so the explicit let.push() may be omitted as well. In practice,
this sums up and the above code could be reduced to a mere :

     let = Let(transient_mark_mode=None)
     ... user code ...

Be careful at assigning the result of the constructor to some Python variable.
Otherwise, the instance would disappear immediately after having been created,
restoring the Emacs Lisp variable much too soon.

Any variable to be bound with Let should have been bound in advance on the Emacs
Lisp side. This restriction usually does no kind of harm. Yet, it will likely be
lifted in some later version of Pymacs.

The Let class has other methods meant for some macros which are common in Emacs
Lisp programming, in the spirit of let bindings. These method names look like
push_* or pop_*, where Emacs Lisp macros are save-*. One has to use the matching
pop_* for undoing the effect of a given push_* rather than a mere .pop() : the
Python code is clearer, this also ensures that things are undone in the proper
order. The same Let instance may use many push_* methods, their effects nest.

push_excursion() and pop_excursion() save and restore the current buffer, point
and mark. push_match_data() and pop_match_data() save and restore the state of
the last regular expression match. push_restriction() and pop_restriction() save
and restore the current narrowing limits. push_selected_window() and
pop_selected_window() save and restore the fact that a window holds the cursor.
push_window_excursion() and pop_window_excursion() save and restore the current
window configuration in the Emacs display.

As a convenience, let.push() and all other push_* methods return the Let
instance. This helps chaining various push_* right after the instance
generation. For example, one may write :

         let = Let().push_excursion()
         if True :
         ... user code ...
         del let

The if True: (use if 1: with older Python releases, some people might prefer
writing if let: anyway), has the only goal of indenting user code, so the scope
of the let variable is made very explicit. This is purely stylistic, and not at
all necessary. The last del let might be omitted in a few circumstances, for
example if the excursion lasts until the end of the Python function.
</t>
<t tx="ekr.20071103091052.5">Raw Emacs Lisp expressions

Pymacs offers a device for evaluating a raw Emacs Lisp expression, or a sequence of such, expressed as a string. One merely uses lisp as a function, like this :

     lisp("""
     ...
     possibly-long-sequence-of-lisp-expressions
     ...
     """)


The Emacs Lisp value of the last or only expression in the sequence becomes the value of the lisp call, after conversion back to Python.
</t>
<t tx="ekr.20071103091052.6">User interaction

Emacs functions have the concept of user interaction for completing the specification of their arguments while being called. This happens only when a function is interactively called by the user, it does not happen when a function is programmatically called by another. As Python does not have a corresponding facility, a bit of trickery was needed to retrofit that facility on the Python side.

After loading a Python module but prior to creating an Emacs view for this
module, Pymacs decides whether loaded functions will be interactively callable
from Emacs, or not. Whenever a function has an interaction attribute, this
attribute holds the Emacs interaction specification for this function. The
specification is either another Python function or a string. In the former case,
that other function is called without arguments and should, maybe after having
consulted the user, return a list of the actual arguments to be used for the
original function. In the latter case, the specification string is used verbatim
as the argument to the (interactive ...) function on the Emacs side. To get a
short reminder about how this string is interpreted on the Emacs side, try C-h f
interactive within Emacs. Here is an example where an empty string is used to
specify that an interactive has no arguments::

    from Pymacs import lisp

    def hello_world() :
        "`Hello world' from Python."
        lisp.insert("Hello from Python!")
        hello_world.interaction = ''

Versions of Python released before the integration of PEP 232 do not allow users
to add attributes to functions, so there is a fallback mechanism. Let's presume
that a given function does not have an interaction attribute as explained above.
If the Python module contains an interactions global variable which is a
dictionary, if that dictionary has an entry for the given function with a value
other than None, that function is going to be interactive on the Emacs side.
Here is how the preceeding example should be written for an older version of
Python, or when portability is at premium::

    from Pymacs import lisp
    interactions = {}

    def hello_world() :
        "`Hello world' from Python."
        lisp.insert("Hello from Python!")
        interactions[hello_world] = ''

One might wonder why we do not merely use lisp.interactive(...) from within
Python. There is some magic in the Emacs Lisp interpreter itself, looking for
that call before the function is actually entered, this explains why
(interactive ...) has to appear first in an Emacs Lisp defun. Pymacs could try
to scan the already compiled form of the Python code, seeking for
lisp.interactive, but as the evaluation of lisp.interactive arguments could get
arbitrarily complex, it would a real challenge un-compiling that evaluation into
Emacs Lisp.
</t>
<t tx="ekr.20071103091052.7">Keybindings

An interactive function may be bound to a key sequence.

To translate bindings like C-x w, say, one might have to know a bit more how
Emacs Lisp processes string escapes like \C-x or \M-\C-x in Emacs Lisp, and
emulate it within Python strings, since Python does not have such escapes. \C-L,
where L is an upper case letter, produces a character which ordinal is the
result of subtracting 0x40 from ordinal of L. \M- has the ordinal one gets by
adding 0x80 to the ordinal of following described character. So people can use
self-inserting non-ASCII characters, \M- is given another representation, which
is to replace the addition of 0x80 by prefixing with `ESC', that is 0x1b.

So \C-x in Emacs is '\x18' in Python. This is easily found, using an interactive
Python session, by givin it : chr(ord('X') - ord('A') + 1). An easier way would
be using the kbd function on the Emacs Lisp side, like with lisp.kbd('C-x w') or
lisp.kbd('M-&lt;f2&gt;').

To bind the F1 key to the helper function in some module :

     lisp.global_set_key((lisp.f1,), lisp.module_helper)

(item,) is a Python tuple yielding an Emacs Lisp vector. lisp.f1 translates to
the Emacs Lisp symbol f1. So, Python (lisp.f1,) is Emacs Lisp [f1]. Keys like
[M-f2] might require some more ingenuity, one may write either (lisp['M-f2'],)
or (lisp.M_f2,) on the Python side.
</t>
<t tx="ekr.20071103092153"></t>
<t tx="ekr.20071103092153.1">The *Pymacs* buffer

Emacs and Python are two separate processes (well, each may use more than one process). Pymacs implements a simple communication protocol between both, and does whatever needed so the programmers do not have to worry about details. The main debugging tool is the communication buffer between Emacs and Python, which is named *Pymacs*. As it is sometimes helpful to understand the communication protocol, it is briefly explained here, using an artificially complex example to do so. Consider :

     (pymacs-eval "lisp('(pymacs-eval \"`2L**111`\")')")
     "2596148429267413814265248164610048L"

Here, Emacs asks Python to ask Emacs to ask Python for a simple bignum computation. Note that Emacs does not natively know how to handle big integers, nor has an internal representation for them. This is why I use backticks, so Python returns a string representation of the result, instead of the result itself. Here is a trace for this example. The &lt; character flags a message going from Python to Emacs and is followed by an expression written in Emacs Lisp. The &gt; character flags a message going from Emacs to Python and is followed by a expression written in Python. The number gives the length of the message.

     &lt;22   (pymacs-version "0.3")
     &gt;49   eval("lisp('(pymacs-eval \"`2L**111`\")')")
     &lt;25   (pymacs-eval "`2L**111`")
     &gt;18   eval("`2L**111`")
     &lt;47   (pymacs-reply "2596148429267413814265248164610048L")
     &gt;45   reply("2596148429267413814265248164610048L")
     &lt;47   (pymacs-reply "2596148429267413814265248164610048L")

Python evaluation is done in the context of the Pymacs.pymacs module, so for example a mere reply really means Pymacs.pymacs.reply. On the Emacs Lisp side, there is no concept of module namespaces, so we use the pymacs- prefix as an attempt to stay clean. Users should ideally refrain from naming their Emacs Lisp objects with a pymacs- prefix.

reply and pymacs-reply are special functions meant to indicate that an expected result is finally transmitted. error and pymacs-error are special functions that introduce a string which explains an exception which recently occurred. pymacs-expand is a special function implementing the copy() methods of Emacs Lisp handles or symbols. In all other cases, the expression is a request for the other side, that request stacks until a corresponding reply is received.

Part of the protocol manages memory, and this management generates some extra-noise in the *Pymacs* buffer. Whenever Emacs passes a structure to Python, an extra pointer is generated on the Emacs side to inhibit garbage collection by Emacs. Python garbage collector detects when the received structure is no longer needed on the Python side, at which time the next communication will tell Emacs to remove the extra pointer. It works symmetrically as well, that is, whenever Python passes a structure to Emacs, an extra Python reference is generated to inhibit garbage collection on the Python side. Emacs garbage collector detects when the received structure is no longer needed on the Emacs side, after which Python will be told to remove the extra reference. For efficiency, those allocation-related messages are delayed, merged and batched together within the next communication having another purpose.

Variable pymacs-trace-transit may be modified for controlling how and when the *Pymacs* buffer, or parts thereof, get erased.
</t>
<t tx="ekr.20071103092153.2">Emacs usual debugging

If cross-calls between Emacs Lisp and Python nest deeply, an error will raise
successive exceptions alternatively on both sides as requests unstack, and the
diagnostic gets transmitted back and forth, slightly growing as we go. So,
errors will eventually be reported by Emacs. I made no kind of effort to
transmit the Emacs Lisp backtrace on the Python side, as I do not see a purpose
for it : all debugging is done within Emacs windows anyway.

On recent Emacses, the Python backtrace gets displayed in the mini-buffer, and
the Emacs Lisp backtrace is simultaneously shown in the *Backtrace* window. One
useful thing is to allow to mini-buffer to grow big, so it has more chance to
fully contain the Python backtrace, the last lines of which are often especially
useful. Here, I use :

         (setq resize-mini-windows t
          max-mini-window-height .85)

in my .emacs file, so the mini-buffer may use 85% of the screen, and quickly
shrinks when fewer lines are needed. The mini-buffer contents disappear at the
next keystroke, but you can recover the Python backtrace by looking at the end
of the *Messages* buffer. In which case the ffap package in Emacs may be yet
another friend! From the *Messages* buffer, once ffap activated, merely put the
cursor on the file name of a Python module from the backtrace, and C-x C-f RET
will quickly open that source for you.
</t>
<t tx="ekr.20071103092153.3">Auto-reloading on save

I found useful to automatically pymacs-load some Python files whenever they get
saved from Emacs. This can be decided on a per-file or per-directory basis. To
get a particular Python file to be reloaded automatically on save, add the
following lines at the end :

     # Local Variables :
     # pymacs-auto-reload : t
     # End :

Here is an example of automatic reloading on a per-directory basis. The code
below assumes that Python files meant for Pymacs are kept in
~/share/emacs/python.

    (defun fp-maybe-pymacs-reload ()
        (let ((pymacsdir (expand-file-name "~/share/emacs/python/")))
         (when (and (string-equal (file-name-directory buffer-file-name)
                  pymacsdir)
              (string-match "\\.py\\'" buffer-file-name))
          (pymacs-load (substring buffer-file-name 0 -3)))))
         (add-hook 'after-save-hook 'fp-maybe-pymacs-reload)
</t>
<t tx="ekr.20071103092153.4">@nocolor
Let's say I have a a module, call it manglers.py, containing this simple python
function::

    def break_on_whitespace(some_string) :
         words = some_string.split()
         return '\n'.join(words)

The goal is telling Emacs about this function so that I can call it on a region
of text and replace the region with the result of the call. We shall also bind
this function to the key [f7].

Here is the Python side::
@color

    from Pymacs import lisp
    interactions = {}

    def break_on_whitespace():
        # start and end may be given in any order.
        start,end = lisp.point(),lisp.mark(lisp.t)
        words = lisp.buffer_substring(start, end).split()
        lisp.delete_region(start,end)
        lisp.insert('\n'.join(words))

    interactions[break_on_whitespace] = ''
@nocolor

Here is the emacs side::

    (pymacs-load "manglers")
    (global-set-key [f7] 'manglers-break-on-whitespace)
</t>
<t tx="ekr.20071103093725">For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box by hand, as needed. This piece of
Python code eases my life on this. It may be used interactively from within
Emacs through the Pymacs interface, or in batch as a script which filters a
single region to be reformatted.

In batch mode, the reboxing is driven by command options and arguments and expects a
complete, self-contained boxed comment from a file.

Emacs function rebox-region also presumes that the region encloses a single
boxed comment.

Emacs rebox-comment is different, as it has to chase itself the extent of the
surrounding boxed comment.

</t>
<t tx="ekr.20071103093725.1">@color
@language python
@tabwidth -4

@others
&lt;&lt; templates &gt;&gt;

if __name__ == '__main__':
    apply(main, sys.argv[1:])
</t>
<t tx="ekr.20071103093725.10">def emacs_engine(self, flag, find_limits):
    """\
Rebox text while obeying FLAG.  Call FIND_LIMITS to discover the extent
of the boxed comment.
"""
    # `C-u -' means that box style is to be decided interactively.
    if flag == lisp['-']:
        flag = self.ask_for_style()
    # If FLAG is zero or negative, only change default box style.
    if type(flag) is type(0) and flag &lt;= 0:
        self.default_style = -flag
        lisp.message("Default style set to %d" % -flag)
        return
    # Decide box style and refilling.
    if flag is None:
        style = self.default_style
        refill = 1
    elif type(flag) == type(0):
        if self.default_style is None:
            style = flag
        else:
            style = merge_styles(self.default_style, flag)
        refill = 1
    else:
        flag = flag.copy()
        if type(flag) == type([]):
            style = self.default_style
            refill = 0
        else:
            lisp.error("Unexpected flag value %s" % flag)
    # Prepare for reboxing.
    lisp.message("Reboxing...")
    checkpoint = lisp.buffer_undo_list.value()
    start, end = find_limits()
    text = lisp.buffer_substring(start, end)
    width = lisp.fill_column.value()
    tabify = lisp.indent_tabs_mode.value() is not None
    point = lisp.point()
    if start &lt;= point &lt; end:
        position = point - start
    else:
        position = None
    # Rebox the text and replace it in Emacs buffer.
    old_style, new_style, text, position = engine(
        text, style=style, width=width,
        refill=refill, tabify=tabify, position=position)
    if text is None:
        lisp.error("Cannot rebox to style %d" % new_style)
    lisp.delete_region(start, end)
    lisp.insert(text)
    if position is not None:
        lisp.goto_char(start + position)
    # Collapse all operations into a single one, for Undo.
    self.clean_undo_after(checkpoint)
    # We are finished, tell the user.
    if old_style == new_style:
        lisp.message("Reboxed with style %d" % old_style)
    else:
        lisp.message("Reboxed from style %d to %d"
                     % (old_style, new_style))

</t>
<t tx="ekr.20071103093725.11">def ask_for_style(self):
    """\
Request the style interactively, using the minibuffer.
"""
    language = quality = type = None
    while language is None:
        lisp.message("\
Box language is 100-none, 200-/*, 300-//, 400-#, 500-;, 600-%%")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('6'):
            language = key - ord('0')
    while quality is None:
        lisp.message("\
Box quality/width is 10-simple/1, 20-rounded/2, 30-starred/3 or 40-starred/4")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('4'):
            quality = key - ord('0')
    while type is None:
        lisp.message("\
Box type is 1-opened, 2-half-single, 3-single, 4-half-double or 5-double")
        key = lisp.read_char()
        if key &gt;= ord('0') and key &lt;= ord('5'):
            type = key - ord('0')
    return 100*language + 10*quality + type

</t>
<t tx="ekr.20071103093725.12">def find_region(self):
    """\
Return the limits of the region.
"""
    return lisp.point(), lisp.mark(lisp.t)

</t>
<t tx="ekr.20071103093725.13">def find_comment(self):
    """\
Find and return the limits of the block of comments following or enclosing
the cursor, or return an error if the cursor is not within such a block
of comments.  Extend it as far as possible in both directions.
"""
    let = Let()
    let.push_excursion()
    # Find the start of the current or immediately following comment.
    lisp.beginning_of_line()
    lisp.skip_chars_forward(' \t\n')
    lisp.beginning_of_line()
    if not language_matcher[0](self.remainder_of_line()):
        temp = lisp.point()
        if not lisp.re_search_forward('\\*/', None, lisp.t):
            lisp.error("outside any comment block")
        lisp.re_search_backward('/\\*')
        if lisp.point() &gt; temp:
            lisp.error("outside any comment block")
        temp = lisp.point()
        lisp.beginning_of_line()
        lisp.skip_chars_forward(' \t')
        if lisp.point() != temp:
            lisp.error("text before start of comment")
        lisp.beginning_of_line()
    start = lisp.point()
    language = guess_language(self.remainder_of_line())
    # Find the end of this comment.
    if language == 2:
        lisp.search_forward('*/')
        if not lisp.looking_at('[ \t]*$'):
            lisp.error("text after end of comment")
    lisp.end_of_line()
    if lisp.eobp():
        lisp.insert('\n')
    else:
        lisp.forward_char(1)
    end = lisp.point()
    # Try to extend the comment block backwards.
    lisp.goto_char(start)
    while not lisp.bobp():
        if language == 2:
            lisp.skip_chars_backward(' \t\n')
            if not lisp.looking_at('[ \t]*\n[ \t]*/\\*'):
                break
            if lisp.point() &lt; 2:
                break
            lisp.backward_char(2)
            if not lisp.looking_at('\\*/'):
                break
            lisp.re_search_backward('/\\*')
            temp = lisp.point()
            lisp.beginning_of_line()
            lisp.skip_chars_forward(' \t')
            if lisp.point() != temp:
                break
            lisp.beginning_of_line()
        else:
            lisp.previous_line(1)
            if not language_matcher[language](self.remainder_of_line()):
                break
        start = lisp.point()
    # Try to extend the comment block forward.
    lisp.goto_char(end)
    while language_matcher[language](self.remainder_of_line()):
        if language == 2:
            lisp.re_search_forward('[ \t]*/\\*')
            lisp.re_search_forward('\\*/')
            if lisp.looking_at('[ \t]*$'):
                lisp.beginning_of_line()
                lisp.forward_line(1)
                end = lisp.point()
        else:
            lisp.forward_line(1)
            end = lisp.point()
    return start, end

</t>
<t tx="ekr.20071103093725.14">def remainder_of_line(self):
    """\
Return all characters between point and end of line in Emacs buffer.
"""
    return lisp('''\
(buffer-substring (point) (save-excursion (skip-chars-forward "^\n") (point)))
''')

</t>
<t tx="ekr.20071103093725.15">def clean_undo_after_old(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    # Declare some LISP functions.
    car = lisp.car
    cdr = lisp.cdr
    eq = lisp.eq
    setcdr = lisp.setcdr
    # Remove any `nil' delimiter recently added to the Undo list.
    cursor = lisp.buffer_undo_list.value()
    if not eq(cursor, checkpoint):
        tail = cdr(cursor)
        while not eq(tail, checkpoint):
            if car(tail):
                cursor = tail
                tail = cdr(cursor)
            else:
                tail = cdr(tail)
                setcdr(cursor, tail)

</t>
<t tx="ekr.20071103093725.16">def clean_undo_after(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    lisp("""
(let ((undo-list %s))
(if (not (eq buffer-undo-list undo-list))
  (let ((cursor buffer-undo-list))
(while (not (eq (cdr cursor) undo-list))
  (if (car (cdr cursor))
      (setq cursor (cdr cursor))
    (setcdr cursor (cdr (cdr cursor)))))))
nil)
"""
         % (checkpoint or 'nil'))

</t>
<t tx="ekr.20071103093725.17">def engine(text, style=None, width=79, refill=1, tabify=0, position=None):
    """\
Add, delete or adjust a boxed comment held in TEXT, according to STYLE.
STYLE values are explained at beginning of this file.  Any zero attribute
in STYLE indicates that the corresponding attribute should be recovered
from the currently existing box.  Produced lines will not go over WIDTH
columns if possible, if refilling gets done.  But if REFILL is false, WIDTH
is ignored.  If TABIFY is true, the beginning of produced lines will have
spaces replace by TABs.  POSITION is either None, or a character position
within TEXT.  Returns four values: the old box style, the new box style,
the reformatted text, and either None or the adjusted value of POSITION in
the new text.  The reformatted text is returned as None if the requested
style does not exist.
"""
    last_line_complete = text and text[-1] == '\n'
    if last_line_complete:
        text = text[:-1]
    lines = string.split(string.expandtabs(text), '\n')
    # Decide about refilling and the box style to use.
    new_style = 111
    old_template = guess_template(lines)
    new_style = merge_styles(new_style, old_template.style)
    if style is not None:
        new_style = merge_styles(new_style, style)
    new_template = template_registry.get(new_style)
    # Interrupt processing if STYLE does not exist.
    if not new_template:
        return old_template.style, new_style, None, None
    # Remove all previous comment marks, and left margin.
    if position is not None:
        marker = Marker()
        marker.save_position(text, position, old_template.characters())
    lines, margin = old_template.unbuild(lines)
    # Ensure only one white line between paragraphs.
    counter = 1
    while counter &lt; len(lines) - 1:
        if lines[counter] == '' and lines[counter-1] == '':
            del lines[counter]
        else:
            counter = counter + 1
    # Rebuild the boxed comment.
    lines = new_template.build(lines, width, refill, margin)
    # Retabify to the left only.
    if tabify:
        for counter in range(len(lines)):
            tabs = len(re.match(' *', lines[counter]).group()) / 8
            lines[counter] = '\t' * tabs + lines[counter][8*tabs:]
    # Restore the point position.
    text = string.join(lines, '\n')
    if last_line_complete:
        text = text + '\n'
    if position is not None:
        position = marker.get_position(text, new_template.characters())
    return old_template.style, new_style, text, position

</t>
<t tx="ekr.20071103093725.18">def guess_language(line):
    """\
Guess the language in use for LINE.
"""
    for language in range(len(language_matcher) - 1, 1, -1):
        if language_matcher[language](line):
            return language
    return 1

</t>
<t tx="ekr.20071103093725.19">def guess_template(lines):
    """\
Find the heaviest box template matching LINES.
"""
    best_template = None
    for template in template_registry.values():
        if best_template is None or template &gt; best_template:
            if template.match(lines):
                best_template = template
    return best_template

</t>
<t tx="ekr.20071103093725.2">#!/usr/bin/env python
# Copyright © 1991-1998, 2000, 2002 Progiciels Bourbeau-Pinard inc.
# François Pinard &lt;pinard@iro.umontreal.ca&gt;, April 1991.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""\
Handling of boxed comments in various box styles.

Introduction
------------

For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box "by hand", as needed.  This piece
of Python code eases my life on this.  It may be used interactively from
within Emacs through the Pymacs interface, or in batch as a script which
filters a single region to be reformatted.  I find only fair, while giving
all sources for a package using such boxed comments, to also give the
means I use for nicely modifying comments.  So here they are!

Box styles
----------

Each supported box style has a number associated with it.  This number is
arbitrary, yet by _convention_, it holds three non-zero digits such the the
hundreds digit roughly represents the programming language, the tens digit
roughly represents a box quality (or weight) and the units digit roughly
a box type (or figure).  An unboxed comment is merely one of box styles.
Language, quality and types are collectively referred to as style attributes.

When rebuilding a boxed comment, attributes are selected independently
of each other.  They may be specified by the digits of the value given
as Emacs commands argument prefix, or as the `-s' argument to the `rebox'
script when called from the shell.  If there is no such prefix, or if the
corresponding digit is zero, the attribute is taken from the value of the
default style instead.  If the corresponding digit of the default style
is also zero, than the attribute is recognised and taken from the actual
boxed comment, as it existed before prior to the command.  The value 1,
which is the simplest attribute, is ultimately taken if the parsing fails.

A programming language is associated with comment delimiters.  Values are
100 for none or unknown, 200 for `/*' and `*/' as in plain C, 300 for `//'
as in C++, 400 for `#' as in most scripting languages, 500 for `;' as in
LISP or assembler and 600 for `%' as in TeX or PostScript.

Box quality differs according to language. For unknown languages (100) or
for the C language (200), values are 10 for simple, 20 for rounded, and
30 or 40 for starred.  Simple quality boxes (10) use comment delimiters
to left and right of each comment line, and also for the top or bottom
line when applicable. Rounded quality boxes (20) try to suggest rounded
corners in boxes.  Starred quality boxes (40) mostly use a left margin of
asterisks or X'es, and use them also in box surroundings.  For all others
languages, box quality indicates the thickness in characters of the left
and right sides of the box: values are 10, 20, 30 or 40 for 1, 2, 3 or 4
characters wide.  With C++, quality 10 is not useful, it is not allowed.

Box type values are 1 for fully opened boxes for which boxing is done
only for the left and right but not for top or bottom, 2 for half
single lined boxes for which boxing is done on all sides except top,
3 for fully single lined boxes for which boxing is done on all sides,
4 for half double lined boxes which is like type 2 but more bold,
or 5 for fully double lined boxes which is like type 3 but more bold.

The special style 221 is for C comments between a single opening `/*'
and a single closing `*/'.  The special style 111 deletes a box.

Batch usage
-----------

Usage is `rebox [OPTION]... [FILE]'.  By default, FILE is reformatted to
standard output by refilling the comment up to column 79, while preserving
existing boxed comment style.  If FILE is not given, standard input is read.
Options may be:

  -n         Do not refill the comment inside its box, and ignore -w.
  -s STYLE   Replace box style according to STYLE, as explained above.
  -t         Replace initial sequence of spaces by TABs on each line.
  -v         Echo both the old and the new box styles on standard error.
  -w WIDTH   Try to avoid going over WIDTH columns per line.

So, a single boxed comment is reformatted by invocation.  `vi' users, for
example, would need to delimit the boxed comment first, before executing
the `!}rebox' command (is this correct? my `vi' recollection is far away).

Batch usage is also slow, as internal structures have to be reinitialised
at every call.  Producing a box in a single style is fast, but recognising
the previous style requires setting up for all possible styles.

Emacs usage
-----------

For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file:

     (add-hook 'c-mode-hook 'fp-c-mode-routine)
     (defun fp-c-mode-routine ()
       (local-set-key "\M-q" 'rebox-comment))
     (autoload 'rebox-comment "rebox" nil t)
     (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

     (pymacs-load "Pymacs.rebox")

Install Pymacs from `http://www.iro.umontreal.ca/~pinard/pymacs.tar.gz'.

The Emacs function `rebox-comment' automatically discovers the extent of
the boxed comment near the cursor, possibly refills the text, then adjusts
the box style.  When this command is executed, the cursor should be within
a comment, or else it should be between two comments, in which case the
command applies to the next comment.  The function `rebox-region' does
the same, except that it takes the current region as a boxed comment.
Both commands obey numeric prefixes to add or remove a box, force a
particular box style, or to prevent refilling of text.  Without such
prefixes, the commands may deduce the current box style from the comment
itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

If you use the `rebox' script rather than Emacs, the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

On average, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.

History
-------

I first observed rounded corners, as in style 223 boxes, in code from
Warren Tucker, a previous maintainer of the `shar' package, circa 1980.

Except for very special files, I carefully avoided boxed comments for
real work, as I found them much too hard to maintain.  My friend Paul
Provost was working at Taarna, a computer graphics place, which had boxes
as part of their coding standards.  He asked that we try something to get
him out of his misery, and this how `rebox.el' was originally written.
I did not plan to use it for myself, but Paul was so enthusiastic that I
timidly started to use boxes in my things, very little at first, but more
and more as time passed, still in doubt that it was a good move.  Later,
many friends spontaneously started to use this tool for real, some being very
serious workers.  This convinced me that boxes are acceptable, after all.

I do not use boxes much with Python code.  It is so legible that boxing
is not that useful.  Vertical white space is less necessary, too.  I even
avoid white lines within functions.  Comments appear prominent enough when
using highlighting editors like Emacs or nice printer tools like `enscript'.

After Emacs could be extended with Python, in 2001, I translated `rebox.el'
into `rebox.py', and added the facility to use it as a batch script.
"""

## Note: This code is currently compatible down to Python version 1.5.2.
## It is probably worth keeping it that way for a good while, still.

## Note: a double hash comment introduces a group of functions or methods.

import re, string, sys

</t>
<t tx="ekr.20071103093725.20">def left_margin_size(lines):
    """\
Return the width of the left margin for all LINES.  Ignore white lines.
"""
    margin = None
    for line in lines:
        counter = len(re.match(' *', line).group())
        if counter != len(line):
            if margin is None or counter &lt; margin:
                margin = counter
    if margin is None:
        margin = 0
    return margin

</t>
<t tx="ekr.20071103093725.21">def merge_styles(original, update):
    """\
Return style attributes as per ORIGINAL, in which attributes have been
overridden by non-zero corresponding style attributes from UPDATE.
"""
    style = [original / 100, original / 10 % 10, original % 10]
    merge = update / 100, update / 10 % 10, update % 10
    for counter in range(3):
        if merge[counter]:
            style[counter] = merge[counter]
    return 100*style[0] + 10*style[1] + style[2]

</t>
<t tx="ekr.20071103093725.22">def refill_lines(lines, width):
    """\
Refill LINES, trying to not produce lines having more than WIDTH columns.
"""
    # Try using GNU `fmt'.
    import tempfile, os
    name = tempfile.mktemp()
    open(name, 'w').write(string.join(lines, '\n') + '\n')
    process = os.popen('fmt -cuw %d %s' % (width, name))
    text = process.read()
    os.remove(name)
    if process.close() is None:
        return map(string.expandtabs, string.split(text, '\n')[:-1])
    # If `fmt' failed, do refilling more naively, wihtout using the
    # Knuth algorithm, nor protecting full stops at end of sentences.
    lines.append(None)
    new_lines = []
    new_line = ''
    start = 0
    for end in range(len(lines)):
        if not lines[end]:
            margin = left_margin_size(lines[start:end])
            for line in lines[start:end]:
                counter = len(re.match(' *', line).group())
                if counter &gt; margin:
                    if new_line:
                        new_lines.append(' ' * margin + new_line)
                        new_line = ''
                    indent = counter - margin
                else:
                    indent = 0
                for word in string.split(line):
                    if new_line:
                        if len(new_line) + 1 + len(word) &gt; width:
                            new_lines.append(' ' * margin + new_line)
                            new_line = word
                        else:
                            new_line = new_line + ' ' + word
                    else:
                        new_line = ' ' * indent + word
                        indent = 0
            if new_line:
                new_lines.append(' ' * margin + new_line)
                new_line = ''
            if lines[end] is not None:
                new_lines.append('')
                start = end + 1
    return new_lines

</t>
<t tx="ekr.20071103093725.23">class Marker:
    @others
</t>
<t tx="ekr.20071103093725.24">
## Heuristic to simulate a marker while reformatting boxes.

def save_position(self, text, position, ignorable):
    """\
Given a TEXT and a POSITION in that text, save the adjusted position
by faking that all IGNORABLE characters before POSITION were removed.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    for character in text[:position]:
        if character in ignore:
            counter = counter + 1
    self.position = position - counter

</t>
<t tx="ekr.20071103093725.25">def get_position(self, text, ignorable, latest=0):
    """\
Given a TEXT, return the value that would yield the currently saved position,
if it was saved by `save_position' with IGNORABLE.  Unless the position lies
within a series of ignorable characters, LATEST has no effect in practice.
If LATEST is true, return the biggest possible value instead of the smallest.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    position = 0
    if latest:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                if position == self.position:
                    break
                position = position + 1
    elif self.position &gt; 0:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                position = position + 1
                if position == self.position:
                    break
    return position + counter

</t>
<t tx="ekr.20071103093725.26">## Template processing.

class Template:
    @others
</t>
<t tx="ekr.20071103093725.27">
def __init__(self, style, weight, lines):
    """\
Digest and register a single template.  The template is numbered STYLE,
has a parsing WEIGHT, and is described by one to three LINES.
STYLE should be used only once through all `declare_template' calls.

One of the lines should contain the substring `box' to represent the comment
to be boxed, and if three lines are given, `box' should appear in the middle
one.  Lines containing only spaces are implied as necessary before and after
the the `box' line, so we have three lines.

Normally, all three template lines should be of the same length.  If the first
line is shorter, it represents a start comment string to be bundled within the
first line of the comment text.  If the third line is shorter, it represents
an end comment string to be bundled at the end of the comment text, and
refilled with it.
"""
    assert style not in template_registry, \
           "Style %d defined more than once" % style
    self.style = style
    self.weight = weight
    # Make it exactly three lines, with `box' in the middle.
    start = string.find(lines[0], 'box')
    if start &gt;= 0:
        line1 = None
        line2 = lines[0]
        if len(lines) &gt; 1:
            line3 = lines[1]
        else:
            line3 = None
    else:
        start = string.find(lines[1], 'box')
        if start &gt;= 0:
            line1 = lines[0]
            line2 = lines[1]
            if len(lines) &gt; 2:
                line3 = lines[2]
            else:
                line3 = None
        else:
            assert 0, "Erroneous template for %d style" % style
    end = start + len('box')
    # Define a few booleans.
    self.merge_nw = line1 is not None and len(line1) &lt; len(line2)
    self.merge_se = line3 is not None and len(line3) &lt; len(line2)
    # Define strings at various cardinal directions.
    if line1 is None:
        self.nw = self.nn = self.ne = None
    elif self.merge_nw:
        self.nw = line1
        self.nn = self.ne = None
    else:
        if start &gt; 0:
            self.nw = line1[:start]
        else:
            self.nw = None
        if line1[start] != ' ':
            self.nn = line1[start]
        else:
            self.nn = None
        if end &lt; len(line1):
            self.ne = string.rstrip(line1[end:])
        else:
            self.ne = None
    if start &gt; 0:
        self.ww = line2[:start]
    else:
        self.ww = None
    if end &lt; len(line2):
        self.ee = line2[end:]
    else:
        self.ee = None
    if line3 is None:
        self.sw = self.ss = self.se = None
    elif self.merge_se:
        self.sw = self.ss = None
        self.se = string.rstrip(line3)
    else:
        if start &gt; 0:
            self.sw = line3[:start]
        else:
            self.sw = None
        if line3[start] != ' ':
            self.ss = line3[start]
        else:
            self.ss = None
        if end &lt; len(line3):
            self.se = string.rstrip(line3[end:])
        else:
            self.se = None
    # Define parsing regexps.
    if self.merge_nw:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '.*$')
    elif self.nw and not self.nn and not self.ne:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '$')
    elif self.nw or self.nn or self.ne:
        self.regexp1 = re.compile(
            ' *' + regexp_quote(self.nw) + regexp_ruler(self.nn)
            + regexp_quote(self.ne) + '$')
    else:
        self.regexp1 = None
    if self.ww or self.ee:
        self.regexp2 = re.compile(
            ' *' + regexp_quote(self.ww) + '.*'
            + regexp_quote(self.ee) + '$')
    else:
        self.regexp2 = None
    if self.merge_se:
        self.regexp3 = re.compile('.*' + regexp_quote(self.se) + '$')
    elif self.sw and not self.ss and not self.se:
        self.regexp3 = re.compile(' *' + regexp_quote(self.sw) + '$')
    elif self.sw or self.ss or self.se:
        self.regexp3 = re.compile(
            ' *' + regexp_quote(self.sw) + regexp_ruler(self.ss)
            + regexp_quote(self.se) + '$')
    else:
        self.regexp3 = None
    # Save results.
    template_registry[style] = self

</t>
<t tx="ekr.20071103093725.28">def __cmp__(self, other):
    return cmp(self.weight, other.weight)

</t>
<t tx="ekr.20071103093725.29">def characters(self):
    """\
Return a string of characters which may be used to draw the box.
"""
    characters = ''
    for text in (self.nw, self.nn, self.ne,
                 self.ww, self.ee,
                 self.sw, self.ss, self.se):
        if text:
            for character in text:
                if character not in characters:
                    characters = characters + character
    return characters

</t>
<t tx="ekr.20071103093725.3">def main(*arguments):
    refill = 1
    style = None
    tabify = 0
    verbose = 0
    width = 79
    import getopt
    options, arguments = getopt.getopt(arguments, 'ns:tvw:', ['help'])
    for option, value in options:
        if option == '--help':
            sys.stdout.write(__doc__)
            sys.exit(0)
        elif option == '-n':
            refill = 0
        elif option == '-s':
            style = int(value)
        elif option == '-t':
            tabify = 1
        elif option == '-v':
            verbose = 1
        elif option == '-w':
            width = int(value)
    if len(arguments) == 0:
        text = sys.stdin.read()
    elif len(arguments) == 1:
        text = open(arguments[0]).read()
    else:
        sys.stderr.write("Invalid usage, try `rebox --help' for help.\n")
        sys.exit(1)
    old_style, new_style, text, position = engine(
        text, style=style, width=width, refill=refill, tabify=tabify)
    if text is None:
        sys.stderr.write("* Cannot rebox to style %d.\n" % new_style)
        sys.exit(1)
    sys.stdout.write(text)
    if verbose:
        if old_style == new_style:
            sys.stderr.write("Reboxed with style %d.\n" % old_style)
        else:
            sys.stderr.write("Reboxed from style %d to %d.\n"
                             % (old_style, new_style))

</t>
<t tx="ekr.20071103093725.30">def match(self, lines):
    """\
Returns true if LINES exactly match this template.
"""
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        if start == end or not self.regexp1.match(lines[start]):
            return 0
        start = start + 1
    if self.regexp3 is not None:
        if end == 0 or not self.regexp3.match(lines[end-1]):
            return 0
        end = end - 1
    if self.regexp2 is not None:
        for line in lines[start:end]:
            if not self.regexp2.match(line):
                return 0
    return 1

</t>
<t tx="ekr.20071103093725.31">def unbuild(self, lines):
    """\
Remove all comment marks from LINES, as hinted by this template.  Returns the
cleaned up set of lines, and the size of the left margin.
"""
    margin = left_margin_size(lines)
    # Remove box style marks.
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        lines[start] = unbuild_clean(lines[start], self.regexp1)
        start = start + 1
    if self.regexp3 is not None:
        lines[end-1] = unbuild_clean(lines[end-1], self.regexp3)
        end = end - 1
    if self.regexp2 is not None:
        for counter in range(start, end):
            lines[counter] = unbuild_clean(lines[counter], self.regexp2)
    # Remove the left side of the box after it turned into spaces.
    delta = left_margin_size(lines) - margin
    for counter in range(len(lines)):
        lines[counter] = lines[counter][delta:]
    # Remove leading and trailing white lines.
    start = 0
    end = len(lines)
    while start &lt; end and lines[start] == '':
        start = start + 1
    while end &gt; start and lines[end-1] == '':
        end = end - 1
    return lines[start:end], margin

</t>
<t tx="ekr.20071103093725.32">def build(self, lines, width, refill, margin):
    """\
Put LINES back into a boxed comment according to this template, after
having refilled them if REFILL.  The box should start at column MARGIN,
and the total size of each line should ideally not go over WIDTH.
"""
    # Merge a short end delimiter now, so it gets refilled with text.
    if self.merge_se:
        if lines:
            lines[-1] = lines[-1] + '  ' + self.se
        else:
            lines = [self.se]
    # Reduce WIDTH according to left and right inserts, then refill.
    if self.ww:
        width = width - len(self.ww)
    if self.ee:
        width = width - len(self.ee)
    if refill:
        lines = refill_lines(lines, width)
    # Reduce WIDTH further according to the current right margin,
    # and excluding the left margin.
    maximum = 0
    for line in lines:
        if line:
            if line[-1] in '.!?':
                length = len(line) + 1
            else:
                length = len(line)
            if length &gt; maximum:
                maximum = length
    width = maximum - margin
    # Construct the top line.
    if self.merge_nw:
        lines[0] = ' ' * margin + self.nw + lines[0][margin:]
        start = 1
    elif self.nw or self.nn or self.ne:
        if self.nn:
            line = self.nn * width
        else:
            line = ' ' * width
        if self.nw:
            line = self.nw + line
        if self.ne:
            line = line + self.ne
        lines.insert(0, string.rstrip(' ' * margin + line))
        start = 1
    else:
        start = 0
    # Construct all middle lines.
    for counter in range(start, len(lines)):
        line = lines[counter][margin:]
        line = line + ' ' * (width - len(line))
        if self.ww:
            line = self.ww + line
        if self.ee:
            line = line + self.ee
        lines[counter] = string.rstrip(' ' * margin + line)
    # Construct the bottom line.
    if self.sw or self.ss or self.se and not self.merge_se:
        if self.ss:
            line = self.ss * width
        else:
            line = ' ' * width
        if self.sw:
            line = self.sw + line
        if self.se and not self.merge_se:
            line = line + self.se
        lines.append(string.rstrip(' ' * margin + line))
    return lines

</t>
<t tx="ekr.20071103093725.33">def regexp_quote(text):
    """\
Return a regexp matching TEXT without its surrounding space, maybe
followed by spaces.  If STRING is nil, return the empty regexp.
Unless spaces, the text is nested within a regexp parenthetical group.
"""
    if text is None:
        return ''
    if text == ' ' * len(text):
        return ' *'
    return '(' + re.escape(text.strip() + ') *'

</t>
<t tx="ekr.20071103093725.34">def regexp_ruler(character):
    """\
Return a regexp matching two or more repetitions of CHARACTER, maybe
followed by spaces.  Is CHARACTER is nil, return the empty regexp.
Unless spaces, the ruler is nested within a regexp parenthetical group.
"""
    if character is None:
        return ''
    if character == ' ':
        return '  +'
    return '(' + re.escape(character + character) + '+) *'

</t>
<t tx="ekr.20071103093725.35">def unbuild_clean(line, regexp):
    """\
Return LINE with all parenthetical groups in REGEXP erased and replaced by an
equivalent number of spaces, except for trailing spaces, which get removed.
"""
    match = re.match(regexp, line)
    groups = match.groups()
    for counter in range(len(groups)):
        if groups[counter] is not None:
            start, end = match.span(1 + counter)
            line = line[:start] + ' ' * (end - start) + line[end:]
    return string.rstrip(line)

</t>
<t tx="ekr.20071103093725.36">## Template data.

# Matcher functions for a comment start, indexed by numeric LANGUAGE.
language_matcher = []
for pattern in (r' *(/\*|//+|#+|;+|%+)',
                r'',            # 1
                r' */\*',       # 2
                r' *//+',       # 3
                r' *#+',        # 4
                r' *;+',        # 5
                r' *%+'):       # 6
    language_matcher.append(re.compile(pattern).match)

# Template objects, indexed by numeric style.
template_registry = {}

def make_generic(style, weight, lines):
    """\
Add various language digit to STYLE and generate one template per language,
all using the same WEIGHT.  Replace `?' in LINES accordingly.
"""
    for language, character in ((300, '/'),  # C++ style comments
                                (400, '#'),  # scripting languages
                                (500, ';'),  # LISP and assembler
                                (600, '%')): # TeX and PostScript
        new_style = language + style
        if 310 &lt; new_style &lt;= 319:
            # Disallow quality 10 with C++.
            continue
        new_lines = []
        for line in lines:
            new_lines.append(string.replace(line, '?', character))
        Template(new_style, weight, new_lines)

</t>
<t tx="ekr.20071103093725.37">
make_generic(11, 115, ('? box',))

make_generic(12, 215, ('? box ?',
                       '? --- ?'))

make_generic(13, 315, ('? --- ?',
                       '? box ?',
                       '? --- ?'))

make_generic(14, 415, ('? box ?',
                       '???????'))

make_generic(15, 515, ('???????',
                       '? box ?',
                       '???????'))

make_generic(21, 125, ('?? box',))

make_generic(22, 225, ('?? box ??',
                       '?? --- ??'))

make_generic(23, 325, ('?? --- ??',
                       '?? box ??',
                       '?? --- ??'))

make_generic(24, 425, ('?? box ??',
                       '?????????'))

make_generic(25, 525, ('?????????',
                       '?? box ??',
                       '?????????'))

make_generic(31, 135, ('??? box',))

make_generic(32, 235, ('??? box ???',
                       '??? --- ???'))

make_generic(33, 335, ('??? --- ???',
                       '??? box ???',
                       '??? --- ???'))

make_generic(34, 435, ('??? box ???',
                       '???????????'))

make_generic(35, 535, ('???????????',
                       '??? box ???',
                       '???????????'))

make_generic(41, 145, ('???? box',))

make_generic(42, 245, ('???? box ????',
                       '???? --- ????'))

make_generic(43, 345, ('???? --- ????',
                       '???? box ????',
                       '???? --- ????'))

make_generic(44, 445, ('???? box ????',
                       '?????????????'))

make_generic(45, 545, ('?????????????',
                       '???? box ????',
                       '?????????????'))

# Textual (non programming) templates.

Template(111, 113, ('box',))

Template(112, 213, ('| box |',
                    '+-----+'))

Template(113, 313, ('+-----+',
                    '| box |',
                    '+-----+'))

Template(114, 413, ('| box |',
                    '*=====*'))

Template(115, 513, ('*=====*',
                    '| box |',
                    '*=====*'))

Template(121, 123, ('| box |',))

Template(122, 223, ('| box |',
                    '`-----\''))

Template(123, 323, ('.-----.',
                    '| box |',
                    '`-----\''))

Template(124, 423, ('| box |',
                    '\\=====/'))

Template(125, 523, ('/=====\\',
                    '| box |',
                    '\\=====/'))

Template(141, 143, ('| box ',))

Template(142, 243, ('* box *',
                    '*******'))

Template(143, 343, ('*******',
                    '* box *',
                    '*******'))

Template(144, 443, ('X box X',
                    'XXXXXXX'))

Template(145, 543, ('XXXXXXX',
                    'X box X',
                    'XXXXXXX'))
# C language templates.

Template(211, 118, ('/* box */',))

Template(212, 218, ('/* box */',
                    '/* --- */'))

Template(213, 318, ('/* --- */',
                    '/* box */',
                    '/* --- */'))

Template(214, 418, ('/* box */',
                    '/* === */'))

Template(215, 518, ('/* === */',
                    '/* box */',
                    '/* === */'))

Template(221, 128, ('/* ',
                    '   box',
                    '*/'))

Template(222, 228, ('/*    .',
                    '| box |',
                    '`----*/'))

Template(223, 328, ('/*----.',
                    '| box |',
                    '`----*/'))

Template(224, 428, ('/*    \\',
                    '| box |',
                    '\\====*/'))

Template(225, 528, ('/*====\\',
                    '| box |',
                    '\\====*/'))

Template(231, 138, ('/*    ',
                    ' | box',
                    ' */   '))

Template(232, 238, ('/*        ',
                    ' | box | ',
                    ' *-----*/'))

Template(233, 338, ('/*-----* ',
                    ' | box | ',
                    ' *-----*/'))

Template(234, 438, ('/* box */',
                    '/*-----*/'))

Template(235, 538, ('/*-----*/',
                    '/* box */',
                    '/*-----*/'))

Template(241, 148, ('/*    ',
                    ' * box',
                    ' */   '))

Template(242, 248, ('/*     * ',
                    ' * box * ',
                    ' *******/'))

Template(243, 348, ('/******* ',
                    ' * box * ',
                    ' *******/'))

Template(244, 448, ('/* box */',
                    '/*******/'))

Template(245, 548, ('/*******/',
                    '/* box */',
                    '/*******/'))

Template(251, 158, ('/* ',
                    ' * box',
                    ' */   '))

</t>
<t tx="ekr.20071103093725.4">def pymacs_load_hook():
    global interactions, lisp, Let, region, comment, set_default_style
    from Pymacs import lisp, Let
    emacs_rebox = Emacs_Rebox()
    # Declare functions for Emacs to import.
    interactions = {}
    region = emacs_rebox.region
    interactions[region] = 'P'
    comment = emacs_rebox.comment
    interactions[comment] = 'P'
    set_default_style = emacs_rebox.set_default_style

</t>
<t tx="ekr.20071103093725.5">class Emacs_Rebox:
    @others
</t>
<t tx="ekr.20071103093725.6">
def __init__(self):
    self.default_style = None

</t>
<t tx="ekr.20071103093725.7">def set_default_style(self, style):
    """\
Set the default style to STYLE.
"""
    self.default_style = style

</t>
<t tx="ekr.20071103093725.8">def region(self, flag):
    """\
Rebox the boxed comment in the current region, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_region)

</t>
<t tx="ekr.20071103093725.9">def comment(self, flag):
    """\
Rebox the surrounding boxed comment, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_comment)

</t>
<t tx="ekr.20071103094355">Design notes for rebox.py:

Pymacs specific features are used exclusively from within the pymacs_load_hook
function and the Emacs_Rebox class. In batch mode, Pymacs is not even imported.

In batch mode, as well as with rebox-region, the text to handle is turned over
to Python, and fully processed in Python, with practically no Pymacs interaction
while the work gets done. On the other hand, rebox-comment is rather Pymacs
intensive: the comment boundaries are chased right from the Emacs buffer, as
directed by the function Emacs_Rebox.find_comment. Once the boundaries are
found, the remainder of the work is essentially done on the Python side.

Once the boxed comment has been reformatted in Python, the old comment is
removed in a single delete operation, the new comment is inserted in a second
operation. This occurs in Emacs_Rebox.process_emacs_region. But by doing so, if
point was within the boxed comment before the reformatting, its precise position
is lost. To well preserve point, Python might have driven all reformatting
details directly in the Emacs buffer. We really preferred doing it all on the
Python side : as we gain legibility by expressing the algorithms in pure Python,
the same Python code may be used in batch or interactively, and we avoid the
slowdown that would result from heavy use of Emacs services.

To avoid completely loosing point, I kludged a Marker class, which goal is to
estimate the new value of point from the old. Reformatting may change the amount
of white space, and either delete or insert an arbitrary number characters meant
to draw the box. The idea is to initially count the number of characters between
the beginning of the region and point, while ignoring any problematic character.
Once the comment has been reboxed, point is advanced from the beginning of the
region until we get the same count of characters, skipping all problematic
characters. This Marker class works fully on the Python side, it does not
involve Pymacs at all, but it does solve a problem that resulted from my choice
of keeping the data on the Python side instead of handling it directly in the
Emacs buffer.

We want a comment reformatting to appear as a single operation, in the context
of Emacs Undo. The method Emacs_Rebox.clean_undo_after handles the general case
for this. Not that we do so much in practice : a reformatting implies one
delete-region and one insert, and maybe some other little adjustements at
Emacs_Rebox.find_comment time. Even if this method scans and mofifies an Emacs
Lisp list directly in the Emacs memory, the code doing this stays neat and
legible. However, I found out that the undo list may grow quickly when the Emacs
buffer use markers, with the consequence of making this routine so Pymacs
intensive that most of the CPU is spent there. I rewrote that routine in Emacs
Lisp so it executes in a single Pymacs interaction.

Function Emacs_Rebox.remainder_of_line could have been written in Python, but it
was probably not worth going away from this one-liner in Emacs Lisp. Also, given
this routine is often called by find_comment, a few Pymacs protocol interactions
are spared this way. This function is useful when there is a need to apply a
regexp already compiled on the Python side, it is probably better fetching the
line from Emacs and do the pattern match on the Python side, than transmitting
the source of the regexp to Emacs for it to compile and apply it.

For refilling, I could have either used the refill algorithm built within in
Emacs, programmed a new one in Python, or relied on Ross Paterson's fmt,
distributed by GNU and available on most Linuxes. In fact, refill_lines prefers
the latter. My own Emacs setup is such that the built-in refill algorithm is
already overridden by GNU fmt, and it really does a much better job. Experience
taught me that calling an external program is fast enough to be very bearable,
even interactively. If Python called Emacs to do the refilling, Emacs would
itself call GNU fmt in my case, I preferred that Python calls GNU fmt directly.
I could have reprogrammed GNU fmt in Python. Despite interesting, this is an
uneasy project : fmt implements the Knuth refilling algorithm, which depends on
dynamic programming techniques; Ross did carefully fine tune them, and took care
of many details. If GNU fmt fails, for not being available, say, refill_lines
falls back on a dumb refilling algorithm, which is better than none.
</t>
<t tx="ekr.20071103094355.1">For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file::

    (add-hook 'c-mode-hook 'fp-c-mode-routine)
    (defun fp-c-mode-routine ()
        (local-set-key "\M-q" 'rebox-comment))
    (autoload 'rebox-comment "rebox" nil t)
    (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

    (pymacs-load "Pymacs.rebox")

The Emacs function `rebox-comment' automatically discovers the extent of the
boxed comment near the cursor, possibly refills the text, then adjusts the box
style. When this command is executed, the cursor should be within a comment, or
else it should be between two comments, in which case the command applies to the
next comment.

The Emacs function `rebox-region' does the same, except that it takes the
current region as a boxed comment. Both commands obey numeric prefixes to add or
remove a box, force a particular box style, or to prevent refilling of text.
Without such prefixes, the commands may deduce the current box style from the
comment itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

In batch mode [If you use the `rebox' script rather than Emacs], the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

Usually, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.
</t>
<t tx="ekr.20071104222805"></t>
<t tx="ekr.20071105164407">def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
</t>
<t tx="ekr.20071106083149">@killcolor

In general, autocompletion is a tricky problem. Consider:

- There may be no 'clean' version of the source code that you want to
auto-complete: you may be creating a new node, or a new file, and the source
code, being incomplete, will not parse correctly.

- Except in special circumstances, there is no 'real' object corresponding to s,
so there is no way to use Python's inspect module on s. Modules are an
exception: the autocompleter can handle existing modules fairly well. Try "os."
or "os.path." for example.


It might be possible to generalize c.k.defineObjectDict so that the user
could specify autocompleter conventions, say in an @autocompleter node in an
@settings tree.
</t>
<t tx="ekr.20071109165315">def stripPathCruft (path):

    '''Strip cruft from a path name.'''

    if not path:
        return path # Retain empty paths for warnings.

    if len(path) &gt; 2 and (
        (path[0]=='&lt;' and path[-1] == '&gt;') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
</t>
<t tx="ekr.20071110105107">def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank &amp; tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
</t>
<t tx="ekr.20071110144948">def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
</t>
<t tx="ekr.20071114081313">@

To do:

- Define standard icons in a subfolder of Icons folder?
- Tree control recomputes height of each line.
</t>
<t tx="ekr.20071114081313.1">def insertIcon (self,event=None):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20071114082418">def deleteFirstIcon (self,event=None):

    c = self.c ; p = c.p

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[1:])
        c.setChanged(True)
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20071114082418.1">def deleteNodeIcons (self,event=None):

    c = self.c ; p = c.p

    if hasattr(p.v,"unknownAttributes"):
        a = p.v.unknownAttributes
        p.v._p_changed = 1
        self.setIconList(p,[])
        a["lineYOffset"] = 0
        p.setDirty()
        c.setChanged(True)
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20071114085054">def deleteLastIcon (self,event=None):

    c = self.c ; p = c.p

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[:-1])
        c.setChanged(True)
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20071114092622">def deleteIconByName (self,t,name,relPath): ### t not used.
    """for use by the right-click remove icon callback"""
    c = self.c ; p = c.p

    aList = self.getIconList(p)
    if not aList: return

    basePath = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    absRelPath = c.os_path_finalize_join(basePath,relPath)
    name = c.os_path_finalize(name)

    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = c.os_path_finalize(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)

    if len(newList) != len(aList):
        self.setIconList(p, newList)       
        c.setChanged(True)
        c.redraw_after_icons_changed()
    else:
        g.trace('not found',name)
</t>
<t tx="ekr.20071114113736">def makePathRelativeTo (fullPath,basePath):

    if fullPath.startswith(basePath):
        s = fullPath[len(basePath):]
        if s.startswith(os.path.sep):
            s = s[len(os.path.sep):]
        return s
    else:
        return fullPath
</t>
<t tx="ekr.20071117060958"># def getFileName (fileName,script):

    # '''Return the filename from sys.argv.'''

    # if not fileName and not script:
        # g.trace(sys.argv)
        # if False and sys.platform.startswith('win'):
            # if len(sys.argv) &gt; 1:
                # fileName = ' '.join(sys.argv[1:])
            # else:
                # fileName = None
        # else:
            # fileName = len(sys.argv) &gt; 1 and sys.argv[-1]

    # return completeFileName(fileName)
</t>
<t tx="ekr.20071117152308">def putBuffered (self,s):

    '''Put s, converting all tabs to blanks as necessary.'''

    if not s: return

    w = self.tab_width
    if w &lt; 0:
        result = []
        lines = s.split('\n')
        for line in lines:
            line2 = [] ; j = 0
            for ch in line:
                j += 1
                if ch == '\t':
                    w2 = g.computeWidth(s[:j],w)
                    w3 = (abs(w) - (w2 % abs(w)))
                    line2.append(' ' * w3)
                else:
                    line2.append(ch)
            result.append(''.join(line2))
        s = '\n'.join(result)

    self.os(s)
</t>
<t tx="ekr.20071127175948">class leoImportCommands (scanUtility):

    @others
</t>
<t tx="ekr.20071127175948.1"></t>
<t tx="ekr.20071128094234.1">def createSpellTab(self,c,spellHandler,tabName):

    pass # This method keeps pylint happy.
</t>
<t tx="ekr.20071201072917">def adjustDefStart (self,unused_s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    return i
</t>
<t tx="ekr.20071201073102.1">def adjustDefStart (self,s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    if i == 0 or s[i-1] != '\n':
        return i

    while i &gt; 0:
        progress = i

        start = j = g.find_line_start(s,i-2)
        j = g.skip_ws(s,j)
        if not g.match(s,j,'@'):
            return i

        j += 1
        k = g.skip_id(s,j)
        word = s[j:k]

        if word and word not in g.globalDirectiveList:
            # g.trace(repr(word),repr(s[start:i]))
            i = start
            assert i &lt; progress
        else:
            return i
</t>
<t tx="ekr.20071211134300">@
The most natural default directory is the directory containing the .leo file
that we are about to open. If the user has specified the "Default Directory"
preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) &gt; 0:
    c.openDirectory = c.frame.openDirectory = theDir
</t>
<t tx="ekr.20071212104050">def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            b = d2.get(key2)
            if b.commandName == commandName:
                b.func=func
                d2[key2] = b
</t>
<t tx="ekr.20071213123942">def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.p ; cc = c.chapterController
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    flag = False
    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        if cc:
            # name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName('main')
        c.selectPosition(p)
        c.redraw_after_select(p)
    else:
        g.es('no more clones',color='blue')
</t>
<t tx="ekr.20071213185710">def toggleSparseMove (self,event=None):

    c = self

    c.sparse_move = not c.sparse_move

    if not g.unitTesting:
        g.es('sparse-move: %s' % c.sparse_move,color='blue')
</t>
<t tx="ekr.20071214072145">def scanXmlText (self,s,parent,atAuto=False):

    # g.trace(atAuto,parent.h)

    scanner = xmlScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20071214072145.1">class xmlScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20071214072451">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='xml')
        # sets self.c

    # Set the parser delims.
    self.blockCommentDelim1 = '&lt;!--'
    self.blockCommentDelim2 = '--&gt;'
    self.blockDelim1 = None 
    self.blockDelim2 = None
    self.classTags = [] # Inited by import_xml_tags setting.
    self.extraIdChars = None
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = False
    self.sigHeadExtraTokens = []
    self.sigFailTokens = []

    # Overrides more attributes.
    self.hasClasses = True
    self.hasFunctions = False
    self.strict = False
    self.trace = False

    self.addTags()
</t>
<t tx="ekr.20071214072924.3">def skipToEndOfTag(self,s,i):

    '''Skip to the end of an open tag.'''

    while i &lt; len(s):
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'/&gt;'):
            return i,False # Starts a self-contained tag.
        elif g.match(s,i,'&gt;'):
            i += 1
            if g.match(s,i,'\n'): i += 1
            return i,True
        else:
            i += 1
        assert progress &lt; i

    return i,False
</t>
<t tx="ekr.20071214072924.4">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace ; verbose = False
    self.codeEnd = self.sigEnd = self.sigId = None

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    if not g.match(s,i,'&lt;'): return False
    self.sigStart = i
    i += 1
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if theId not in tags:
        if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
        return False

    if trace and verbose: g.trace(theId)
    classId = '' 
    sigId = theId

    # Complete the opening tag.
    i, ok = self.skipToEndOfTag(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if 0:
        if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
            if trace and verbose: g.trace('extending sigEnd')
            sigEnd = g.skip_line(s,sigEnd)

    i,ok = self.skipToMatchingTag(s,i,theId)
    if not ok:
        if trace: g.trace('no matching tag',theId)
        return False

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20071214075117">def skipToMatchingTag (self,s,i,tag):

    while i &lt; len(s):
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'&lt;/'):
            i += 2 ; j = i
            i = self.skipId(s,j)
            tag2 = s[j:i]
            if tag2.lower() == tag.lower():
                i,ok = self.skipToEndOfTag(s,i)
                return i,ok
        else:
            i += 1
        assert progress &lt; i

    return i,False
</t>
<t tx="ekr.20071214131818">def addTags (self):

    '''Add items to self.class/functionTags and from settings.'''

    trace = False and not g.unitTesting
    c = self.c

    for ivar,setting in (
        ('classTags','import_xml_tags',),
        # ('functionTags','import_xml_function_tags'),
    ):
        aList = getattr(self,ivar)
        aList2 = c.config.getData(setting) or []
        aList.extend(aList2)
        if trace: g.trace(ivar,aList)
</t>
<t tx="ekr.20071214140900">def doData (self,p,kind,name,val):

    s = p.b
    lines = g.splitLines(s)
    data = [z.strip() for z in lines if z.strip() and not z.startswith('#')]

    self.set(p,kind,name,data)
</t>
<t tx="ekr.20071214140900.1">def getData (self,c,setting):

    '''Return a list of non-comment strings in the body text of @data setting.'''

    return self.get(c,setting,"data")
</t>
<t tx="ekr.20080108090719">def insertIconFromFile (self,path,p=None,pos=None,**kargs):

    trace = False and not g.unitTesting
    c = self.c
    if not p: p = c.p

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    aList = [] ; xoffset = 2
    xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset,**kargs)

    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos,aList[0])
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
    # c.redraw()
</t>
<t tx="ekr.20080108091349">def appendImageDictToList(self,aList,iconDir,path,xoffset,**kargs):

    trace = False and not g.unitTesting
    c = self.c
    path = c.os_path_finalize_join(iconDir,path)
    relPath = g.makePathRelativeTo(path,iconDir)

    image,image_height = g.app.gui.getTreeImage(c,path)
    if not image:
        g.es('can not load image:',path)
        return xoffset

    if image_height is None:
        yoffset = 0
    else:
        yoffset = 0 # (c.frame.tree.line_height-image_height)/2
        # TNB: I suspect this is being done again in the drawing code

    newEntry = {
        'type' : 'file',
        'file' : path,
        'relPath': relPath,
        'where' : 'beforeHeadline',
        'yoffset' : yoffset, 'xoffset' : xoffset, 'xpad' : 1, # -2,
        'on' : 'tnode',
    }
    newEntry.update(kargs)  # may switch 'on' to 'vnode'
    aList.append (newEntry)
    xoffset += 2

    return xoffset
</t>
<t tx="ekr.20080108092811"></t>
<t tx="ekr.20080110082845">@nocolor

Python code completion module


From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 20:57:18 +0300

I've been developing IDLE over the past 2 years or so. Even before
that, I helped a friend of mine, Noam Raphael, write IDLE's
auto-completion, which is included in recent versions of IDLE.

Noam wrote the original completion code from scratch, and AFAIK every
Python IDE which features code completion has done the same. Surely
there is -some- functionality which could be useful cross-IDE?
Retrieving possible completions from the namespace, for example. And
we should be learning from each-others' ideas and experiences.

So how about we design a generic Python completion module, that
each IDE could extend, and use for the completion logic?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:06:01 +0100

I am very keen for this. I will help where it is required. PIDA
currently has no code completion (outside what vim/emacs provide),



From: "phil jones" &lt;inters...@gmail.com&gt;
Date: Wed, 6 Jun 2007 11:07:33 -0700

What functions would we ask for a code completion module?

Presumably recognition of the beginnings of
- a) python keywords
- b) classes and functions defined earlier in this file?
- c) in scope variables?

As python is dynamically typed, I guess we can't expect to know the
names of methods of objects?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:13:10 +0100

&gt; Presumably recognition of the beginnings of
&gt; - a) python keywords
&gt; - b) classes and functions defined earlier in this file?
&gt; - c) in scope variables?

does c) include: d) imported modules



From: Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
Date: Wed, 6 Jun 2007 20:17:30 +0200

&gt; &gt;Presumably recognition of the beginnings of
&gt; &gt;- a) python keywords
&gt; &gt;- b) classes and functions defined earlier in this file?
&gt; &gt;- c) in scope variables?

&gt; does c) include: d) imported modules

For code-completion, I suppose astng[1] could be useful.

1: http://www.logilab.org/project/eid/856



From: Stani's Python Editor &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 20:48:41 +0200

A good point. I think we all have been thinking about this. Important
issues for the design is the extraction method and the sources.

*the method*
Importing is a lazy, but accurate way of importing, but is security wise
not such a good idea. Parsing throught an AST compiler is better,
however more difficult. Here are two options.

From version 2.5 the standard Python compiler converts internally the
source code to an abstract syntax tree (AST) before producing the
bytecode. So probably that is a good way to go as every python
distribution has this battery included.

As Nicolas suggested earlier on this mailing list, there is another
option: the AST compiler in python or PyPy:

On Mar 14 2006, 12:16 am, Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
wrote:

&gt; &gt; WingIDE use anASTgenerator written in C (but cross-platform),
&gt; &gt; lightningly quick, and open sourced. This could be a potential
&gt; &gt; starting point.

&gt; &gt; Additionally isn't Python2.5 planned to have a C-written compiler?

&gt; PyPy also produced an improved parser/compiler.

&gt; http://codespeak.net/pypy/dist/pypy/doc/index.html
&gt; http://codespeak.net/pypy/dist/pypy/module/recparser/

But if it could be done with the standard one it is one dependency less.

*the sources*
In the design we could define first the sources:
1 external imported modules from the pythonpath
2 local modules relative to the current file or context dependent
(Blender, Gimp, ...)
3 inner code

For 1:
It might be a good idea to have a function which scans all the modules
from the pythonpath or one specific module to cache all autocompletion
and calltip information of all classes, methods and doc strings. Why?
Modules in the pythonpath don't change so often. With some criteria
(file name, time stamp, size, ...) you could check if updates are
necessary at startup. Having a readymade 'database' (could be python
dictionary or sqlite database) for autocompletion/call tips would speed
up things (and is also more secure if you are importing rather than
parsing. For example trying to provide gtk autocompletion in a wxPython
by importing is problematic).

For 2:
Here you load the parser on demand. Autocompletion/calltip information
can be added to the database.

For 3:
A different kind of parser needs to be used here as per definition code
you edit contains errors while typing. External modules are retrieved
from 1 and 2, for internal code you can scan all the words and add them
to the autocomplete database. As a refinement you can give special
attention to 'self'. Also for calltips you can inherit when there are
assignments, eg
frame = Frame()
than frame inherits autocomplete &amp; calltip information from Frame.

So autocompletion &amp; calltips deals with two steps: extraction and
'database'. If someone has a good parser already, we could use it.
Otherwise we can define an API for the extraction and maybe lazily
implement it first with importing and concentrate first on the
'database'. When the database is ready we can implement the parsing. You
could also implement the parsing first, but than it takes longer before
you have results. Of course the library is GUI independent, it only
works with strings or lists.

What concerns SPE, it uses importing for autocompletion (1+2) and does
internal code analysis for local code (however without the inheriting).

Tal, how does IDLE's autocompletion works?

Stani



From: Stani's Python Editor &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 20:53:10 +0200

Nicolas Chauvat wrote:
&gt; On Wed, Jun 06, 2007 at 07:13:10PM +0100, Ali Afshar wrote:
&gt;&gt;&gt; Presumably recognition of the beginnings of
&gt;&gt;&gt; - a) python keywords
&gt;&gt;&gt; - b) classes and functions defined earlier in this file?
&gt;&gt;&gt; - c) in scope variables?
&gt;&gt; does c) include: d) imported modules

&gt; For code-completion, I suppose astng[1] could be useful.

&gt; 1: http://www.logilab.org/project/eid/856

How dependent/independent is this from the standard AST compiler or
PyPy? Is it more IDE friendly? Is it based on it or a total independent
implementation?



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Wed, 6 Jun 2007 19:59:13 +0100

&gt; A good point. I think we all have been thinking about this. Important
&gt; issues for the design is the extraction method and the sources.

&gt; *the method*
&gt; Importing is a lazy, but accurate way of importing, but is security wise
&gt; not such a good idea. Parsing throught an AST compiler is better,
&gt; however more difficult. Here are two options.

&gt; From version 2.5 the standard Python compiler converts internally the
&gt; source code to an abstract syntax tree (AST) before producing the
&gt; bytecode. So probably that is a good way to go as every python
&gt; distribution has this battery included.

&gt; As Nicolas suggested earlier on this mailing list, there is another
&gt; option: the AST compiler in python or PyPy:

What concerns me about these is whether they would work in a module
which has a syntax error.

I believe Wing's compiler bit of their code completion is open source.
I remember having seen the code.



From: Stani &lt;spe.stani...@gmail.com&gt;
Date: Wed, 06 Jun 2007 12:08:00 -0700

&gt; What concerns me about these is whether they would work in a module
&gt; which has a syntax error.

&gt; I believe Wing's compiler bit of their code completion is open source.
&gt; I remember having seen the code.

It is indeed, but is implemented in C, which means an extra dependency
and not a 100% python solution. Normally modules (especially in the
pythonpath) which you import don't have syntax errors. Maybe logilabs
implementation handles syntax errors well as it is developed for
PyLint. Nicolas?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 22:34:41 +0300

&gt; As python is dynamically typed, I guess we can't expect to know the
&gt; names of methods of objects?

Well, the dir() builtin does just that, though there can be attributes
which won't be included therein. However, the builtin dir() can be
overridden... and ignoring it can break libraries like RPyC which
define a custom dir() function just for this purpose.

This issue has already been run in to by RPyC (an Python RPC lib). The
main developr went ahead and suggested adding a __dir__ method which
will return a list of attributes, and IIRC he has already implemented
a patch for this, and it will likely enter Python2.6.

Until then, I guess we're going to have to rely on dir for this.



From: "Josiah Carlson" &lt;josiah.carl...@gmail.com&gt;
Date: Wed, 6 Jun 2007 12:42:01 -0700

For reference, PyPE auto-parses source code in the background, generating
(among other things) a function/class/method hierarchy.  Its autocomplete
generally sticks to global functions and keywords, but when doing
self.method lookups, it checks the current source code line, looks up in its
index of classes/methods, and trims the results based on known methods in
the current class in the current source file.

It certainly isn't complete (it should try to check base classes of the
class in the same file, it could certainly pay attention to names assigned
in the current scope, the global scope, imports, types of objects as per
WingIDE's assert isinstance(obj, type), etc.), but it also makes the
computation fairly straightforward, fast, and only in reference to the
current document.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Wed, 6 Jun 2007 22:52:08 +0300

&gt; Tal, how does IDLE's autocompletion works?

Much like Stani said, since Python is interpreted, collection of
possible completions splits into two methods:
1) source code analysis
2) dynamic introspection

Of course, we could do either or a combination of both.

IDLE just uses introspection: since IDLE always has a python shell
running, it just completes according to the shell's state (plus
built-in keywords and modules). This is a very simple method,
obviously lacking. It does allow the user some control of the
completion, though - just import whatever you want to be completable
in the shell. However, introspection is all that is needed in a Python
shell, which is the major reason this is the method used in IDLE.



From: Nicolas Chauvat &lt;nicolas.chau...@logilab.fr&gt;
Date: Wed, 6 Jun 2007 23:59:32 +0200


&gt; How dependent/independent is this from the standard AST compiler or
&gt; PyPy? Is it more IDE friendly? Is it based on it or a total independent
&gt; implementation?

It is independent from PyPy.

The above web page says:

"""
Python Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.Python
Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.
"""

From: "Sylvain Thénault" &lt;thena...@gmail.com&gt;
Date: Wed, 13 Jun 2007 10:51:04 +0200

&gt; Please let me involve Sylvain in the discussion. As the main author of
&gt; pylint and astng, he will provide better answers.

well logilab-astng is basically a big monkey patching of the compiler
package from the stdlib, so you can't get an astng representation from a
module with syntax errors in. However inference and most others
navigation methods (which are basically the value added by astng) are
"syntax error resilient" : if a dependency module (direct or indirect)
contains a syntax error, you don't get any exception, though since some
information is missing you can miss some results you'ld get if the
faulting module were parseable.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 10:33:33 +0300

Since astng already does some inference (which we definitely want!)
and is based on the standard Python AST compiler, it sounds like our
#1 candidate. I think we should give the code a serious once-over and
see how well it fits our requirements, and if it can be adapted to
better handle errors. Any volunteers?

Also, has anyone used astng for completion, calltips, or something
similar? Or the standard AST compiler, for that matter?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 10:40:11 +0300

How does PyPE parse code? Home-rolled, standard AST compiler, something else?

It seems to me we should try to come up with an algorithm for parsing,
before getting to the code. All of the details you mentioned -
noticing assignments, using base-class methods, etc. - could be better
defined and organized this way. Perhaps we could brainstorm on this in
a wiki?



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 11:38:40 +0300

Sorry for being away for such a long time. I hope we can get this
conversation rolling again, and get started with the actual work.

I'll try to sum up what has been said so far, and how I see things.

== Top Priorities ==
* Can we implement a parser based on the standard Python AST compiler
(or astng)? For example, can syntax errors be handled well?
* Is importing reasonable security-wise? If not, can it be made secure?

== General issues ==
* Do we aim for just completion, or also calltips? Perhaps also other
meta-data, e.g. place defined, source code, ... (see IPython's '??')
* Dependencies - do we want to allow C-extensions, or are we going for
a Python-only solution? (IDLE would only use such a Python-only tool.)
It seems that we want to pre-process most of the data in the
background, so I don't see why we would want to do this in C for
efficiency reasons.

== Completion sources ==
1) Importing "external" modules
2) Importing/Parsing "local" modules
3) Parsing the current file
4) Using objects/modules from the shell (e.g. IDLE has both editor
windows and a Python shell)

== Importing ==
* Stani mentioned that importing is problematic from a security point
of view. What are the security issues? Are they really an issue for an
IDE? If so, perhaps we could overcome this by importing in some kind
of "sandbox"?
* What are the pros and cons of Importing vs. Parsing?
* If importing is always preferable to parsing unless there's a syntax
error, perhaps try to import and parse on failure?

== Parsing ==
* This is going to be the most complex method - I think we should have
a general idea of how this should work before starting an
implementation. I suggest hashing ideas out on a wiki, since there a
lot of details to consider.
* Can a parser based on the standard AST compiler (or astng) work? Is
there a way to deal with errors? (HIGH PRIORITY!)
* There are other existing, open-source implementations out there -
WingIDE, PyPE have been mentioned. Any others? We should collect these
so we can use the code for learning, and perhaps direct use (if
possible license-wise).

== Shell ==
This is relatively straight-forward - just use dir(). This should be
optional, for use by IDEs which have a shell (support multiple
shells?).

Some known issues from IDLE and PyCrust:
* Handle object proxies such as RPC proxies (e.g. RPyC)
* Handle ZODB "ghost" objects
* Watch out for circular references
* Watch out for objects with special __getattr__/__hasattr__
implementations (for example xmlrpc, soap)

== Persistence ==
* Stani mentioned a 'database'. I feel Sqlite should be at most
optional, to reduce dependencies.
* Do we really want to have the data persistent (between IDE
sessiosns)? If so, we need to support simultaneous instances of the
IDE so they don't corrupt the data. Any other issues? (I have a
feeling this would better be left for later stages of development.)



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 12:22:59 +0300

One more note: We should distinguish between completion in an editor
and completion in a shell. The conversation up until now has focused
on editors, which is reasonable since that is the problematic scene. I
think a generic Python completion library should support completion in
both contexts, especially if it uses can use a shell's namespace for
completion in the editor.



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Tue, 31 Jul 2007 11:20:19 +0100

I have just implemented a completion mockup using Rope (which is a
refactoring library). It works quite nicely, and definitely worth a
look.

http://rope.sourceforge.net/

It even achieves this kind of completion:

class Banana(object):
    def do_something(self):
         return

def foo():
    return [Banana(), Banana()]

foo()[0].&lt;complete&gt; includes do_something

Which seems pretty impressive to me.



From: "Tal Einat" &lt;talei...@gmail.com&gt;
Date: Tue, 31 Jul 2007 20:12:50 +0300

Wow, Rope does look very impressive! A quick look at the code tells me
that a lot of work has been invested in it.

So we have one existing Python-only solution. We should evaluate it -
see what it can and can't do, and perhaps take a look at the overall
design.

I'm CC-ing Rope's developer, Ali. Hopefully Ali can help us quickly
understand Rope's code analysis capabilities.

Ali, could you elaborate a bit on what kinds of completion Rope can
do, and the methods it uses? We would especially like to know how your
static and dynamic inference work, what they can accomplish, and what
their limitations are.



From: "Ali Afshar" &lt;aafs...@gmail.com&gt;
Date: Tue, 31 Jul 2007 19:45:15 +0100

&gt; Ali, could you elaborate a bit on what kinds of completion Rope can
&gt; do, and the methods it uses? We would especially like to know how your
&gt; static and dynamic inference work, what they can accomplish, and what
&gt; their limitations are.

Well, I haven't really looked at the code. But I can tell you this:

from rope.ide.codeassist import PythonCodeAssist
from rope.base.project import Project
for compl in PythonCodeAssist(Project(package_root)).assist(buffer,
offset).completions:
    print compl

And that is as far as I really got. I expect to get a better look at
it later in the week though...


From: "Josiah Carlson" &lt;josiah.carl...@gmail.com&gt;
Date: Wed, 1 Aug 2007 00:26:14 -0700

&gt; How does PyPE parse code? Home-rolled, standard AST compiler, something else?

The compiler for syntactically correct Python, a line-based compiler
for broken Python.  TO generate a method list for self.methods, using
the current line number, I discover the enclosing class, check the
listing of methods for that class (generated by the compiler or
line-based parsers), and return a valid list for the specified prefix.
 It doesn't walk the inheritance tree, it doesn't do imports, etc.

&gt; It seems to me we should try to come up with an algorithm for parsing,
&gt; before getting to the code. All of the details you mentioned -
&gt; noticing assignments, using base-class methods, etc. - could be better
&gt; defined and organized this way. Perhaps we could brainstorm on this in
&gt; a wiki?

A wiki would be fine, the one for this mailing list would likely be
best (if it is still up and working).  Then again, Rope looks quite
nifty.  I may have to borrow some of that source ;)


Discussion subject changed to "Fwd: Python code completion module" by Tal Einat

From: Ali Gholami Rudi &lt;aligr...@gmail.com&gt;
Date: Aug 1, 2007 5:50 PM

First of all I should note that rope's main goal was being a
refactoring tool and a refactoring tool needs to know a lot about
python modules.  `rope.base` package provides information about python
modules.

Actually what ropeide provides as auto-completion is defined in
`rope.ide.codeassist` module.  This module almost does nothing but use
`rope.base`.  Since `rope.ide` package is not included in the rope
library (which has been separated from ropeide since 0.6m4) it lacks
good documentation and the API might not be easy to use (most of it is
written in the first months of rope's birth).

&gt; ..., could you elaborate a bit on what kinds of completion Rope can
&gt; do, ...

I don't know what to say here.  Well, actually it tries to use the
source code as much as possible and infer things from it.  So I can
say that it can complete any obvious thing that can be inferred by a
human.  Like this is the first parameter of a method and after dots
its attributes can appear or these modules are imported so their names
and contents are available or this is an instance of some known type
and we know its attributes and ... .  Try ropeide (it uses emacs-like
keybinding, C-/ for completion; see ~/.rope if you want to change
that); it completes common cases (and sometimes completes things you
don't expect it to!).

&gt; ..., and the methods it uses?

Rope analyzes python source code and AST.  Rope used to use the
`compiler` module till 0.5 and now it uses `_ast` module.

&gt; We would especially like to know how your
&gt; static and dynamic inference work, what they can accomplish

There are a few examples in docs/overview.txt.  Unit-test modules like
`ropetest.base.objectinfertest` and `advanced_oi_test` might help,
too.  Also have a look at `rope.base.oi.__init__` pydoc for an
overview of how they work; (I'm afraid it is a bit out of date and
carelessly written.)  The idea behind rope's object inference is to
guess what references (names in source-code) hold.  They collect
information about code when they can and use them later.

&gt;..., and what their limitations are.

Many things in rope are approximations that might be exact if some
conditions hold.  For instance rope might assume that every normal
reference in module scope holds only one kind of object.  Apart from
these assumptions both SOI and DOI have their own disadvantages; For
instance SOI fails when dynamic code is evaluated while DOI does not.
Or DOI is slower than SOI.  (Well, after recent enhancements to rope's
SOI I rarely use DOI).

I tried to answer as short as possible.  If there are questions on
specific parts of rope, I'll be happy to answer.

By the way, I tried to reply this mail to the group, but it seems that
your group requires subscription for posting, so I've sent it to you,
instead.
</t>
<t tx="ekr.20080112175736">gtkGui:

** Rewrite leoKeyEventClass.
   This should be done by EKR: it is an essential part of all key handline.
- There is no root ivar in the gtk gui.  Rewrite all code that uses self.root.
- Rewrite runOpenFileDialog
- Rewrite runSaveFileDialog

gtkFrame:
- What is the correct way to close a window?
- Should there be a separate minibuffer class?
- Should there be separate files for the log, body, etc.?
- Should there be smaller methods to create components and make bindings?

gtkFind:
- Create the find tab.

gtkComparePanel:
- At present this does not exist.  The compare window is optional.

General:
- Write unit tests for all new gui code.
- Unit tests for showFindPanel and openCompareWindow.

</t>
<t tx="ekr.20080113061130">- Added code to Leo's code to do nothing it the compare panel and stand-alone find panel do not exist.
</t>
<t tx="ekr.20080113165010">@nocolor

Summary: inspect when possible, ask for types otherwise.

    os.? gives a list of all instances of os module.
    x.? gives a list of all known classes.
    x.# gives list of all known functions.
    self.? gives all known methods and ivars of the enclosing class.
    The user will be able to specify type conventsions, like Leo's c,g,p,t,v vars.

Completed (mostly): user interface stuff.

Performance isn't too hard:
    - Do all scanning in separate threads.
    - Associate node info with tnodes.
    - Update node info when deselecting a node (in tree base class)

Parsing:
    - Forgiving parser is essentially complete.
    - It's easy to parse python def lines.
</t>
<t tx="ekr.20080114142724">@nocolor

@all
</t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.b,ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080211065754">def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    # Pascal interfaces have no argument list.
    if kind == 'class':
        return i, True

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i &gt;= len(s):
        return start,False
    else:
        return i,True 
</t>
<t tx="ekr.20080211065906">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='pascal')

    # Set the parser overrides.
    self.anonymousClasses = ['interface']
    self.blockCommentDelim1 = '(*'
    self.blockCommentDelim1_2 = '{'
    self.blockCommentDelim2 = '*)'
    self.blockCommentDelim2_2 = '}'
    self.blockDelim1 = 'begin'
    self.blockDelim2 = 'end'
    self.blockDelim2Cruft = [';','.'] # For Delphi.
    self.classTags = ['interface']
    self.functionTags = ['function','procedure','constructor','destructor',]
    self.hasClasses = True
    self.lineCommentDelim = '//'
    self.strict = False
</t>
<t tx="ekr.20080211070056">def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace

    # Pascal interface has no tail.
    if kind == 'class':
        return i,True

    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i &lt; len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
</t>
<t tx="ekr.20080211070816">def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i

    if kind == 'class':
        i = self.skipInterface(s,i)
    else:
        i = self.skipBlock(s,i,delim1=None,delim2=None)

        if self.sigFailTokens:
            i = g.skip_ws(s,i)
            for z in self.sigFailTokens:
                if g.match(s,i,z):
                    if trace: g.trace('failtoken',z)
                    return start,False

    if i &gt; start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
</t>
<t tx="ekr.20080211070945">def skipInterface(self,s,i):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    delim2 = 'end.'
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and g.match(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,delim2):
            i += len(delim2)
            if trace: g.trace('returns\n',repr(s[start:i]))
            return i

        else: i += 1
        assert progress &lt; i

    self.error('no interface')
    if 1:
        g.pr('** no interface **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no interface')
    return start
</t>
<t tx="ekr.20080211071959">def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Create a node containing the entire interface.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Put the entire interface in the body.
    result = s[start:codeEnd]
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20080211085914">def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory = g.setDefaultDirectory(c,p,importing=False)
</t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'"))
        for z in sorted(self.decls)]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220111323">def translateArgs(args,d):

    '''Return the concatenation of s and all args,

    with odd args translated.'''

    if not hasattr(g,'consoleEncoding'):
        e = sys.getdefaultencoding()
        g.consoleEncoding = isValidEncoding(e) and e or 'utf-8'
        # print 'translateArgs',g.consoleEncoding

    result = [] ; n = 0 ; spaces = d.get('spaces')
    for arg in args:
        n += 1

        # print('g.translateArgs: arg',arg,type(arg),g.isString(arg),'will trans',(n%2)==1)

        # First, convert to unicode.
        if type(arg) == type('a'):
            arg = g.toUnicode(arg,g.consoleEncoding)

        # Now translate.
        if not g.isString(arg):
            arg = repr(arg)
        elif (n % 2) == 1:
            arg = g.translateString(arg)
        else:
            pass # The arg is an untranslated string.

        if arg:
            if result and spaces: result.append(' ')
            result.append(arg)

    return ''.join(result)
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080311135649.2">@nocolor

On Tue, Mar 11, 2008 at 7:03 AM, Kent Tenney &lt;kten...@gmail.com&gt; wrote:

&gt; On 3/11/08, derwisch &lt;johannes.hues...@med.uni-heidelberg.de&gt; wrote:

&gt; &gt;  On 11 Mrz., 08:03, "Ville M. Vainio" &lt;vivai...@gmail.com&gt; wrote:
&gt; &gt;  &gt; It could also be argued that

&gt; &gt;  &gt; - Referring to previous cloned vnodes explicitly in XML does not
&gt; &gt;  &gt; necessarily obscure DAG - it follows the "do not repeat yourself"
&gt; rule
&gt; &gt;  &gt; - It will speed up reading
&gt; &gt;  &gt; - Wouldn't it be better for preserving the integrity of the XML file?

&gt; &gt; I would lean towards this line of argumentation. A couple of days I
&gt; &gt;  had my Leo extension destroy the Leo ODM file (which was still valid
&gt; &gt;  according to Leo, but unreadable wrt the extension and broken uAs). I
&gt; &gt;  resorted to editing the Leo file with Emacs, and was quite surprised
&gt; &gt;  to see that the headStrings were attributes of vnodes.

&gt; I'll chime in with my pet peeve re: .leo file structure::

&gt; I think that putting the headstrings on vnodes and body strings on tnodes
&gt; obscures the informational content of the .leo file, and makes the .leo
&gt; file
&gt; format less attractive as a generalized solution to the problem of how to
&gt; manage head/body pairs which live in a hierarchal structure.

&gt; Thanks,
&gt; Kent

&gt; &gt;  I think that
&gt; &gt;  editing the file might have been a bit easier if there had been no
&gt; &gt;  such redundancy. But this is more a feeling rather than a qualified
&gt; &gt;  opinion.

Thanks for all these comments.  I'll respond to them all here.

Clearly, we should be using a standard xml parser to read .leo files.

My present thoughts:

- I personally like human-readable headlines in &lt;v&gt; elements.

- I am open to putting headlines in &lt;t&gt; elements, as an indication that
tnodes do indeed contain headlines and body text.

- I am willing to consider only writing shared subtrees once.

Oh! (An Aha)  All these are preferences.  We can allow any combination of
these provided that headlines appear somewhere.

So that's clean.  This will happen in Leo 4.5. 
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080312071248.6">def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    aList = [] ; c = self.c ; tag = '@command'
    for p in p.subtree():
        h = p.h
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.h,script),)

    # g.trace(g.listToString(aList))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonCommandsList = aList


</t>
<t tx="ekr.20080312071248.7">def getCommonAtCommands (self):

    '''Return the list of tuples (headline,script) for common @command nodes.'''

    return g.app.config.atCommonCommandsList
</t>
<t tx="ekr.20080313032655.2"></t>
<t tx="ekr.20080408060320.1">def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i &lt; end:
                i = s.find(ch,i+1,end) # Ensure progress and i &gt; 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20080408060320.790">def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.widget
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


</t>
<t tx="ekr.20080408060320.791">def killLine (self,protect=True):

    k = self ; c = self.c
    w = self.widget
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080410115129.1">def checkPaste (self,parent,p):

    '''Return True if p may be pasted as a child of parent.'''

    if not parent: return True

    parents = [z.copy() for z in parent.self_and_parents()]

    for p in p.self_and_subtree():
        for z in parents:
            # g.trace(p.h,id(p.v),id(z.v))
            if p.v == z.v:
                g.es('Invalid paste: nodes may not descend from themselves',color="blue")
                return False

    return True
</t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080412172151.2">def updateFixedStatus (self):

    c = self.c
    p = g.app.config.findSettingsPosition(c,'@bool fixedWindow')
    if p:
        import leo.core.leoConfig as leoConfig
        parser = leoConfig.settingsTreeParser(c)
        kind,name,val = parser.parseHeadline(p.h)
        if val and val.lower() in ('true','1'):
            val = True
        else:
            val = False
        c.fixed = val

    # g.trace('c.fixed',c.fixed)
</t>
<t tx="ekr.20080416161551.190">def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
</t>
<t tx="ekr.20080416161551.191">def key (self):

    p = self

    # For unified nodes we must include a complete key,
    # so we can distinguish between clones.
    result = []
    for z in p.stack:
        v,childIndex = z
        result.append('%s:%s' % (id(v),childIndex))

    result.append('%s:%s' % (id(p.v),p._childIndex))

    return '.'.join(result)
</t>
<t tx="ekr.20080416161551.192">def hasBack(self):
    p = self
    return p.v and p._childIndex &gt; 0

def hasNext(self):
    p = self
    try:
        parent_v = p._parentVnode()
            # Returns None if p.v is None.
        return p.v and parent_v and p._childIndex+1 &lt; len(parent_v.children)
    except Exception:
        g.trace('*** Unexpected exception')
        g.es_exception()
        return None

def hasParent(self):
    p = self
    return p.v and len(p.stack) &gt; 0

def hasThreadBack(self):
    p = self
    return p.hasParent() or p.hasBack() # Much cheaper than computing the actual value.
</t>
<t tx="ekr.20080416161551.193">def hasThreadNext (self):

    p = self
    if not p.v: return False

    if p.hasChildren() or p.hasNext(): return True

    n = len(p.stack) -1
    while n &gt;= 0:
        v,childIndex = p.stack[n]
        # See how many children v's parent has.
        if n == 0:
            parent_v = v.context.hiddenRootNode
        else:
            parent_v,junk = p.stack[n-1]
        if len(parent_v.children) &gt; childIndex+1:
            # v has a next sibling.
            return True
        n -= 1
    return False
</t>
<t tx="ekr.20080416161551.194">def isAncestorOf (self, p2):

    p = self ; v = p.v

    for z in p2.stack:
        v2,junk = z
        if v2 == v:
            return True

    return False
</t>
<t tx="ekr.20080416161551.196">def isVisible (self,c):

    p = self ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.h)
        return limitIsVisible

    # It's much easier with a full stack.
    n = len(p.stack)-1
    while n &gt;= 0:
        progress = n
        # v,n = p.vParentWithStack(v,p.stack,n)
        v,junk = p.stack[n]
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded:',v._headString,p.h)
            return False
        n -= 1
        assert progress &gt; n

    return True
</t>
<t tx="ekr.20080416161551.197">def level (self):

    '''Return the number of p's parents.'''

    p = self
    return p.v and len(p.stack) or 0

simpleLevel = level
</t>
<t tx="ekr.20080416161551.199">@ These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
</t>
<t tx="ekr.20080416161551.200">def moveToBack (self):

    """Move self to its previous sibling."""

    p = self ; n = p._childIndex

    parent_v = p._parentVnode()
        # Returns None if p.v is None.

    # Do not assume n is in range: this is used by positionExists.
    if parent_v and p.v and 0 &lt; n &lt;= len(parent_v.children):
        p._childIndex -= 1
        p.v = parent_v.children[n-1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.201">def moveToFirstChild (self):

    """Move a position to it's first child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[0]
        p._childIndex = 0
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.202">def moveToLastChild (self):

    """Move a position to it's last child's position."""

    p = self

    if p.v and p.v.children:
        p.stack.append((p.v,p._childIndex),)
        n = len(p.v.children)
        p.v = p.v.children[n-1]
        p._childIndex = n-1
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.203">def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self

    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p
</t>
<t tx="ekr.20080416161551.204">def moveToNext (self):

    """Move a position to its next sibling."""

    p = self ; n = p._childIndex

    parent_v = p._parentVnode()
        # Returns None if p.v is None.
    if not p.v: g.trace('parent_v',parent_v,'p.v',p.v)

    if p.v and parent_v and len(parent_v.children) &gt; n+1:
        p._childIndex = n+1
        p.v = parent_v.children[n+1]
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.205">def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.206">def moveToNthChild (self,n):

    p = self

    if p.v and len(p.v.children) &gt; n:
        p.stack.append((p.v,p._childIndex),)
        p.v = p.v.children[n]
        p._childIndex = n
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.207">def moveToParent (self):

    """Move a position to its parent position."""

    p = self

    if p.v and p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None

    return p
</t>
<t tx="ekr.20080416161551.208">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20080416161551.209">def moveToThreadNext (self):

    """Move a position to threadNext position."""

    p = self

    if p.v:
        if p.v.children:
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.hasNext():
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p
</t>
<t tx="ekr.20080416161551.210">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    trace = False and not g.unitTesting
    verbose = True
    p = self ; limit,limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p,'limit',limit,'limitIsVisible',limitIsVisible)
    if trace: g.trace('***entry','parent',p.parent(),'p',p,g.callers(5))
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))

        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        # if back and (not back.hasChildren() or not back.isExpanded()):
            # p.moveToBack()
        # else:
            # p.moveToThreadBack()
        if trace: g.trace(p.parent(),p)
        if p:
            if trace and verbose: g.trace('**p',p)
            done,val = self.checkVisBackLimit(limit,limitIsVisible,p)
            if done:
                if trace and verbose: g.trace('done',p)
                return val
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible',p)
                return p
    else:
        # assert not p.
        return p
</t>
<t tx="ekr.20080416161551.211">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    trace = False and not g.unitTesting
    verbose = False
    p = self ; limit,limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1',p.h)
        # if trace: g.trace('hasChildren %s, isExpanded %s %s' % (
            # p.hasChildren(),p.isExpanded(),p.h))
        # Short-circuit if possible.
        if p.hasNext() and p.hasChildren() and p.isExpanded():
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if trace: g.trace('2',p.h)
        if p:
            done,val = self.checkVisNextLimit(limit,p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        return p
</t>
<t tx="ekr.20080416161551.212">def _parentVnode (self):

    '''Return the parent vnode.
    Return the hiddenRootNode if there is no other parent.'''

    p = self

    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        else:
            return p.v.context.hiddenRootNode
    else:
        return None
</t>
<t tx="ekr.20080416161551.214">def _linkAfter (self,p_after,adjust=True):

    '''Link self after p_after.'''

    p = self
    parent_v = p_after._parentVnode()
        # Returns None if p.v is None

    # Init the ivars.
    p.stack = p_after.stack[:]
    p._childIndex = p_after._childIndex + 1

    # Set the links.
    child = p.v
    n = p_after._childIndex+1
    child._addLink(n,parent_v,adjust=adjust)
</t>
<t tx="ekr.20080416161551.215">def _linkAsNthChild (self,parent,n,adjust=True):

    p = self
    parent_v = parent.v

    # Init the ivars.
    p.stack = parent.stack[:]
    p.stack.append((parent_v,parent._childIndex),)
    p._childIndex = n

    child = p.v
    child._addLink(n,parent_v,adjust=adjust)

</t>
<t tx="ekr.20080416161551.216">def _linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self
    assert(p.v)

    hiddenRootNode = p.v.context.hiddenRootNode

    if oldRoot: oldRootNode = oldRoot.v
    else:       oldRootNode = None

    # Init the ivars.
    p.stack = []
    p._childIndex = 0

    parent_v = hiddenRootNode
    child = p.v
    if not oldRoot: parent_v.children = []
    child._addLink(0,parent_v)

    return p
</t>
<t tx="ekr.20080416161551.217">def _unlink (self):

    '''Unlink the receiver p from the tree.'''

    p = self ; n = p._childIndex
    parent_v = p._parentVnode()
        # returns None if p.v is None
    child = p.v
    assert(p.v)
    assert(parent_v)

    # Delete the child.
    if (0 &lt;= n &lt; len(parent_v.children) and
        parent_v.children[n] == child
    ):
        # This is the only call to v._cutlink.
        child._cutLink(n,parent_v)
    else:
        self.badUnlink(parent_v,n,child)
</t>
<t tx="ekr.20080421140032.1">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/663e1f9d8e2d1c24

@color
</t>
<t tx="ekr.20080423062035.1"># These methods are only for the use of low-level code
# in leoNodes.py, leoFileCommands.py and leoUndo.py.
</t>
<t tx="ekr.20080425060424.1"></t>
<t tx="ekr.20080425060424.10">def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.12">def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20080425060424.13">def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.14">def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.2">def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
</t>
<t tx="ekr.20080425060424.3">def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
</t>
<t tx="ekr.20080425060424.4">def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
</t>
<t tx="ekr.20080425060424.5">def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
</t>
<t tx="ekr.20080425060424.8">def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20080425060424.9">def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080426051658.1">@
Every nodes gets visited, so we only check consistency
between p and its parent, not between p and its children.

In other words, this is a strong test.
@c

parent_v = p._parentVnode()
n = p.childIndex()

assert parent_v.children[n] == p.v,'fail 1'
</t>
<t tx="ekr.20080427062528.4">def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace: g.trace('entry',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i &lt; len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2.v == p3.v: # A match with the to-be-moved node?
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
</t>
<t tx="ekr.20080427062528.9"></t>
<t tx="ekr.20080429051644.1"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
</t>
<t tx="ekr.20080429053831.10">def isWriteBit (self):

    v = self
    return (v.statusBits &amp; v.writeBit) != 0
</t>
<t tx="ekr.20080429053831.12">def setDirty (self):

    self.statusBits |= self.dirtyBit
</t>
<t tx="ekr.20080429053831.13">def setFileIndex (self, index):

    self.fileIndex = index
</t>
<t tx="ekr.20080429053831.6">def hasBody (self):

    '''Return True if this vnode contains body text.'''

    s = self._bodyString

    return s and len(s) &gt; 0
</t>
<t tx="ekr.20080429053831.8">def clearWriteBit (self):
    self.statusBits &amp;= ~ self.writeBit
</t>
<t tx="ekr.20080429053831.9">def setWriteBit (self):
    self.statusBits |= self.writeBit
</t>
<t tx="ekr.20080503055349.1">def setPositionAfterSort (self,sortChildren):

    c = self
    p = c.p
    p_v = p.v
    parent = p.parent()
    parent_v = p._parentVnode()

    if sortChildren:
        p = parent or c.rootPosition()
    else:
        if parent:
            p = parent.firstChild()
        else:
            p = leoNodes.position(parent_v.children[0])
        while p and p.v != p_v:
            p.moveToNext()
        p = p or parent

    return p
</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # editCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # keyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # killBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # macroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # registerCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # editCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # keyHandlerCommandsClass
        'repeat-complex-command',
        # killBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # queryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # rectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # registerCommandsClass
        'jump-to-register',
        'point-to-register',
        # searchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510095819.1">def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) &gt; 1:
        # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20080510153327.2">def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.widget
    if not w: return

    w.setForegroundColor(self.minibuffer_error_color) # 'red')

    if label is not None:
        k.setLabel(label,protect)
</t>
<t tx="ekr.20080510153327.3">def setForegroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setForegroundColor(color)

SetForegroundColour = setForegroundColor
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState (self):

    k = self
    k.setInputState(k.defaultUnboundKeyAction)
</t>
<t tx="ekr.20080512115455.1">def showStateColors (self,inOutline,w):

    k = self ; c = k.c ; state = k.unboundKeyAction

    body = c.frame.body ; bodyCtrl = body.bodyCtrl

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    # g.trace(state,w,g.app.gui.widget_name(w),g.callers(4))

    # if inOutline and w == bodyCtrl:
        # return # Don't recolor the body.
    if w != bodyCtrl and not g.app.gui.widget_name(w).startswith('head'):
        # Don't recolor the minibuffer, log panes, etc.
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    # g.trace(id(w),bg,fg,self)

    if w == bodyCtrl:
        body.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
</t>
<t tx="ekr.20080514084054.4">def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j &gt; -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i &gt; -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    modeName = s + '-mode'
    return modeName
</t>
<t tx="ekr.20080514131122.10">def invalidateFocus (self):

    '''Indicate that the focus is in an invalid location, or is unknown.'''

    # c = self
    # c.requestedFocusWidget = None
    pass
</t>
<t tx="ekr.20080514131122.12">def requestRecolor (self):

    c = self
    # g.trace(g.callers(4))
    c.requestRecolorFlag = True

recolor = requestRecolor
</t>
<t tx="ekr.20080514131122.13">def recolor_now(self,p=None,incremental=False,interruptable=True):

    c = self
    if p is None:
        p = c.p

    # g.trace('incremental',incremental,p and p.h,g.callers(4))

    c.frame.body.colorizer.colorize(p,
        incremental=incremental,interruptable=interruptable)
</t>
<t tx="ekr.20080514131122.14"></t>
<t tx="ekr.20080514131122.16">def traceFocus (self,w):

    c = self

    if False or (not g.app.unitTesting and c.config.getBool('trace_focus')):
        c.trace_focus_count += 1
        g.pr('%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8))
</t>
<t tx="ekr.20080514131122.17">def widget_name (self,widget):

    c = self

    return g.app.gui and g.app.gui.widget_name(widget) or ''
</t>
<t tx="ekr.20080514131122.18">
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)

def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self ; k = c.k
    if k: k.minibufferWantsFocus()

def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)

def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
</t>
<t tx="ekr.20080514131122.19"># widgetWantsFocusNow does an automatic update.
def widgetWantsFocusNow(self,w):
    c = self
    c.request_focus(w)
    c.outerUpdate()
    # Re-request widget so we don't use the body by default.
    c.request_focus(w) 

# All other "Now" methods wait.
bodyWantsFocusNow = bodyWantsFocus
logWantsFocusNow = logWantsFocus
minibufferWantsFocusNow = minibufferWantsFocus
treeWantsFocusNow = treeWantsFocus
</t>
<t tx="ekr.20080514131122.20">def outerUpdate (self):

    trace = False and not g.unitTesting
    verbose = True ; traceFocus = False
    c = self ; aList = []
    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    c.requestRedrawFlag = False

    # The iconify requests are made only by c.bringToFront.
    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        if trace: g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw')
        c.frame.tree.redraw_now(forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        # This should be the only call to c.recolor_now.
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if traceFocus: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList)) # ,c.shortFileName() or '&lt;no name&gt;',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''

    # g.trace('after')
</t>
<t tx="ekr.20080514131122.7">
def beginUpdate(self):

    '''Deprecated: does nothing.'''

    g.trace('***** c.beginUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

def endUpdate(self,flag=True):

    '''Request a redraw of the screen if flag is True.'''

    g.trace('***** c.endUpdate is deprecated',g.callers())
    if g.app.unitTesting: assert(False)

    c = self
    if flag:
        c.requestRedrawFlag = True
        # g.trace('flag is True',c.shortFileName(),g.callers())

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20080514131122.8">def bringToFront(self,set_focus=True):

    c = self
    c.requestedIconify = 'deiconify'
    c.requestedFocusWidget = c.frame.body.bodyCtrl

BringToFront = bringToFront # Compatibility with old scripts
</t>
<t tx="ekr.20080514131122.9">def get_focus (self):

    c = self
    return g.app.gui and g.app.gui.get_focus(c)

def get_requested_focus (self):

    c = self
    return c.requestedFocusWidget

def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w

def set_focus (self,w,force=False):

    trace = False # and g.unitTesting
    c = self
    if w and g.app.gui:
        if trace: print('c.set_focus:',repr(w))
        g.app.gui.set_focus(c,w)
    else:
        if trace: print('c.set_focus: no w')

    c.requestedFocusWidget = None
</t>
<t tx="ekr.20080515053412.1"># These wrappers ensure that c.outerUpdate get called.
</t>
<t tx="ekr.20080531075119.1">class Tracer:

    '''A "debugger" that computes a call graph.

    To trace a function and its callers, put the following at the function's start:

    g.startTracer()
    '''

    @others

def startTracer():

    import sys
    t = g.Tracer()
    sys.settrace(t.tracer)
    return t
</t>
<t tx="ekr.20080531075119.2">def __init__(self):

    self.callDict = {}
        # Keys are function names.
        # Values are the number of times the function was called by the caller.
    self.calledDict = {}
        # Keys are function names.
        # Values are the total number of times the function was called.

    self.count = 0
    self.inited = False
    self.limit = 2 # 0: no limit, otherwise, limit trace to n entries deep.
    self.stack = []
    self.trace = False
    self.verbose = False # True: print returns as well as calls.
</t>
<t tx="ekr.20080531075119.3">def computeName (self,frame):

    import inspect

    if not frame: return ''

    code = frame.f_code ; result = []

    module = inspect.getmodule(code)
    if module:
        module_name = module.__name__
        if module_name == 'leo.core.leoGlobals':
            result.append('g')
        else:
            tag = 'leo.core.'
            if module_name.startswith(tag):
                module_name = module_name[len(tag):]
            result.append(module_name)

    try:
        # This can fail during startup.
        self_obj = frame.f_locals.get('self')
        if self_obj: result.append(self_obj.__class__.__name__)
    except Exception:
        pass

    result.append(code.co_name)

    return '.'.join(result)
</t>
<t tx="ekr.20080531075119.4">def report (self):

    if 0:
        g.pr('\nstack')
        for z in self.stack:
            g.pr(z)

    g.pr('\ncallDict...')

    for key in sorted(self.callDict):

        # Print the calling function.
        g.pr('%d' % (self.calledDict.get(key,0)),key)

        # Print the called functions.
        d = self.callDict.get(key)
        for key2 in sorted(d):
            g.pr('%8d' % (d.get(key2)),key2)
</t>
<t tx="ekr.20080531075119.5">def stop (self):

    sys.settrace(None)
    self.report()
</t>
<t tx="ekr.20080531075119.6">def tracer (self, frame, event, arg):

    '''A function to be passed to sys.settrace.'''

    n = len(self.stack)
    if event == 'return': n = max(0,n-1)
    pad = '.' * n

    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) &lt; self.limit):
            g.trace('%scall' % (pad),name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    elif event == 'return':
        if self.stack:
            name = self.stack.pop()
            if self.trace and self.verbose and (self.limit == 0 or len(self.stack) &lt; self.limit):
                g.trace('%sret ' % (pad),name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        else:
            self.stop()
            return None
    else:
        return self.tracer
</t>
<t tx="ekr.20080531075119.7">def updateStats (self,name):

    if not self.stack:
        return

    caller = self.stack[-1]
    d = self.callDict.get(caller,{})
        # d is a dict reprenting the called functions.
        # Keys are called functions, values are counts.
    d[name] = 1 + d.get(name,0)
    self.callDict[caller] = d

    # Update the total counts.
    self.calledDict[name] = 1 + self.calledDict.get(name,0)
</t>
<t tx="ekr.20080603052650.466">@nocolor

4.8 vim, cleanups, your mission...

http://groups.google.com/group/leo-editor/browse_thread/thread/141690c553bfde55

Vim mode users: your top 3 complaints, please

@color
</t>
<t tx="ekr.20080605064555.2">def os_path_realpath(path):


    path = g.toUnicodeFileEncoding(path)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
</t>
<t tx="ekr.20080606074139.2">def chdir (path):

    if not g.os_path_isdir(path):
        path = g.os_path_dirname(path)

    if g.os_path_isdir(path) and g.os_path_exists(path):
        os.chdir(path)
</t>
<t tx="ekr.20080610085158.2">def add_command (self,menu,**keys):

    c = self ; command = keys.get('command')

    if command:

        def add_commandCallback(c=c,command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys ['command'] = add_commandCallback

        menu.add_command(**keys)

    else:
        g.trace('can not happen: no "command" arg')
</t>
<t tx="ekr.20080610085158.3">def bind (self,w,pattern,func,*args,**keys):

    c = self ; callers = g.callers()

    def bindCallback(event,c=c,func=func,callers=callers):
        # g.trace('func',func.__name__)
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback,*args,**keys)

def bind2 (self,w,pattern,func,*args,**keys):

    c = self

    def bindCallback2(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.bind(pattern,bindCallback2,*args,**keys)
</t>
<t tx="ekr.20080610085158.4">def tag_bind (self,w,tag,event_kind,func):

    c = self
    def tag_bindCallback(event,c=c,func=func):
        val = func(event)
        # Careful: func may destroy c.
        if c.exists: c.outerUpdate()
        return val

    w.tag_bind(tag,event_kind,tag_bindCallback)
</t>
<t tx="ekr.20080616110054.2">The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
</t>
<t tx="ekr.20080623083646.10">def dumpBead (self,n):

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n &gt; 0:
        return self.dumpBead(n-1)
    else:
        return '&lt;no top bead&gt;'
</t>
<t tx="ekr.20080626081829.2">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/eb718b4c6d478ac0

I'm just getting started learning how to use Leo. Now, I'd like to use
it for some of my projects, but there's no chance that I can convert
everyone at work to using it, so putting sentinel-filled files in our
repository is out of the question. At the same time, my code looks
awfully bare without sentinels because the documentation ends up in
the section names, not the comments!

So, I was wondering if there's a convenient way to pull the section
names into a comment at the start of each section?

===============

Interesting question.  Am I correct in assuming you are using @nosent trees
to generate your files?  If so, it would be easy to add support for the
following options:

@bool write_section_comments_in_at_nosent_trees
@bool write_node_name_comments_in_at_nosent_trees

The first would write a sentinel consisting of only the section name;
the second would write a sentinel consisting only of the node's headline
(for nodes whose headline is not a section name).

These seem like they would be useful additions.  One can even imagine
corresponding Leo directives so that the comments could be turned on or off
within an @nosent tree.

What do you think?

=====================

&gt; Interesting question.  Am I correct in assuming you are using @nosent trees
&gt; to generate your files?  If so, it would be easy to add support for the
&gt; following options:

&gt; @bool write_section_comments_in_at_nosent_trees
&gt; @bool write_node_name_comments_in_at_nosent_trees

&gt; The first would write a sentinel consisting of only the section name;
&gt; the second would write a sentinel consisting only of the node's headline
&gt; (for nodes whose headline is not a section name).

&gt; These seem like they would be useful additions.  One can even imagine
&gt; corresponding Leo directives so that the comments could be turned on or off
&gt; within an @nosent tree.

That sounds like an excellent solution. Particularly the last bit --
if you could turn section-comments on and off as required, it would
become very convenient to use Leo to produce source that is intended
to also be read by non Leo users. 
</t>
<t tx="ekr.20080628095358.1">http://groups.google.com/group/leo-editor/browse_thread/thread/5688ed9aaa39be2e#

@nocolor

The main difficulty I see in the migration is creating the tables in the getPublicCommands methods in the various classes in leoEditCommands.py.  At present, these tables associate command names (strings) with corresponding methods.  The form of getPublicCommands is always:

def getPublicCommands (self):
  return {
    'command-name1': self.methodName1,
    'command-name2': self.methodName2,
    ...
  }

Thinking out loud, let's see whether the migration can be done easily.  We would change the entry:

    'command-name1': self.methodNameN,

to:

    'command-name1': self.classNameN(self),

That is, the table creates an instance of the class by calling the class's ctor, with self (the container object) as the ctor's only argument.  To make this work, all we need to do is give the class a __call__ method whose signature matches the signature of methodNameN, that is, the signature used to call methods previously.

Well, isn't this nice.  We can transition gradually, as needed.  No need *ever* to do a mass migration.  It should be easy to verify this scheme with one or two examples.  Please report your experiences if you decide to play around with this.

Edward

P.S.  I think it would be good style to append "Class" to the name of each command class. This makes it clear that self.myCommandClass(self) is a ctor.
</t>
<t tx="ekr.20080704085627.3">def splitList (self,ivar,fileName):

    '''Process lines containing pairs of entries 
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2.'''

    result1 = [] ; result2 = []
    aList = getattr(self,ivar)

    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (fileName,s))

    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s1' % ivar
    setattr(self,name1, result1)
    setattr(self,name2, result2)

    # g.trace(name1,getattr(self,name1))
    # g.trace(name2,getattr(self,name2))
</t>
<t tx="ekr.20080707150137.5">class nullScriptingControllerClass:

    '''A default, do-nothing class to be overridden by mod_scripting or other plugins.

    This keeps pylint happy.'''

    def __init__ (self,c,iconBar=None):

        self.c = c
        self.iconBar = iconBar

    def createAllButtons(self):

        pass

</t>
<t tx="ekr.20080708094444.1">@first # -*- coding: utf-8 -*-

&lt;&lt; docstring &gt;&gt;
&lt;&lt; imports &gt;&gt;

@language python
@tabwidth -4
@pagewidth 70

@others
</t>
<t tx="ekr.20080708094444.12">class sourcereader:
    """
    A class to read lines sequentially.

    The class keeps an internal index, so that each
    call to get returns the next line.

    Index returns the internal index, and sync
    advances the index to the the desired line.

    The index is the *next* line to be returned.

    The line numbering starts from 0.
    """
    @others
</t>
<t tx="ekr.20080708094444.13">def __init__ (self,shadowController,lines):

    self.lines = lines 
    self.length = len(self.lines)
    self.i = 0
    self.shadowController=shadowController
</t>
<t tx="ekr.20080708094444.14">def index (self):
    return self.i
</t>
<t tx="ekr.20080708094444.15">def get (self):

    '''Return the next line.'''

    trace = False and not g.unitTesting

    if 0: # Old code: crashed.
        result = self.lines[self.i]
        self.i+=1
    else:
        # A simple-minded guard.
        if self.i &lt; len(self.lines):
            result = self.lines[self.i]
            self.i+=1
        else:
            result = ''

    if trace: g.trace(repr(result))
    return result 
</t>
<t tx="ekr.20080708094444.16">def sync (self,i):
    self.i = i 
</t>
<t tx="ekr.20080708094444.17">def size (self):
    return self.length 
</t>
<t tx="ekr.20080708094444.18">def atEnd (self):
    return self.index&gt;=self.length
</t>
<t tx="ekr.20080708094444.19"># def clone(self):
    # sr = self.shadowController.sourcereader(shadowController,self.lines)
    # sr.i = self.i
    # return sr
</t>
<t tx="ekr.20080708094444.20">def dump(self, title):

    g.pr(title)
    # g.pr('self.i',self.i)
    for i, line in enumerate(self.lines):
        marker = g.choose(i==self.i,'**','  ')
        g.pr("%s %3s:%s" % (marker, i, repr(line)),)
</t>
<t tx="ekr.20080708094444.21">class sourcewriter:
    """
    Convenience class to capture output to a file.

    Similar to class sourcereader.
    """
    @others
</t>
<t tx="ekr.20080708094444.22">def __init__ (self,shadowController):

    self.i = 0
    self.lines =[]
    self.shadowController=shadowController
</t>
<t tx="ekr.20080708094444.23">def put(self, line, tag=''):

    trace = False and not g.unitTesting

    # An important hack.  Make sure *all* lines end with a newline.
    # This will cause a mismatch later in check_the_final_output,
    # and a special case has been inserted to forgive this newline.
    if not line.endswith('\n'):
        if trace: g.trace('adding newline',repr(line))
        line = line + '\n'

    self.lines.append(line)
    self.i+=1

    if trace: g.trace('%30s %s' % (tag,repr(line)))
</t>
<t tx="ekr.20080708094444.24">def index (self):

    return self.i 
</t>
<t tx="ekr.20080708094444.25">def getlines (self):

    return self.lines 
</t>
<t tx="ekr.20080708094444.26">def dump(self, title):

    '''Dump lines for debugging.'''

    g.pr(title)
    for i, line in enumerate(self.lines):
        marker = '  '
        g.pr("%s %3s:%s" % (marker, i, repr(line)),newline=False)
</t>
<t tx="ekr.20080708094444.29">def separate_sentinels (self, lines, marker):

    '''
    Separates regular lines from sentinel lines.

    Returns (regular_lines, sentinel_lines)
    '''

    x = self ; regular_lines = [] ; sentinel_lines = []

    i = 0 ; n = len(lines)
    while i &lt; len(lines):
        line = lines[i]
        if marker.isSentinel(line):
            sentinel_lines.append(line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i &lt; len(lines):
                    line = lines[i]
                    regular_lines.append(line)
                else:
                    x.verbatim_error()
        else:
            regular_lines.append(line)
        i += 1

    return regular_lines, sentinel_lines 
</t>
<t tx="ekr.20080708094444.30">def push_filter_mapping (self,lines, marker):
    """
    Given the lines of a file, filter out all
    Leo sentinels, and return a mapping:

      stripped file -&gt; original file

    Filtering should be the same as
    separate_sentinels
    """

    x = self ; mapping = [None]

    i = 0 ; n = len(lines)
    while i &lt; n:
        line = lines[i]
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                i += 1
                if i &lt; n:
                    mapping.append(i+1)
                else:
                    x.verbatim_error()
        else:
            mapping.append(i+1)
        i += 1

    return mapping 
</t>
<t tx="ekr.20080708094444.33">def show_error (self, lines1, lines2, message, lines1_message, lines2_message):

    x = self
    banner1 = '=' * 30
    banner2 = '-' * 30
    g.es_print('%s\n%s\n%s\n%s\n%s' % (
        banner1,message,banner1,lines1_message,banner2))

    x.show_error_lines(lines1,'shadow_errors.tmp1')

    g.es_print('\n%s\n%s\n%s' % (
        banner1,lines2_message,banner1))

    x.show_error_lines(lines2,'shadow_errors.tmp2')

    g.es_print('\n@shadow did not pick up the external changes correctly')

    # g.es_print('Please check shadow.tmp1 and shadow.tmp2 for differences')
</t>
<t tx="ekr.20080708094444.34">def strip_sentinels_with_map (self, lines, marker):

    '''Strip sentinels from lines, a list of lines with sentinels.

    Return (results,mapping)

    'lines':     A list of lines containing sentinels.
    'results':   The list of non-sentinel lines.
    'mapping':   A list mapping each line in results to the original list.
                results[i] comes from line mapping[i] of the original lines.'''

    x = self
    mapping = [] ; results = [] ; i = 0 ; n = len(lines)
    while i &lt; n:
        line = lines[i]
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                i += 1
                if i &lt; n:
                    # Not a sentinel, whatever it looks like.
                    line = lines[i]
                    # g.trace('not a sentinel',repr(line))
                    results.append(line)
                    mapping.append(i)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
            mapping.append(i)
        i += 1

    mapping.append(len(lines)) # To terminate loops.
    return results, mapping 
</t>
<t tx="ekr.20080708094444.35">def check_the_final_output(self, new_private_lines, new_public_lines, sentinel_lines, marker):
    """
    Check that we produced a valid output.

    Input:
        new_targetlines:   the lines with sentinels which produce changed_lines_without_sentinels.
        sentinels:         new_targetlines should include all the lines from sentinels.

    checks:
        1. new_targetlines without sentinels must equal changed_lines_without_sentinels.
        2. the sentinel lines of new_targetlines must match 'sentinels'
    """
    new_public_lines2, new_sentinel_lines2 = self.separate_sentinels(
        new_private_lines, marker)

    lines1 = new_public_lines
    lines2 = new_public_lines2
    sents1 = sentinel_lines
    sents2 = new_sentinel_lines2
    if 1: # Ignore trailing ws:
        s1 = ''.join(lines1).rstrip()
        s2 = ''.join(lines2).rstrip()
        lines1 = g.splitLines(s1)
        lines2 = g.splitLines(s2)
    if 1: # Ignore trailing ws on every line.
        lines1 = [z.rstrip() for z in lines1]
        lines2 = [z.rstrip() for z in lines2]
        sents1 = [z.rstrip() for z in sents1]
        sents2 = [z.rstrip() for z in sents2]
    lines_ok = lines1 == lines2
    sents_ok = sents1 == sents2

    if g.unitTesting:
        # The unit test will report the error.
        return lines_ok and sents_ok

    if not lines_ok:
        if 1:
            g.trace()
            d = difflib.Differ()
            # g.trace('Different!!',d)
            aList = list(d.compare(new_public_lines2,new_public_lines))
            pprint.pprint(aList)
        else:
            self.show_error(
                lines1 = new_public_lines2,
                lines2 = new_public_lines,
                message = "Error in updating public file!",
                lines1_message = "new public lines (derived from new private lines)",
                lines2_message = "new public lines")

    if not sents_ok:
        self.show_error(
            lines1 = sentinel_lines,
            lines2 = new_sentinel_lines2,
            message = "Sentinals not preserved!",
            lines1_message = "old sentinels",
            lines2_message = "new sentinels")

    return lines_ok and sents_ok
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    trace = False and not g.unitTesting
    x = self ; at = self.c.atFileCommands
    at.errors = 0

    old_public_lines  = open(old_public_file).readlines()
    old_private_lines = open(old_private_file).readlines()
    marker = x.markerFromFileLines(old_private_lines,old_private_file)

    if trace:
        g.trace(
            'marker',marker,
            '\npublic_file',old_public_file,
            '\npublic lines...\n%s' %(
                g.listToString(old_public_lines,toRepr=True)),
            '\nprivate_file',old_private_file,
            '\nprivate lines...\n%s\n' %(
                g.listToString(old_private_lines,toRepr=True)))

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,old_private_lines,marker)

    # Important bug fix: Never create the private file here!
    fn = old_private_file
    copy = os.path.exists(fn) and new_private_lines != old_private_lines

    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        ok = x.replaceFileWithString(fn,s)
        # g.trace('ok',ok,'writing private file',fn)

    return copy
</t>
<t tx="ekr.20080708094444.37">def copy_sentinels(self,reader,writer,marker,limit):

    '''Copy sentinels from reader to writer while reader.index() &lt; limit.'''

    x = self
    start = reader.index()
    while reader.index() &lt; limit:
        line = reader.get()
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                # We are *deleting* non-sentinel lines, so we must delete @verbatim sentinels!
                # We must **extend** the limit to get the next line.
                if reader.index() &lt; limit + 1:
                    # Skip the next line, whatever it is.
                    # Important: this **deletes** the @verbatim sentinel,
                    # so this is a exception to the rule that sentinels are preserved.
                    line = reader.get()
                else:
                    x.verbatim_error()
            else:
                # g.trace('put line',repr(line))
                writer.put(line,tag='copy sent %s:%s' % (start,limit))
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
       New at 2010/01/07: Replacements preserve sentinel locations.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    trace = False and g.unitTesting
    verbose = True
    x = self
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    &lt;&lt; init vars &gt;&gt;
    &lt;&lt; define print_tags &gt;&gt;

    delim1,delim2 = marker.getDelims()
    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        &lt;&lt; About this loop &gt;&gt;

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old: %s %s' % (old_i,prev_old_j))
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new: %s %s' % (new_i,prev_new_j))

        &lt;&lt; Handle the opcode &gt;&gt;

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,
        new_private_lines_wtr,
        marker,
        limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        &lt;&lt; do final correctness check&gt;&gt;
    return result
</t>
<t tx="ekr.20080708094444.39">def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


</t>
<t tx="ekr.20080708094444.40">new_private_lines_wtr = self.sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = self.sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = self.sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = self.sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
</t>
<t tx="ekr.20080708094444.45">t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
</t>
<t tx="ekr.20080708094444.52">import leo.core.leoGlobals as g

import difflib
import os
import pprint
import unittest
</t>
<t tx="ekr.20080708094444.78">'''
leoShadow.py


This code allows users to use Leo with files which contain no sentinels
and still have information flow in both directions between outlines and
derived files.

Private files contain sentinels: they live in the Leo-shadow subdirectory.
Public files contain no sentinels: they live in the parent (main) directory.

When Leo first reads an @shadow we create a file without sentinels in the regular directory.

The slightly hard thing to do is to pick up changes from the file without
sentinels, and put them into the file with sentinels.



Settings:
- @string shadow_subdir (default: LeoFolder): name of the shadow directory.

- @string shadow_prefix (default: x): prefix of shadow files.
  This prefix allows the shadow file and the original file to have different names.
  This is useful for name-based tools like py.test.
'''
</t>
<t tx="ekr.20080708094444.79">def __init__ (self,c,trace=False,trace_writers=False):

    self.c = c

    # Configuration...
    self.shadow_subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
    self.shadow_prefix = c.config.getString('shadow_prefix') or ''

    # Munch shadow_subdir
    self.shadow_subdir = g.os_path_normpath(self.shadow_subdir)

    # Error handling...
    self.errors = 0
    self.last_error  = '' # The last error message, regardless of whether it was actually shown.

    # Support for goto-line.
    self.line_mapping = []
</t>
<t tx="ekr.20080708094444.80">class shadowController:

    '''A class to manage @shadow files'''

    @others
</t>
<t tx="ekr.20080708094444.85">def error (self,s,silent=False):

    x = self

    if not silent:
        g.es_print(s,color='red')

    # For unit testing.
    x.last_error = s
    x.errors += 1

def message (self,s):

    g.es_print(s,color='orange')

def verbatim_error(self):

    x = self

    x.error('file syntax error: nothing follows verbatim sentinel')
    g.trace(g.callers())
</t>
<t tx="ekr.20080708094444.89"></t>
<t tx="ekr.20080708094444.9">def markerFromFileName (self,filename):

    '''Return the sentinel delimiter comment to be used for filename.'''

    x = self
    if not filename: return None
    root,ext = g.os_path_splitext(filename)
    if ext=='.tmp':
        root, ext = os.path.splitext(root)

    delims = g.comment_delims_from_extension(filename)
    marker = self.markerClass(delims)
    return marker
</t>
<t tx="ekr.20080708192807.1"></t>
<t tx="ekr.20080708192807.2">@ This loop writes all output lines using a single writer:
new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present
  SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of
  the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips
(deletes) all previously unwritten non-sentinel lines in
old_private_lines_rdr whose index is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from
the old_private_lines_rdr explicitly. This explains why opcode
handlers for the 'insert' and 'delete' opcodes are identical.
</t>
<t tx="ekr.20080708192807.5"># Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace('tag',tag,'old_i',old_i,'limit',limit)

if tag == 'equal':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() &lt;= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (
            tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag == 'insert':
    if limit &lt; old_private_lines_rdr.size():
        self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index() # Only used for tag.
    while new_public_lines_rdr.index() &lt; new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag == 'replace':
    # This case is new: it was the same as the 'insert' case.
    start = old_private_lines_rdr.index() # Only used for tag.
    while (
        old_private_lines_rdr.index() &lt;= mapping[old_j-1]
        and new_public_lines_rdr.index() &lt;  new_j
            # 2010/10/22: the replacement lines can be shorter.
    ):
        old_line = old_private_lines_rdr.get()
        if marker.isSentinel(old_line):
            # Important: this should work for @verbatim sentinels
            # because the next line will also be replaced.
            new_private_lines_wtr.put(old_line,tag='%s %s:%s' % (
                'replace: copy sentinel',start,new_j))
        else:
            new_line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(new_line,tag='%s %s:%s' % (
                'replace: new line',start,new_j))

    # 2010/10/22: The replacement lines can be longer: same as 'insert' code above.
    while new_public_lines_rdr.index() &lt; new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # Leave new_public_lines_rdr unchanged.

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
</t>
<t tx="ekr.20080709062932.10">def runTest (self,define_g = True):

    x = self.shadowController
    p = self.p.copy()

    results = x.propagate_changed_lines(
        self.new_public_lines,self.old_private_lines,self.marker,p=p)

    if not self.lax and results != self.expected_private_lines:

        # g.pr('%s\natShadowTestCase.runTest:failure\n%s' % ('*' * 40,p.h))
        g.pr(p.h)

        for aList,tag in (
            (results,'results'),
            (self.expected_private_lines,'expected_private_lines')
        ):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
</t>
<t tx="ekr.20080709062932.11">def shortDescription (self):

    return self.p and self.p.h or '@test-shadow: no self.p'
</t>
<t tx="ekr.20080709062932.19">def findNode(self,c,p,headline):
    p = g.findNodeInTree(c,p,headline)
    if not p:
        g.es_print('can not find',headline)
        assert False
    return p
</t>
<t tx="ekr.20080709062932.2">class atShadowTestCase (unittest.TestCase):

    '''Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.

    '''

    @others

</t>
<t tx="ekr.20080709062932.20">def createSentinelNode (self,root,p):

    '''Write p's tree to a string, as if to a file.'''

    h = p.h
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2

</t>
<t tx="ekr.20080709062932.21">def makePrivateLines (self,p):

    c = self.c ; at = c.atFileCommands

    at.write (p,
        nosentinels = False,
        thinFile = False,  # Debatable.
        scriptWrite = True,
        toString = True)

    s = at.stringOutput
    return g.splitLines(s)
</t>
<t tx="ekr.20080709062932.22">def makePublicLines (self,lines):

    x = self.shadowController

    lines,mapping = x.strip_sentinels_with_map(lines,self.marker)

    return lines
</t>
<t tx="ekr.20080709062932.23">def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i &lt; n:
        line = lines[i]
        if marker.isSentinel(line):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i &lt; len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
        i += 1

    return results
</t>
<t tx="ekr.20080709062932.6">def __init__ (self,c,p,shadowController,lax,trace=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.lax = lax
    self.p = p.copy()
    self.shadowController=shadowController

    # Hard value for now.
    delims = '#','',''
    self.marker = shadowController.markerClass(delims)

    # For teardown...
    self.ok = True
</t>
<t tx="ekr.20080709062932.7">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20080709062932.8">def setUp (self):

    c = self.c ; p = self.p ; x = self.shadowController

    old = self.findNode (c,p,'old')
    new = self.findNode (c,p,'new')

    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)

    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)

    # We must change node:new to node:old
    self.expected_private_lines = self.mungePrivateLines(self.new_private_lines,'node:new','node:old')

</t>
<t tx="ekr.20080709062932.9">def tearDown (self):

    pass

    # No change is made to the outline.
    # self.c.redraw()
</t>
<t tx="ekr.20080710082231.19">def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        # Force the creation of the directories.
        g.makeAllNonExistentDirectories(path,c=None,force=True)

    return g.os_path_exists(path) and g.os_path_isdir(path)
</t>
<t tx="ekr.20080710101653.1"># see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if app.logInited:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2)
        except Exception:
            # This can fail when running pythonw.ese.
            # g.es('unexpected exception in g.pr')
            g.es(s2)
            # if not g.pr_warning_given:
                # g.pr_warning_given = True
                # # print('unexpected Exception in g.pr')
                # # print('make sure your sitecustomize.py contains::')
                # # print('    sys.setdefaultencoding("utf-8")')
                # g.es_exception()
                # g.trace(g.callers())
            # s2 = s.encode('ascii',"replace")
            # if g.isPython3:
                # s2 = str(s2,'ascii','replace')
            # sys.stdout.write(s2)
    else:
        app.printWaiting.append(s2)
</t>
<t tx="ekr.20080711063656.1"></t>
<t tx="ekr.20080711063656.3">def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename,verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
</t>
<t tx="ekr.20080711063656.4">def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; c = x.c ; theDir = x.baseDirName()

    return theDir and c.os_path_finalize_join(theDir,filename)
</t>
<t tx="ekr.20080711063656.6">def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; c = x.c

    baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)

    return baseDir and c.os_path_finalize_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))
</t>
<t tx="ekr.20080711063656.7">def baseDirName (self):

    x = self ; c = x.c ; filename = c.fileName()

    if filename:
        return g.os_path_dirname(c.os_path_finalize(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None
</t>
<t tx="ekr.20080711093251.3">def writeAtShadowNodes (self,event=None):

    '''Write all @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=False)

def writeDirtyAtShadowNodes (self,event=None):

    '''Write all dirty @shadow nodes in the selected outline.'''

    at = self
    return at.writeAtShadowNodesHelper(writeDirtyOnly=True)
</t>
<t tx="ekr.20080711093251.4">def writeAtShadowNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @shadow nodes in the selected outline"""

    at = self ; c = at.c
    p = c.p ; after = p.nodeAfterTree()
    found = False

    while p and p != after:
        if p.atShadowFileNodeName() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = at.writeOneAtShadowNode(p,toString=toString,force=True)
            if ok:
                found = True
                g.es('wrote %s' % p.atShadowFileNodeName(),color='blue')
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @shadow nodes in the selected tree")
    else:
        g.es("no @shadow nodes in the selected tree")

    return found
</t>
<t tx="ekr.20080711093251.5">def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController
    root = p.copy() 

    fn = p.atShadowFileNodeName()
    if trace: g.trace(p.h,fn)
    if not fn:
        g.es_print('can not happen: not an @shadow node',p.h,color='red')
        return False

    # A hack to support unknown extensions.
    self.adjustTargetLanguage(fn) # May set c.target_language.

    fn = at.fullPath(p)
    at.default_directory = g.os_path_dirname(fn)
    exists = g.os_path_exists(fn)
    if trace: g.trace('exists %s fn %s' % (exists,fn))

    # Bug fix 2010/01/18: Make sure we can compute the shadow directory.
    private_fn = x.shadowPathName(fn)
    if not private_fn:
        return False

    if not toString and not hasattr(root.v,'at_read') and exists:
        # Prompt if writing a new @shadow node would overwrite the existing public file.
        ok = self.promptForDangerousWrite(fn,kind='@shadow')
        if ok:
            root.v.at_read = True # Create the attribute for all clones.
        else:
            g.es("not written:",fn)
            return

    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,targetFileName=None, # Not used.
        atShadow=True,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        forcePythonSentinels=True) # A hack to suppress an error message.
            # The actual sentinels will be set below.

    # Bug fix: Leo 4.5.1: use x.markerFromFileName to force the delim to match
    #                     what is used in x.propegate changes.
    marker = x.markerFromFileName(fn)
    at.startSentinelComment,at.endSentinelComment=marker.getDelims()

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,
            nosentinels=not sentinels,toString=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions),'writeOneAtShadowNode'

    if at.errors == 0 and not toString:
        # Write the public and private files.
        if trace: g.trace('writing',fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    self.checkPythonCode(root,s=at.private_s,targetFn=fn)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName,color='red')
        root.setDirty() # New in Leo 4.4.8.
        root.setOrphan() # 2010/10/22.

    return at.errors == 0
</t>
<t tx="ekr.20080711093251.7">def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    # Remember that we have seen the @shadow node.
    p.v.at_read = True # Create the attribute

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    if shadow_exists:
        at.read(p,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
</t>
<t tx="ekr.20080712080505.1">def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
</t>
<t tx="ekr.20080712080505.3">def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file
    or use an existing public file.'''

    return (
        g.os_path_exists(fn) and
        g.os_path_isfile(fn) and
        g.os_path_getsize(fn) &gt; 10
    )
</t>
<t tx="ekr.20080712150045.1">def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    at = self ; testing = g.app.unitTesting

    # g.trace('fn',fn,'s','\n',s)
    # g.trace(g.callers())

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        s2,e = g.readFileIntoString(fn)
        if s is None:
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            g.es('not written: %s directory not found' % fn,color='red')
        return False

    # Replace
    try:
        f = open(fn,'wb')
        if g.isPython3:
            s = g.toEncodedString(s,encoding=self.encoding)
        f.write(s)
        f.close()
        if not testing:
            if exists:
                g.es('wrote:    ',fn)
            else:
                # g.trace('created:',fn,g.callers())
                g.es('created:',fn)
        return True
    except IOError:
        at.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
</t>
<t tx="ekr.20080712150045.2">def openStringFile (self,fn):

    at = self

    at.shortFileName = g.shortFileName(fn)
    at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
    at.outputFile = g.fileLikeObject()
    at.targetFileName = "&lt;string-file&gt;"

    return at.outputFile
</t>
<t tx="ekr.20080712150045.3">def closeStringFile (self,theFile):

    at = self

    if theFile:
        theFile.flush()
        s = at.stringOutput = theFile.get()
        theFile.close()
        at.outputFile = None

        # at.outputFileName = u''
        if g.isPython3:
            at.outputFileName = ''
        else:
            at.outputFileName = unicode('')

        at.shortFileName = ''
        at.targetFileName = None
        return s
    else:
        return None
</t>
<t tx="ekr.20080713091247.1">def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    trace = False and not g.unitTesting
    x = self
    exists = g.os_path_exists(fn)

    if exists:
        # Read the file.  Return if it is the same.
        s2,e = g.readFileIntoString(fn)
        if s2 is None:
            return False
        if s == s2:
            if not g.unitTesting: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            x.error('not written: %s directory not found' % fn)
        return False

    # Replace the file.
    try:
        f = open(fn,'wb')
        f.write(g.toEncodedString(s))
        if trace: g.trace('fn',fn,
            '\nlines...\n%s' %(g.listToString(g.splitLines(s))),
            '\ncallers',g.callers(4))
        f.close()
        if not g.unitTesting:
            # g.trace('created:',fn,g.callers())
            if exists:  g.es('wrote:',fn)
            else:       g.es('created:',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
</t>
<t tx="ekr.20080727122007.1">What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&amp;lt;something&amp;gt;" namespace?
</t>
<t tx="ekr.20080729142651.1">def getIvarsDict(obj):

    '''Return a dictionary of ivars:values for non-methods of obj.'''

    import types

    d = dict(
        [[key,getattr(obj,key)] for key in dir(obj)
            if type (getattr(obj,key)) != types.MethodType])

    # g.pr(g.listToString(sorted(d)))
    return d

def checkUnchangedIvars(obj,d,exceptions=None):

    if not exceptions: exceptions = []
    ok = True

    for key in d:
        if key not in exceptions:
            if getattr(obj,key) != d.get(key):
                g.trace('changed ivar: %s old: %s new: %s' % (
                    key,repr(d.get(key)),repr(getattr(obj,key))))
                ok = False
    return ok
</t>
<t tx="ekr.20080729142651.2">def os_path_getsize (path):

    '''Return the size of path.'''

    path = g.toUnicodeFileEncoding(path)

    return os.path.getsize(path)
</t>
<t tx="ekr.20080730161153.2">'''A program to run unit tests with the leoBridge module.'''

import leo.core.leoBridge as leoBridge
import leo.core.leoTest as leoTest

import optparse

# Do not define g here.  Use the g returned by the bridge.

@others

if __name__ == '__main__':
    print ('leoBridgeTest.py: argv: %s' % repr(sys.argv))
    gui = scanOptions()
    main(gui=gui)
</t>
<t tx="ekr.20080730161153.3">def main (gui='nullGui'):

    trace = False
    tag = 'leoTestBridge'

    # Setting verbose=True prints messages that would be sent to the log pane.
    bridge = leoBridge.controller(gui=gui,verbose=False)
    if bridge.isOpen():
        g = bridge.globals()
        path = g.os_path_finalize_join(
            g.app.loadDir,'..','test','unitTest.leo')
        c = bridge.openLeoFile(path)
        if trace: g.es('%s %s' % (tag,c.shortFileName()))
        runUnitTests(c,g)

    g.pr(tag,'done')
</t>
<t tx="ekr.20080730161153.4">def runUnitTests (c,g):

    nodeName = 'All unit tests' # The tests to run.

    try:
        u = leoTest.testUtils(c)
        p = u.findNodeAnywhere(nodeName)
        if p:
            g.es('running unit tests in %s...' % nodeName)
            c.selectPosition(p)
            c.debugCommands.runUnitTests()
            g.es('unit tests complete')
        else:
            g.es('node not found:' % nodeName)
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
        raise
</t>
<t tx="ekr.20080730161153.5">'''A program to run dynamic unit tests with the leoBridge module.'''

import optparse
import os
import sys

# Make sure the current directory is on sys.path.
cwd = os.getcwd()
if cwd not in sys.path:
    sys.path.append(cwd)

if 1:
    print('leoDynamicTest:curdir',cwd)

import time
import leo.core.leoBridge as leoBridge

# Do not define g here. Use the g returned by the bridge.

@others

if __name__ == '__main__':
    if False:
        print('leoDynamicTest.py: argv...')
        for z in sys.argv[2:]: print('  %s' % repr(z))
    main()
</t>
<t tx="ekr.20080730161153.6">def main ():

    trace = False
    tag = 'leoDynamicTests.leo'
    if trace: t1 = time.time()

    # Setting verbose=True prints messages that would be sent to the log pane.
    path,gui,silent = scanOptions()
    # print('(leoDynamicTest.py:main)','silent',silent)

    # Not loading plugins and not reading settings speeds things up considerably.
    bridge = leoBridge.controller(gui=gui,
        loadPlugins=False,readSettings=False,verbose=False)

    if trace:
         t2 = time.time() ; print('%s open bridge:  %0.2fsec' % (tag,t2-t1))

    if bridge.isOpen():
        g = bridge.globals()
        g.app.silentMode = silent
        path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
        c = bridge.openLeoFile(path)
        if trace:
            t3 = time.time() ; print('%s open file: %0.2fsec' % (tag,t3-t2))
        runUnitTests(c,g)
</t>
<t tx="ekr.20080730161153.7">def runUnitTests (c,g):

    p = c.rootPosition()
    #g.es_print('running dynamic unit tests...')
    c.selectPosition(p)
    c.debugCommands.runAllUnitTestsLocally()
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080730212711.7">@nocolor-node

- Don't repeat "can not load &lt;plugin&gt;" messages.

- Unify print-plugins and print-plugins-info commands, and make them more informative.

- Fix the plugin mess.

    - Create a way to unload a plugin.  This should be relatively easy.
</t>
<t tx="ekr.20080801071227.4">def readAtShadowNodes (self,event=None):

    '''Read all @shadow nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p

    c.endEditing()
    undoData = u.beforeChangeTree(p)
    c.atFileCommands.readAtShadowNodes(p)
    u.afterChangeTree(p,'Read @shadow Nodes',undoData)
    c.redraw() 
</t>
<t tx="ekr.20080801071227.5">def writeAtShadowNodes (self,event=None):

    '''Write all @file nodes in the selected outline.'''

    self.c.atFileCommands.writeAll(writeAtFileNodesFlag=True)
</t>
<t tx="ekr.20080801071227.6">def writeDirtyAtShadowNodes (self,event=None):

    '''Write all changed @shadow Nodes.'''

    self.c.atFileCommands.writeDirtyAtShadowNodes()

</t>
<t tx="ekr.20080801071227.7">def readAtShadowNodes (self,p):

    '''Read all @shadow nodes in the p's tree.'''

    at = self ; after = p.nodeAfterTree()
    p = p.copy() # Don't change p in the caller.

    while p and p != after: # Don't use iterator.
        if p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20080802070659.11"></t>
<t tx="ekr.20080805071954.2">def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
</t>
<t tx="ekr.20080805085257.1">def createUaList (self,aList):

    '''Given aList of pairs (p,torv), return a list of pairs (torv,d)
    where d contains all picklable items of torv.unknownAttributes.'''

    result = []

    for p,torv in aList:
        if type(torv.unknownAttributes) != type({}):
            g.es("ignoring non-dictionary uA for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(torv.unknownAttributes) # Copy the dict.

            for key in d:
                # Just see if val can be pickled.  Suppress any error.
                ok = self.pickle(torv=torv,val=d.get(key),tag=None)
                if not ok:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key",key,"in",p.h,color="blue")

            if d:
                result.append((torv,d),)

    return result
</t>
<t tx="ekr.20080805085257.2">def pickle (self,torv,val,tag):

    '''Pickle val and return the hexlified result.'''

    trace = False and g.unitTesting
    try:
        s = pickle.dumps(val,protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.ue(s2,'utf-8')
        if trace: g.trace('\n',
            type(val),val,'\n',type(s),repr(s),'\n',
            type(s2),s2,'\n',type(s3),s3)
        field = ' %s="%s"' % (tag,s3)
        return field

    except pickle.PicklingError:
        if tag: # The caller will print the error if tag is None.
            g.es_print("ignoring non-pickleable value",val,"in",torv,color="blue")
        return ''

    except Exception:
        g.es("fc.pickle: unexpected exception in",torv,color='red')
        g.es_exception()
        return ''
</t>
<t tx="ekr.20080805114146.2"></t>
<t tx="ekr.20080805132422.3">def resolveArchivedPosition(self,archivedPosition,root_v):

    '''Return a vnode corresponding to the archived position relative to root node root_v.'''

    def oops (message):
        if not g.app.unitTesting:
            g.es_print('bad archived position: %s' % (message),color='red')

    try:
        aList = [int(z) for z in archivedPosition.split('.')]
        aList.reverse()
    except Exception:
        return oops('"%s"' % archivedPosition)

    if not aList:
        return oops('empty')

    last_v = root_v
    n = aList.pop()
    if n != 0:
        return oops('root index="%s"' % n )

    while aList:
        n = aList.pop()
        children = last_v.children
        if n &lt; len(children):
            last_v = children[n]
        else:
            return oops('bad index="%s", len(children)="%s"' % (n,len(children)))

    return last_v
</t>
<t tx="ekr.20080806054207.3">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/76789df8aac08c70

When using leo as outliner, I often use only node headlines to write
down some data. If the headline string is too long, the cursor goes
beyond the visible area. When modifying a node headline, is it
possible to make leo to auto-scroll, so the cursor is always visible? 
</t>
<t tx="ekr.20080807111553.1"></t>
<t tx="ekr.20080811174246.1">def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20080813064908.8"></t>
<t tx="ekr.20080814134319.1">@nocolor

C:\leo.repo\trunk&gt;bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

C:\leo.repo\trunk&gt;bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

</t>
<t tx="ekr.20080815174457.5">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/e86796831635311b

I was wondering whether it would be a good idea to have leo
automatically delete the corresponding shadow file when a @shadow node
is deleted? Ditto for deleting the .leo_shadow dir when it is empty.

Answer:

My second thought is that this is too dangerous--shadow files might
turn out to be useful emergency backups.  I would prefer to have Leo
mess with the file system as little as possible.
</t>
<t tx="ekr.20080816125725.2"># The syntax of these functions must be valid on Python2K and Python3K.

def isBytes(s):
    '''Return True if s is Python3k bytes type.'''
    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isCallable(obj):
    if g.isPython3:
        return hasattr(obj, '__call__')
    else:
        return callable(obj)

def isChar(s):
    '''Return True if s is a Python2K character type.'''
    if g.isPython3:
        return False
    else:
        return type(s) == types.StringType

def isString(s):
    '''Return True if s is any string, but not bytes.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes

def isUnicode(s):
    '''Return True if s is a unicode string.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) == types.UnicodeType
</t>
<t tx="ekr.20080819075811.13">def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
</t>
<t tx="ekr.20080819075811.3">def contractAllOtherNodes (self,event=None):

    '''Contract all nodes except those needed to make the
    presently selected node visible.'''

    c = self ; leaveOpen = c.p

    for p in c.rootPosition().self_and_siblings():
        c.contractIfNotCurrent(p,leaveOpen)

    c.redraw()

</t>
<t tx="ekr.20080819075811.7">def contractIfNotCurrent(self,p,leaveOpen):

    c = self

    if p == leaveOpen or not p.isAncestorOf(leaveOpen):
        p.contract()

    for child in p.children():
        if child != leaveOpen and child.isAncestorOf(leaveOpen):
            c.contractIfNotCurrent(child,leaveOpen)
        else:
            for p2 in child.self_and_subtree():
                p2.contract()
</t>
<t tx="ekr.20080821073134.2">def doKeywordArgs (keys,d=None):

    '''Return a result dict that is a copy of the keys dict
    with missing items replaced by defaults in d dict.'''

    if d is None: d = {}

    result = {}
    for key,default_val in d.items():
        isBool = default_val in (True,False)
        val = keys.get(key)
        if isBool and val in (True,'True','true'):
            result[key] = True
        elif isBool and val in (False,'False','false'):
            result[key] = False
        elif val is None:
            result[key] = default_val
        else:
            result[key] = val

    return result 
</t>
<t tx="ekr.20080822065427.10">def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

</t>
<t tx="ekr.20080822065427.12">def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,
            underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
</t>
<t tx="ekr.20080822065427.14">def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
</t>
<t tx="ekr.20080822065427.16">def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
</t>
<t tx="ekr.20080822065427.21">def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
</t>
<t tx="ekr.20080822065427.3"></t>
<t tx="ekr.20080822065427.4">def show_error_lines (self,lines,fileName):

    for i,line in enumerate(lines):
        g.es_print('%3s %s' % (i,repr(line)))

    if False: # Only for major debugging.
        try:
            f1 = open(fileName, "w")
            for s in lines:
                if not g.isPython3: # 2010/08/27
                    s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
                f1.write(repr(s))
            f1.close()
        except IOError:
            g.es_exception()
            g.es_print('can not open',fileName)
</t>
<t tx="ekr.20080822065427.8">class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
</t>
<t tx="ekr.20080822065427.9">def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("&lt;Key&gt;", self.onKey)
</t>
<t tx="ekr.20080825131124.3">def createImportDispatchDict (self):

    self.importDispatchDict = {
        # Keys are file extensions, values are text scanners.
        # Text scanners must have the signature scanSomeText(self,s,parent,atAuto=False)
        '.c':       self.scanCText,
        '.h':       self.scanCText,
        '.h++':     self.scanCText,
        '.cc':      self.scanCText,
        '.c++':     self.scanCText,
        '.cpp':     self.scanCText,
        '.cxx':     self.scanCText,
        '.cs':      self.scanCSharpText,
        '.el':      self.scanElispText,
        '.htm':     self.scanXmlText,
        '.html':    self.scanXmlText,
        '.ini':     self.scanIniText,
        '.java':    self.scanJavaText,
        '.js':      self.scanJavaScriptText,
        '.php':     self.scanPHPText,
        '.pas':     self.scanPascalText,
        '.py':      self.scanPythonText,
        '.pyw':     self.scanPythonText,
        # '.txt':     self.scanRstText, # A reasonable default.
        # '.rest':    self.scanRstText,
        # '.rst':     self.scanRstText,
        '.xml':     self.scanXmlText,
    }
</t>
<t tx="ekr.20080827175609.1">def get_directives_dict_list(p):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""

    trace = False and not g.unitTesting

    # if trace: time1 = g.getTime()

    result = []
    p1 = p.copy()
    for p in p1.self_and_parents():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    # if trace:
        # n = len(p1.h) + len(p1.b)
        # g.trace('%4d %s' % (n,g.timeSince(time1)))

    return result
</t>
<t tx="ekr.20080827175609.32">def scanAtEncodingDirectives(aList):

    '''Scan aList for @encoding directives.'''

    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            # g.trace(encoding)
            return encoding
        elif encoding and not g.app.unitTesting:
            g.es("invalid @encoding:",encoding,color="red")

    return None
</t>
<t tx="ekr.20080827175609.33">def scanAtLineendingDirectives(aList):

    '''Scan aList for @lineending directives.'''

    for d in aList:

        e = d.get('lineending')
        if e in ("cr","crlf","lf","nl","platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.es("invalid @lineending directive:",e,color="red")

    return None
</t>
<t tx="ekr.20080827175609.34">def scanAtPagewidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @pagewidth directives.'''

    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s,0)
            if val != None and val &gt; 0:
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @pagewidth",s,color="red")

    return None
</t>
<t tx="ekr.20080827175609.37">def scanAtTabwidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @tabwidth directives.'''

    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk,val = g.skip_long(s,0)
            if val not in (None,0):
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @tabwidth",s,color="red")
    return None

def scanAllAtTabWidthDirectives(c,p):

    '''Scan p and all ancestors looking for @tabwidth directives.'''

    if c and p:
        aList = g.get_directives_dict_list(p)
        val = g.scanAtTabwidthDirectives(aList)
        ret = g.choose(val is None,c.tab_width,val)
    else:
        ret = None
    # g.trace(ret,p and p.h,ret)
    return ret
</t>
<t tx="ekr.20080827175609.39">def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.p

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }
</t>
<t tx="ekr.20080827175609.52">def scanAtCommentAndAtLanguageDirectives(aList):

    '''Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.'''

    lang = None

    for d in aList:

        comment = d.get('comment')
        language = d.get('language')

        # Important: assume @comment follows @language.
        if language:
            # if g.unitTesting: g.trace('language',language)
            lang,delim1,delim2,delim3 = g.set_language(language,0)

        if comment:
            # if g.unitTesting: g.trace('comment',comment)
            delim1,delim2,delim3 = g.set_delims_from_string(comment)

        if comment or language:
            delims = delim1,delim2,delim3
            return {'language':lang,'comment':comment,'delims':delims}

    return None
</t>
<t tx="ekr.20080827175609.53">def scanAtHeaderDirectives(aList):

    '''scan aList for @header and @noheader directives.'''

    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.es_print("conflicting @header and @noheader directives",color='red')
</t>
<t tx="ekr.20080828103146.12"># Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
</t>
<t tx="ekr.20080828103146.15">def scanAtPathDirectives(self,aList):

    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''

    trace = False and (force or createPath) and not g.unitTesting
    verbose = True

    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry',g.callers(4))

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose:
        g.trace('base   ',base)
        g.trace('loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d',d)
            g.trace('**** @path path',path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or &lt;path&gt; to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths,tag='c.scanAtPathDirectives: raw paths')

    path = c.os_path_finalize_join(*paths)

    if trace and verbose: g.trace('joined path:',path)
    if trace: g.trace('returns',path)

    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
</t>
<t tx="ekr.20080828103146.8">def scanColorDirectives(self,p):

    '''Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.'''

    c = self.c
    if not c: return # May be None for testing.

    table = (
        ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
        ('root',        c.scanAtRootDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,func in table:
        val = func(aList)
        if val: d[key]=val

    # Post process.
    lang_dict       = d.get('lang-dict')
    self.rootMode   = d.get('root') or None

    if lang_dict:
        self.language       = lang_dict.get('language')
        self.comment_string = lang_dict.get('comment')
    else:
        self.language       = c.target_language and c.target_language.lower()
        self.comment_string = None

    # g.trace('self.language',self.language)
    return self.language # For use by external routines.
</t>
<t tx="ekr.20080831084419.4">def scanAtWrapDirectives(aList,issue_error_flag=False):

    '''Scan aList for @wrap and @nowrap directives.'''

    for d in aList:
        if d.get('wrap') is not None:
            return True
        elif d.get('nowrap') is not None:
            return False

    return None

def scanAllAtWrapDirectives(c,p):

    '''Scan p and all ancestors looking for @wrap/@nowrap directives.'''

    if c and p:
        default = c and c.config.getBool("body_pane_wraps")
        aList = g.get_directives_dict_list(p)

        val = g.scanAtWrapDirectives(aList)
        ret = g.choose(val is None,default,val)
    else:
        ret = None
    # g.trace(ret,p.h)
    return ret
</t>
<t tx="ekr.20080901124540.1"># These are all new in Leo 4.5.1.
</t>
<t tx="ekr.20080901195858.4">def scanDirectives(c,p=None):

    return c.scanAllDirectives(p)
</t>
<t tx="ekr.20080917061525.3">def getSettingSource (self,c,setting):

    '''return the name of the file responsible for setting.'''

    aList = [self.localOptionsDict.get(c.hash())]
    aList.extend(self.localOptionsList)
    aList.extend(self.dictList)

    for d in aList:
        if d:
            bunch = d.get(setting)
            if bunch is not None:
                return bunch.path,bunch.val
    else:
        return 'unknown setting',None
</t>
<t tx="ekr.20080917153158.10">@nocolor

How to create launchpad key pairs:

http://help.launchpad.net/YourAccount/CreatingAnSSHKeyPair

How to create/use branches

===== pushes a branch after it has been created on launchpad

bzr push --use-existing-dir lp:leo-editor/whatever (private)

bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever (private)

====== remembers the push

bzr push --remember bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever

===== creates branch on local machine: do this from leo.repo directory

bzr branch lp:leo-editor new-branch-name 

bzr branch bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever new-branch-name

====== To resolve conflicts

kdiff3 file1 file2 file3 -m


Docs:
- http://doc.bazaar-vcs.org/latest/en/user-guide/index.html
    - http://bazaar-vcs.org/BzrWhy (referenced in sec 1.1.3 of the guide)
        - http://ianclatworthy.files.wordpress.com/2007/10/dvcs-why-and-how3.pdf
        - PQM: https://launchpad.net/pqm (google)
        - BB Bundle buggy: http://bundlebuggy.aaronbentley.com/help (google)
        - Spike solution: http://www.extremeprogramming.org/rules/spike.html (google)
- My log was at: http://bzr.arbash-meinel.com/irc_log/bzr/2008/02/bzr-2008-02-25.html

Windows

EKR:  do ed-bzr

- Configuration file is .bazaar in XP
C:\Documents and Settings\HP_Administrator\Application Data\bazaar\2.0

Linux:

- Configuration file is bazaar.conf in ~/.bazaar directory
</t>
<t tx="ekr.20080918164844.12">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/bce1065d9a332fcd

Now that the leo is more "modeless" (I'm speaking of switching between
outline navigation and body editing modes), which btw is a clear improvement
to how leo used to behave, here are some things that still feel a bit
un-intuitive:

- ctrl+H (edit-headline) "locks" the user into the mode way too much.

   * The headline editing mode should be cancelled when the user does:
      - cursor up/down
      - ESC

   * Even better alternative: I find myself constantly thinking that "ok,
now I need to edit a headline (typically not the current headline), so now
I'll press ctrl+H". I think perhaps pressing up/down should cancel the
current headline editing, and select the next/previous headline for editing.
That is, I wouldn't need to navigate to the headline I want to edit before I
start editing it.

  - cut-node (ctrl+shift+x) selects the wrong node after the cut. The
intuitive assumption is that cut will select the node that "took the place
of the
    current node", instead of starting to travel upwards the set of nodes.

   * Typical use case is the way you usually start deleting a set of items.
You move to the first item and start cutting repeatedly. This wont work with
the current behaviour. 
</t>
<t tx="ekr.20080919065433.1">def toUnicodeWithErrorCode (s,encoding,reportErrors=False):

    ok = True
    if g.isPython3: f = str
    else: f = unicode
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s,encoding,'strict')
        except Exception:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = f(s,encoding,'replace')
            ok = False
    return s,ok
</t>
<t tx="ekr.20080919065433.2">def toEncodedStringWithErrorCode (s,encoding,reportErrors=False):

    ok = True

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except Exception:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
            ok = False
    return s, ok
</t>
<t tx="ekr.20080919085541.3">http://groups.google.com/group/leo-editor/browse_thread/thread/dff0c165e2211691
</t>
<t tx="ekr.20080920052058.3">def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.h,p2 and p2.v and p2.h))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
</t>
<t tx="ekr.20080921060401.13">def os_path_expanduser(path):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path)

    result = os.path.normpath(os.path.expanduser(path))

    return result
</t>
<t tx="ekr.20080921060401.14">def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)

    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(path,**keys)
            for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
</t>
<t tx="ekr.20080921060401.4">def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
</t>
<t tx="ekr.20080921060401.5">def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
</t>
<t tx="ekr.20080921060401.6">def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
</t>
<t tx="ekr.20080921091311.1"># import pdb ; pdb = pdb.set_trace
import optparse
import os
import sys
import traceback

try:
    import Tkinter ; Tkinter.wantobjects = 0
        # An ugly hack for Tk/Tkinter 8.5
        # See http://sourceforge.net/forum/message.php?msg_id=4078577
except ImportError:
    try:
        import tkinter ; tkinter.wantobject = 0
    except ImportError:
        pass

path = os.getcwd()
if path not in sys.path:
    # print('appending %s to sys.path' % path)
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

try:
    # This will fail if True/False are not defined.
    import leo.core.leoGlobals as g
except ImportError:
    print("runLeo.py: can not import leo.core.leoGlobals")
    raise
except Exception:
    print("runLeo.py: unexpected exception: import leo.core.leoGlobals")
    raise

# Set leoGlobals.g here, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

# Do early inits
import leo.core.leoNodes as leoNodes
import leo.core.leoConfig as leoConfig

# There is a circular dependency between leoCommands and leoEditCommands.
import leo.core.leoCommands as leoCommands

# Make sure we call the new leoPlugins.init top-level function.
# This prevents a crash when run is called repeatedly from
# IPython's lleo extension.
import leo.core.leoPlugins as leoPlugins
leoPlugins.init()

# Do all other imports.
import leo.core.leoGui as leoGui
</t>
<t tx="ekr.20080921091311.2">def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.pluginsController.finishCreate() # 2010/09/09
</t>
<t tx="ekr.20080921154026.1">def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if True: # Just read the file into the node.
        fileName = g.os_path_finalize(fileName)
        s,e = g.readFileIntoString(fileName)
        if s is None: return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.p
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.p
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.p
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Mark the outline dirty.
    return c
</t>
<t tx="ekr.20080922115725.1"># Allow block comments in private shadow files.
# Compute delims using the private shadow file, not the file extension!
# Can @shadow mark externally changed nodes?
</t>
<t tx="ekr.20080922124033.5">def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
</t>
<t tx="ekr.20080922124033.6">def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s: return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 &lt; i &lt; j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

        if trace: g.trace(s1,s)
    return s
</t>
<t tx="ekr.20080923070954.13">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20080923070954.14">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20080923070954.4">def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
    createPath=True,
    issuePathWarning=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    trace = False and not g.unitTesting
    at = self ; c = self.c
    g.app.atPathInBodyWarning = None
    &lt;&lt; set ivars &gt;&gt;
    lang_dict = {'language':at.language,'delims':delims,}
    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    if issuePathWarning and g.app.atPathInBodyWarning:
        g.es('warning: ignoring @path directive in',
            g.app.atPathInBodyWarning,color='red')

    # Post process.
    lang_dict   = d.get('lang-dict')
    delims      = lang_dict.get('delims')
    lineending  = d.get('lineending')

    at.encoding             = d.get('encoding')
    at.explicitLineEnding   = bool(lineending)
    at.language             = lang_dict.get('language')
    at.output_newline       = lineending or g.getOutputNewline(c=c)
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        &lt;&lt; set comment strings from delims &gt;&gt;

    # For unit testing.
    d = {
        "all"       : all,
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
    if trace: g.trace(d)
    return d
</t>
<t tx="ekr.20080923124254.16">def scanAllDirectives(self,p):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    self.init_directive_ivars()
    if p:
        s = p.b
        &lt;&lt; Collect @first attributes &gt;&gt;

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives), 
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    lang_dict = {'language':None,'delims':None}
    self.parent_language_comment_settings(p,lang_dict)

    # Post process.
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.init_delims          = lang_dict.get('delims')
    self.page_width           = d.get('pagewidth')
    self.tangle_directory     = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # Handle the print-mode directives.
    self.print_mode = None
    for d in aList:
        for key in ('verbose','terse','quiet','silent'):
            if d.get(key) is not None:
                self.print_mode = key ; break
        if self.print_mode: break
    if not self.print_mode: self.print_mode = 'verbose'

    # g.trace(self.tangle_directory)

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.tangle_directory,
        "tabwidth"  : self.tab_width,
    }
</t>
<t tx="ekr.20080923124254.17">@
Stephen P. Schaefer 9/13/2002: Add support for @first. Unlike other
root attributes, does *NOT* inherit from parent nodes.
@c

tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20080923200153.1"># This affects the add_directives plugin.
# Also, the color_markup plugin doesn't work with the threading colorizer.
</t>
<t tx="ekr.20080924032842.3">def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.p

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i &gt; 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
</t>
<t tx="ekr.20080924032842.5">def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i &lt;= 1.
    while i &gt; 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
</t>
<t tx="ekr.20081001062423.1">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c46eabe8a9fe6e8

@color
</t>
<t tx="ekr.20081001062423.10"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

def getAbsPathFromNode(c,p,name=''): # Name is for unit testing.

    default_dir = ''
    if p:
        name = p.anyAtFileNodeName()

    if name:
        theDir = g.os_path_dirname(name)
        if theDir and g.os_path_isabs(theDir):
            if g.os_path_exists(theDir):
                default_dir = theDir
            else:
                default_dir = g.makeAllNonExistentDirectories(theDir,c=c)

    return default_dir
</t>
<t tx="ekr.20081001062423.11">def getPathFromDirectives(c,p,createFlag=True):

    '''Scan for @path directives.'''

    trace = False and not g.unitTesting
    default_dir = '' ; error = ''
    if not p: return default_dir,error
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    if path:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = c.os_path_finalize_join(base,path)
        exists = g.os_path_exists(path)
        if createFlag:
            if exists:
                default_dir = path
            else:
                default_dir = g.makeAllNonExistentDirectories(path,c=c)
                if not default_dir:
                    error = "invalid @path: %s" % path
        else:
            default_dir = path
            if not exists:
                error = "does not exist: @path %s" % path

    return default_dir,error
</t>
<t tx="ekr.20081001062423.12"># This code is executed if no valid absolute path was specified in
# the @file node or in an @path directive.

def findDefaultDirectory(c):

    '''Attempt to find a suitable default directory.'''

    default_dir = ''

    # Check that c.openDirectory and c.frame.openDirectory are in synch.
    if c.openDirectory != c.frame.openDirectory:
        g.trace('***can not happen: c.openDirectory != c.frame.openDirectory')
        g.trace('c.openDirectory',c.openDirectory)
        g.trace('c.frame.openDirectory',c.frame.openDirectory)

    if not g.os_path_isabs(c.openDirectory):
        g.trace('*** can not happen: relative c.openDirectory',c.openDirectory)

    for theDir in (c.openDirectory,g.getBaseDirectory(c)):
        if theDir and g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
            if g.os_path_exists(theDir):
                default_dir = theDir
            else:
                default_dir = g.makeAllNonExistentDirectories(theDir,c=c)
            if default_dir: break

    return default_dir
</t>
<t tx="ekr.20081001062423.9">def setDefaultDirectory(c,p,importing=False):

    ''' Return a default directory by scanning @path directives.'''

    name = p.anyAtFileNodeName()
    if name:
        # An absolute path overrides everything.
        d = g.os_path_dirname(name)
        if d and g.os_path_isabs(d):
            return d

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
        # Returns g.getBaseDirectory(c) by default.
        # However, g.getBaseDirectory can return ''
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory,g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''

    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")

    return path
</t>
<t tx="ekr.20081004102201.2">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5e7bd3af2d1fbf51

How about a shadow.log file which Leo told what it thought of the relationship
between the node, file and shadow? It might provide useful clues.
</t>
<t tx="ekr.20081005065934.1">def initAfterLoad (self):

    '''Provide an offical hook for late inits of the commander.'''

    pass
</t>
<t tx="ekr.20081005065934.12">@nocolor-node

It seems Scintilla relies on externally generated api description
files to provide autocompletion. Links that may be of interest:

http://www.riverbankcomputing.co.uk/static/Docs/QScintilla2/classQsciAPIs.html#b0f824492bb0f3ca54edb4d46945a3de

http://www.burgaud.com/scite-java-api/

http://scintilla.sourceforge.net/tags2api.py

http://www.koders.com/python/fid7000B9C96CF2C6FB5BCE9DF700365C5B2A1F36A7.aspx?s=gtk#L53
</t>
<t tx="ekr.20081005065934.3">def initAfterLoad (self):

    '''Provide offical hooks for late inits of components of Leo frames.'''

    frame = self

    frame.body.initAfterLoad()
    frame.log.initAfterLoad()
    frame.menu.initAfterLoad()
    # if frame.miniBufferWidget: frame.miniBufferWidget.initAfterLoad()
    frame.tree.initAfterLoad()

def initCompleteHint (self):
    pass
</t>
<t tx="ekr.20081005065934.5"># These are optional.
def after_idle (self,idle_handler,thread_count):
    pass

def tag_add(self,tagName,i,j=None,*args):
    pass

def tag_bind (self,tagName,event,callback):
    pass

def tag_config (self,colorName,**keys):
    pass

def tag_configure (self,colorName,**keys):
    pass

def tag_delete(self,tagName):
    pass

def tag_names(self,*args):
    return []

def tag_remove (self,tagName,index1,index2):
    pass
</t>
<t tx="ekr.20081005065934.6">def forceFullRecolor (self):
    self.forceFullRecolorFlag = True

def initAfterLoad (self):
    pass
</t>
<t tx="ekr.20081005065934.7"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
</t>
<t tx="ekr.20081005065934.8"># These are new in Leo 4.6.

def initAfterLoad (self):
    '''Do late initialization.
    Called in g.openWithFileName after a successful load.'''

def afterSelectHint(self,p,old_p):
    '''Called at end of tree.select.'''
    pass

def beforeSelectHint (self,p,old_p):
    '''Called at start of tree.select.'''
    pass

# These are hints for optimization.
# The proper default is c.redraw()
def redraw_after_clone(self):                   self.c.redraw()
def redraw_after_contract(self,p=None):         self.c.redraw()
def redraw_after_expand(self,p=None):           self.c.redraw()
def redraw_after_head_changed(self):            self.c.redraw()
def redraw_after_icons_changed(self,all=False): self.c.redraw()
def redraw_after_select(self,p=None):           self.c.redraw()
</t>
<t tx="ekr.20081005065934.9"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'after_idle',
    'forceFullRecolor', # The base-class method is usually good enough.
    'initAfterLoad',

    # These *are* used by various colorizers, not just in leoColor.py.
    'tag_add',
    'tag_bind',
    'tag_config',
    'tag_configure',
    'tag_delete',
    'tag_names',
    'tag_remove',
)
</t>
<t tx="ekr.20081006100835.1"># Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.
def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    path = g.scanAllAtPathDirectives(c,p)
    name = ''
    for p in p.self_and_parents():
        name = p.anyAtFileNodeName()
        if name: break

    if name:
        name = g.os_path_finalize_join(path,name)
    return name
</t>
<t tx="ekr.20081031074455.13">def bind (self,kind,*args,**keys):          pass
def getWidth (self):                        return 0
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass
def indexIsVisible (self,i):                return False
    # Code will loop if this returns True forever.
def mark_set(self,markName,i):              pass
def setWidth (self,width):                  pass
def tag_add(self,tagName,i,j=None,*args):   pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete (self,tagName,*args,**keys): pass
def tag_names (self, *args):                return []
def tag_ranges(self,tagName):               return tuple()
def tag_remove(self,tagName,i,j=None,*args):pass
def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
def xyToPythonIndex (self,x,y):             return 0
def yview (self,*args):                     return 0,0

tag_config = tag_configure
</t>
<t tx="ekr.20081031074455.2"># These methods are widget-independent because they call the corresponding _xxx methods.
</t>
<t tx="ekr.20081031074455.3">mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
    'onChar',
)
</t>
<t tx="ekr.20081031074455.4">@ The subclass must implement all high-level wrappers or all low-level wrappers,
depending on the highLevelWrapper ivar. The ctor extends .mustBeDefinedInSubclasses
by one of the following lists:
@c

mustBeDefinedInSubclasses = [
]

mustBeDefinedInHighLevelSubclasses = (
    'appendText',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'scrollLines',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

mustBeDefinedInLowLevelSubclasses = (
    '_appendText',
    '_get',
    '_getAllText',
    '_getFocus',
    '_getInsertPoint',
    '_getLastPosition',
    '_getSelectedText',
    '_getSelectionRange',
    '_getYScrollPosition',
    '_hitTest',
    '_insertText',
    '_scrollLines',
    '_see',
    '_setAllText',
    '_setBackgroundColor',
    '_setFocus',
    '_setForegroundColor',
    '_setInsertPoint',
    '_setSelectionRange',
    '_setYScrollPosition',
)
</t>
<t tx="ekr.20081031074455.5">mustBeDefined = (
    'bind',
    'flashCharacter',
    'deleteTextSelection',
    # These can be do-nothings
    'getWidth',
    'indexIsVisible',
    'mark_set',
    'setWidth',
    'tag_add',
    'tag_config',
    'tag_configure',
    'tag_delete',
    'tag_names',
    'tag_ranges',
    'tag_remove',
    'update',
    'update_idletasks',
    'xyToPythonIndex',
    'yview',
    # mayBeDefinedInSubclasses.
    'delete',
    'deleteTextSelection',
    'event_generate',
#     'getName()
#     'GetName()
    'hasSelection',
    'replace',
    'rowColToGuiIndex',
    'selectAllText',
    'toGuiIndex',
    'toPythonIndex',
    'toPythonIndexRowCol',
    # 'xyzzy', # to make test fail.
)
</t>
<t tx="ekr.20081031074455.6"></t>
<t tx="ekr.20081031074455.8"># These are high-level interface methods that do not call low-level methods.
</t>
<t tx="ekr.20081031074455.9"># Define these here to keep pylint happy.

def _appendText(self,s):            self.oops()
def _get(self,i,j):                 self.oops() ; return ''
def _getAllText(self):              self.oops() ; return ''
def _getFocus(self):                self.oops() ; return None
def _getInsertPoint(self):          self.oops() ; return 0
def _getLastPosition(self):         self.oops() ; return 0
def _getSelectedText(self):         self.oops() ; return ''
def _getSelectionRange(self):       self.oops() ; return (0,0)
def _getYScrollPosition(self):      self.oops() ; return None # A flag
def _hitTest(self,pos):             self.oops()
def _insertText(self,i,s):          self.oops()
def _scrollLines(self,n):           self.oops()
def _see(self,i):                   self.oops()
def _setAllText(self,s,new_p=None): self.oops()
def _setBackgroundColor(self,color): self.oops()
def _setForegroundColor(self,color): self.oops()
def _setFocus(self):                self.oops()
def _setInsertPoint(self,i):        self.oops()
def _setSelectionRange(self,i,j):   self.oops()
def _setYScrollPosition(self,i):    self.oops()

_findFocus = _getFocus
</t>
<t tx="ekr.20081113095540.1">/etc/apt/sources.list.d is a directory
It contains, on my machine, files called edgy-universe.list.x
The prefix doesn't matter, but the contents of these files must contain the proper ubuntu distro name,
for example, gutsy, hardy, intrepid.
</t>
<t tx="ekr.20081119083601.1">def toUnicode (self,s):

    if g.isPython3:
        return str(s)
    else:
        return unicode(s)
</t>
<t tx="ekr.20081119132758.2"></t>
<t tx="ekr.20081123102100.1">def backToHome (self,event):

    '''Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins == 0 or not(s): return

    # Toggle back and forth between start of line and first-non-blank character.
    i,j = g.getLine(s,ins)
    i1 = i
    while i &lt; j and s[i] in (' \t'):
        i += 1
    if i == ins:
        i = i1

    self.moveToHelper(event,i,extend=False)
</t>
<t tx="ekr.20081208102356.1">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

&gt; Tk only colorizes one body editor, and if you delete that editor it
&gt; colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
</t>
<t tx="ekr.20081216090156.1">def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    trace = False and not g.app.unitTesting

    if self.isRst:
        return s # Never unindent rst code.

    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws &lt; undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

</t>
<t tx="ekr.20081216090156.4">def parseUnderindentTag (self,s):

    tag = self.underindentEscapeString
    s2 = s[len(tag):]

    # To be valid, the escape must be followed by at least one digit.
    i = 0
    while i &lt; len(s2) and s2[i].isdigit():
        i += 1

    if i &gt; 0:
        n = int(s2[:i])
        return n,s2[i:]
    else:
        return 0,s
</t>
<t tx="ekr.20090103070824.11">def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
</t>
<t tx="ekr.20090103070824.12"></t>
<t tx="ekr.20090103070824.9">def setFileTimeStamp (self,fn):

    c = self

    timeStamp = os.path.getmtime(fn)
    c.timeStampDict[fn] = timeStamp

    # g.trace('%20s' % (timeStamp),fn)

</t>
<t tx="ekr.20090105132011.6">@nocolor-node

# *** match pat2 if not preceded by pat1::

(?&lt;!pat1)pat2

.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:

copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x

[]
    Used to indicate a set of characters. Characters can be listed individually,
    or a range of characters can be indicated by giving two characters and
    separating them by a '-'. Special characters are not active inside sets.

    [akm$] will match any of the characters 'a', 'k', 'm', or '$';
    [a-z] will match any lowercase letter.
    [a-zA-Z0-9] matches any letter or digit.

    Character classes such as \w or \S (defined below) are also
    acceptable inside a range, although the characters they match depends on
    whether LOCALE or UNICODE mode is in force. If you want to include a ']' or
    a '-' inside a set, precede it with a backslash, or place it as the first
    character. The pattern []] will match ']', for example.

    You can match the characters not within a range by complementing the set.
    This is indicated by including a '^' as the first character of the set; '^'
    elsewhere will simply match the '^' character. For example, [^5] will match
    any character except '5', and [^^] will match any character except '^'.

(?=...)
    Matches if ... matches next, but doesnt consume any of the string.
    This is called a lookahead assertion.
    For example, Isaac (?=Asimov) will match 'Isaac ' only if it's followed by 'Asimov'.

(?!...)
    Matches if ... doesn't match next.
    This is a negative lookahead assertion.
    For example, Isaac (?!Asimov) will match 'Isaac ' only if it is not followed by 'Asimov'.

(?&lt;=...)
    Matches if the current position in the string is preceded by a match for ...
    that ends at the current position. This is called a positive lookbehind assertion.
    The contained pattern must only match strings of some fixed length,
    meaning that abc or a|b are allowed, but a* and a{3,4} are not.
    
(?&lt;!...) Matches if the current position in the string is not preceded by a
    match for .... This is called a negative lookbehind assertion. Similar to
    positive lookbehind assertions, the contained pattern must only match
    strings of some fixed length. Patterns which start with negative lookbehind
    assertions may match at the beginning of the string being searched.</t>
<t tx="ekr.20090107113956.1">def vnode2position (self,v):

    '''Given a vnode v, construct a valid position p such that p.v = v.
    '''

    c = self
    context = v.context # v's commander.
    root = c.hiddenRootNode
    assert (c == context)

    stack = []
    while v.parents:
        parent = v.parents[0]
        if v in parent.children:
            n = parent.children.index(v)
        else:
            return None
        stack.insert(0,(v,n),)
        v = parent

    # v.parents includes the hidden root node.
    if not stack:
        # a vnode not in the tree
        return c.nullPosition()
    v,n = stack.pop()
    p = leoNodes.position(v,n,stack)
    return p

</t>
<t tx="ekr.20090110073010.1">def redraw (self,p=None,setFocus=False):
    '''Redraw the screen immediately.'''

    c = self
    if not p: p = c.p or c.rootPosition()

    c.expandAllAncestors(p)
    c.frame.tree.redraw(p)
    c.selectPosition(p)

    if setFocus: c.treeFocusHelper()

# Compatibility with old scripts
force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090110073010.2">def redraw_after_head_changed(self):

    '''Redraw the screen (if needed) when editing ends.
    This may be a do-nothing for some gui's.'''

    return self.frame.tree.redraw_after_head_changed()
</t>
<t tx="ekr.20090110073010.3">def redraw_after_icons_changed(self):

    '''Update the icon for the presently selected node,
    or all icons if the 'all' flag is true.'''

    c = self

    c.frame.tree.redraw_after_icons_changed()

    # c.treeFocusHelper()
</t>
<t tx="ekr.20090110073010.4">def redraw_after_select(self,p):

    '''Redraw the screen after node p has been selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(Commands)',p and p.h or '&lt;No p&gt;', g.callers(4))

    c = self

    flag = c.expandAllAncestors(p)
    if flag:
        c.frame.tree.redraw_after_select(p)
</t>
<t tx="ekr.20090110131802.2">def redraw_after_contract (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_contract(p)
        if setFocus: c.treeFocusHelper()
</t>
<t tx="ekr.20090112065525.1">def redraw_after_expand (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_expand(p)
        if setFocus: c.treeFocusHelper()
</t>
<t tx="ekr.20090121164439.6176">def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--path',dest='path')
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- path
    # We can't finalize the path here, because g does not exist ye.
    path = options.path or 'dynamicUnitTest.leo'

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = 'nullGui'

    # --silent
    silent = options.silent

    return path,gui,silent
</t>
<t tx="ekr.20090121164439.6177">def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('--gui',dest="gui")
    parser.add_option('--silent',action="store_true",dest="silent")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None

    # --silent
    silent = options.silent

    return gui,silent
</t>
<t tx="ekr.20090122201952.4">def appendStringToBody (self,p,s):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    if s:
        body = p.b
        assert(g.isUnicode(body))
        s = g.toUnicode(s,self.encoding)
        self.setBodyString(p,body + s)

def setBodyString (self,p,s):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    c = self.c ; v = p.v
    if not c or not p: return

    s = g.toUnicode(s,self.encoding)
    current = c.p
    if current and p.v==current.v:
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)

    # Keep the body text up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
</t>
<t tx="ekr.20090122201952.5"></t>
<t tx="ekr.20090122201952.6">def appendStringToBody (self,p,s):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s)

def setBodyString (self,p,s):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s)
</t>
<t tx="ekr.20090126063121.1">def editWidget (self,event):

    '''An override of baseEditCommands.editWidget

    that does *not* set focus when using anything other than the tk gui.

    This prevents this class from caching an edit widget
    that is about to be deallocated.'''

    c = self.c ; w = event and event.widget
    bodyCtrl = self.c.frame.body and self.c.frame.body.bodyCtrl

    # g.trace('isText',g.app.gui.isTextWidget(w),'w',w,g.app.gui.widget_name(w))

    if g.app.gui.guiName() == 'tkinter':

        # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
        if w and g.app.gui.isTextWidget(w):
            self.w = w
        else:
            self.w = bodyCtrl
        if self.w:
            c.widgetWantsFocusNow(self.w)
    else:
        # Do not cache a pointer to a headline!
        # It will die when the minibuffer is selected.
        self.w = bodyCtrl

    return self.w
</t>
<t tx="ekr.20090126063121.3">def createWxGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the wx gui class."""

    app = self

    app.pluginsController.loadOnePlugin ('leo.plugins.wxGui',verbose=verbose)

    if fileName and verbose:

        print('wxGui created in %s' % fileName)
</t>
<t tx="ekr.20090128083459.74"></t>
<t tx="ekr.20090128083459.75">def __get_b(self):

    p = self
    return p.bodyString()

def __set_b(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Don't redraw the screen: p.b must be fast.
        # c.redraw_after_icons_changed()

b = property(
    __get_b, __set_b,
    doc = "position body string property")
</t>
<t tx="ekr.20090128083459.76">def __get_h(self):

    p = self
    return p.headString()

def __set_h(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setHeadString(p,val)
        # Don't redraw the screen: p.h must be fast.
        # c.redraw_after_head_changed()

h = property(
    __get_h, __set_h,
    doc = "position headline string property")  
</t>
<t tx="ekr.20090128083459.82">class posList(list):
    &lt;&lt; docstring for posList &gt;&gt;
    def __init__ (self,c,aList=None):
        self.c = c
        list.__init__(self) # Init the base class
        if aList is None:
            for p in c.all_positions():
                self.append(p.copy())
        else:
            for p in aList:
                self.append(p.copy())

    def dump (self,sort=False,verbose=False):
        if verbose: return g.listToString(self,sort=sort)
        else: return g.listToString([p.h for p in self],sort=sort)

    def select(self,pat,regex=False,removeClones=True):
        '''Return a new posList containing all positions
        in self that match the given pattern.'''
        c = self.c ; aList = []
        if regex:
            for p in self:
                if re.match(pat,p.h):
                    aList.append(p.copy())
        else:
            for p in self:
                if p.h.find(pat) != -1:
                    aList.append(p.copy())
        if removeClones:
            aList = self.removeClones(aList)
        return posList(c,aList)

    def removeClones(self,aList):
        seen = {} ; aList2 = []
        for p in aList:
            if p.v not in seen:
                seen[p.v] = p.v
                aList2.append(p)
        return aList2
</t>
<t tx="ekr.20090130065000.1"></t>
<t tx="ekr.20090130114732.2">'''A subclass of list for creating and selecting lists of positions.

    This is deprecated, use leoNodes.poslist instead!

    aList = g.posList(c)
        # Creates a posList containing all positions in c.

    aList = g.posList(c,aList2)
        # Creates a posList from aList2.

    aList2 = aList.select(pattern,regex=False,removeClones=True)
        # Creates a posList containing all positions p in aList
        # such that p.h matches the pattern.
        # The pattern is a regular expression if regex is True.
        # if removeClones is True, all positions p2 are removed
        # if a position p is already in the list and p2.v == p.v.

    aList.dump(sort=False,verbose=False)
        # Prints all positions in aList, sorted if sort is True.
        # Prints p.h, or repr(p) if verbose is True.
'''
</t>
<t tx="ekr.20090130114732.5">def __get_b(self):

    v = self
    return v.bodyString()

def __set_b(self,val):

    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc = "vnode body string property")
</t>
<t tx="ekr.20090130114732.6">def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
</t>
<t tx="ekr.20090130125002.1">def __get_h(self):

    v = self
    return v.headString()

def __set_h(self,val):

    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc = "vnode headline string property")  
</t>
<t tx="ekr.20090130135126.1">def __get_p(self):

    c = self
    return c.currentPosition()

p = property(
    __get_p, # No setter.
    doc = "commander current position property")
</t>
<t tx="ekr.20090131200406.11">@nocolor-node

Eliminate all tk-indices from leoEditCommands.py

These are marked with ###

(found) wordend, wordstart
(found) lineend, linestart
(found) sel.first, sel.last
(found) w.insert, w.delete
</t>
<t tx="ekr.20090131200406.14"></t>
<t tx="ekr.20090131200406.15"></t>
<t tx="ekr.20090201152408.1">def printMacros (self,event=None):

    names = [z for z in self.namedMacros]
    g.es(''.join(names),tabName='Macros')
</t>
<t tx="ekr.20090202064534.4"></t>
<t tx="ekr.20090202191501.1">def createQtGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the Qt gui class."""

    app = self

    try:
        # Take care to try the same imports as in qtGui.py.
        import PyQt4.QtCore
        import PyQt4.QtGui            
        import leo.plugins.qtGui as qtGui
    except ImportError:
        qtGui = None

    if qtGui:
        qtGui.init()
        if app.gui and fileName and verbose:
            print('qtGui created in %s' % fileName)
</t>
<t tx="ekr.20090202191501.5">def createNullGui (self):

    # Don't import this at the top level:
    # it might interfere with Leo's startup logic.

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.gui = leoGui.nullGui("nullGui")
</t>
<t tx="ekr.20090204084607.1">def abortSearch (self):

    '''Restore the original position and selection.'''

    c = self.c ; k = self.k ; w = c.frame.body.bodyCtrl

    k.clearState()
    k.resetLabel()

    p,i,j,in_headline = self.stack[0]
    self.ifinder.in_headline = in_headline
    c.selectPosition(p)
    c.redraw_after_select(p)
    c.bodyWantsFocusNow()
    w.setSelectionRange(i,j)

    # g.trace(p.h,i,j)
</t>
<t tx="ekr.20090204084607.2">def iSearch (self,again=False):

    '''Handle the actual incremental search.'''

    c = self.c ; k = self.k ; p = c.p
    ifinder = self.ifinder
    reverse = not self.forward
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        return self.abortSearch()
    ifinder.c = c ; ifinder.p = p.copy()
    # Get the base ivars from the find tab.
    ifinder.update_ivars()
    # Save
    oldPattern = ifinder.find_text
    oldRegexp  = ifinder.pattern_match
    oldReverse = ifinder.reverse
    oldWord =  ifinder.whole_word
    # Override
    ifinder.pattern_match = self.regexp
    ifinder.reverse = reverse
    ifinder.find_text = pattern
    ifinder.whole_word = False # Word option can't be used!
    # Prepare the search.
    if len(self.stack) &lt;= 1: ifinder.in_headline = False
    w = self.setWidget()
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if again:   ins = g.choose(reverse,i,j+len(pattern))
    else:       ins = g.choose(reverse,j+len(pattern),i)
    ifinder.init_s_ctrl(s,ins)
    # Do the search!
    pos, newpos = ifinder.findNextMatch()
    # Restore.
    ifinder.find_text = oldPattern
    ifinder.pattern_match = oldRegexp
    ifinder.reverse = oldReverse
    ifinder.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None: # success.
        w = ifinder.showSuccess(pos,newpos,showState=False)
        if w: i,j = w.getSelectionRange(sort=False)
        # else: g.trace('****')
        if not again: self.push(c.p,i,j,ifinder.in_headline)
    elif ifinder.wrapping:
        g.es("end of wrapped search")
    else:
        g.es("not found","'%s'" % (pattern))
        event = g.Bunch(char='\b',keysym='\b',stroke='BackSpace')
        k.updateLabel(event)
</t>
<t tx="ekr.20090204084607.4">def iSearchBackspace (self):

    trace = False and not g.unitTesting
    c = self.c ; ifinder = self.ifinder

    if len(self.stack) &lt;= 1:
        self.abortSearch()
        return

    # Reduce the stack by net 1.
    junk = self.pop()
    p,i,j,in_headline = self.pop()
    self.push(p,i,j,in_headline)
    if trace: g.trace(p.h,i,j,in_headline)

    if in_headline:
        # Like ifinder.showSuccess.
        selection = i,j,i
        c.redrawAndEdit(p,selectAll=False,
            selection=selection,
            keepMinibuffer=True)
    else:
        c.selectPosition(p)
        w = c.frame.body.bodyCtrl
        c.bodyWantsFocusNow()
        if i &gt; j: i,j = j,i
        w.setSelectionRange(i,j)

    if len(self.stack) &lt;= 1:
        self.abortSearch()



</t>
<t tx="ekr.20090204084607.5">def push (self,p,i,j,in_headline):

    data = p.copy(),i,j,in_headline
    self.stack.append(data)

def pop (self):

    data = self.stack.pop()
    p,i,j,in_headline = data
    return p,i,j,in_headline
</t>
<t tx="ekr.20090204084607.6">def getStrokes (self,commandName):

    c = self.c

    aList = self.inverseBindingDict.get(commandName,[])
    return [key for pane,key in aList]
</t>
<t tx="ekr.20090205085858.1">def setWidget (self):

    c = self.c ; p = c.currentPosition()
    bodyCtrl = c.frame.body.bodyCtrl
    ifinder = self.ifinder

    if ifinder.in_headline:
        w = c.edit_widget(p)
        if not w:
            # Selecting the minibuffer can kill the edit widget.
            selection = 0,0,0
            c.redrawAndEdit(p,selectAll=False,
                selection=selection,keepMinibuffer=True)
            w = c.edit_widget(p)
        if not w: # Should never happen.
            g.trace('**** no edit widget!')
            ifinder.in_headline = False ; w = bodyCtrl
    else:
        w = bodyCtrl
    if w == bodyCtrl:
        c.bodyWantsFocusNow()
    return w
</t>
<t tx="ekr.20090210093316.1"></t>
<t tx="ekr.20090212054250.9">def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
</t>
<t tx="ekr.20090213065933.14">def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20090213065933.6">def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self
    c.autoindent_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    c.contractVisitedNodes  = c.config.getBool('contractVisitedNodes')
    c.fixed                 = c.config.getBool('fixedWindow',default=False)
    c.fixedWindowPosition   = c.config.getData('fixedWindowPosition')
    c.showMinibuffer        = c.config.getBool('useMinibuffer')
        # This option is a bad idea.
    c.putBitsFlag           = c.config.getBool('put_expansion_bits_in_leo_files',default=True)
    # g.trace('putBitsFlag',c.putBitsFlag,c.fileName())
    c.sparse_move           = c.config.getBool('sparse_move_outline_left')
    c.sparse_find           = c.config.getBool('collapse_nodes_during_finds')
    c.sparce_spell          = c.config.getBool('collapse_nodes_while_spelling')
    c.stayInTree            = c.config.getBool('stayInTreeAfterSelect')
    c.smart_tab             = c.config.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = c.config.getInt('tab_width') or -4

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
</t>
<t tx="ekr.20090213065933.7">def setWindowPosition (self):

    c = self

    # g.trace(c.fixed,c.fixedWindowPosition)

    if c.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            c.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition),color='red')
    else:
        c.windowPosition = 500,700,50,50 # width,height,left,top.
</t>
<t tx="ekr.20090214075058.10">def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    if 0: # 2010/02/01
        # The code never this, and this regex is broken
        # because it can confuse g.get_directives_dict.
        # @others can have leading whitespace.
        aList.append(r'^\s@others\s')

    return '|'.join(aList)
</t>
<t tx="ekr.20090214075058.6">g_language_pat = re.compile(r'(^@language)',re.MULTILINE)

def findLanguageDirectives(c,p):

    '''Return the language in effect at position p.'''

    trace = False and not g.unitTesting

    if c is None:
        return # c may be None for testing. 
    if c.target_language:
        language = c.target_language.lower()
    else:
        language = 'python'
    found = False
    # 2009/10/02: no need for copy arg to iter.
    for p in p.self_and_parents():
        if found: break
        for s in p.h,p.b:
            if found: break
            anIter = g_language_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = i + len(word)
                k = g.skip_line(s,j)
                language = s[j:k].strip()
                found = True

    if trace: g.trace(language)
    return language
</t>
<t tx="ekr.20090214075058.8">g_tabwidth_pat = re.compile(r'(^@tabwidth)',re.MULTILINE)

def findTabWidthDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None:
        return # c may be None for testing.

    w = None
    # 2009/10/02: no need for copy arg to iter
    for p in p.self_and_parents():
        if w: break
        for s in p.h,p.b:
            if w: break
            anIter = g_tabwidth_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = g.skip_ws(s,i + len(word))
                junk,w = g.skip_long(s,j)
                if w == 0: w = None
    return w
</t>
<t tx="ekr.20090214075058.9"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('&lt;'+'&lt;'+'*'+'&gt;'+'&gt;'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive"""

    trace = False and not g.unitTesting
    verbose = False
    if trace: g.trace('*'*20,p.h)

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('head',p.h),('body',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if j &lt; len(s) and s[j] not in (' ','\t','\n'):
                    # g.es_print('invalid character after directive',s[max(0,i-1):k-1],color='red')
                    # if trace:g.trace(word,repr(val),s[i:i+20])
                    pass # Not a valid directive: just ignore it.
                else:
                    directive_word = word.strip()
                    if directive_word in ('root-doc', 'root-code'):
                        d['root'] = val # in addition to optioned version
                    d[directive_word] = val
                    if trace: g.trace(word.strip(),kind,repr(val))
                    # A special case for @path in the body text of @&lt;file&gt; nodes.
                    # Don't give an actual warning: just set some flags.
                    if kind == 'body' and word.strip() == 'path' and p.isAnyAtFileNode():
                        g.app.atPathInBodyWarning = p.h
                        d['@path_in_body'] = p.h
                        if trace: g.trace('@path in body',p.h)

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= may only occur in a topmost node (i.e., without a parent)' % (
                    g.angleBrackets('*')))
            break

    if trace and verbose: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
</t>
<t tx="ekr.20090215165030.1">def __get_gnx(self):
    v = self
    return g.app.nodeIndices.toString(v.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "vnode gnx property")
</t>
<t tx="ekr.20090215165030.3">def __get_gnx(self):
    p = self
    return g.app.nodeIndices.toString(p.v.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "position gnx property")
</t>
<t tx="ekr.20090218115025.3">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

&gt; On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney &lt;ktenney@gmail.com&gt; wrote:
&gt;&gt;
&gt;&gt; Currently, Leo pickles the value of unknown attributes unless
&gt;&gt; the name starts with 'str_'
&gt;&gt;
&gt;&gt; Running the following code in node 'UA'
&gt;&gt;
&gt;&gt; p = c.currentPosition()
&gt;&gt; p.v.u = {'hello':'world', 'str_hello':'world'}
&gt;&gt;
&gt;&gt; results in the following in the .leo file:
&gt;&gt;
&gt;&gt; &lt;v t="ktenney.20090218114928.367" str_hello="world"
&gt;&gt; hello="5505776f726c6471002e"&gt;&lt;vh&gt;UA&lt;/vh&gt;&lt;/v&gt;
&gt;&gt;
&gt;&gt; I think this is surprising, Python-centric and contrary to the
&gt;&gt; spirit of Leo as a flexible data management platform.
&gt;
&gt; I suppose your point is that you can't create an arbitrarily named attribute
&gt; with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

&gt; As far as being Python-centric, can you suggest any other way of converting
&gt; arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

&gt; Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
</t>
<t tx="ekr.20090218115025.4"></t>
<t tx="ekr.20090218115025.5">def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    # self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.gnxDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
    self.vnodesDict = {}
        # keys are gnx strings; values are ignored
</t>
<t tx="ekr.20090225080846.3">def readOneAtEditNode (self,fn,p):

    at = self ; c = at.c ; ic = c.importCommands
    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    junk,ext = g.os_path_splitext(fn)

    # 2010/7/28: Remember that we have seen the @edit node.
    p.v.at_read = True # Create the attribute

    if not g.unitTesting:
        g.es("reading @edit:", g.shortFileName(fn))

    s,e = g.readFileIntoString(fn,kind='@edit')
    if s is None: return
    encoding = g.choose(e is None,'utf-8',e)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html','.htm'):   head = '@language html\n'
    elif ext in ('.txt','.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor\n'

    p.b = g.u(head) + g.toUnicode(s,encoding=encoding,reportErrors='True')

    if not changed: c.setChanged(False)
    g.doHook('after-edit',p=p)
</t>
<t tx="ekr.20090225080846.5">def writeOneAtEditNode(self,p,toString,force=False):

    '''Write one @edit node.'''

    at = self ; c = at.c ; root = p.copy()
    c.endEditing()

    fn = p.atEditNodeName()
    if not fn and not toString: return False

    if p.hasChildren():
        g.es('@edit nodes must not have children',color='red')
        g.es('To save your work, convert @edit to @auto or @thin')
        return False

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fn = c.os_path_finalize_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)
    if not hasattr(root.v,'at_read') and exists:
        # Prompt if writing a new @edit node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fn,kind='@edit')
        if ok:
            root.v.at_read = True # Create the attribute for all clones.
        else:
            g.es("not written:",fn)
            return False

    at.targetFileName = fn
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True, atEdit=True,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=toString)

    # Compute the file's contents.
    # Unlike the @nosent file logic it does not add a final newline.
    contents = ''.join([s for s in g.splitLines(p.b)
        if at.directiveKind4(s,0) == at.noDirective])

    if toString:
        at.stringOutput = contents
        return True

    ok = at.openFileForWriting(root,fileName=fn,toString=False)
    if ok:
        self.os(contents)
        at.closeWriteFile()
    if ok and at.errors == 0:
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    else:
        g.es("not written:",at.targetFileName) # 2010/10/22
        root.setDirty()
        root.setOrphan() # 2010/10/22

    return ok
</t>
<t tx="ekr.20090226080753.8">def pdb (self,event=None):

    g.pdb()
</t>
<t tx="ekr.20090306060344.2">def selectChapterByNameHelper (self,chapter,collapse=True):

    cc = self ; c = cc.c

    if chapter != cc.selectedChapter:
        if cc.selectedChapter:
            cc.selectedChapter.unselect()
        chapter.select()
        c.setCurrentPosition(chapter.p)
        cc.selectedChapter = chapter

        # New in Leo 4.6 b2: clean up, but not initially.
        if collapse and chapter.name == 'main':
            for p in c.all_unique_positions():
                # 2010/01/26: compare vnodes, not positions.
                if p.v != c.p.v:
                    p.contract()

        # New in Leo 4.6 b2: *do* call c.redraw.
        c.redraw()
</t>
<t tx="ekr.20090320055710.4">def toPythonIndexRowCol(self,index):

    w = self
    s = w.getAllText()
    i = w.toPythonIndex(index)
    row,col = g.convertPythonIndexToRowCol(s,i)
    return i,row,col
</t>
<t tx="ekr.20090402072059.13">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/4ec30df3f1db8db3

On Sat, Mar 28, 2009 at 3:24 AM, VR &lt;viktor.ransmayr@gmail.com&gt; wrote:


    When I tried to de-install Leo-4.6b1 I succeeded, but the program
    reported that 5 directories
    were not removed.

    Three of the directories where

    1) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\config
    2) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\doc
    3) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\plugins

    [containing]


    a) .leoSettings.leo_db
    b) .leoDocs.leo_db
    c) .leo_shadow
    d) .leoPluginsRef.leo_db


Thanks for this report. I think it is important, and needs a good solution.

I dislike all these files being sprayed around the file system. I'd like to see
these files placed somewhere the ~/.leo directory. Is there a reason why this
would be a bad idea?

Similarly, we might also prefer to have shadow files place in, say,
~/.leo/shadow_files.

In both cases, I think we want to create files that indicate their location.
Either that, or mirror their location in (subdirectories) ~/.leo. In other
words, this is a general problem, and it would be good to have a robust, general
solution.
</t>
<t tx="ekr.20090402072059.2">@

First do a normal clone-find-all for the word "clone". Then click the script
button and do it again. Notice that children of previously found nodes don't get
added again in the modified version.
</t>
<t tx="ekr.20090402072059.4">import leo.core.leoFind as leoFind 

def new_find_all(self):
    &lt;&lt; do some initial stuff &gt;&gt;


    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break

        if count % 10 == 0 and count &gt; 0:
            g.es("still searching, matches found: ", count)

        &lt;&lt; Skip node if it's a child of a previously found node &gt;&gt;

        count += 1

        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                &lt;&lt; create the found node &gt;&gt;
            clones.append(self.p.v.t)
            positions.append(self.p)
            &lt;&lt; create a clone of p under the find node &gt;&gt;

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")


leoFind.leoFind.findAll = new_find_all

c.executeMinibufferCommand("clone-find-all") 
</t>
<t tx="ekr.20090402072059.5">g.es("findAll..., self: ", self)

c = self.c ; w = self.s_ctrl ; u = c.undoer
undoType = 'Clone Find All'
if not self.checkArgs():
    return
self.initInHeadline()
if self.clone_find_all:
    self.p = None # Restore will select the root position.
data = self.save()
self.initBatchCommands()
count = 0 ; clones = []; positions = []
</t>
<t tx="ekr.20090402072059.6">oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
</t>
<t tx="ekr.20090402072059.7">q = self.p.clone()
q.moveToLastChildOf(found)
</t>
<t tx="ekr.20090402072059.8">&lt;&lt; def: is a child of b &gt;&gt;

is_child_of_previous = False
for previously_found in positions:
    if is_a_child_of_b(self.p, previously_found):
        is_child_of_previous = True
        break

if is_child_of_previous:
    continue
</t>
<t tx="ekr.20090402072059.9">
def is_a_child_of_b(a, b):
    for child in b.children_iter():
        if a.t == child.t:
            return True
        if is_a_child_of_b(a, child):
            return True
    return False
</t>
<t tx="ekr.20090501095634.41">class rstScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20090501095634.42">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='rest')

    # Scanner overrides
    self.atAutoWarnsAboutLeadingWhitespace = True
    self.blockDelim1 = self.blockDelim2 = None
    self.classTags = []
    self.escapeSectionRefs = False
    self.functionSpelling = 'section'
    self.functionTags = []
    self.hasClasses = False
    self.isRst = True
    self.lineCommentDelim = '..'
    self.outerBlockDelim1 = None
    self.sigFailTokens = []
    self.strict = False # Mismatches in leading whitespace are irrelevant.

    # Ivars unique to rst scanning &amp; code generation.
    self.lastParent = None # The previous parent.
    self.lastSectionLevel = 0 # The section level of previous section.
    self.sectionLevel = 0 # The section level of the just-parsed section.
    self.underlineCh = '' # The underlining character of the last-parsed section.
    self.underlines = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~" # valid rst underlines.
    self.underlines1 = [] # Underlining characters for underlines.
    self.underlines2 = [] # Underlining characters for over/underlines.
</t>
<t tx="ekr.20090501095634.45">def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts an rST section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = True
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i &lt; len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i &gt; progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
</t>
<t tx="ekr.20090501095634.46">def isUnderLine(self,s):

    '''Return True if s consists of only the same rST underline character.'''

    if not s: return False
    ch1 = s[0]

    if not ch1 in self.underlines:
        return False

    for ch in s:
        if ch != ch1:
            return False

    return True
</t>
<t tx="ekr.20090501095634.47">def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    verbose = False

    # Under/overlines can not begin with whitespace.
    i1,j,nows,line = self.getLine(s,i)
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j,nows,line2 = self.getLine(s,next_i)
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 &gt;= n2 and n2 &gt; 0 and n3 &gt;= n2 and ch1 == ch3)
        if ok:
            i += n3
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                if trace: g.trace('*** underlines2',self.underlines2,name)
            if trace and verbose:
                g.trace('\nline  %s\nname  %s\nline2 %s' % (
                    repr(line),repr(name),repr(line2))) #,'\n',g.callers(4))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j,nows2,line2 = self.getLine(s,i)
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4,nows4,line4 = self.getLine(s,j3)
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 &gt; 0 and n2 &gt;= n3 and n4 &gt;= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 &gt; 0 and n2 &gt;= n1)
        if ok:
            old_i = i
            i += n2
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                if trace: g.trace('*** underlines1',self.underlines1,name)
            if trace and verbose: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2))) # ,'\n',g.callers(4))
    return kind,name,i,ch
</t>
<t tx="ekr.20090501095634.48">def scanRstText (self,s,parent,atAuto=False):

    scanner = rstScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20090501095634.50"># These do not affect parsing.

def startsComment (self,s,i):
    return False

def startsID (self,s,i):
    return False

def startsString (self,s,i):
    return False
</t>
<t tx="ekr.20090502071837.1">def endGen (self,s):

    '''Do any language-specific post-processing.'''
    pass
</t>
<t tx="ekr.20090502071837.100">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        # g.trace('before',p.h,attr)
        # if bwm_file:
            # print &gt;&gt; bwm_file
            # print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            # pprint.pprint((p, attr), bwm_file)
        http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        # if bwm_file:
            # print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            # pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            # if bwm_file: 
                # print &gt;&gt; bwm_file, "relocate_references(3): line:", line,
                # "Column:", column, "href:", href, "href_file:",
                # href_file, "http_node_ref:", http_node_ref
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                # replacement = u"%s#%s" % (http_node_ref,marker)
                replacement = '%s#%s' % (http_node_ref,marker)
                try:
                    # attr [line + 2] = attr [line + 2].replace(u'href="%s"' % href, u'href="%s"' % replacement)
                    attr [line + 2] = attr [line + 2].replace('href="%s"' % href, 'href="%s"' % replacement)
                except:
                    g.es("Skipped ", attr[line + 2])
            else:
                filename = marker_parts [0]
                try:
                    # attr [line + 2] = attr [line + 2].replace(u'href="%s"' % href,u'href="%s"' % http_node_ref)
                    attr [line + 2] = attr [line + 2].replace('href="%s"' % href,'href="%s"' % http_node_ref)
                except:
                    g.es("Skipped", attr[line+2])
    # g.trace('after %s\n\n\n',attr)
</t>
<t tx="ekr.20090502071837.101">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20090502071837.102">def getPublicCommands (self):        

    c = self.c

    return {
        'rst3': self.rst3, # Formerly write-restructured-text.
        'code-to-rst': self.code_to_rst_command,
    }
</t>
<t tx="ekr.20090502071837.103">@nocolor

These are projects that3 I'd like to follow up on.

Scripts--&gt;@thin leoScripts.txt--&gt;Others--&gt;
Call hierarchy tracing (using python 'trace' module)

- autosphinx.py plugin
  http://groups.google.com/group/leo-editor/browse_thread/thread/f292f7c9f2fd66d8
  bzr branch lp:~villemvainio/leo-editor/autosphinx 

- Caliopy: integrate Leo with many scientific computing tools.
  http://www.caliopywork.org/

- Clone digger: find similar code
  http://clonedigger.sourceforge.net/

- Fuse (pyfuse) Leo as a file system.
  http://leo.zwiki.org/LeoAsAFileSystem

- Google wave: 
  http://wave.google.com/

- Thread: Leo forum proof of concept:
  A few buttons turns Leo into a competitor for google groups :-)
  http://groups.google.com/group/leo-editor/browse_thread/thread/db6e75d82da4b41d

- Manuel: rST testing tool
  http://pypi.python.org/pypi/manuel/1.0.0a3
  Manuel parses documents, evaluates their contents,
  then formats the result of the evaluation.

- objtrees: object trees for unit testing
  http://groups.google.com/group/leo-editor/browse_thread/thread/32c3a295d2dae35b

- pexpect: a Python module for spawning child applications and
  controlling them automatically. 
  http://pexpect.sourceforge.net/pexpect.html

- Pyjamas: AJAX tool kit.
  http://pyjs.org/

- Pysmell: python IDE completion helper.
  http://code.google.com/p/pysmell/

- pythoscope: create unit tests automatically.
  http://pythoscope.org/

- rope: Python refactoring library.
  http://rope.sourceforge.net/

- rst2a: a web service that converts reStructuredText to pdf or other formats.
  http://rst2a.com/

- Tomboy: wiki-like notes
  http://projects.gnome.org/tomboy/index.html
  http://groups.google.com/group/leo-editor/browse_thread/thread/18d4af19686f2ead
</t>
<t tx="ekr.20090502071837.12">def code_block (name,arguments,options,
    content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}
</t>
<t tx="ekr.20090502071837.2">def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    trace = False and not g.unitTesting
    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        if trace: g.trace(repr(underlines1),repr(underlines2),g.callers(4))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
</t>
<t tx="ekr.20090502071837.3">&lt;&lt; docstring &gt;&gt;

if 0:
    bwm_file = open("bwm_file", "w")

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ekr.20090502071837.33">@ This plugin optionally stores information for the http plugin. Each node can
have one additional attribute, with the name rst_http_attributename, which is a
list. The first three elements are stack of tags, the rest is html code::

    [&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure::

    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

class rstCommands:

    '''A class to write rst markup in Leo outlines.'''

    @others
</t>
<t tx="ekr.20090502071837.34"></t>
<t tx="ekr.20090502071837.35">def __init__ (self,c):

    global SilverCity

    # g.trace(c)
    self.c = c
    &lt;&lt; init ivars &gt;&gt;
    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
</t>
<t tx="ekr.20090502071837.36">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.scriptSettingsDict = {} # 2010/08/12: for format-code command.

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.topLevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {} 
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.atAutoWrite = False # True, special cases for writeAtAutoFile.
self.atAutoWriteUnderlines = '' # Forced underlines for writeAtAutoFile.
self.leoDirectivesList = g.globalDirectiveList
self.encoding = 'utf-8'
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
self.trialWrite = False # True if doing a trialWrite.
</t>
<t tx="ekr.20090502071837.38">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        '@rst',
        '@rst-code',
        '@rst-default-path',
        '@rst-doc-only',
        '@rst-head',
        '@rst-ignore-node',
        '@rst-ignore-tree',
        '@rst-no-head',
        '@rst-no-headlines',
        '@rst-option',
        '@rst-options',
    ]
</t>
<t tx="ekr.20090502071837.39">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20090502071837.4">'''Support for restructured text (rST), adapted from rst3 plugin.

For full documentation, see:
http://webpages.charter.net/edreamleo/rstplugin3.html

To generate documents from rST files, Python's docutils_ module must be
installed. The code will use the SilverCity_ syntax coloring package if is is
available.'''
</t>
<t tx="ekr.20090502071837.40">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = g.choose(name.startswith('rst'),3,0)

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20090502071837.41"></t>
<t tx="ekr.20090502071837.42">def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
</t>
<t tx="ekr.20090502071837.43">def dumpSettings (self):

    d = self.optionsDict
    keys = sorted(d)

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20090502071837.44">def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    # g.trace(name,self.optionsDict.get(self.munge(name)))
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag):

    self.optionsDict [self.munge(name)] = val
</t>
<t tx="ekr.20090502071837.45">def initCodeBlockString(self,p):

    trace = False and not g.unitTesting
    c = self.c
    # if trace: os.system('cls')
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None: language = 'python'
    else: language = language.lower()
    syntax = SilverCity is not None

    if trace: g.trace('language',language,'language.title()',language.title(),p.h)

    # Note: lines that end with '\n\n' are a signal to handleCodeMode.
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n\n' % (
            language.title())
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n\n'
</t>
<t tx="ekr.20090502071837.46">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20090502071837.47">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20090502071837.48">def parseOptionLine (self,s):

    '''Parse a line containing name=val and return (name,value) or None.

    If no value is found, default to True.'''

    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name: return None
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        # g.trace(val)
        return name,val
    else:
        # g.trace('*True')
        return name,'True'
</t>
<t tx="ekr.20090502071837.49">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20090502071837.50">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,'@rst-option'):
        s = h [len('@rst-option'):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,'@rst-options'):
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for option,ivar,val in (
            ('@rst',                'code_mode',False),
            ('@rst-code',           'code_mode',True),
            ('@rst-default-path',   'default_prefix',''),
            ('@rst-doc-only',       'doc_only_mode',True),
            ('@rst-head',           'show_this_headline',True),
            # ('@rst-head' ,        'show_headlines',False),
            ('@rst-ignore',         'ignore_this_tree',True),
            ('@rst-ignore-node',    'ignore_this_node',True),
            ('@rst-ignore-tree',    'ignore_this_tree',True),
            ('@rst-no-head',        'ignore_this_headline',True),
            ('@rst-preformat',      'preformat_this_node',True),
        ):
            if word == option:
                d = { ivar: val }
                # Special case: code mode and doc-only modes are linked.
                if ivar == 'code_mode':
                    d ['doc_only_mode'] = False
                elif ivar == 'doc_only_mode':
                    d ['code_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == '@rst':
                    d ['ignore_this_headline'] = True
                # g.trace(repr(h),d)
                return d

        if h.startswith('@rst'):
            g.trace('unknown kind of @rst headline',p.h,g.callers(4))

        return {}
</t>
<t tx="ekr.20090502071837.51">def scanNodeForOptions (self,p):

    '''Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.'''

    h = p.h

    d = self.scanHeadlineForOptions(p)

    d2 = self.scanForOptionDocParts(p,p.b)

    # A fine point: body options over-ride headline options.
    d.update(d2)

    return d
</t>
<t tx="ekr.20090502071837.52">def scanOption (self,p,s):

    '''Return { name:val } if s is a line of the form name=val.
    Otherwise return {}'''

    if not s.strip() or s.strip().startswith('..'): return {}

    data = self.parseOptionLine(s)

    if data:
        name,val = data
        if self.munge(name) in list(self.defaultOptionsDict.keys()):
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
            return { self.munge(name): val }
        else:
            g.es_print('ignoring unknown option: %s' % (name),color='red')
            return {}
    else:
        g.trace(repr(s))
        s2 = 'bad rst3 option in %s: %s' % (p.h,s)
        g.es_print(s2,color='red')
        return {}
</t>
<t tx="ekr.20090502071837.53">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20090502071837.54"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings() # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

    # g.trace('-'*20)
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        # g.trace(p.h,d)
        for key in d.keys():
            ivar = self.munge(key)
            if not ivar in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)

    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20090502071837.55">def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
</t>
<t tx="ekr.20090502071837.56">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        #g.trace('%24s %8s %s' % (ivar,val,p.h))
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20090502071837.58"></t>
<t tx="ekr.20090502071837.59"></t>
<t tx="ekr.20090502071837.60">def init_write (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c

    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or 'utf-8'
    self.path = d.get('path') or ''

    # g.trace('path:',self.path)
</t>
<t tx="ekr.20090502071837.62">def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    # This strange looking code looks up and down the tree for @rst nodes.
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
        elif h.startswith('@slides'):
            self.processTree(p,ext=None,toString=False,justOneFile=False)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')
</t>
<t tx="ekr.20090502071837.63">def processTree(self,p,ext=None,toString=False,justOneFile=False):

    '''Process all @rst nodes in a tree.
    ext is the docutils extention: it's useful for scripts and unit tests.
    '''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            fn = h[4:].strip()
            if ((fn and fn[0] != '-') or (toString and not fn)):
                found = True
                self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        elif g.match(h,0,"@slides"):
            self.write_slides(p)
            found = True
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst or @slides nodes in selected tree',color='blue')
    return None,None
</t>
<t tx="ekr.20090502071837.64">def write_rst_tree (self,p,ext,fn,toString=False,justOneFile=False):

    '''Convert p's tree to rst sources.
    Optionally call docutils to convert rst to output.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    c = self.c
    self.topNode = p.copy()
    self.topLevel = p.level()
    if toString:
        ext = ext or '.html' # 2010/08/12: Unit test found this.
    else:
        junk,ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext.startswith('.'): ext = '.' + ext

    # Init options...
    self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')

    # Write the rst sources to self.source.
    self.outputFile = StringIO()
    self.writeTree(p,fn)
    self.source = self.outputFile.getvalue() # the rST sources.
    self.outputFile = None
    self.stringOutput = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
</t>
<t tx="ekr.20090502071837.65">def writeToDocutils (self,s,ext):

    '''Send s to docutils using the writer implied by ext and return the result.'''

    trace = False and not g.unitTesting

    if not docutils:
        g.es('docutils not present',color='red')
        return None

    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext2,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if ext2 == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (ext),color='red')
        return ''

    if ext in ('.html','.htm') and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        rel_path = rel_path.replace('\\','/') # 2010/01/28
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
        if g.isBytes(result):
            result = g.toUnicode(result)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
</t>
<t tx="ekr.20090502071837.66">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 &lt; cm &lt; eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm+1:].strip()
        else: # key = val
            key = s[:eq].strip()
            s = s[eq+1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[:rb+1]
                s = s[rb+1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm+1:].strip()

        # g.trace('key',repr(key),'val',repr(val),'s',repr(s))
        if not key: break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)

    return d
</t>
<t tx="ekr.20090502071837.67">def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns (p, s), where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20090502071837.68">def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20090502071837.69">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20090502071837.70">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20090502071837.71">def writeBody (self,p):

    # g.trace(p.h,p.b)

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
</t>
<t tx="ekr.20090502071837.72">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
</t>
<t tx="ekr.20090502071837.73">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20090502071837.74">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20090502071837.75">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20090502071837.76">def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20090502071837.77">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20090502071837.78">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    # g.trace('kind %s, result %s, s %s' % (
        # repr(kind),result,repr(s)))

    return result
</t>
<t tx="ekr.20090502071837.79">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20090502071837.80">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20090502071837.81">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20090502071837.82">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20090502071837.83">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20090502071837.84">def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for these...
        if word in (
            '@rst-option','@rst-options',
            '@rst-no-head','@rst-no-headlines'
        ):
            return

        # Remove all other headline commands from the headline.
        for command in self.headlineCommands:
            if word == command:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20090502071837.85">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20090502071837.86">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20090502071837.87">def writeTree(self,p,fn):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % fn))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
</t>
<t tx="ekr.20090502071837.88"></t>
<t tx="ekr.20090502071837.89">def computeOutputFileName (self,fn):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')

    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fn)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fn)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fn)
    else:
        path = g.os_path_finalize_join(fn)

    # g.trace('openDirectory %s\ndefault_path %s\npath %s' % (
        # repr(openDirectory),repr(default_path),repr(path)))

    return path
</t>
<t tx="ekr.20090502071837.90">def encode (self,s):

    # g.trace(self.encoding)

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20090502071837.91">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.es_print('wrote: %s' % (name),color="blue")
</t>
<t tx="ekr.20090502071837.92">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20090502071837.93">def underline (self,s,p):

    '''Return the underlining string to be used at the given level for string s.
    This includes the headline, and possibly a leading overlining line.
    '''

    trace = False and not g.unitTesting

    if self.atAutoWrite:
        # We *might* generate overlines for top-level sections.
        u = self.atAutoWriteUnderlines
        level = p.level()-self.topLevel

        if trace: g.trace('level: %s under2: %s under1: %s %s' % (
            level,repr(self.underlines2),repr(self.underlines1),p.h))

        # This is tricky. The index n depends on several factors.
        if self.underlines2:
            level -= 1 # There *is* a double-underlined section.
            n = level
        else:
            n = level-1

        if 0 &lt;= n &lt; len(u):
            ch = u[n]
        elif u:
            ch = u[-1]
        else:
            g.trace('can not happen: no u')
            ch = '#'

        # 2010/01/10: write longer underlines for non-ascii characters.
        n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        if level == 0 and self.underlines2:
            return '%s\n%s\n%s\n\n' % (ch*n,p.h,ch*n)
        else:
            return '%s\n%s\n\n' % (p.h,ch*n)
    else:
        # The user is responsible for top-level overlining.
        u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
        level = max(0,p.level()-self.topLevel)
        level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
        ch = u [level]
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
        # return '%s\n%s\n\n' % (p.h.strip(),ch*n)
        return '%s\n%s\n\n' % (s.strip(),ch*n)
            # Fixes bug 618570:
</t>
<t tx="ekr.20090502071837.94">def write (self,s,theFile=None):

    if theFile is None:
        theFile = self.outputFile

    if g.isPython3:
        if g.is_binary_file(theFile):
            s = self.encode(s)
    else:
        s = self.encode(s)

    theFile.write(s)
</t>
<t tx="ekr.20090502071837.96">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        # if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20090502071837.97"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.es_print('html updated for http plugin',color="blue")

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20090502071837.98">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20090502071837.99">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        # g.trace(pprint.pprint(html))
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            # bwm: changed to unicode(line)
            except:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)        
    # g.trace(g.dictToString(self.anchor_map,tag='anchor_map'))
</t>
<t tx="ekr.20090511055302.5792">def finishCreate(self):

    c = self.c
    d = self.getPublicCommands()
    c.commandsDict.update(d)
</t>
<t tx="ekr.20090511055302.5793">def rst3 (self,event=None):

    '''Write all @rst nodes.'''

    self.processTopTree(self.c.p)
</t>
<t tx="ekr.20090512080015.5797">def computeSectionLevel (self,ch,kind):

    '''Return the section level of the underlining character ch.'''

    # Can't use g.choose here.
    if kind == 'over':
        assert ch in self.underlines2
        level = 0
    else:
        level = 1 + self.underlines1.index(ch)

    if False:
        g.trace('level: %s kind: %s ch: %s under2: %s under1: %s' % (
            level,kind,ch,self.underlines2,self.underlines1))

    return level
</t>
<t tx="ekr.20090512080015.5798">def adjustParent (self,parent,headline):

    '''Return the proper parent of the new node.'''

    trace = False and not g.unitTesting

    level,lastLevel = self.sectionLevel,self.lastSectionLevel
    lastParent = self.lastParent

    if trace: g.trace('**entry level: %s lastLevel: %s lastParent: %s' % (
        level,lastLevel,lastParent and lastParent.h or '&lt;none&gt;'))

    if self.lastParent:

        if level &lt;= lastLevel:
            parent = lastParent.parent()
            while level &lt; lastLevel:
                level += 1
                parent = parent.parent()
        else: # level &gt; lastLevel.
            level -= 1
            parent = lastParent
            while level &gt; lastLevel:
                level -= 1
                h2 = '@rst-no-head %s' % headline
                body = ''
                parent = self.createFunctionNode(h2,body,parent)

    else:
        assert self.root
        self.lastParent = self.root

    if not parent: parent = self.root

    if trace: g.trace('level %s lastLevel %s %s returns %s' % (
        level,lastLevel,headline,parent.h))

    #self.lastSectionLevel = self.sectionLevel
    self.lastParent = parent.copy()
    return parent.copy()
</t>
<t tx="ekr.20090512080015.5800">def adjustParent (self,parent,headline):

    '''Return the effective parent.

    This is overridden by the rstScanner class.'''

    return parent
</t>
<t tx="ekr.20090512153903.5803">def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
</t>
<t tx="ekr.20090512153903.5806">def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start &gt; 0 and s[start-1] in (' ','\t'):
            start -= 1

    # g.trace(repr(s[sigStart:codeEnd]))

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

        # g.trace(repr(s[sigStart:codeEnd]))
        # g.pdb()

    return body
</t>
<t tx="ekr.20090512153903.5810">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '@rst-no-head %s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20090513073632.5733">def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.init_write(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) &gt; 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:&gt;&lt;_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
</t>
<t tx="ekr.20090513073632.5735">def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 &gt;= 2 and n2 &gt;= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
</t>
<t tx="ekr.20090513073632.5737">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '%s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20090514072254.5746">def runUnitTestLeoFile (gui='qt',path='unitTest.leo',silent=True):

    '''Run all unit tests in path (a .leo file) in a pristine environment.'''

    # New in Leo 4.5: leoDynamicTest.py is in the leo/core folder.
    trace = False
    path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
    leo  = g.os_path_finalize_join(g.app.loadDir,'..','core','leoDynamicTest.py')

    if sys.platform.startswith('win'): 
        if ' ' in leo: leo = '"' + leo + '"'
        if ' ' in path: path = '"' + path + '"'

    guiArg = '--gui=%s' % gui
    pathArg = '--path=%s' % path
    args = [sys.executable,leo,path,guiArg,pathArg]
    if silent: args.append('--silent')
    if trace: g.trace(args)

    # 2010/03/05: set the current directory so that importing leo.core.whatever works.
    leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')

    # os.chdir(leoDir)
    # os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
    env = dict(os.environ)
    env['PYTHONPATH'] = env.get('PYTHONPATH', '') + os.pathsep + leoDir

    if False:
        keys = list(os.environ.keys())
        keys.sort()
        for z in keys:
            print(z,os.environ.get(z))

    if trace: g.trace('*** spawning test process',path)
    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
</t>
<t tx="ekr.20090514093345.6054"></t>
<t tx="ekr.20090514111518.5661">def checkPythonCode (self,root,s=None,targetFn=None):

    c = self.c

    if not targetFn: targetFn = self.targetFileName

    if targetFn and targetFn.endswith('.py') and self.checkPythonCodeOnWrite:

        if not s:
            s,e = g.readFileIntoString(self.outputFileName)
            if s is None: return

        # It's too slow to check each node separately.
        ok = self.checkPythonSyntax(root,s)

        # Syntax checking catches most indentation problems.
        if False and ok: self.tabNannyNode(root,s)
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax (self,p,body,supress=False):

    try:
        ok = True
        if not g.isPython3:
            body = g.toEncodedString(body)
        body = body.replace('\r','')
        fn = '&lt;node: %s&gt;' % p.h
        compile(body + '\n',fn,'exec')
    except SyntaxError:
        if not supress:
            self.syntaxError(p,body)
        ok = False
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        ok = False
    return ok
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode (self,p,body,suppress=False):

    import parser,tabnanny,tokenize

    try:
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.es("ParserError in",p.h,color="red")
            g.es('',str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.es("IndentationError in",p.h,color="red")
            g.es('',str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.es("TokenError in",p.h,color="red")
            g.es('',str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        else:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("indentation error in",p.h,"line",badline,color="red")
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n",line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self,p,body):

    g.es_print("Syntax error in: %s" % (p.h),color="red")
    typ,val,tb = sys.exc_info()
    message = hasattr(val,'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None:return
    i = val.lineno-1
    for j in range(max(0,i-3),min(i+3,len(lines)-1)):
        g.es_print('%5s:%s %s' % (
            j,g.choose(j==i,'*',' '),lines[j].rstrip()))
        if j == i:
            g.es_print(' '*(7+offset)+'^')
</t>
<t tx="ekr.20090516135452.5776"># Warning: g.removeTrailingWs already exists.
# Do not change it!

def removeLeading (s,chars):

    '''Remove all characters in chars from the front of s.'''

    i = 0
    while i &lt; len(s) and s[i] in chars:
        i += 1
    return s[i:]

def removeTrailing (s,chars):

    '''Remove all characters in chars from the end of s.'''

    i = len(s)-1
    while i &gt;= 0 and s[i] in chars:
        i -= 1
    i += 1
    return s[:i]
</t>
<t tx="ekr.20090516135452.5777">def ensureLeadingNewlines (s,n):

    s = g.removeLeading(s,'\t\n\r ')
    return ('\n' * n) + s

def ensureTrailingNewlines (s,n):

    s = g.removeTrailing(s,'\t\n\r ')
    return s + '\n' * n


</t>
<t tx="ekr.20090518072506.8494">def isFKey (self,shortcut):


    if not shortcut: return False

    s = shortcut.lower()

    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090519143741.5915">def doPrePluginsInit(fileName,pymacs):

    ''' Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    options = scanOptions()

    # Post-process the options.
    fileName2 = options.get('fileName')
    if fileName2: fileName = fileName2

    if pymacs:
        options['script'] = script = None
        options['windowFlag'] = False
    else:
        script = options.get('script')
    verbose = script is None

    # Init the app.
    initApp(verbose)
    files = getFiles(fileName2)
    reportDirectories(verbose)

    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(None,verbose)
    for fn in files:
        g.app.config.readSettingsFiles(fn,verbose)

    if not files and not script:
        # This must be done *after* the standard settings have been read.
        fn = getDefaultFile()
        if fn:
            files = [fn]
            g.app.config.readSettingsFiles(fn,verbose=True)

    g.app.setGlobalDb()
    createGui(pymacs,options)

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    versionFlag = options.get('versionFlag')
    if versionFlag:
        print(g.app.signon)
    if versionFlag or not g.app.gui:
        options['exit'] = True

    return files,options
</t>
<t tx="ekr.20090519143741.5917">def doPostPluginsInit(args,files,options):

    '''Return True if the frame was created properly.'''

    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,fileName = None,None
    for fileName in files:
        c,frame = createFrame(fileName,options)
        if not frame:
            g.trace('createFrame failed',repr(fileName))
            return False

    if not c:
        c,frame = createFrame(None,options)
        if c and frame:
            fileName = c.fileName()
        else:
            g.trace('createFrame failed 2')
            return False

    # Do the final inits.
    c.setLog() # 2010/10/20
    g.app.logInited = True # 2010/10/20
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)

    screenshot_fn = options.get('screenshot_fn')
    if screenshot_fn:
        make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.

    return True
</t>
<t tx="ekr.20090520055433.5945">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)

    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    app.setLog(None) # 2010/10/20
    app.lockLog()# 2010/10/20
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None
    app.unlockLog()# 2010/10/20
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    # Handle the open hooks and open the log for c.
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.app.writeWaitingLog(c)
    c.setLog() # 2010/10/20
    g.createMenu(c,fn)
    g.finishOpen(c)
    return True,c.frame
</t>
<t tx="ekr.20090520055433.5946">def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(fileName)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
</t>
<t tx="ekr.20090520055433.5948">def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if munge(fileName) == munge(c.mFileName):
            frame.bringToFront()
            c.setLog()
            c.outerUpdate()
            return c
    return None
</t>
<t tx="ekr.20090520055433.5949">def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
</t>
<t tx="ekr.20090520055433.5950">def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        if theFile:
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    if not c.openDirectory:
        c.openDirectory = c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True
</t>
<t tx="ekr.20090520055433.5951">def createMenu(c,fileName=None):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
</t>
<t tx="ekr.20090520055433.5952">def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
</t>
<t tx="ekr.20090520055433.5954">def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
</t>
<t tx="ekr.20090521175848.5881"># From the Python cookbook, recipe 5.23

class nullObject:

    """An object that does nothing, and does it very well."""

    def __init__   (self,*args,**keys): pass
    def __call__   (self,*args,**keys): return self
    # def __len__    (self): return 0 # Debatable.
    def __repr__   (self): return "nullObject"
    def __str__    (self): return "nullObject"
    if isPython3:
        def __bool__(self): return False
    else:
        def __nonzero__(self): return 0
    def __delattr__(self,attr):     return self
    def __getattr__(self,attr):     return self
    def __setattr__(self,attr,val): return self
</t>
<t tx="ekr.20090525144314.6526">def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
</t>
<t tx="ekr.20090526081836.5841">def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c = self.c

    try:
        ok = True
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
</t>
<t tx="ekr.20090529061522.5727">class markerClass:

    '''A class representing comment delims in @shadow files.'''

    @others

</t>
<t tx="ekr.20090529061522.6257">def __init__(self,delims):

    delim1,delim2,delim3 = delims
    self.delim1 = delim1 # Single-line comment delim.
    self.delim2 = delim2 # Block comment starting delim.
    self.delim3 = delim3 # Block comment ending delim.
    if not delim1 and not delim2:
        self.delim1 = g.app.language_delims_dict.get('unknown_language')

def __repr__ (self):

    if self.delim1:
        delims = self.delim1
    else:
        delims = '%s %s' % (self.delim2,self.delim2)

    return '&lt;markerClass: delims: %s&gt;' % repr(delims)
</t>
<t tx="ekr.20090529061522.6258">def getDelims(self):

    if self.delim1:
        return self.delim1,''
    else:
        return self.delim2,self.delim3
</t>
<t tx="ekr.20090529061522.6259">def isSentinel(self,s,suffix=''):
    '''Return True is line s contains a valid sentinel comment.'''

    s = s.strip()
    if self.delim1 and s.startswith(self.delim1):
        return s.startswith(self.delim1+'@'+suffix)
    elif self.delim2:
        return s.startswith(self.delim2+'@'+suffix) and s.endswith(self.delim3)
    else:
        return False
</t>
<t tx="ekr.20090529061522.6260">def isVerbatimSentinel(self,s):

    return self.isSentinel(s,suffix='verbatim')
</t>
<t tx="ekr.20090529125512.6122">def markerFromFileLines (self,lines,fn):  # fn used only for traces.

    '''Return the sentinel delimiter comment to be used for filename.'''

    trace = False and not g.unitTesting
    x = self ; at = x.c.atFileCommands

    s = x.findLeoLine(lines)
    ok,junk,start,end,junk = at.parseLeoSentinel(s)
    if end:
        delims = '',start,end
    else:
        delims = start,'',''

    if trace: g.trace('delim1 %s delim2 %s delim3 %s fn %s' % (
        delims[0],delims[1],delims[2], fn))

    marker = x.markerClass(delims)
    return marker
</t>
<t tx="ekr.20090529125512.6125">def findLeoLine (self,lines):

    '''Return the @+leo line, or ''.'''

    for line in lines:
        i = line.find('@+leo')
        if i != -1:
            return line
    else:
        return ''
</t>
<t tx="ekr.20090530055015.6023">def getPathUa (self,p):

    if hasattr(p.v,'tempAttributes'):
        d = p.v.tempAttributes.get('read-path',{})
        return d.get('path')
    else:
        return ''

def setPathUa (self,p,path):

    if not hasattr(p.v,'tempAttributes'):
        p.v.tempAttributes = {}

    d = p.v.tempAttributes.get('read-path',{})
    d['path'] = path
    p.v.tempAttributes ['read-path'] = d
</t>
<t tx="ekr.20090530055015.6050">def fullPath (self,p,simulate=False):

    '''Return the full path (including fileName) in effect at p.

    Neither the path nor the fileName will be created if it does not exist.
    '''

    at = self ; c = at.c
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    if simulate: # for unit tests.
        fn = p.h
    else:
        fn = p.anyAtFileNodeName()
    if fn:
        path = g.os_path_finalize_join(path,fn)
    else:
        g.trace('can not happen: not an @&lt;file&gt; node:',g.callers(4))
        for p2 in p.self_and_parents():
            g.trace(p2.h)
        path = ''

    # g.trace(p.h,repr(path))
    return path
</t>
<t tx="ekr.20090530181848.6034">def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
</t>
<t tx="ekr.20090530181848.6035">def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
</t>
<t tx="ekr.20090601083544.6051">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

&gt; What would work for me is if named sections in a @rst subtree
&gt; would work exactly as they work for other derived files: they
&gt; get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
</t>
<t tx="ekr.20090601083544.6052">@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  &lt;&lt;code fragment&gt;&gt;

Unfortunately, &lt;&lt;code fragment&gt;&gt; will not be expanded. Furthermore, in order to
get to this work, I should have &lt;&lt;code fragment&gt;&gt; under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
</t>
<t tx="ekr.20090601083544.6066">These are plugins/projects that I'd like to investigate further.

interact.py:  Add buttons so leo can interact with command line environments.

g.command (class command) decorator:
http://groups.google.com/group/leo-editor/browse_thread/thread/a83082cec5ad3df8
</t>
<t tx="ekr.20090601083544.6067">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/a83082cec5ad3df8

QQQ (Ville)
So to create command you would do

import leoPlugins

def mycmd(c,p, event):
  print c,p

leoPlugins.expose_command('my-command', mycmd)
leoPlugins.expose_button('press-this',mycmd)

[EKR: I would rather use g.app.exposeCommand, g.app.exposeButton].

These would be available on *all* new commanders, and the current
commander as well (for easy testing). Plugins would not have to
contain more code than what is presented above.

The idea is to have a global command dict, [EKR: g.app.commandsDict]
and global button dict.
There is one after-create-frame handler that introduces all the
entries in this dict to the commander command dict.
QQQ

============


QQQ
g.app.global_commands_dict, which gets copied to c on commander
creation. it's rev 1889, you'll note that it's a simple
implementation. I didn't add g.button yet. An example:

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') 
QQQ
</t>
<t tx="ekr.20090601083544.6068"></t>
<t tx="ekr.20090608081524.6109">def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    p.restoreCursorAndScroll(w)
</t>
<t tx="ekr.20090619065122.8593">def createDefaultGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to create the default gui class."""

    app = self ; argName = app.guiArgName

    # This method can be called twice if we had to get .leoID.txt.
    if app.gui: return

    if argName == 'qt':
        app.createQtGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Qt gui: trying Tk gui')
            app.createTkGui(fileName,verbose=verbose)  
    elif argName == 'tk':
        app.createTkGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Tk gui: trying Qt gui')
            app.createQtGui(fileName,verbose=verbose)
    elif argName == 'null':
        app.createNullGui()
    elif argName == 'curses':
        app.createCursesGui()

    if not app.gui:
        print('Leo requires either Tk or Qt to be installed.')
</t>
<t tx="ekr.20090620052003.8505">u = c.undoer
w = c.frame.body.bodyCtrl
p2 = p.insertAsNthChild(0)
c.setHeadString(p2,'@test xxx')
s = '''\
if g.unitTesting:

    c,p = g.getTestVars()

    '''
c.setBodyString(p2,s)
c.selectPosition(p2)
c.redraw()
w.setInsertPoint(len(s))
c.bodyWantsFocus()
c.outerUpdate()
</t>
<t tx="ekr.20090622020908.6058">http://groups.google.com/group/leo-editor/browse_thread/thread/c4f2cf250600e4a9
</t>
<t tx="ekr.20090628075121.5994">def leoQuickStart (self,event=None):

    '''Open quickstart.leo in a new Leo window.'''

    c = self ; name = "quickstart.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found:",name)
</t>
<t tx="ekr.20090629183608.8445">Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
</t>
<t tx="ekr.20090629183608.8446">Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-&lt;object&gt; command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
</t>
<t tx="ekr.20090701125429.6012">def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    trace = False and not g.unitTesting

    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
</t>
<t tx="ekr.20090701125429.6013">def dHash(self, d):
    """Hash a dictionary"""
    return ''.join(['%s%s' % (str(k),str(d[k])) for k in sorted(d)])
</t>
<t tx="ekr.20090706110836.6135">def _addLink (self,childIndex,parent_v,adjust=True):
    '''Adjust links after adding a link to v.'''

    trace = False and not g.unitTesting
    v = self

    # Update parent_v.children &amp; v.parents.
    parent_v.children.insert(childIndex,v)
    v.parents.append(parent_v)
    if trace: g.trace('*** added parent',parent_v,'to',v,
        'len(parents)',len(v.parents))

    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1

    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if adjust:
        if len(v.parents) == 1:
            for child in v.children:
                child._addParentLinks(parent=v)
</t>
<t tx="ekr.20090706171333.6226">def badUnlink (self,parent_v,n,child):

    if 0 &lt;= n &lt; len(parent_v.children):
        g.trace('**can not happen: children[%s] != p.v' % (n))
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v',parent_v)
        g.trace('parent_v.children[n]',parent_v.children[n])
        g.trace('child',child)
        g.trace('** callers:',g.callers())
        if g.app.unitTesting: assert False, 'children[%s] != p.v'
    else:   
        g.trace('**can not happen: bad child index: %s, len(children): %s' % (
            n,len(parent_v.children)))
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v',parent_v,'child',child)
        g.trace('** callers:',g.callers())
        if g.app.unitTesting: assert False, 'bad child index: %s' % (n)
</t>
<t tx="ekr.20090712050729.6017">def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
</t>
<t tx="ekr.20090713080429.6042">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/bd3e06a8a34a1938

This is the first time we have done this ("stable" branch + trunk),
so it might be good to bring this up:

- When doing a bugfix/improvement, always do it in the oldest branch that will
  receive it.

- Only after that, merge it to trunk

This prevents "manual" merges, and accidental incorporation of unwanted fixes.
It also gives us clean merge history.

I think this is the process python-the-project will use with mercurial. If they
find a bug in python 2.6.whatever, they fix it in that branch first, then merge
from that branch to trunk (so python 2.7 will receive it).

===================

http://groups.google.com/group/leo-editor/browse_thread/thread/3f24628c7f735c42

&gt; I'll probably open a branch (based on the 4-6-final branch) to
  attempt a fix for an rst bug.

You don't need to create the branch on launchpad to do little fixes. The local
branch you create with "bzr branch" is a full-blown branch.

Here's how I do all my commits to trunk:

I have ~/leotrunk. I always keep this up to date with "bzr pull", but never
develop here.  (But I merge from leo-editor, as shown below.)
EKR: I call this main-trunk.

I have ~/leo-editor, also created from trunk. I develop here normally.
Occasionally, I just "bzr push", but often it fails because "branches have
diverged". I resist the temptation to "bzr merge" here, because it screws up
history. Rather, I:

- cd ~/leotrunk
- bzr pull (this always succeeds)
- bzr merge ~/leo-editor
- (investigate diffs)
- bzr qcommit (select the files I really want to commit--usually .py files)
- bzr push

Then, to get my ~/leo-editor up to date again:

cd ~/leo-editor
bzr pull 
</t>
<t tx="ekr.20090714085914.5994"></t>
<t tx="ekr.20090715145956.6166">def checkVisBackLimit (self,limit,limitIsVisible,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting
    c = p.v.context

    if limit:
        if limit == p:
            if trace: g.trace('at limit',p)
            if limitIsVisible and p.isVisible(c):
                return True,p
            else:
                return True,None
            #return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree',limit,p)
            return True,None
    else:
        return False,None
</t>
<t tx="ekr.20090715145956.6167">def checkVisNextLimit (self,limit,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting

    if limit:
        # Unlike moveToVisBack, being at the limit does not terminate.
        if limit == p:
            return False, None
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree')
            return True,None
    else:
        return False,None
</t>
<t tx="ekr.20090717092906.12765">'''A module holding version-related info.'''

# Leo 4.5.1 final: September 14, 2008
# Leo 4.6.1 final: July 30, 2009.
# Leo 4.7.1 final: February 26, 2010.

@language python
@tabwidth -4

build = 3005
date = "February 26, 2010"
version = "4.8 devel"
</t>
<t tx="ekr.20090717112235.6007">def computeSignon (self):

    app = self
    build,date  = leoVersion.build,leoVersion.date
    guiVersion  = app.gui and app.gui.getFullVersion() or 'no gui!'
    leoVer      = leoVersion.version
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            sysVersion += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: sysVersion = sys.platform

    app.signon = 'Leo %s, build %s, %s' % (
        leoVer,build,date)
    app.signon2 = 'Python %s.%s.%s, %s\n%s' % (
        n1,n2,n3,guiVersion,sysVersion)
</t>
<t tx="ekr.20090724081340.5987">@nocolor-node

Instead of adding an @ignore directive, it might be better
to change @auto to @@auto.

Should @auto be more lenient with C files?

Improve the recursive import script.
    - Minimize the path names
    - Option to include/exclude the @auto itself

</t>
<t tx="ekr.20090801103907.6018">http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20090804105939.5993"></t>
<t tx="ekr.20090804184658.6128">def _cutLink (self,childIndex,parent_v):
    '''Adjust links after cutting a link to v.'''
    v = self

    assert parent_v.children[childIndex]==v
    del parent_v.children[childIndex]
    v.parents.remove(parent_v)
    v._p_changed = 1
    parent_v._p_changed = 1

    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if len(v.parents) == 0:
        for child in v.children:
            child._cutParentLinks(parent=v)
</t>
<t tx="ekr.20090804184658.6129">def _addParentLinks(self,parent): 

    trace = False and not g.unitTesting
    v = self

    v.parents.append(parent)
    if trace: g.trace(
        '*** added parent',parent,'to',v,'len(parents)',len(v.parents))

    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
</t>
<t tx="ekr.20090804190529.6133">def _cutParentLinks(self,parent):

    trace = False and not g.unitTesting
    v = self

    if trace: g.trace('parent',parent,'v',v)
    v.parents.remove(parent)

    if len(v.parents) == 0:
        for child in v.children:
            child._cutParentLinks(parent=v)
</t>
<t tx="ekr.20090811141250.5955">@ Important: There is another features list for 4.9.
</t>
<t tx="ekr.20090814190307.5983">import glob

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')

aList = glob.glob(theDir)

for z in aList:
    print g.os_path_basename(z)

@
Exist:

    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
"w"     : "cweb",
"xml"   : "xml",
"xsl"   : "xslt",

Add first:


ada95.py
antlr.py
apacheconf.py
apdl.py
applescript.py
asp.py
aspect_j.py
assembly_macro32.py
assembly_mcs51.py
assembly_parrot.py
assembly_r2000.py
assembly_x86.py
awk.py
b.py
batch.py
bbj.py
bcel.py
bibtex.py
c.py
chill.py
cobol.py
coldfusion.py
cplusplus.py
csharp.py
css.py
cvs_commit.py
d.py
doxygen.py
dsssl.py
eiffel.py
embperl.py
erlang.py
factor.py
forth.py
fortran.py
fortran90.py
foxpro.py
freemarker.py
gettext.py
groovy.py
haskell.py
hex.py
html.py
i4gl.py
icon.py
idl.py
inform.py
ini.py
inno_setup.py
interlis.py
io.py
java.py
javascript.py
jcl.py
jhtml.py
jmk.py
jsp.py
latex.py
lilypond.py
lisp.py
lotos.py
lua.py
mail.py
makefile.py
maple.py
matlab.py
ml.py
modula3.py
moin.py
mqsc.py
netrexx.py
nqc.py
nsis2.py
objective_c.py
objectrexx.py
occam.py
omnimark.py
pascal.py
patch.py
perl.py
php.py
phpsection.py
pike.py
pl1.py
plain.py
plsql.py
pop11.py
postscript.py
povray.py
powerdynamo.py
progress.py
prolog.py
props.py
psp.py
ptl.py
pvwave.py
pyrex.py
python.py
r.py
rebol.py
redcode.py
relax_ng_compact.py
rest.py
rhtml.py
rib.py
rpmspec.py
rtf.py
ruby.py
rview.py
sas.py
scheme.py
sdl_pr.py
sgml.py
shell.py
shellscript.py
shtml.py
smalltalk.py
smi_mib.py
splus.py
sqr.py
squidconf.py
ssharp.py
svn_commit.py
swig.py
tcl.py
tex.py
texinfo.py
text.py
tpl.py
tsql.py
uscript.py
vbscript.py
velocity.py
verilog.py
vhdl.py
xml.py
xsl.py
zpt.py
__init__.py
</t>
<t tx="ekr.20090816125009.5993"></t>
<t tx="ekr.20090829140232.6036">def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open ' + fname)
</t>
<t tx="ekr.20090830051712.6151"></t>
<t tx="ekr.20090830051712.6153">def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
</t>
<t tx="ekr.20090830051712.6157"># Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) &gt; 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
</t>
<t tx="ekr.20090905110447.6098">def cloneMarked(self,event=None):

    """Clone all marked nodes as children of parent position."""

    c = self ; u = c.undoer
    current = c.currentPosition()

    # Create a new node to hold clones.
    parent = current.insertAfter()
    parent.h = 'Clones of marked nodes'
    marked = []
    for p in c.all_positions():
        if p.isMarked() and not p.v in marked:
            marked.append(p.v)
    marked.reverse()

    undoData = u.beforeChangeTree(parent)
    for v in marked:
        # This only works for one-node world.
        v._linkAsNthChild(parent.v,0)
    u.afterChangeTree(parent,'Clone marked',undoData)
    parent.expand()
    c.selectPosition(parent)
    c.redraw()    
</t>
<t tx="ekr.20090907080624.6081"></t>
<t tx="ekr.20091001141621.6043">def all_nodes(self):
    c = self
    for p in c.all_positions():
        yield p.v
    raise StopIteration

def all_unique_nodes(self):
    c = self
    for p in c.all_unique_positions():
        yield p.v
    raise StopIteration

# Compatibility with old code.
all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
</t>
<t tx="ekr.20091001141621.6044">def all_positions (self):
    c = self
    p = c.rootPosition() # Make one copy.
    while p:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_iter = all_positions
allNodes_iter = all_positions
</t>
<t tx="ekr.20091001141621.6055">def children(self):

    '''Return all children of p.'''

    p = self
    p = p.firstChild()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
children_iter = children
</t>
<t tx="ekr.20091001141621.6056">def subtree(self):

    '''Return all descendants of p, not including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_iter = subtree
</t>
<t tx="ekr.20091001141621.6057">def self_and_siblings(self):
    '''Return all siblings of p including p.
    '''

    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
self_and_siblings_iter = self_and_siblings
</t>
<t tx="ekr.20091001141621.6058">def parents(self):

    '''Return all parents of p.'''

    p = self
    p = p.parent()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
parents_iter = parents
</t>
<t tx="ekr.20091001141621.6060"></t>
<t tx="ekr.20091001141621.6061"></t>
<t tx="ekr.20091001141621.6062">def all_unique_positions(self):
    c = self
    p = c.rootPosition() # Make one copy.
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
</t>
<t tx="ekr.20091001141621.6066">def self_and_subtree(self):

    '''Return p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
self_and_subtree_iter = self_and_subtree
</t>
<t tx="ekr.20091002083910.6099">def self_and_parents(self):

    '''Return p and all parents of p.'''

    p = self
    p = p.copy()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
self_and_parents_iter = self_and_parents
</t>
<t tx="ekr.20091002083910.6102">def following_siblings(self):
    '''
    Return all siblings that follow p, not including p.
    '''

    p = self
    p = p.copy() # Always include the original node.
    p = p.next()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
following_siblings_iter = following_siblings
</t>
<t tx="ekr.20091002083910.6103">def unique_subtree (self):
    '''Return unique positions in p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    seen = set()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_with_unique_tnodes_iter = unique_subtree
subtree_with_unique_vnodes_iter = unique_subtree
</t>
<t tx="ekr.20091002083910.6104">def nodes (self):

    p = self
    p = p.copy()
    while p:
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.
tnodes_iter = nodes
vnodes_iter = nodes
</t>
<t tx="ekr.20091002083910.6105">def unique_nodes (self):

    p = self
    p = p.copy()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.v
            p.moveToThreadNext()

# Compatibility with old code.
unique_tnodes_iter = unique_nodes
unique_vnodes_iter = unique_nodes
</t>
<t tx="ekr.20091002083910.6106"></t>
<t tx="ekr.20091007103358.6061">def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path")
    add('--debug',        action="store_true",dest="debug")
    add('-f', '--file',   dest="fileName")
    add('--gui', dest="gui",help = 'gui to use (qt/tk/qttabs)')
    add('--ipython',      action="store_true",dest="use_ipython")
    add('--no-cache',     action="store_true",dest='no_cache')
    add('--silent',       action="store_true",dest="silent")
    add('--screen-shot',  dest='screenshot_fn')
    add('--script',       dest="script")
    add('--script-window',dest="script_window")
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui
    g.app.qt_use_tabs = False

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
    else:
        gui = g.app.guiArgName = 'qt'

    assert gui == g.app.guiArgName

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
</t>
<t tx="ekr.20091206161352.6232">if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
</t>
<t tx="ekr.20091210082012.6230">def __ge__ (self,other):

    return self.__eq__(other) or self.__gt__(other)

def __le__ (self,other):

    return self.__eq__(other) or self.__lt__(other)

def __lt__ (self,other):

    return not self.__eq__(other) and not self.__gt__(other)
</t>
<t tx="ekr.20091210082012.6233">def __gt__ (self,other):

    '''Return True if self appears after other in outline order.'''

    stack1,stack2 = self.stack,other.stack
    n1,n2 = len(stack1),len(stack2) ; n = min(n1,n2)
    # Compare the common part of the stacks.
    for item1,item2 in zip(stack1,stack2):
        v1,x1 = item1 ; v2,x2 = item2
        if x1 &gt; x2: return True
        elif x1 &lt; x2: return False
    # Finish the comparison.
    if n1 == n2:
        x1,x2 = self._childIndex,other._childIndex
        return x1 &gt; x2
    elif n1 &lt; n2:
        x1 = self._childIndex; v2,x2 = other.stack[n]
        return x1 &gt; x2
    else:
        return True
</t>
<t tx="ekr.20091211111443.6265">def doBatchOperations (self,aList=None):
    # Validate aList and create the parents dict
    if aList is None: aList = []
    ok, d = self.checkBatchOperationsList(aList)
    if not ok:
        return g.es('do-batch-operations: invalid list argument',
            color='red')

    for v in list(d.keys()):
        aList2 = d.get(v,[])
        if aList2:
            aList.sort()
            for n,op in aList2:
                if op == 'insert':
                    g.trace('insert:',v.h,n)
                else:
                    g.trace('delete:',v.h,n)
</t>
<t tx="ekr.20091211111443.6266">def checkBatchOperationsList(self,aList):
    ok = True ; d = {}
    for z in aList:
        try:
            op,p,n = z
            ok= (op in ('insert','delete') and
                isinstance(p,leoNodes.position) and
                type(n) == type(9))
            if ok:
                aList2 = d.get(p.v,[])
                data = n,op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok,d
</t>
<t tx="ekr.20091217112515.6069">@nocolor-node

1. codewisecompleter.py now completes by explicit type hints (as seen in
screenhots). p, c also work, as does 'self'.

self works by scanning for parent headlines looking for "class Foo"

Work remains for presentation part (it's mouse only now) but Edward
will probably do it :-).

2. &gt; Would codewise work outside of leo, as stand-alone plugin for a text
&gt; editor?

Yes, currently Leo uses it as an external program ("codewise m
MyClass" dumps the methods in MyClass to stdout).

Someone just has to write the vim integration plugin (or whatever they
call it). OTOH, vim already has "pysmell" and the likes that do the
same thing.

==============

The version of codewise completer that works with Tk is now on trunk.
</t>
<t tx="ekr.20091217112515.6070">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e

Ville's completer is working and very cool, here are instructions for
making it go.  They're like the instructions Ville gave, only usable ;-)

1. (done) Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. (done) Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. (done) You need a recent trunk version of leo to get the plugin which uses
the above module.

4. (done) Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
with 'op' etc.


===== Ville's response

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

&gt; Then, after restarting leo if necessary, type

&gt; c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
&gt; with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.&lt;alt+0&gt;

And self.&lt;alt+0&gt;
</t>
<t tx="ekr.20091217112515.6071">@nocolor-node

- You need to create ctags file to ~/.leo/tags. Example::

    cd ~/.leo
    ctags -R /usr/lib/python2.5 ~/leo-editor ~/my-project

- Enter text you want to complete and press alt+0 to show completions
  (or bind/execute ctags-complete command yourself).

Attempting to complete 'foo-&gt;' is useless, but 'foo-&gt;ba' will work (provided you
don't have 2000 functions/methods starting with 'ba'. 'foo-&gt;' portion is ignored
in completion search.
</t>
<t tx="ekr.20091218120633.6299"></t>
<t tx="ekr.20091218120633.6300"></t>
<t tx="ekr.20091221145433.6381">def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
</t>
<t tx="ekr.20091224155043.6539"># Required so the unit test that simulates an @auto leoImport.py will work!
import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest
import string

if g.isPython3:
    import io
    StringIO = io.StringIO
else:
    import StringIO
    StringIO = StringIO.StringIO
</t>
<t tx="ekr.20091227115606.6468">def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
</t>
<t tx="ekr.20091228080620.6499">def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
</t>
<t tx="ekr.20091229075924.6234">def getLine (self,s,i):

    i,j = g.getLine(s,i)
    line = s[i:j]
    nows = i == g.skip_ws(s,i)
    line = line.strip()

    return i,j,nows,line
</t>
<t tx="ekr.20091229075924.6235">def removeLeadingBlankLines (s):

    lines = g.splitLines(s)

    result = [] ; remove = True
    for line in lines:
        if remove and not line.strip():
            pass
        else:
            remove = False
            result.append(line)

    return ''.join(result)
</t>
<t tx="ekr.20091229090857.11694">def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start &gt; 0 and s[start-1] in (' ','\t'):
            start -= 1

    # Never indent any text; discard the entire signature.
    body1 = s[start:sigStart]
    body2 = s[self.sigEnd+1:codeEnd]
    body2 = g.removeLeadingBlankLines(body2) # 2009/12/28
    body = body1 + body2

    # Don't warn about missing tail newlines: they will be added.
    if trace: g.trace('body: %s' % repr(body))
    return body
</t>
<t tx="ekr.20091229090857.11698">def removeBlankLines (s):

    lines = g.splitLines(s)
    lines = [z for z in lines if z.strip()]
    return ''.join(lines)
</t>
<t tx="ekr.20091230062012.6238">@  For characters valid in names see:
   www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
@c

def skipId (self,s,i):

    # Fix bug 497332: @data import_xml_tags does not allow dashes in tag.
    chars = '.-:' # Allow : anywhere.
    n = len(s)
    while i &lt; n and (self.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
</t>
<t tx="ekr.20091230062012.6239">@ From www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar    ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x2FF]    |
    [#x370-#x37D]   | [#x37F-#x1FFF]  | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar    ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]
@c

def isWordChar(self,ch):

    # At present, same as g.isWordChar.
    # This is not correct.
    return ch and (ch.isalnum() or ch == '_')
</t>
<t tx="ekr.20091230094319.6240">def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    keyStatesTuple = ('command','insert','overwrite')

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
</t>
<t tx="ekr.20091230094319.6242">def doPlainKey (self,event,stroke,w):

    '''Handle a plain key.  Return done,b.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # Important: only keys bound somewhere have a stroke.
    # All unbound plain keys will be handled by handleUnboundKeys.
    if k.unboundKeyAction in ('insert','overwrite'):
        for key in (k.unboundKeyAction,'body','log','text','all'):
            # Ignore bindings for all plain keys in insert/overwrite mode
            # *except* auto-complete.
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    if trace: g.trace('%s: auto-complete key in %s mode' % (
                        stroke,k.unboundKeyAction))
                    return True,b

        if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
        return True,g.bunch(func=None,stroke=stroke,commandName=None)

    # Ignore all command-state keys if we are not in a text widget.
    elif k.unboundKeyAction == 'command':
        if g.app.gui.isTextWidget(w):
            return False,None
        else:
            c.onCanvasKey(event)
            return True,None
    else:
        return False,None
</t>
<t tx="ekr.20091230094319.6244">def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return True,'break'
</t>
<t tx="ekr.20100108101415.6196">insert-tab-or-indent-region, insert-hard-tab, insert-soft-tab.
</t>
<t tx="ekr.20100109094541.6227">def moveToBufferHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
</t>
<t tx="ekr.20100109094541.6228">def moveToCharacterHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
</t>
<t tx="ekr.20100109094541.6231">def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
</t>
<t tx="ekr.20100109094541.6232">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
</t>
<t tx="ekr.20100109214940.6225"></t>
<t tx="ekr.20100112051224.6222">Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to &lt;character&gt;"
that requires a "copy to clipboard" operation after the "find-character"
command.
</t>
<t tx="ekr.20100112051224.6223">Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
</t>
<t tx="ekr.20100112051224.6225">Support the ';' key: repeat the last "To character" or "Find character" command.
</t>
<t tx="ekr.20100112051224.6226">The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

</t>
<t tx="ekr.20100112051224.6227">The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
</t>
<t tx="ekr.20100112051224.6228">Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.
</t>
<t tx="ekr.20100112051224.6229">Binding arrow keys, with or without Shift, Ctrl, Alt, and their combinations, to
commands or @mode nodes have no effect.
</t>
<t tx="ekr.20100112051224.6230">Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
</t>
<t tx="ekr.20100112051224.6231">Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
</t>
<t tx="ekr.20100112051224.6232">Leo provides support for switching to upper or lower case but no method exists
to toggle between cases (used by Vi's "~" command).

</t>
<t tx="ekr.20100112051224.6233">Vi's "r" command allows user to replace the current character with the next
entered character.
</t>
<t tx="ekr.20100112051224.6234">Vi has a collection of "z&lt;movement&gt;" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
</t>
<t tx="ekr.20100112051224.6235">Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

</t>
<t tx="ekr.20100112051224.6236">Vi supports two types of words in its commands:

1. Words that consist of only a subset of the character set and
2. words that consist of all characters except the space and tab characters.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
</t>
<t tx="ekr.20100112051224.6237">Leo's sentence related functions:

- do not stop at empty lines.
- do not skip periods within words.
- do not stop at sentences ending in non-periods.
- do not stop at the end or beginning of the buffer.

Note: see forwardSentenceHelper and backSentenceHelper functions.
</t>
<t tx="ekr.20100112051224.6238">Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.
</t>
<t tx="ekr.20100112051224.6239">@nocolor-node

The "--&gt; mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
</t>
<t tx="ekr.20100112051224.6246"></t>
<t tx="ekr.20100113075303.6270"></t>
<t tx="ekr.20100113075303.6271"></t>
<t tx="ekr.20100113075303.6272"></t>
<t tx="ekr.20100119145629.6106">def createActualFile (self,fileName,toOPML,toZip):

    c = self.c

    if toOPML and not self.mFileName.endswith('opml'):
        fileName = self.mFileName + '.opml'

    if toZip:
        self.toString = True
        theActualFile = None
    else:
        try:
            # 2010/01/21: always write in binary mode.
            theActualFile = open(fileName,'wb')
        except IOError:
            theActualFile = None

    return fileName,theActualFile
</t>
<t tx="ekr.20100119145629.6108">def handleWriteLeoFileException(self,fileName,backupName,theActualFile):

    c = self.c

    g.es("exception writing:",fileName)
    g.es_exception(full=True)

    if theActualFile:
        theActualFile.close()

    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName,'')

    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring",fileName,"from",backupName)

        # No need to create directories when restoring.
        g.utils_rename(c,backupName,fileName)
    else:
        g.trace('backup file does not exist!',
            repr(backupName),color='red')
</t>
<t tx="ekr.20100119145629.6109">def checkOutline (self):

    c = self.c

    g.trace('@bool check_outline_before_save = True',color='blue')

    errors = c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    ok = errors == 0
    if not ok:
        g.es_print('outline not written',color='red')

    return ok
</t>
<t tx="ekr.20100119145629.6110">def writeToStringHelper (self,fileName):

    try:
        self.mFileName = fileName
        self.outputFile = StringIO()
        self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s
        return True
    except Exception:
        g.es("exception writing:",fileName)
        g.es_exception(full=True)
        g.app.write_Leo_file_string = ''
        return False
</t>
<t tx="ekr.20100119145629.6111">def writeToFileHelper (self,fileName,toOPML):

    c = self.c ; toZip = c.isZipped
    ok,backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName,theActualFile = self.createActualFile(fileName,toOPML,toZip)
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.

    try:
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            if g.isPython3:
                s = bytes(s,self.leo_file_encoding,'replace')
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName,'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName,backupName,theActualFile)
        return False
</t>
<t tx="ekr.20100119145629.6114">def writeAllAtFileNodesHelper (self):

    '''Write all @&lt;file&gt; nodes and set orphan bits.
    '''

    c = self.c

    try:
        # 2010/01/19: Do *not* signal failure here.
        # This allows Leo to quit properly.
        c.atFileCommands.writeAll()
        return True
    except Exception:
        g.es_error("exception writing external files")
        g.es_exception()
        return False
</t>
<t tx="ekr.20100119205347.6015">@all
</t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100120072650.6089">@all
</t>
<t tx="ekr.20100120092047.6087">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100120092047.6088">""" ILeo - Leo plugin for IPython

"""
import IPython.ipapi
import IPython.genutils
import IPython.generics
from IPython.hooks import CommandChainDispatcher
import re
import UserDict
from IPython.ipapi import TryNext 
import IPython.macro
import IPython.Shell

_leo_push_history = set()

wb = None
</t>
<t tx="ekr.20100120092047.6089">def init_ipython(ipy):
    """ This will be run by _ip.load('ipy_leo') 

    Leo still needs to run update_commander() after this.

    """
    global ip
    ip = ipy
    IPython.Shell.hijack_tk()
    ip.set_hook('complete_command', mb_completer, str_key = '%mb')
    ip.expose_magic('mb',mb_f)
    ip.expose_magic('lee',lee_f)
    ip.expose_magic('leoref',leoref_f)
    ip.expose_magic('lleo',lleo_f)    
    ip.expose_magic('lshadow', lshadow_f)
    ip.expose_magic('lno', lno_f)    
    # Note that no other push command should EVER have lower than 0
    expose_ileo_push(push_mark_req, -1)
    expose_ileo_push(push_cl_node,100)
    # this should be the LAST one that will be executed,
    # and it will never raise TryNext.
    expose_ileo_push(push_ipython_script, 1000)
    expose_ileo_push(push_plain_python, 100)
    expose_ileo_push(push_ev_node, 100)
    ip.set_hook('pre_prompt_hook', ileo_pre_prompt_hook)     
    global wb
    wb = LeoWorkbook()
    ip.user_ns['wb'] = wb
</t>
<t tx="ekr.20100120092047.6090">first_launch = True

c,g = None, None

def update_commander(new_leox):
    """ Set the Leo commander to use

    This will be run every time Leo does ipython-launch; basically,
    when the user switches the document he is focusing on, he should do
    ipython-launch to tell ILeo what document the commands apply to.

    """

    global first_launch
    if first_launch:
        show_welcome()
        first_launch = False

    global c,g
    c,g = new_leox.c, new_leox.g
    print("Set Leo Commander:",c.frame.getTitle())

    # will probably be overwritten by user,
    # but handy for experimentation early on.
    ip.user_ns['c'] = c
    ip.user_ns['g'] = g
    ip.user_ns['_leo'] = new_leox

    new_leox.push = push_position_from_leo
    run_leo_startup_node()
    ip.user_ns['_prompt_title'] = 'ileo'
</t>
<t tx="ekr.20100120092047.6091">from IPython.external.simplegeneric import generic 
import pprint

def es(s):    
    g.es(s, tabName = 'IPython')
    pass
</t>
<t tx="ekr.20100120092047.6092">@generic
def format_for_leo(obj):
    """ Convert obj to string representiation (for editing in Leo)"""
    return pprint.pformat(obj)

# Just an example - note that this is a bad to actually do!
#@format_for_leo.when_type(list)
#def format_list(obj):
#    return "\n".join(str(s) for s in obj)
</t>
<t tx="ekr.20100120092047.6093">attribute_re = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')

def valid_attribute(s):
    return attribute_re.match(s)    
</t>
<t tx="ekr.20100120092047.6094">_rootnode = None

def rootnode():
    """ Get ileo root node (@ipy-root) 

    if node has become invalid or has not been set, return None

    Note that the root is the *first* @ipy-root item found    
    """
    global _rootnode
    if _rootnode is None:
        return None
    if c.positionExists(_rootnode.p):
        return _rootnode
    _rootnode = None
    return None  
</t>
<t tx="ekr.20100120092047.6095">def all_cells():
    global _rootnode
    d = {}
    r = rootnode() 
    if r is not None:
        nodes = r.p.children_iter()
    else:
        nodes = c.allNodes_iter()

    for p in nodes:
        h = p.headString()
        if h.strip() == '@ipy-root':
            # update root node (found it for the first time)
            _rootnode = LeoNode(p)            
            # the next recursive call will use the children of new root
            return all_cells()

        if h.startswith('@a '):
            d[h.lstrip('@a ').strip()] = p.parent().copy()
        elif not valid_attribute(h):
            continue 
        d[h] = p.copy()
    return d    
</t>
<t tx="ekr.20100120092047.6096">def eval_node(n):
    body = n.b    
    if not body.startswith('@cl'):
        # plain python repr node, just eval it
        return ip.ev(n.b)
    # @cl nodes deserve special treatment:
    # first eval the first line (minus cl),
    # then use it to call the rest of body.
    first, rest = body.split('\n',1)
    tup = first.split(None, 1)
    # @cl alone SPECIAL USE-&gt; dump var to user_ns
    if len(tup) == 1:
        val = ip.ev(rest)
        ip.user_ns[n.h] = val
        es("%s = %s" % (n.h, repr(val)[:20]  )) 
        return val

    cl, hd = tup 

    xformer = ip.ev(hd.strip())
    es('Transform w/ %s' % repr(xformer))
    return xformer(rest, n)
</t>
<t tx="ekr.20100120092047.6097">class LeoNode(object, UserDict.DictMixin):
    """ Node in Leo outline

    Most important attributes (getters/setters available:
     .v     - evaluate node, can also be alligned 
     .b, .h - body string, headline string
     .l     - value as string list

    Also supports iteration, 

    setitem / getitem (indexing):  
     wb.foo['key'] = 12
     assert wb.foo['key'].v == 12

    Note the asymmetry on setitem and getitem! Also other
    dict methods are available. 

    .ipush() - run push-to-ipython

    Minibuffer command access (tab completion works):

     mb save-to-file

    """
    @others
    uA = property(__get_uA,
        doc = "Access persistent unknownAttributes of node")
</t>
<t tx="ekr.20100120092047.6098">def __init__(self,p):
    self.p = p.copy()

</t>
<t tx="ekr.20100120092047.6099">def __str__(self):
    return "&lt;LeoNode %s&gt;" % str(self.p)

__repr__ = __str__
</t>
<t tx="ekr.20100120092047.6101">def __get_h(self):
    return self.p.headString()


def __set_h(self,val):
    c.setHeadString(self.p,val)
    LeoNode.last_edited = self
    c.redraw()

h = property( __get_h, __set_h, doc = "Node headline string")  
</t>
<t tx="ekr.20100120092047.6103">def __get_b(self):
    return self.p.bodyString()

def __set_b(self,val):
    c.setBodyString(self.p, val)
    LeoNode.last_edited = self
    c.redraw()

b = property(__get_b, __set_b, doc = "Nody body string")
</t>
<t tx="ekr.20100120092047.6104">def __set_val(self, val):        
    self.b = format_for_leo(val)

v = property(lambda self: eval_node(self), __set_val,
    doc = "Node evaluated value")
</t>
<t tx="ekr.20100120092047.6105">def __set_l(self,val):
    self.b = '\n'.join(val )

l = property(lambda self : IPython.genutils.SList(self.b.splitlines()), 
             __set_l, doc = "Node value as string list")
</t>
<t tx="ekr.20100120092047.6106">def __iter__(self):
    """ Iterate through nodes direct children """

    return (LeoNode(p) for p in self.p.children_iter())

</t>
<t tx="ekr.20100120092047.6107">def __children(self):
    d = {}
    for child in self:
        head = child.h
        tup = head.split(None,1)
        if len(tup) &gt; 1 and tup[0] == '@k':
            d[tup[1]] = child
            continue

        if not valid_attribute(head):
            d[head] = child
            continue
    return d
</t>
<t tx="ekr.20100120092047.6108">def keys(self):
    d = self.__children()
    return list(d.keys()) # 2010/02/04: per 2to3
</t>
<t tx="ekr.20100120092047.6109">def __getitem__(self, key):
    """ wb.foo['Some stuff']
    Return a child node with headline 'Some stuff'

    If key is a valid python name (e.g. 'foo'),
    look for headline '@k foo' as well
    """  
    key = str(key)
    d = self.__children()
    return d[key]
</t>
<t tx="ekr.20100120092047.6110">def __setitem__(self, key, val):
    """ You can do wb.foo['My Stuff'] = 12 to create children 

    Create 'My Stuff' as a child of foo (if it does not exist), and 
    do .v = 12 assignment.

    Exception:

    wb.foo['bar'] = 12

    will create a child with headline '@k bar',
    because bar is a valid python name and we don't want to crowd
    the WorkBook namespace with (possibly numerous) entries.
    """
    key = str(key)
    d = self.__children()
    if key in d:
        d[key].v = val
        return

    if not valid_attribute(key):
        head = key
    else:
        head = '@k ' + key
    p = c.createLastChildNode(self.p, head, '')
    LeoNode(p).v = val

</t>
<t tx="ekr.20100120092047.6111">def __delitem__(self, key):
    """ Remove child

    Allows stuff like wb.foo.clear() to remove all children
    """
    self[key].p.doDelete()
    c.redraw()

</t>
<t tx="ekr.20100120092047.6112">def ipush(self):
    """ Does push-to-ipython on the node """
    push_from_leo(self)

</t>
<t tx="ekr.20100120092047.6113">def go(self):
    """ Set node as current node (to quickly see it in Outline) """
    #c.setCurrentPosition(self.p)

    # argh, there should be another way
    #c.redraw()
    #s = self.p.bodyString()
    #c.setBodyString(self.p,s)
    c.selectPosition(self.p)
</t>
<t tx="ekr.20100120092047.6114">def append(self):
    """ Add new node as the last child, return the new node """
    p = self.p.insertAsLastChild()
    return LeoNode(p)
</t>
<t tx="ekr.20100120092047.6115">def script(self):
    """ Method to get the 'tangled' contents of the node

    (parse @others, %s references etc.)
    """ % g.angleBrackets(' section ')

    return g.getScript(c,self.p,useSelectedText=False,useSentinels=False)

</t>
<t tx="ekr.20100120092047.6116">def __get_uA(self):
    p = self.p

    # Create the uA if necessary.

    # EKR: change p.v.t to p.v here.
    if not hasattr(p.v,'unknownAttributes'):
        p.v.unknownAttributes = {}        

    d = p.v.unknownAttributes.setdefault('ipython', {})
    return d        

</t>
<t tx="ekr.20100120092047.6117">class LeoWorkbook:
    """ class for 'advanced' node access 

    Has attributes for all "discoverable" nodes.
    Node is discoverable if it either

    - has a valid python name (Foo, bar_12)
    - is a parent of an anchor node.
    If it has a child '@a foo', it is visible as foo.

    """
    @others
</t>
<t tx="ekr.20100120092047.6118">def __getattr__(self, key):
    if key.startswith('_') or key == 'trait_names' or not valid_attribute(key):
        raise AttributeError
    cells = all_cells()
    p = cells.get(key, None)
    if p is None:
        return add_var(key)

    return LeoNode(p)

</t>
<t tx="ekr.20100120092047.6119">def __str__(self):
    return "&lt;LeoWorkbook&gt;"

__repr__ = __str__
</t>
<t tx="ekr.20100120092047.6120">def __setattr__(self,key, val):
    raise AttributeError(
        "Direct assignment to workbook denied, try wb.%s.v = %s" % (
            key,val))

</t>
<t tx="ekr.20100120092047.6121">def __iter__(self):
    """ Iterate all (even non-exposed) nodes """
    cells = all_cells()
    return (LeoNode(p) for p in c.allNodes_iter())

</t>
<t tx="ekr.20100120092047.6122">def match_h(self, regex):
    cmp = re.compile(regex)
    res = PosList()
    for node in self:
        if re.match(cmp, node.h, re.IGNORECASE):
            res.append(node)
    return res

</t>
<t tx="ekr.20100120092047.6123">def require(self, req):
    """ Used to control node push dependencies 

    Call this as first statement in nodes.
    If node has not been pushed, it will be pushed before proceeding

    E.g. wb.require('foo') will do wb.foo.ipush()
    if it hasn't been done already.
    """

    if req not in _leo_push_history:
        es('Require: ' + req)
        getattr(self,req).ipush()
</t>
<t tx="ekr.20100120092047.6124">class PosList(list):

    def select(self, pat):
        res = PosList()
        for n in self:
            #print "po",p
            for chi_p in n.p.children_iter():
                #print "chi",chi_p
                if re.match(pat, chi_p.headString()):
                    res.append(LeoNode(chi_p))
        return res
</t>
<t tx="ekr.20100120092047.6126">@IPython.generics.complete_object.when_type(LeoWorkbook)
def workbook_complete(obj, prev):
    # 2010/02/04: per 2to3
    return list(all_cells().keys()) + [
        s for s in prev if not s.startswith('_')]
</t>
<t tx="ekr.20100120092047.6127">def add_var(varname):
    r = rootnode()
    try:
        if r is None:
            p2 = g.findNodeAnywhere(c,varname)
        else:
            p2 = g.findNodeInChildren(c, r.p, varname)
        if p2:
            return LeoNode(p2)

        if r is not None:
            p2 = r.p.insertAsLastChild()

        else:
            p2 =  c.currentPosition().insertAfter()

        c.setHeadString(p2,varname)
        return LeoNode(p2)
    finally:
        c.redraw()
</t>
<t tx="ekr.20100120092047.6128">def add_file(self,fname):
    p2 = c.currentPosition().insertAfter()
</t>
<t tx="ekr.20100120092047.6129">push_from_leo = CommandChainDispatcher()

def expose_ileo_push(f, prio = 0):
    push_from_leo.add(f, prio)

</t>
<t tx="ekr.20100120092047.6130">def push_ipython_script(node):
    """ Execute the node body in IPython,
    as if it was entered in interactive prompt """
    try:
        ohist = ip.IP.output_hist 
        hstart = len(ip.IP.input_hist)
        script = node.script()

        # The current node _p needs to handle
        # wb.require() and recursive ipushes.
        old_p = ip.user_ns.get('_p',None)
        ip.user_ns['_p'] = node
        ip.runlines(script)
        ip.user_ns['_p'] = old_p
        if old_p is None:
            del ip.user_ns['_p']

        has_output = False
        for idx in range(hstart,len(ip.IP.input_hist)):
            val = ohist.get(idx,None)
            if val is None:
                continue
            has_output = True
            inp = ip.IP.input_hist[idx]
            if inp.strip():
                es('In: %s' % (inp[:40], ))

            es('&lt;%d&gt; %s' % (idx, pprint.pformat(ohist[idx],width = 40)))

        if not has_output:
            es('ipy run: %s (%d LL)' %( node.h,len(script)))
    finally:
        c.redraw()
</t>
<t tx="ekr.20100120092047.6131">def eval_body(body):
    try:
        val = ip.ev(body)
    except:
        # just use stringlist if it's not completely legal python expression
        val = IPython.genutils.SList(body.splitlines())
    return val 

</t>
<t tx="ekr.20100120092047.6132">def push_plain_python(node):
    if not node.h.endswith('P'):
        raise TryNext
    script = node.script()
    lines = script.count('\n')
    try:
        # exec script in ip.user_ns
        # 2010/02/04: per 2to3
        exec(script,ip.user_ns)
    except:
        print(" -- Exception in script:\n"+script + "\n --")
        raise
    es('ipy plain: %s (%d LL)' % (node.h,lines))
</t>
<t tx="ekr.20100120092047.6133">def push_cl_node(node):
    """ If node starts with @cl, eval it

    The result is put as last child of @ipy-results node, if it exists
    """
    if not node.b.startswith('@cl'):
        raise TryNext

    p2 = g.findNodeAnywhere(c,'@ipy-results')
    val = node.v
    if p2:
        es("=&gt; @ipy-results")
        LeoNode(p2).v = val
    es(val)

</t>
<t tx="ekr.20100120092047.6134">def push_ev_node(node):
    """ If headline starts with @ev, eval it and put result in body """
    if not node.h.startswith('@ev '):
        raise TryNext
    expr = node.h.lstrip('@ev ')
    es('ipy eval ' + expr)
    res = ip.ev(expr)
    node.v = res

</t>
<t tx="ekr.20100120092047.6135">def push_mark_req(node):
    """ This should be the first one that gets called.

    It will mark the node as 'pushed', for wb.require.
    """
    _leo_push_history.add(node.h)
    raise TryNext
</t>
<t tx="ekr.20100120092047.6136">def push_position_from_leo(p):
    try:
        push_from_leo(LeoNode(p))

    # 2010/02/04: per 2to3
    except AttributeError as e:
        if e.args == ("Commands instance has no attribute 'frame'",):
            es("Error: ILeo not associated with .leo document")
            es("Press alt+shift+I to fix!")
        else:
            raise

</t>
<t tx="ekr.20100120092047.6137">@generic
def edit_object_in_leo(obj, varname):
    """ Make it @cl node so it can be pushed back directly by alt+I """
    node = add_var(varname)
    formatted = format_for_leo(obj)
    if not formatted.startswith('@cl'):
        formatted = '@cl\n' + formatted
    node.b = formatted 
    node.go()

</t>
<t tx="ekr.20100120092047.6138">@edit_object_in_leo.when_type(IPython.macro.Macro)
def edit_macro(obj,varname):
    bod = '_ip.defmacro("""\\\n' + obj.value + '""")'
    node = add_var('Macro_' + varname)
    node.b = bod
    node.go()

</t>
<t tx="ekr.20100120092047.6139">def get_history(hstart = 0):
    res = []
    ohist = ip.IP.output_hist 

    for idx in range(hstart, len(ip.IP.input_hist)):
        val = ohist.get(idx,None)
        has_output = True
        inp = ip.IP.input_hist_raw[idx]
        if inp.strip():
            res.append('In [%d]: %s' % (idx, inp))
        if val:
            res.append(pprint.pformat(val))
            res.append('\n')    
    return ''.join(res)
</t>
<t tx="ekr.20100120092047.6140">def lee_f(self,s):
    """ Open file(s)/objects in Leo

    - %lee hist -&gt; open full session history in leo
    - Takes an object. l = [1,2,"hello"]; %lee l.
      Alt+I in leo pushes the object back
    - Takes an mglob pattern, e.g. '%lee *.cpp' or %lee 'rec:*.cpp'
    - Takes input history indices:  %lee 4 6-8 10 12-47
    """
    import os

    try:
        if s == 'hist':
            wb.ipython_history.b = get_history()
            wb.ipython_history.go()
            return

        if s and s[0].isdigit():
            # numbers; push input slices to leo
            lines = self.extract_input_slices(s.strip().split(), True)
            v = add_var('stored_ipython_input')
            v.b = '\n'.join(lines)
            return

        # try editing the object directly
        obj = ip.user_ns.get(s, None)
        if obj is not None:
            edit_object_in_leo(obj,s)
            return

        # if it's not object, it's a file name / mglob pattern
        from IPython.external import mglob

        files = (os.path.abspath(f) for f in mglob.expand(s))
        for fname in files:
            p = g.findNodeAnywhere(c,'@auto ' + fname)
            if not p:
                p = c.currentPosition().insertAfter()

            p.setHeadString('@auto ' + fname)
            if os.path.isfile(fname):
                c.setBodyString(p,open(fname).read())
            c.selectPosition(p)
        print("Editing file(s), \
            press ctrl+shift+w in Leo to write @auto nodes")
    finally:
        c.redraw()
</t>
<t tx="ekr.20100120092047.6141">def leoref_f(self,s):
    """ Quick reference for ILeo """
    import textwrap
    print(textwrap.dedent("""\
    %lee file/object - open file / object in leo
    %lleo Launch leo (use if you started ipython first!)
    wb.foo.v  - eval node foo (i.e. headstring is 'foo' or '@ipy foo')
    wb.foo.v = 12 - assign to body of node foo
    wb.foo.b - read or write the body of node foo
    wb.foo.l - body of node foo as string list

    for el in wb.foo:
      print el.v

    """
    ))
</t>
<t tx="ekr.20100120092047.6142">def mb_f(self, arg):
    """ Execute leo minibuffer commands 

    Example:
     mb save-to-file
    """
    c.executeMinibufferCommand(arg)
</t>
<t tx="ekr.20100120092047.6143">def mb_completer(self,event):
    """ Custom completer for minibuffer """
    cmd_param = event.line.split()
    if event.line.endswith(' '):
        cmd_param.append('')
    if len(cmd_param) &gt; 2:
        return ip.IP.Completer.file_matches(event.symbol)

    # 2010/02/04: per 2to3
    cmds = list(c.commandsDict.keys())
    cmds.sort()
    return cmds

</t>
<t tx="ekr.20100120092047.6144">def ileo_pre_prompt_hook(self):
    # this will fail if leo is not running yet
    try:
        c.outerUpdate()
    except (NameError, AttributeError):
        pass
    raise TryNext

</t>
<t tx="ekr.20100120092047.6145">def show_welcome():
    print("------------------")
    print("Welcome to Leo-enabled IPython session!")
    print("Try %leoref for quick reference.")
    import IPython.platutils
    IPython.platutils.set_term_title('ILeo')
    IPython.platutils.freeze_term_title()

</t>
<t tx="ekr.20100120092047.6146">def run_leo_startup_node():
    p = g.findNodeAnywhere(c,'@ipy-startup')
    if p:
        print("Running @ipy-startup nodes")
        for n in LeoNode(p):
            push_from_leo(n)

</t>
<t tx="ekr.20100120092047.6147">def lleo_f(selg,  args):
    """ Launch leo from within IPython

    This command will return immediately when Leo has been
    launched, leaving a Leo session that is connected 
    with current IPython session (once you press alt+I in leo)

    Usage::
      lleo foo.leo
      lleo 
    """

    import shlex, sys,os
    argv = shlex.split(args)

    # when run without args, leo will open ipython_notebook for 
    # quick note taking / experimentation

    if not argv:
        argv = [os.path.join(ip.options.ipythondir,'ipython_notebook.leo')]

    sys.argv = ['leo'] + argv
    # if this var exists and is true, leo will "launch" (connect)
    # ipython immediately when it's started
    global _request_immediate_connect
    _request_immediate_connect = True
    import leo.core.runLeo
    leo.core.runLeo.run()

</t>
<t tx="ekr.20100120092047.6148">def lno_f(self, arg):
    """ %lno [note text]

    Gather quick notes to leo notebook

    """

    import time
    try:
        scr = wb.Scratch
    except AttributeError:
        print("No leo yet, attempt launch of notebook...")
        lleo_f(self,'')
        scr = wb.Scratch

    child = scr.get(arg, None)
    if child is None:
        scr[arg] = time.asctime()
        child = scr[arg]

    child.go()
</t>
<t tx="ekr.20100120092047.6149">def lshadow_f(self, arg):
    """ lshadow [path] 

    Create shadow nodes for path (default .)

    """
    if not arg.split():
        arg = '.'

    p = c.currentPosition().insertAfter()
    c.setCurrentPosition(p)
    shadow_walk(arg)
    c.redraw()
</t>
<t tx="ekr.20100120092047.6150">def shadow_walk(directory, parent=None, isroot=True):
    """ source: http://leo.zwiki.org/CreateShadows

    """

    from os import listdir
    from os.path import join, abspath, basename, normpath, isfile
    from fnmatch import fnmatch

    RELATIVE_PATHS = False

    patterns_to_ignore = [
        '*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']

    match = lambda s: any(fnmatch(s, p) for p in patterns_to_ignore)

    is_ignorable = lambda s: any([ s.startswith('.'), match(s) ])

    p = c.currentPosition()

    if not RELATIVE_PATHS: directory = abspath(directory)
    if isroot:
        body = "@path %s" % normpath(directory)
        c.setHeadString(p, body)
    for name in listdir(directory):
        if is_ignorable(name):
            continue
        path = join(directory, name)
        if isfile(path):
            g.es('file:', path)
            headline = '@shadow %s' % basename(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
        else:
            g.es('dir:', path)
            headline = basename(path)
            body = "@path %s" % normpath(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
            child.initBodyString(body)
            shadow_walk(path, parent=child, isroot=False)
</t>
<t tx="ekr.20100120092047.6151">def mkbutton(text, node_to_push):
    ib = c.frame.getIconBarObject()
    ib.add(text = text, command = node_to_push.ipush)

</t>
<t tx="ekr.20100120092047.6152">current = property(
    lambda self: LeoNode(c.currentPosition()),
    doc = "Currently selected node")
</t>
<t tx="ekr.20100122130101.6174">def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
</t>
<t tx="ekr.20100122130101.6175">def shouldDeleteChildren (self,root,thinFile):

    '''Return True if we should delete all children before a read.'''

    # Delete all children except for old-style @file nodes

    if root.isAtNoSentFileNode():
        return False
    elif root.isAtFileNode() and not thinFile:
        return False
    else:
        return True
</t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100125073206.8709" annotate="7d71002e">def getPythonEncodingFromString(s):

    '''Return the encoding given by Python's encoding line.
    s is the entire file.
    '''

    encoding = None
    tag,tag2 = '# -*- coding:','-*-'
    n1,n2 = len(tag),len(tag2)

    if s:
        # For Python 3.x we must convert to unicode before calling startswith.
        # The encoding doesn't matter: we only look at the first line, and if
        # the first line is an encoding line, it will contain only ascii characters.
        s = g.toUnicode(s,encoding='ascii',reportErrors=False)
        lines = g.splitLines(s)
        line1 = lines[0].strip()
        if line1.startswith(tag) and line1.endswith(tag2):
            e = line1[n1:-n2].strip()
            if e and g.isValidEncoding(e):
                encoding = e

    return encoding
</t>
<t tx="ekr.20100125073206.8710">def readFileIntoString (fn,
    encoding='utf-8',
    kind=None,
    mode='rb',
    raw=False,
    silent=False,
):

    '''Return the contents of the file whose full path is fn.

    Return (s,e)
    s is the string, converted to unicode, or None if there was an error.
    e the encoding line for Python files: it is usually None.
    '''

    try:
        e = None
        f = open(fn,mode)
        s = f.read()
        f.close()
        if raw:
            return s,None
        else:
            # Python's encoding comments override everything else.
            if s:
                junk,ext = g.os_path_splitext(fn)
                if ext == '.py':
                    e = g.getPythonEncodingFromString(s)
            s = g.toUnicode(s,encoding=e or encoding)
            return s,e
    except IOError:
        # Translate 'can not open' and kind, but not fn.
        # g.trace(g.callers(5))
        if not silent:
            if kind:
                g.es('can not open','',kind,fn,color='red')
            else:
                g.es('can not open',fn,color='red')
    except Exception:
        g.trace('unexpected exception reading %s' % (fn),color='red')
        g.es_exception()

    import leo.core.leoTest as leoTest
    leoTest.fail()
    return None,None
</t>
<t tx="ekr.20100126062623.6240">def internalError (*args):

    callers = g.callers(5).split(',')
    caller = callers[-1]
    g.es_print('Internal Leo error in',caller,color='red')
    g.es_print(*args)
    g.es_print('Called from',','.join(callers[:-1]))
</t>
<t tx="ekr.20100128094926.6222">Pmw should be deprecated.
</t>
<t tx="ekr.20100131161507.6303"># Just make the test.  It doesn't have to pass.
</t>
<t tx="ekr.20100203050306.5797">def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
</t>
<t tx="ekr.20100203050306.5937">def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if g.os_path_exists(fn):
            g.es('recreating:  ',g.shortFileName(fn),color='red')
        else:
            g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time: g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        # child.setBodyString('%s %s' % (tag,gnx))
        line1 = '%s %s\nDiff...\n' % (tag,gnx)
        d = difflib.Differ().compare(g.splitLines(b2),g.splitLines(b1))
        # d = difflib.unified_diff(g.splitLines(b2),g.splitLines(b1))
        diffLines = [z for z in d]
        lines = [line1]
        lines.extend(diffLines)
        # There is less need to show trailing newlines because
        # we don't report changes involving only trailing newlines.
        child.setBodyString(''.join(lines)) # .replace('\n','\\n\n'))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
</t>
<t tx="ekr.20100205152016.14055">gnx = 'ekr.20100205162207.5844'
for v in c.all_nodes():
    if v.gnx == gnx:
        print(v.h)</t>
<t tx="ekr.20100205162207.5844">print(p.v.gnx)

# ekr.20100205162207.5844
</t>
<t tx="ekr.20100206074650.5843"># This can be done in the trunk.
# For example new-complete commands.
</t>
<t tx="ekr.20100206074650.5844"></t>
<t tx="ekr.20100208062523.5885">class cacher:

    '''A class that encapsulates all aspects of Leo's file caching.'''

    @others
</t>
<t tx="ekr.20100208062523.5886">def __init__ (self,c=None):

    trace = False and not g.unitTesting
    if trace: g.trace('cacher','c',c)
    self.c = c

    # set by initFileDB and initGlobalDB...
    self.db = None # will be a PickleShareDB instance.
    self.dbdirname = None # A string.
    self.inited = False

</t>
<t tx="ekr.20100208065621.5890">def test(self):

    if g.app.gui.guiName() == 'nullGui':
        # Null gui's don't normally set the g.app.gui.db.
        g.app.setGlobalDb() 

    assert g.app.db
        # a cacher instance.
    assert g.app.db.db is not None
        # a PickleShareDB instance.

    # Make sure g.guessExternalEditor works.
    junk = g.app.db.db.get("LEO_EDITOR")

    self.initFileDB('~/testpickleshare')
    db = self.db
    db.clear()
    assert not list(db.items())
    db['hello'] = 15
    db['aku ankka'] = [1,2,313]
    db['paths/nest/ok/keyname'] = [1,(5,46)]
    db.uncache() # frees memory, causes re-reads later
    if 0: print(db.keys())
    db.clear()
    return True
</t>
<t tx="ekr.20100208065621.5894">'''A module encapsulating Leo's file caching'''

&lt;&lt; imports &gt;&gt;

# Abbreviations used throughout.
abspath     = g.os_path_abspath
basename    = g.os_path_basename
expanduser  = g.os_path_expanduser
isdir       = g.os_path_isdir
isfile      = g.os_path_isfile
join        = g.os_path_join
normcase    = g.os_path_normcase
split       = g.os_path_split

@others
</t>
<t tx="ekr.20100208071151.5901">def makeCacheList(self,p):

    '''Create a recursive list describing a tree
    for use by createOutlineFromCacheList.
    '''

    # This is called after at.copyAllTempBodyStringsToVnodes,
    # so p.b *is* the body text.

    return [
        p.h,p.b,p.gnx,
        [self.makeCacheList(p2) for p2 in p.children()]]
</t>
<t tx="ekr.20100208071151.5903"># Was atFile.writeCachedTree

def writeFile(self,p,fileKey):

    trace = False and not g.unitTesting
    verbose = False
    c = self.c

    # Bug fix: 2010/05/26: check g.enableDB before giving internal error.
    if not g.enableDB:
        if trace and verbose: g.trace('cache disabled')
    elif not fileKey:
        g.trace(g.callers(5))
        g.internalError('empty fileKey')
    elif fileKey in self.db:
        if trace: g.trace('already cached',fileKey)
    else:
        if trace: g.trace('caching ',p.h,fileKey)
        self.db[fileKey] = self.makeCacheList(p)
    if trace:g.trace('* callers',g.callers(4))
</t>
<t tx="ekr.20100208071151.5905">def readFile (self,fileName,root):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c

    if not g.enableDB:
        if trace: g.trace('g.enableDB is False')
        return '',False,None

    s,e = g.readFileIntoString(fileName,raw=True,silent=True)
    if s is None:
        if trace: g.trace('empty file contents',fileName)
        return s,False,None
    assert not g.isUnicode(s)

    if trace and verbose:
        for i,line in enumerate(g.splitLines(s)):
            print('%3d %s' % (i,repr(line)))

    # There will be a bug if s is not already an encoded string.
    key = self.fileKey(root.h,s,requireEncodedString=True)
    ok = self.db and key in self.db
    if trace: g.trace('in cache',ok,fileName,key)
    if ok:
        # Delete the previous tree, regardless of the @&lt;file&gt; type.
        while root.hasChildren():
            root.firstChild().doDelete()
        # Recreate the file from the cache.
        aList = self.db[key]
        self.createOutlineFromCacheList(root.v,aList,fileName=fileName)

    return s,ok,key
</t>
<t tx="ekr.20100208071151.5907"># was atFile._contentHashFile

def fileKey(self,s,content,requireEncodedString=False):

    '''Compute the hash of s (usually a headline) and content.
    s may be unicode, content must be bytes (or plain string in Python 2.x'''

    m = hashlib.md5()

    if g.isUnicode(s):
        s = g.toEncodedString(s)

    if g.isUnicode(content):
        if requireEncodedString:
            g.internalError('content arg must be str/bytes')
        content = g.toEncodedString(content)

    m.update(s)
    m.update(content)
    return "fcache/" + m.hexdigest()
</t>
<t tx="ekr.20100208071151.5910">def createOutlineFromCacheList(self,parent_v,aList,fileName,top=True):

    """ Create outline structure from recursive aList
    built by makeCacheList."""

    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    if not c:
        g.internalError('no c')

    if top:
        if trace and verbose: g.trace(fileName)
        c.cacheListFileName = fileName

    h,b,gnx,children = aList
    if h is not None:
        v = parent_v
        v._headString = h    
        v._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = self.fastAddLastChild(parent_v,gnx)

        if isClone:
            self.reportChangedClone(child_v,b,h,gnx)
        else:
            self.createOutlineFromCacheList(
                child_v,z,fileName,top=False)
</t>
<t tx="ekr.20100208071151.5911"># Similar to createThinChild4
def fastAddLastChild(self,parent_v,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    # parent_v = self
    indices = g.app.nodeIndices
    gnxDict = c.fileCommands.gnxDict

    if gnxString is None: v = None
    else:                 v = gnxDict.get(gnxString)
    is_clone = v is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'v',repr(v))

    if is_clone:
        pass
    else:
        v = leoNodes.vnode(context=c)
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            v.fileIndex = gnx
        gnxDict[gnxString] = v

    child_v = v
    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
</t>
<t tx="ekr.20100208082353.5918">def initFileDB (self,fn):

    trace = False and not g.unitTesting
    if trace: g.trace('inited',self.inited,repr(fn))

    if not fn: return

    pth, bname = split(fn)

    if pth and bname and g.enableDB:
        fn = fn.lower()
        fn = g.toEncodedString(fn) # Required for Python 3.x.

        # Important: this creates a top-level directory of the form x_y.
        # x is a short file name, included for convenience.
        # y is a key computed by the *full* path name fn.
        # Thus, there will a separate top-level directory for every path.
        self.dbdirname = dbdirname = join(g.app.homeLeoDir,'db',
            '%s_%s' % (bname,hashlib.md5(fn).hexdigest()))

        self.db = PickleShareDB(dbdirname)
        self.inited = True
</t>
<t tx="ekr.20100208082353.5919"></t>
<t tx="ekr.20100208082353.5920">def initGlobalDB (self):

    trace = False and not g.unitTesting

    if g.enableDB:
        dbdirname = g.app.homeLeoDir + "/db/global"
        self.db = db = PickleShareDB(dbdirname)
        if trace: g.trace(db,dbdirname)
        self.inited = True
        return db
    else:
        return None
</t>
<t tx="ekr.20100208082353.5922">def getCachedWindowPositionDict (self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        g.internalError('no commander')
        return {}

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)
    data = self.db.get('window_position_%s' % (key))

    if data:
        top,left,height,width = data
        top,left,height,width = int(top),int(left),int(height),int(width)
        d = {'top':top,'left':left,'height':height,'width':width}
    else:
        d = {}

    if trace: g.trace(fn,key,data)
    return d
</t>
<t tx="ekr.20100208082353.5923">def getCachedGlobalFileRatios (self):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    # globals_tag = g.toEncodedString(globals_tag,'ascii')

    key = self.fileKey(c.mFileName,globals_tag)

    ratio  = float(self.db.get('body_outline_ratio_%s' % (key),'0.5'))
    ratio2 = float(self.db.get('body_secondary_ratio_%s' % (key),'0.5'))

    if trace:
        g.trace('key',key,'%1.2f %1.2f' % (ratio,ratio2))

    return ratio,ratio2
</t>
<t tx="ekr.20100208082353.5924">def getCachedStringPosition(self):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    # globals_tag = g.toEncodedString(globals_tag,'ascii')

    key = self.fileKey(c.mFileName,globals_tag)
    str_pos = self.db.get('current_position_%s' % key)

    if trace: g.trace(str_pos,key)
    return str_pos
</t>
<t tx="ekr.20100208082353.5925"></t>
<t tx="ekr.20100208082353.5927"></t>
<t tx="ekr.20100208082353.5928">def setCachedStringPosition(self,str_pos):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    # globals_tag = g.toEncodedString(globals_tag,'ascii')

    key = self.fileKey(c.mFileName,globals_tag)
    self.db['current_position_%s' % key] = str_pos

    if trace: g.trace(str_pos,key)
</t>
<t tx="ekr.20100208082353.5929">def setCachedGlobalsElement(self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)

    if trace: g.trace(c.mFileName,key,g.callers(5))

    self.db['body_outline_ratio_%s' % key] = str(c.frame.ratio)
    self.db['body_secondary_ratio_%s' % key] = str(c.frame.secondary_ratio)
    if trace: g.trace('ratios: %1.2f %1.2f' % (
        c.frame.ratio,c.frame.secondary_ratio))

    width,height,left,top = c.frame.get_window_info()

    self.db['window_position_%s' % key] = (
        str(top),str(left),str(height),str(width))
    if trace:
        g.trace('top',top,'left',left,'height',height,'width',width)
</t>
<t tx="ekr.20100208095423.5940">import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()</t>
<t tx="ekr.20100208223942.10436">import sys
isPython3 = sys.version_info &gt;= (3,0,0)

import leo.core.leoGlobals as g
import leo.core.leoNodes as leoNodes

if isPython3:
    import pickle
else:
    import cPickle as pickle

import glob
import fnmatch
import hashlib
import os
import stat
# import time
import zlib

# try:
    # import marshal
# except ImportError:
    # marshal = None
</t>
<t tx="ekr.20100208223942.10452">def _makedirs(self,fn,mode=0o777):

    trace = False and not g.unitTesting
    if trace: g.trace(self.root)

    os.makedirs(fn,mode)

</t>
<t tx="ekr.20100208223942.10454">def _walkfiles(self,s, pattern=None):

    """ D.walkfiles() -&gt; iterator over files in D, recursively.

    The optional argument, pattern, limits the results to files
    with names that match the pattern.  For example,
    mydir.walkfiles('*.tmp') yields only files with the .tmp
    extension.
    """

    for child in self._listdir(s):
        if isfile(child):
            if pattern is None or self._fn_match(child,pattern):
                yield child
        elif isdir(child):
            for f in self._walkfiles(child,pattern):
                yield f

</t>
<t tx="ekr.20100208223942.10456">def _listdir(self,s, pattern=None):

    """ D.listdir() -&gt; List of items in this directory.

    Use D.files() or D.dirs() instead if you want a listing
    of just files or just subdirectories.

    The elements of the list are path objects.

    With the optional 'pattern' argument, this only lists
    items whose names match the given pattern.
    """

    names = os.listdir(s)

    if pattern is not None:
        names = fnmatch.filter(names, pattern)

    return [join(s,child) for child in names]

</t>
<t tx="ekr.20100208223942.10458">def _openFile(self,fn, mode='r'):

    """ Open this file.  Return a file object.

    Do not print an error message.
    It is not an error for this to fail. 
    """

    try:
        return open(fn, mode)
    except Exception:
        return None
</t>
<t tx="ekr.20100208223942.10460"># Used only by _normalized.

def _relpathto(self,src, dst):

    """ Return a relative path from self to dst.

    If there is no relative path from self to dst, for example if
    they reside on different drives in Windows, then this returns
    dst.abspath().
    """

    origin = abspath(src)
    dst = abspath(dst)
    orig_list = self._splitall(normcase(origin))
    # Don't normcase dst!  We want to preserve the case.
    dest_list = self._splitall(dst)

    if orig_list[0] != normcase(dest_list[0]):
        # Can't get here from there.
        return dst

    # Find the location where the two paths start to differ.
    i = 0
    for start_seg, dest_seg in zip(orig_list, dest_list):
        if start_seg != normcase(dest_seg):
            break
        i += 1

    # Now i is the point where the two paths diverge.
    # Need a certain number of "os.pardir"s to work up
    # from the origin to the point of divergence.
    segments = [os.pardir] * (len(orig_list) - i)
    # Need to add the diverging part of dest_list.
    segments += dest_list[i:]
    if len(segments) == 0:
        # If they happen to be identical, use os.curdir.
        return os.curdir
    else:
        return join(*segments)
</t>
<t tx="ekr.20100208223942.10462"># Used by relpathto.

def _splitall(self,s):
    """ Return a list of the path components in this path.

    The first item in the list will be a path.  Its value will be
    either os.curdir, os.pardir, empty, or the root directory of
    this path (for example, '/' or 'C:\\').  The other items in
    the list will be strings.

    path.path.joinpath(*result) will yield the original path.
    """
    parts = []
    loc = s
    while loc != os.curdir and loc != os.pardir:
        prev = loc
        loc,child = split(prev)
        if loc == prev:
            break
        parts.append(child)
    parts.append(loc)
    parts.reverse()
    return parts

</t>
<t tx="ekr.20100208223942.10464">def _fn_match(self,s, pattern):
    """ Return True if self.name matches the given pattern.

    pattern - A filename pattern with wildcards,
        for example '*.py'.
    """

    return fnmatch.fnmatch(basename(s), pattern)

</t>
<t tx="ekr.20100208223942.5967">_sentinel = object()

class PickleShareDB:

    """ The main 'connection' object for PickleShare database """

    @others
</t>
<t tx="ekr.20100208223942.5968"></t>
<t tx="ekr.20100208223942.5969">def __init__(self,root):

    """
    Init the PickleShareDB class.
    root: The directory that contains the data. Created if it doesn't exist.
    """

    trace = False and not g.unitTesting

    self.root = abspath(expanduser(root))

    if trace: g.trace('PickleShareDB',self.root)

    if not isdir(self.root):
        self._makedirs(self.root)

    self.cache = {}
        # Keys are normalized file names.
        # Values are tuples (obj, orig_mod_time)

    def loadz(fileobj):
        if fileobj:
            val = pickle.loads(
                zlib.decompress(fileobj.read()))
            return val
        else:
            return None

    def dumpz(val, fileobj):
        if fileobj:
            compressed = zlib.compress(pickle.dumps(
                val, pickle.HIGHEST_PROTOCOL))
            fileobj.write(compressed)

    self.loader = loadz
    self.dumper = dumpz
</t>
<t tx="ekr.20100208223942.5970">def __contains__(self, key):

    trace = False and g.unitTesting

    if trace: g.trace('(PickleShareDB)',key)

    return self.has_key(key)
</t>
<t tx="ekr.20100208223942.5971">def __delitem__(self,key):

    """ del db["key"] """

    trace = False and not g.unitTesting

    fn = join(self.root,key)

    if trace: g.trace('(PickleShareDB)',
        g.shortFileName(fn))

    self.cache.pop(fn,None)

    try:
        os.remove(fn)
    except OSError:
        # notfound and permission denied are ok - we
        # lost, the other process wins the conflict
        pass
</t>
<t tx="ekr.20100208223942.5972">def __getitem__(self,key):

    """ db['key'] reading """

    trace = False and not g.unitTesting

    fn = join(self.root,key)
    try:
        mtime = (os.stat(fn)[stat.ST_MTIME])
    except OSError:
        if trace: g.trace('***OSError',fn,key)
        raise KeyError(key)

    if fn in self.cache and mtime == self.cache[fn][1]:
        obj = self.cache[fn][0]
        if trace: g.trace('(PickleShareDB: in cache)',key)
        return obj
    try:
        # The cached item has expired, need to read
        obj = self.loader(self._openFile(fn,'rb'))
    except Exception:
        if trace: g.trace('***Exception',key)
        raise KeyError(key)

    self.cache[fn] = (obj,mtime)
    if trace: g.trace('(PickleShareDB: set cache)',key)
    return obj
</t>
<t tx="ekr.20100208223942.5973">def __iter__(self):

    trace = False and g.unitTesting

    if trace: g.trace('(PickleShareDB)',list(self.keys()))

    for k in list(self.keys()):
        yield k
</t>
<t tx="ekr.20100208223942.5974">def __repr__(self):

    return "PickleShareDB('%s')" % self.root



</t>
<t tx="ekr.20100208223942.5975">def __setitem__(self,key,value):

    """ db['key'] = 5 """

    trace = False and not g.unitTesting
    fn = join(self.root,key)

    if trace: g.trace('(PickleShareDB)',key)
    parent,junk = split(fn)

    if parent and not isdir(parent):
        self._makedirs(parent)

    self.dumper(value,self._openFile(fn,'wb'))

    try:
        mtime = os.path.getmtime(fn)
        self.cache[fn] = (value,mtime)
    except OSError as e:
        if trace: g.trace('***OSError')
        if e.errno != 2:
            raise
</t>
<t tx="ekr.20100208223942.5976">def _normalized(self, p):
    """ Make a key suitable for user's eyes """

    # os.path.relpath doesn't work here.

    return self._relpathto(self.root,p).replace('\\','/')

</t>
<t tx="ekr.20100208223942.5978">def clear (self,verbose=False):

    # Deletes all files in the fcache subdirectory.
    # It would be more thorough to delete everything
    # below the root directory, but it's not necessary.

    if verbose:
        g.es_print('clearing cache at directory...\n',
            color='red')
        g.es_print(self.root)

    for z in self.keys():
        self.__delitem__(z)
</t>
<t tx="ekr.20100208223942.5979">def get(self, key, default=None):

    trace = False and g.unitTesting
    if trace: g.trace('(PickleShareDB)')

    try:
        return self[key]
    except KeyError:
        return default
</t>
<t tx="ekr.20100208223942.5980">def has_key(self, key):

    trace = False and g.unitTesting
    if trace: g.trace('(PickleShareDB)',key)

    try:
        value = self[key]
    except KeyError:
        return False

    return True
</t>
<t tx="ekr.20100208223942.5981">def items(self):
    return [z for z in self]
</t>
<t tx="ekr.20100208223942.5982"># Called by clear, and during unit testing.

def keys(self, globpat = None):

    """Return all keys in DB, or all keys matching a glob"""

    trace = False and not g.unitTesting

    if globpat is None:
        files = self._walkfiles(self.root)
    else:
        files = [z for z in glob.glob(join(self.root,globpat))]

    result = [self._normalized(p) for p in files if isfile(p)]

    if trace: g.trace('(PickleShareDB)',len(result),result)

    return result
</t>
<t tx="ekr.20100208223942.5989">def uncache(self,*items):
    """ Removes all, or specified items from cache

    Use this after reading a large amount of large objects
    to free up memory, when you won't be needing the objects
    for a while.

    """

    trace = False and not g.unitTesting
    if trace: g.trace()

    if not items:
        self.cache = {}
    for it in items:
        self.cache.pop(it,None)

</t>
<t tx="ekr.20100209114432.5751"># Simplify the structure of the cache: put more into the "minor" files.
</t>
<t tx="ekr.20100209160132.5759">def clearCache (self):
    if self.db:
        self.db.clear(verbose=True)

def clearAllCaches (self):

    # Clear the global cacher.
    if g.app.db:
        g.app.db.clearCache()

    # Clear the cachers *only* for all open windows.
    # This is much safer than tryting to Kill all db's.
    for frame in g.windows():
        c = frame.c
        if c.cacher:
            c.cacher.clearCache()
</t>
<t tx="ekr.20100209160132.5763">def clearAllCaches (self,event=None):
    c = self.c
    if c.cacher:
        c.cacher.clearAllCaches()

def clearCache (self,event=None):
    c = self.c
    if c.cacher:
        c.cacher.clearCache()
</t>
<t tx="ekr.20100209160132.5770">@nocolor-node

Top-level folder are direct subfolders of .leo/db.
Top-level folders represent file *locations* not file contents.
Exception: the top-level "globals" folder represents minor data.

Only two files are ever needed in a top-level folder:

contents_&lt;key&gt;: the contents of the file.
data_&lt;key&gt;: a dict representing the "minor data" of the file:
    &lt;globals&gt; element stuff, expansion bits, etc.

We write contents_&lt;key&gt; only once.
By definition, its contents never changes, since the contents generates the key.
We can write data_&lt;key&gt; as many times as we like.

To do:
- Simplify or even eliminate the path-manipulation code in PickleShareDB.
- Use g.makeAllNonExistentDirectories to make top-level directories.
- Clear cache should clear all top-level directories.
</t>
<t tx="ekr.20100210102224.5744">@nocolor-node

Requirements:
    - Existing bindings must still be valid.
    - But @mode does not have to remain.

Think data:
    - Drive binding by tables.
    *** Design these tables first.
    - Table design should be flixible.
      It can change without affecting user.

keySequence class?
    - Represents a sequence of keystrokes.

bufferMode class?
    - Might encapsulate directives, etc.

bindHelper class?
    - Would mediate various aspects of binding.
    - c.bindHelper or k.bindHelper?
</t>
<t tx="ekr.20100210163813.5747">def save (self,fn,changeName):

    if changeName or not self.inited:
        self.initFileDB(fn)
</t>
<t tx="ekr.20100210163813.5748">@nocolor-node

This is a recent bug, but imo it has uncovered some other caching buglets. These
buglets are not big enough to delay Leo 4.7, but the new caching scheme would
ensure they never bite.

1. The code that computes what I have been calling the top-level directory is dubious::

    dbdirname = join(g.app.homeLeoDir,'db',
            '%s_%s' % (bname,hashlib.md5(fn).hexdigest()))

The problem is that bname is only the base name of the cached file, not a name
(or key) that depends on the full path. Thus, two copies of the same file in the
same place will be cached in the same directory. Is this ominous?

2. It's not clear what caching to do with the save-to command.
</t>
<t tx="ekr.20100210214809.5767">old,new = None,None
for child in p.children():
    if child.h.startswith('old'):
        old = child.copy()
    if child.h.startswith('new'):
        new = child.copy()
if old and new:
    print(old.b == new.b)
    if old.b != new.b:
        print('*' * 20)
        print(len(old.b),len(new.b))
        old_lines = g.splitLines(old.b)
        new_lines = g.splitLines(new.b)
        for i in range(max(len(old_lines),len(new_lines))):
            if (i &lt; len(old_lines) and i &lt; len(new_lines) and
                old_lines[i] == new_lines[i]
            ):
                pass
            else:
                if i &lt; len(old_lines):
                    print('old %2d %s' % (i,repr(old_lines[i])))
                if i &lt; len(new_lines):
                    print('new %2d %s' % (i,repr(new_lines[i])))</t>
<t tx="ekr.20100211072044.5754"></t>
<t tx="ekr.20100211095442.6201">@nocolor-node

1. Memory does leak, and that's not ok with me.  And I want just two
files per top-level directory.

2. Strange things can happen with caching, as just happened to me when
I restored qtui_generate.py mistakenly deleted from leo/test.  There
is an @auto node for this file in qtGui.py, and I got improper 'can
not open' messages for this file.

3. It is troubling that the present caching scheme does not use the
full path to a file, only the basename.  This means that two identical
files in two different places will use the same cache entries.  I've
been wondering for the last several days about whether this could
cause problems.  I don't know for sure, but I am uncomfortable.

4. I want the clear-cache and clear-all-caches commands to do what
they say: get rid of everything.  Among other things, this is good for
debugging and recovering from cache problems.

</t>
<t tx="ekr.20100216141722.5620">class goToLineNumber:

    '''A class implementing goto-global-line.'''

    @others
</t>
<t tx="ekr.20100216141722.5621">def __init__ (self,c):

    # g.trace('(c.gotoLineNumber)')
    self.c = c
    self.p = c.p.copy()
</t>
<t tx="ekr.20100216141722.5622">def go (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self.c
    if n &lt; 0: return

    if scriptData:
        fileName,lines,p,root = self.setup_script(scriptData)
    else:
        if not p: p = c.p
        fileName,lines,n,root = self.setup_file(n,p)

    isRaw = not root or (
        root.isAtEditNode() or root.isAtAsisFileNode() or
        root.isAtAutoNode() or root.isAtNoSentFileNode())
    ignoreSentinels = root and root.isAtNoSentFileNode()
    if not root:
        if scriptData:  root = p.copy()
        else:           root = c.p

    if isRaw:
        p,n2,found = self.countLines(root,n)
        n2 += 1 # Convert to one-based.
    else:
        vnodeName,gnx,n2,delim = self.findVnode(root,lines,n,ignoreSentinels)
        p,found = self.findGnx(delim,root,gnx,vnodeName)

    self.showResults(found,p or root,n,n2,lines)
    return found
</t>
<t tx="ekr.20100216141722.5623">def countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False and not g.unitTesting
    c = self.c

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
</t>
<t tx="ekr.20100216141722.5624">def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n,
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0 ; n1 = n
    effective_lines = 0 ; skipped_lines = 0
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n + skipped_lines is the target line number.
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %s effective %s skipped %s %s' % (
            i,effective_lines,skipped_lines,line.rstrip()))
        if line.strip().startswith('@'):
            skipped_lines += 1
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        assert effective_lines2 &lt;= new_n
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        elif i == n + skipped_lines: # Found the line.
            if trace:
                g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
            return p,i,-1,True # effective_lines doesn't matter.
        else:
            effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i &gt; progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
</t>
<t tx="ekr.20100216141722.5625">def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*5,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            assert effective_lines2 &lt;= new_n
            # i2 is not used
            effective_lines += effective_lines2
            if trace:
                g.trace('Not found. effective_lines2: %s %s' % (
                    effective_lines2,child.h))
    else:
        return p,-1,effective_lines,False # i does not matter.
</t>
<t tx="ekr.20100216141722.5626">def findGnx (self,delim,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    trace = False and not g.unitTesting

    if delim and gnx:
        gnx = g.app.nodeIndices.scanGnx(gnx,0)
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(),True

        if trace: g.trace('not found! %s, %s' % (gnx,repr(vnodeName)))
        return None,False
    else:
        return root,False
</t>
<t tx="ekr.20100216141722.5627">def findRoot (self,p):

    '''Find the closest ancestor @&lt;file&gt; node, except @all nodes.

    return root, fileName.'''

    c = self.c ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions():
        if p.v == p1.v and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
</t>
<t tx="ekr.20100216141722.5628">def findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    trace = False and not g.unitTesting
    c = self.c
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    delim,readVersion5,thinFile = self.setDelimFromLines(lines)
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    nodeLine,offset = self.findNodeSentinel(delim,lines,n)
    if nodeLine == -1:
        if n &lt; len(lines):
            # The line precedes the first @+node sentinel
            g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeLine]
    gnx,vnodeName = self.getNodeLineInfo(readVersion5,s,thinFile)
    if delim and vnodeName:
        if trace: g.trace('offset: %s, vnodeName: %s' % (offset,vnodeName))
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
</t>
<t tx="ekr.20100216141722.5629">def findNodeSentinel(self,delim,lines,n):

    '''
    Scan backwards from the line n, looking for an @-body line. When found,
    get the vnode's name from that line and set p to the indicated vnode. This
    will fail if vnode names have been changed, and that can't be helped.

    We compute the offset of the requested line **within the found node**.
    '''

    c = self.c
    offset = 0 # This is essentially the Tk line number.
    nodeSentinelLine = -1
    line = n - 1 # Start with the requested line.
    while len(lines) &gt; line &gt;= 0 and nodeSentinelLine == -1:
        progress = line
        s = lines[line]
        i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            line,nodeSentinelLine,offset = self.handleDelim(
                delim,s,i,line,lines,n,offset)
        else:
            line -= 1
        assert nodeSentinelLine &gt; -1 or line &lt; progress
    return nodeSentinelLine,offset
</t>
<t tx="ekr.20100216141722.5630">def handleDelim (self,delim,s,i,line,lines,n,offset):

    '''Handle the delim while scanning backward.'''

    trace = False and not g.unitTesting
    c = self.c
    if line == n:
        g.es("line",str(n),"is a sentinel line")
    i += len(delim)
    nodeSentinelLine = -1

    # This code works for both old and new sentinels.
    if g.match(s,i,"-node"):
        # The end of a nested section.
        old_line = line
        line = self.skipToMatchingNodeSentinel(lines,line,delim)
        assert line &lt; old_line
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"+node"):
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
        line -= 1
    else:
        line -= 1
        nodeSentinelLine = -1
    return line,nodeSentinelLine,offset
</t>
<t tx="ekr.20100216141722.5631">def getNodeLineInfo (self,readVersion5,s,thinFile):

    i = 0 ; gnx = None ; vnodeName = None

    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:   gnx = s[i:j]
            else:       i = len(s) # Force an error.
        else:
            i = len(s) # Force an error.

    # old sentinels: vnode name is everything following the first or second':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
        if readVersion5: # new sentinels: remove level stars.
            vnodeName = self.removeLevelStars(vnodeName)
    else:
        vnodeName = None
        g.es_print("bad @+node sentinel",color='red')

    return gnx,vnodeName
</t>
<t tx="ekr.20100216141722.5632">def setDelimFromLines (self,lines):

    c = self.c ; at = c.atFileCommands

    # Find the @+leo line.
    i = 0 
    while i &lt; len(lines) and lines[i].find("@+leo")==-1:
        i += 1
    leoLine = i # Index of the line containing the leo sentinel

    # Set delim and thinFile from the @+leo line.
    delim,thinFile = None,False

    if leoLine &lt; len(lines):
        s = lines[leoLine]
        valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
        readVersion5 = at.readVersion5

        # New in Leo 4.5.1: only support 4.x files.
        if valid and newDerivedFile:
            delim = start + '@'
    else:
        readVersion5 = False

    return delim,readVersion5,thinFile
</t>
<t tx="ekr.20100216141722.5633">def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
</t>
<t tx="ekr.20100216141722.5634">def getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self.c
    isAtEdit = root.isAtEditNode()
    isAtNoSent = root.isAtNoSentFileNode()

    if isAtNoSent or isAtEdit:
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        kind = g.choose(isAtNoSent,'@nosent','@edit')
        at.write(root,kind=kind,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        path = g.scanAllAtPathDirectives(c,root)
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = self.openFile(fileName)

    return lines
</t>
<t tx="ekr.20100216141722.5635">def openFile (self,filename):
    """
    Open a file and check if a shadow file exists.
    Construct a line mapping. This ivar is empty if no shadow file exists.
    Otherwise it contains a mapping, shadow file number -&gt; real file number.
    """

    c = self.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
</t>
<t tx="ekr.20100216141722.5636">def setup_file (self,n,p):

    '''Return (lines,n) where:

    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    '''

    c = self.c ; x = c.shadowController

    root,fileName = self.findRoot(p)

    if root and fileName:
        c.shadowController.line_mapping = [] # Set by open.
        lines = self.getFileLines(root,fileName)
            # This will set x.line_mapping for @shadow files.
        if len(x.line_mapping) &gt; n:
            n = x.line_mapping[n]
    else:
        if not g.unitTesting:
            g.es("no ancestor @&lt;file node&gt;: using script line numbers",
                color="blue")
        lines = g.getScript(c,p,useSelectedText=False)
        lines = g.splitLines(lines)

    return fileName,lines,n,root
</t>
<t tx="ekr.20100216141722.5637">def setup_script (self,scriptData):

    c = self.c

    p = scriptData.get('p')
    root,fileName = self.findRoot(p)
    lines = scriptData.get('lines')

    return fileName,lines,p,root
</t>
<t tx="ekr.20100216141722.5638">def showResults(self,found,p,n,n2,lines):

    trace = False and not g.unitTesting
    c = self.c ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)
    else:
        ins = len(s)
        if len(lines) &lt; n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    if trace:
        i,j = g.getLine(s,ins)
        g.trace('found: %5s %2s %2s %15s %s' % (
            found,n,n2,p.h,repr(s[i:j])))  

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
</t>
<t tx="ekr.20100219075946.5742">class phpScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20100219075946.5743">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = True # 2010/02/19
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in range(127,256)]
    self.chars.extend(extra)
</t>
<t tx="ekr.20100219075946.5744">def isPurePHP (self,s):

    '''Return True if the file begins with &lt;?php and ends with ?&gt;'''

    s = s.strip()

    return (
        s.startswith('&lt;?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?&gt;'))

</t>
<t tx="ekr.20100219075946.5745"># Does not create @first/@last nodes
</t>
<t tx="ekr.20100219075946.5746">def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'&lt;&lt;&lt;')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
</t>
<t tx="ekr.20100219075946.5747">def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.

    For Php, the first id is better.'''

    return ids and ids[1]
</t>
<t tx="ekr.20100219083854.5615"></t>
<t tx="ekr.20100220190251.5616"># See handleCodeMode
</t>
<t tx="ekr.20100220190251.5617">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac

The indentation of the second @doc causes the doc part to look like
a continuation of the code:: directive.

It's not clear whether this bug is worth fixing, and it's not clear whether
there would be side effects of any potential fix.

The simplest fix appears to be in handleCodeMode.
</t>
<t tx="ekr.20100220204150.5627">@ @rst-options
verbose=True
code_mode=True
show_doc_parts_as_paragraphs=True
number_code_lines=True
write_intermediate_file=True
@c

</t>
<t tx="ekr.20100220204150.5628">@
Greet the world, politely
@c

g.es ("Hello, world")

@
    Was that polite enough?
    Indentation.
@c
</t>
<t tx="ekr.20100221142603.5638">@language python

&lt;&lt; imports &gt;&gt;
@others
&lt;&lt; defines &gt;&gt;

recentCoreList = (
    ('leoPlugins',''),
)

recentPluginsList = (
    ('screenshots',''),
)

tables_table = (
    (recentCoreList,'core'),
    (recentPluginsList,'plugins'),
    # (coreList,'core'),
    # (guiPluginsTable,'plugins'),
    # (tkPass,'plugins'),
    # (passList,'plugins'),
    # (externalList,'external'),
    # (pluginsTable,'plugins'),
)

for table,theDir in tables_table:
    if table in (tkPass,passList,coreList,externalList):
        for fn in table:
            run(theDir,fn,suppress='')
    else:
        for fn,suppress in table:
            run(theDir,fn,suppress)
</t>
<t tx="ekr.20100221142603.5639">import os
import sys
from pylint import lint

</t>
<t tx="ekr.20100221142603.5640">def getCoreList():

    return (
        'leoApp','leoAtFile','leoCache','leoChapters','leoCommands',
        'leoEditCommands','leoFileCommands','leoFind','leoFrame',
        'leoGlobals','leoGui','leoImport','leoMenu','leoNodes',
        'leoPlugins','leoShadow','leoTangle','leoUndo',
    )
</t>
<t tx="ekr.20100221142603.5641">def getPassList():

    return (
        '__init__','FileActions','UNL',
        'active_path','add_directives','attrib_edit',
        'backlink','base64Packager','baseNativeTree','bibtex','bookmarks',
        'codewisecompleter','colorize_headlines','contextmenu',
        'ctagscompleter','cursesGui','datenodes','debugger_pudb',
        'detect_urls','dtest','empty_leo_file','enable_gc','initinclass',
        'leo_to_html','leo_interface','leo_pdf','leo_to_rtf',
        'leoOPML','leoremote','lineNumbers',
        'macros','mime','mod_autosave','mod_framesize','mod_leo2ascd',
        'mod_scripting','mod_speedups','mod_timestamp',
        'nav_buttons','nav_qt','niceNosent','nodeActions','nodebar',
        'open_shell','outline_export','quit_leo',
        'paste_as_headlines','plugins_menu','pretty_print','projectwizard',
        'qt_main','qt_quicksearch','qtframecommands',
        'quickMove','quicksearch','redirect_to_log','rClickBasePluginClasses',
        'run_nodes', # Changed thread.allocate_lock to threading.lock().acquire()
        'rst3',
        'scrolledmessage','setHomeDirectory','slideshow','spydershell','startfile',
        'testRegisterCommand','todo','trace_gc_plugin','trace_keys','trace_tags',
        'vim','xemacs',
    )
</t>
<t tx="ekr.20100221142603.5642">def getPluginsTable ():

    return (
        ('mod_scripting','E0611'),
            # Harmless: E0611:489:scriptingController.runDebugScriptCommand:
            # No name 'leoScriptModule' in module 'leo.core'
        ('open_with',''),
        ('toolbar','E1101,W0221,W0511'),
            # Dangerous: many erroneous E1101 errors
            # Harmless: W0221: Arguments number differs from overridden method
            # Harmless: W0511: Fixme and to-do.
        ('UNL',''),
            # Dangerous: one E0611 error: 94: No name 'parse' in module 'urllib'
        ('vim',''),
        ('xemacs',''),
    )
</t>
<t tx="ekr.20100221142603.5643">def getTkPass():

    return (
        'EditAttributes','Library',
        'URLloader','UniversalScrolling','UASearch',
        'autotrees','chapter_hoist','cleo','dump_globals',
        'expfolder','geotag','graphed','groupOperations',
        'hoist','import_cisco_config',
        'keybindings','leoupdate',
        'maximizeNewWindows', 'mnplugins','mod_labels',
        'mod_read_dir_outline','mod_tempfname','multifile',
        'newButtons','nodeActions','nodenavigator',
        'open_with','pie_menus','pluginsTest',
        'read_only_nodes','rClick',
        'scheduler','searchbar','searchbox','shortcut_button',
        'script_io_to_body','searchbox',
        'templates','textnode','tkGui','toolbar',
        'xcc_nodes',
    )
</t>
<t tx="ekr.20100221142603.5644">def run(theDir,fn,suppress):
    fn = os.path.join('leo',theDir,fn)
    args = ['--rcfile=leo/test/pylint-leo-rc.txt']
    if suppress: args.append('--disable-msg=%s' % (suppress))
    fn = os.path.abspath(fn)
    if not fn.endswith('.py'): fn = fn+'.py'
    args.append(fn)
    if os.path.exists(fn):
        print('*****',fn,suppress)
        lint.Run(args)
    else:
        print('file not found:',fn)
</t>
<t tx="ekr.20100221142603.5645">coreList = getCoreList()
externalList = ('ipy_leo','lproto',)
guiPluginsTable = (
    ('qtGui','W0221'),
    ('tkGui','W0221'),
)
passList = getPassList()
pluginsTable = getPluginsTable()
tkPass = getTkPass()
</t>
<t tx="ekr.20100223075705.5635"></t>
<t tx="ekr.20100223094350.5834">def skipToTheNextClassOrFunction(self,s,i,lastIndent):

    '''Skip to the next python def or class.
    Return the original i if nothing more is found.
    This allows the "if __name__ == '__main__' hack
    to appear at the top level.'''

    return i ### A rewrite may be needed.

    trace = False # and not g.unitTesting
    c,found,i1 = self.c,False,i
    at_line_start,last_comment,last_nl = True,None,-1
    while i &lt; len(s):
        progress = i
        if self.startsComment(s,i):
            # Break at underindented comments.
            if at_line_start:
                if i == last_nl:
                    n = 0
                else:
                    ws = s[last_nl+1:i]
                    n = g.computeWidth (ws,c.tab_width)
                if n &lt; lastIndent:
                    if trace: g.trace('underindented comment',
                        'ws',repr(ws),'n',n,'lastIndent',lastIndent)
                    found = True ; break
                else:
                    # Remember the start of a range of comments and whitespace.
                    if last_comment is None:
                        last_comment = i
                    last_nl = i = self.skipComment(s,i)
                    at_line_start = True
            else:
                # An interior comment.
                assert last_comment is None
                last_nl = i = self.skipComment(s,i)
                at_line_start = True
        elif self.startsString(s,i):
            at_line_start = False
            last_comment = None
            i = self.skipString(s,i)
        elif at_line_start and (
            g.match_word(s,i,'def') or
            g.match_word(s,i,'class')
        ):
            # Do not break for over-indent matches.
            # This allows something reasonable to happen for::
            # if 0:
            #     def spam():
            #         pass
            ws = s[last_nl+1:i]
            # g.trace('ws',repr(ws))
            n = g.computeWidth (ws,c.tab_width)
            if (not ws or ws.isspace()) and n &lt;= lastIndent:
                found = True ; break
            else: # Ignore the over-indented def.
                if trace: g.trace('overindented','ws',repr(ws),
                    'n',n,'lastIndent',lastIndent)
                last_comment = None
                last_nl = i = g.skip_to_end_of_line(s,i)
                at_line_start = True
        elif s[i] == '@':
            # Leo directives will look like comments,
            # so we can safely assume we have a decorator
            if at_line_start and last_comment is None:
                last_comment = i
            last_nl = i = g.skip_to_end_of_line(s,i)
            at_line_start = True
        elif s[i] ==  '\n':
            at_line_start = True
            last_nl = i
            i += 1
        elif s[i].isspace():
            i += 1
        else:
            at_line_start = False
            last_comment = None
            i += 1
        assert progress &lt; i

    if found:
        if last_comment is None:
            return i
        else:
            return last_comment
    else:
        return i1
</t>
<t tx="ekr.20100223100750.5842">http://groups.google.com/group/pyxides

Robin Dunn's post, reproduced at:
http://groups.google.com/group/leo-editor/browse_thread/thread/4f76a0f57759aba
continues to be one of the benchmarks for Leo.

Leo 4.7 went out the door today.  It contains many important
improvements, but few directly related to Robin's important post.
That doesn't mean Robin's post is irrelevant, but it does mean that
other considerations were more relevant :-)  In particular, Leo passes
all unit tests with Python 2.6 and Python 3.1.

Leo 4.8 will concentrate on better support for vim-like bindings.  As
a happy side effect, this will make Leo compliant with almost all
unfinished aspects of Robin's mission.

There are two major items from Robin's list that are incomplete in
Leo:

* The Kill-Ring.  Leo does have a kill ring.  The vim work will fix
discrepancies between how Leo, emacs and vim handle the kill ring.

* Good keystroke macro recording and the ability to save and load
keystroke macros.  This happen as part of support for vim's "dot"
command.  To some extent, Leo's execute-script command compensates for
wimpy macro support, but I'd like to do better.

The following could be done easily using Leo's @command or @button
features.  There doesn't seem to be much demand for them in Leo, but
I'll list them here for completeness.

- Flexible build/grep commands.
- Interactive diffs, merges and applying of patches.
- Able to be a front-end for gdb. (Leo has a plugin to do this).
- Able to be a front-end for CVS, SVN, etc.
- Have a built-in psychotherapist or be able to play towers of
hanoi.  ;-)

As always, I invite you all to try Leo, and to ask for features that
would be important to you.

======

P.S. Leo does have auto-completion.  It will be improved in Leo 4.9.

</t>
<t tx="ekr.20100223100750.5843">@nocolor-node

Here are the emacs features that I use very often that any editor would
need to have in order for me to switch.  I've seen some editors with
some of these, but none with all unless it is an emacs clone.  I'll
leave out the obvious things like platform independence, good syntax
highlighting, calltips or auto-completion.  Also, these features are
just dealing with the code editor portion of the app, if it is more than
that (like a full IDE) then some of these things may or may not apply to
the non code editor parts:

* (done) Python should be just one of the languages that this editor supports,
not the primary target.  I spend as much time in C/C++ as I do Python,
and my editor of choice needs to help me with C/C++ coding just as much
as it does with Python.  So some sort of support for calltips and
auto-completion would be marvelous, and also being able to act as a
front-end for gdb since I currently use emacs for that most of the time.

* (done) Absolutely every feature or action must be able to be done with just
the keyboard.  Moving the hand back and forth to the mouse wastes time,
breaks concentration and contributes to RSI.  Multi-key sequences are
fine as long as they are grouped in a logical fashion.  For example in
emacs all of the version control features are accessible via the
Ctrl-x,v sequence plus one more letter.

* (done) Incremental search, both forward and reverse, and wrapping around
after you've reached the end or the beginning of the document.  I like
to have the same key to start the search and also do a search-next after
you've typed all the characters you are searching for, and also to have
backspace go back one search position and/or remove one character from
the search text.

* (done) Multiple top level windows, and able to show any buffer in any TLW,
including those that are already displayed in another TLW.  Of course
there should be key-bindings available for opening a new TLW, cycling
forward and backward through the buffer list, and a way to select a
buffer from a popup list of buffer/file names.

* (to be improved) The Kill-Ring.  For those of you that have never used an emacs-like
editor it works like this:  There is a collection of the N previous
blocks of text that have been cut or copied (in emacs 'cut' == 'kill'
more or less)  When I do a yank (paste) it uses the last thing put in
the kill-ring.  If I then immediately use another key-binding then it
replaces that pasted text with the next item in the kill ring, and so on
until I eventually wrap around get back to the first one in the ring, or
I do some other command or move the cursor somewhere else.

* (done) Registers.  A text snippet can be copied into a register, which is
like the kill ring except you refer to each one by name, where the names
are 'a' through 'z'.  You can also append to a register that already has
text in it, and you can paste the contents of a register into the
document at the current cursor location.

* (done) Able to have selections be either a stream of characters or a
rectangle.  A stream selection is like what you have in all text
editors, it starts from position a on line N and continues forward or
back to position b on line M and includes all the characters in between.

  A rectangle selection is all the characters between position a and b
on lines N to M.  In other words, it has width and height and it might
be something like positions 5 through 10 on lines 20 to 25.  Cutting or
deleting a rectangle removes the text in the rectangle and shifts any
text to the right of the rectangle over.  It does not remove any lines
although they may end up being empty.  Pasting a rectangle inserts the
new text with the upper-left of the rectangle at the current cursor
position, shifts existing text to the right if needed, and fills with
spaces on the left if a line affected by the paste is not long enough.
New lines are not added unless the file needs to be extended to
accommodate the rectangle paste.  Rectangles can also be put into registers.

* (to be improved) Good keystroke macro recording and the ability to save and load
keystroke macros, and the ability to assign a key-binding to a saved
recorded macro. Any time I need to make the same edits to a bunch of
lines or groups of lines I'll record doing it on the first one including
the keystrokes needed to reposition for the next line, and then stop
recording and then it's just one keystroke to replay the keystrokes for
every other line that needs it done.  I record, use and throw away up to
a dozen or so macros per day.

* (done, and better than asserted) If you must have a toolbar make it optional
and keep it simple. Toolbars require the mouse and the goal is to keep the hand
off the mouse as much as possible.

* (done) Similarly, avoid using popup dialogs whenever possible.  This includes
things like the file dialog.  I don't mind seeing the file dialog if I
select a menu item, because most likely my hand is already on the mouse,
but the rest of the time I just want to hit a key, type a path name
(with tab-completion to help find stuff, up/down keys to cycle through
past selections) and press enter.  So I would prefer this editor to have
something like emacs' minibuffer, or the QuickFind panel in Firefox.  In
other words, when there is something you would normally use a dialog for
just create a small panel that rolls up from the bottom of the frame,
put the keyboard focus there, perhaps do stuff in the main buffer as
they are typing if appropriate, and then when the user is done the panel
rolls out of sight again and keyboard focus is restored to their active
buffer.  This can be done for file open/saves, search &amp; replace,
specifying build or grep commands (see next item) choosing to execute
some editor function by name that may not have some key-binding yet (see
item after next) etc.

* (done, with user @commands)

Flexible build/grep commands.  Emacs handles both of these in almost
the same way so I'll list them together here.  I hit a key and am
presented with either the default, or the most recently used compile or
grep command.  I can edit the command or use the up/down arrows to
select previous commands that I've used.  I then hit enter and emacs
runs the command putting the output in an editor buffer.  There is a key
I can hit to kill the compile if needed.  It then parses the output and
there is a key I can use to find the file listed in the compile or grep
output, load it, and position the cursor on the reported line.  (This
can even be done while the compile/grep is still running.)

* (done) For access to editor commands/functionality that may not be bound to a
keystroke it's real nice to have the ability to hit a key, type the
command name, press enter and then it's done.  This can also allow for
commands that might need to prompt for parameters, be interactive, etc.
  All editor commands should be named and can be bound to keys by name
or executed by name in this way.

* (done) Regex search.  Emacs has support for regular expression search modes
for all of the search types, incremental search, search/replace,
although I don't use it that much.

* (done, or not needed, depending on your point of view)
Multi-file search and replace.  Be able to select files interactively,
or by wildcard, or both.  Enter search string, or regex, and replace
text.  The editor loads each file and does the search, allowing you to
choose for each one whether to do the replacement, or replace all.

* If it is a full IDE it would be nice to have a way to start just the
code editor portion for quick edits.

Things that would be nice to have, but that I could live without:

(All of these things can be done easily with @command)

* Interactive diffs, merges and applying of patches.

* Able to be a front-end for gdb.

* Able to be a front-end for CVS, SVN, etc.

* (done) Be able to run shell commands, or the shell itself in an editor buffer.

* (easy) have a built-in psychotherapist or be able to play towers of hanoi.  ;-) 
</t>
<t tx="ekr.20100223123910.5835"></t>
<t tx="ekr.20100223123910.5930">@
The present operation of recent files is surprising.

Recent files should be a global list, managed by a single controller.
</t>
<t tx="ekr.20100223133351.5996"># for v in c.all_unique_nodes():
n = 0
g.es('cleaning',c.p.h)
for p in c.p.self_and_subtree():
    print(p.h)
    lines = []
    for s in g.splitLines(p.b):
        if s.strip():
            lines.append(s)
        else:
            # Ensures a trailing newline.
            lines.append('\n')
    s2 = ''.join(lines)
    if s2 != p.b:
        p.b = s2
        p.v.setDirty()
        n += 1

c.redraw()
g.es('cleaned %s nodes' % n)
</t>
<t tx="ekr.20100223133351.5998"></t>
<t tx="ekr.20100223133351.5999"># This works, but splitting long lines by hand
# is the very essence of stupidity.

# Don't use this script!
# Use a *reliable* pep8 tool instead.

g.es('finding long lines in',p.h)
found = False
while p and not found:
    for line in g.splitLines(p.b):
        if len(line) &gt; 80:
            found = True
            g.es('long line in',p.h)
            c.selectPosition(p)
            break
    else:
        p.moveToThreadNext()
g.es('done')</t>
<t tx="ekr.20100224050618.11547">def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
</t>
<t tx="ekr.20100225053729.5761"># Strips comments and context lines from a diff
# so real changes can be seen more easily.

result = []
for s in g.splitLines(p.b):
    if s.startswith('===') or s.startswith('+') or s.startswith('-'):
        i = s.find('#')
        if i &gt; -1:
            result.append(s[:i] + '\n')
        else:
            result.append(s)

p.b = ''.join(result)

</t>
<t tx="ekr.20100225102636.5627"># It should be possible to avoid duplicate reads.
</t>
<t tx="ekr.20100303074003.5636">def restoreCursorAndScroll (self,w):

    v = self

    if v and v.insertSpot != None:
        spot = v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)

    # Restore the scroll spot after the call to w.see.
    if v and v.scrollBarSpot != None:
        first,last = v.scrollBarSpot
        w.setYScrollPosition(first)
</t>
<t tx="ekr.20100303074003.5637">def restoreCursorAndScroll (self,w):

    self.v.restoreCursorAndScroll(w)

def saveCursorAndScroll (self,w):

    self.v.saveCursorAndScroll(w)
</t>
<t tx="ekr.20100303074003.5638">def saveCursorAndScroll(self,w):

    v = self
    if not w: return

    v.scrollBarSpot = w.getYScrollPosition()
    v.insertSpot = w.getInsertPoint()
</t>
<t tx="ekr.20100329071036.5744">def is_binary_file (f):

    if g.isPython3:
        return f and isinstance(f,io.BufferedIOBase)
    else:
        g.internalError('g.is_binary_file called from Python 2.x code')
</t>
<t tx="ekr.20100407063358.5748">import inspect

fn = g.os_path_finalize_join(g.app.loadDir,'leoNodes.py')

m = __import__ ('leoNodes')
# print(m)

classes = inspect.getmembers(m,inspect.isclass)
# print(classes)
print('='*20)
for z in classes:
    name,value = z
    print(name)
    members = inspect.getmembers(value)
    print('members of',name)
    for name2,value2 in members:
        if False: # not name2.startswith('__'):
            print('  ',name2)
        if name2 == '__init__':
            print('__init__',value2)
            if inspect.isfunction(value2):
                init_members = inspect.getmembers(value2)
                print('init members')
                for name3,value3 in init_members:
                    if not name3.startswith('__'):
                        print('    ',name3)</t>
<t tx="ekr.20100506062734.5756">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ee84e52fba476950

&gt; Some of the UI's I've worked with involved going into a state where
&gt; you picked from a numbered, or lettered list of possibilities
&gt; generated based on the currently typed "trigger".  e.g. and expansion
&gt; of trigger "ct" puts a ine like the following in, say, the status
&gt; line:

Note that all design work is unnecessary - this is basically a simple
matter of bugfixing.

qtGui has this method:

http://pastebin.com/GmhZJqDd

Once you can call

w.showCompleter(['hello', 'helloworld'], mycallback )

and select the correct alternative naturally with keyboard (now you
need mouse), almost all of the work is done.

The rest can be provided by codewisecompleter, or any other kind of
completer we may wish to add (e.g. hippie-expand, abbrev expand...).

All discussion regarding the ui design only helps to sidetrack us from
getting a completer that behaves the way completers are "supposed to
behave" on 2010, i.e. the way provided by QCompleter.

-- 
Ville M. Vainio 
</t>
<t tx="ekr.20100507084415.5760">def scanAtRootDirectives(aList):

    '''Scan aList for @root directives.'''

    for d in aList:
        s = d.get('root')
        if s is not None:
            i, mode = g.scanAtRootOptions(s,0)
            g.trace(mode)
            return mode

    return None
</t>
<t tx="ekr.20100515063611.5801">n = 0

for p in c.all_positions():
    n = max(n,p.level())

g.es('n',n)

last = 0
delta = 0
d = {}

for p in c.all_positions():
    n = p.level()
    if n &lt; last:
        delta = max(delta,last-n)
        d [last-n] = d.get(last-n,0) + 1
    last = n

g.es('delta',delta)
g.es('d',d)
</t>
<t tx="ekr.20100518083515.5896">def sentinelKind4_helper(self,s):

    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s = s[:i] + s[i:].replace('@@','@')

    # New sentinels.
    if g.match(s,i,"@+"):
        if g.match(s,i+2,"others"):
            return at.startOthers
        elif g.match(s,i+2,"&lt;&lt;"):
            return at.startRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"&lt;&lt;"):
                return at.startRef
    elif g.match(s,i,"@-"):
        if g.match(s,i+2,"others"):
            return at.endOthers
        elif g.match(s,i+2,"&lt;&lt;"):
            return at.endRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"&lt;&lt;"):
                return at.endRef
    # Old sentinels.
    elif g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j &gt; i+1:
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"@-others"):
                return at.endOthers
            elif g.match(s,j,"&lt;&lt;"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@&lt;&lt;"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) &gt; 0 and key in at.sentinelDict:
        return at.sentinelDict[key]
    else:
        return at.noSentinel
</t>
<t tx="ekr.20100521090440.5885"></t>
<t tx="ekr.20100521090440.5886">@nocolor-node

I put the following in qtGui.py after

# Last minute-munges to keysym.

    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            tkKey = stroke = darwinmap[tkKey]

It works quite reasonabe. Sometimes (not really well reproducable)
following message appears:

/Users/tst/Leo-4.7-final/leo/core/leoKeys.py:3363: UnicodeWarning:
Unicode equal comparison failed to convert both arguments to Unicode -
interpreting them as being unequal
  if k.abortAllModesKey and stroke == k.abortAllModesKey:
/Users/scalet/Leo-4.7-final/leo/core/leoKeys.py:2521: UnicodeWarning:
Unicode equal comparison failed to convert both arguments to Unicode -
interpreting them as being unequal
  if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-
g'

nonetheless the special characters were inserted as expected.

I think all this is quite a hack, but ... thanks for the hack, most
important for me it's working for now. 
</t>
<t tx="ekr.20100521090440.5887">Just playing with part of a template system, the (partial) mock up for
"range()" is:

def tabStopNaming (event=None):

  stateName = 'naming'
  k = c.k
  state = k.getState(stateName)

  help = ('start-value -- optional, -&gt; fill-in or tab eliminate.  ',
           'end-value -- required, -&gt; fill-in.  ',
           'step -- optional, -&gt;fill-in or tab to eliminate.  ')
  tabStop = ('start-value', 'end-value', 'step')

  if state == 0:
      k.setLabelBlue(help[0],protect=True)
      k.getArg(event,stateName,1,tabStopNaming)
      # g.es('does this ever executed?') # yes, imediately!
  else:
      k.clearState()
      g.es_print('%s : %s' % (tabStop[0], k.arg))
      k.setLabelBlue('')

tabStopNaming()

=====================================================
This is hardwired for the first parameter.  Things I need to expand
this:

1. put in a variable that cycles through the tabStops

2. In this mock up, you are entering the parameters in the minibuffer,
a more advanced version would collect each keypress and put it in the
body at the current tabStop, a tab would finalize the entry and
advance to the next stop, no text other than the 'help', ends up in
the minibuffer.

Sinc I'm only modifying existing code without real understanding of
what Leo is doing, andy guidance would be appreciated.

Tom

=======================

Thanks for this work.  You obviously understand the present code well
enough to play with it.

Generalizing the minibuffer code would be a good thing to do.  I
suppose we could define some kind of language that would create, or
rather simulate, hand-written code.  In a sense, @mode nodes are
intended to do this also.

As I look at leoKeys.py again I'll keep this example in the back of my
mind as something that it would be good to support more easily.

Edward
</t>
<t tx="ekr.20100521090440.5890"></t>
<t tx="ekr.20100521090440.5893">def onActivateEvent (self,*args,**keys):
    pass

def onDeactivateEvent(self,*args,**keys):
    pass
</t>
<t tx="ekr.20100521130114.5904">@nocolor-node

We want better docs, automatically, and a way to update @enabled-plugins.

http://groups.google.com/group/leo-editor/browse_thread/thread/b409aac6ca8cd33b
</t>
<t tx="ekr.20100522090453.5912">@nocolor-node

&gt; In the @file family of derived files (@thin, @nosent, etc.)  (i.e.,
&gt; not @root), you can prevent any interpretation of the immediately
&gt; following line with the "@verbatim" directive

This is not true, although it might appear to be true.

There is an @verbatim *sentinel*, but no @verbatim *directive*.

For example, I have just verified that the following does not work:

@verbatim
&lt;&lt; undefined ref &gt;&gt;

@raw and @end_raw do work as described.

There appear to be several bugs in this area:

1. Leo probably should warn that @verbatim does not exist as a
directive, although technically Leo is supposed to write anything that
looks like a sentinel but isn't "verbatim".

2. Leo does appear to read @raw and @end_raw properly in @thin files,
but Leo improperly issues the (red) log message,
converting @file format in @thin test_verbatim_sentinel.py
</t>
<t tx="ekr.20100616083554.5922">def config_iter(self,c):

    '''Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    '''

    names = [] # Already-handled settings names.
    result = []

    if c:
        d = self.localOptionsDict.get(c.hash())
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,c,'F'),)

    for d in self.localOptionsList:
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,None,letter),)

    for d in self.dictList:
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,None,letter),)

    result.sort()
    for z in result:
        yield z

    raise StopIteration
</t>
<t tx="ekr.20100616083554.5923">def config_iter_helper (self,d,names):

    if not d: return []

    result = []
    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')
    theHash = d.get('_hash').lower()

    if theHash.endswith('myleosettings.leo'):
        letter = 'M'
    elif theHash.endswith('leosettings.leo'):
        letter = ' '
    else:
        letter = 'D' # Default setting.

    for key in d:
        if key not in suppressKeys and key not in names:
            bunch = d.get(key)
            if bunch and bunch.kind not in suppressKind:
                names.append(key)
                result.append((key,bunch.val,letter),)

    return result
</t>
<t tx="ekr.20100619222623.5918">@nocolor-node
@

Surprisingly, it's easier to read new sentinels than to read old sentinels:

- There must be closing sentinels for section references and the @all and
  @others directives, collectively known as **embedding constructs.** Indeed,
  these constructs do not terminate the node in which they appear, so without a
  closing sentinel there would be no way to know where the construct ended and
  the following lines of the enclosing node began.

- The read code "accumulates" body text of node v in v.tempBodyList, a list of
  lines. A post-pass assigns v.tempBodyString = ''.join(v.tempBodyList). This
  assignment **terminates** the node.

- The new read code *never* terminates the body text of a node until the
  post-pass. This is the crucial simplification that allows the read code not to
  need @-node sentinels.

- An older version of the body text exists for v iff v has the tempBodyString
  attribute. It is *essential* not to create this attribute until finalizing v.
  The read code warns (creates a "Recovered Nodes" node) if the previous value
  of v.tempBodyString does not match ''.join(tempBodyList) when v is terminated.

- The read code for new sentinels creates nodes using the node-level stars, by
  making the new node at level N a child of of the previous node at level N-1.

Other notes.

- Leo no longer maintains the "spelling" of whitespace before embedding constructs.
  This can never cause any harm.

- Leo does not write @nonl or @nl sentinels when writing new sentinels. In
  effect, this "regularizes" body text so that it always ends with at least one
  blank. Again, this can never cause any harm, because nodes must be terminated
  (in the external file), by a newline the precedes the next sentinel.
  Eliminating @nonl and @nl sentinels simplifies the appearance of the external
  file an reduces spurious sccs diffs.

- Leo always writes private @shadow files using old sentines. This guarantees
  permanent compatibility with older versions of Leo.
</t>
<t tx="ekr.20100624082003.5938">def readStartAt (self,s,i):

    """Read an @+at sentinel."""

    at = self
    assert g.match(s,i,"+at"),'missing +at'
    i += 3

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
</t>
<t tx="ekr.20100624082003.5939">def readStartDoc (self,s,i):

    """Read an @+doc sentinel."""

    at = self
    assert g.match(s,i,"+doc"),'missing +doc'
    i += 4

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]+'\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
</t>
<t tx="ekr.20100624082003.5940">def skipToEndSentinel(self,s,i):

    '''Skip to the end of the sentinel line.'''

    at = self
    end = at.endSentinelComment

    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
</t>
<t tx="ekr.20100624082003.5942">def appendToDocPart (self,s):

    at = self
    trace = False and at.readVersion5 and not g.unitTesting

    # Skip the leading stuff
    if len(at.endSentinelComment) == 0:
        # Skip the single comment delim and a blank.
        i = g.skip_ws(s,0)
        if g.match(s,i,at.startSentinelComment):
            i += len(at.startSentinelComment)
            if g.match(s,i," "): i += 1
    else:
        i = at.skipIndent(s,0,at.indent)

    if at.readVersion5:
        # Append the line to docOut.
        line = s[i:]
        at.docOut.append(line)
    else:
        # Append line to docOut, possibly stripping the newline.
        line = s[i:-1] # remove newline for rstrip.

        if line == line.rstrip():
            # no trailing whitespace: the newline is real.
            at.docOut.append(line + '\n')
        else:
            # trailing whitespace: the newline is fake.
            at.docOut.append(line)

    if trace: g.trace(repr(line))
</t>
<t tx="ekr.20100625085138.5953">def parseThinNodeSentinel (self,s,i):

    at = self

    def oops(message):
        if g.unitTesting: g.trace(message,repr(s))
        else: at.readError(message)
        return None,None,None,False

    j = s.find(':',i)
    if j == -1:
        return oops('Expecting gnx in @+node sentinel')
    else:
        gnx = s[i:j]

    if at.readVersion5:
        if not g.match(s,j,': '):
            return oops('Expecting space after gnx')
        i = j + 2
        if not g.match(s,i,'*'):
            return oops('No level stars')
        i += 1
        if g.match(s,i,' '):
            level = 1 ; i += 1
        elif g.match(s,i,'* '):
            level = 2 ; i += 2
        else:
            # The level stars have the form *N*.
            level = 0  ; j = i
            while i &lt; len(s) and s[i].isdigit():
                i += 1
            if i &gt; j:
                level = int(s[j:i])
            else:
                return oops('No level number')
            if g.match(s,i,'* '):
                i += 2
            else:
                return oops('No space after level stars')
    else: # not readVersion5.
        i = j + 1 # Skip the gnx.
        level = 0

    return gnx,i,level,True
</t>
<t tx="ekr.20100625085138.5955">def getNodeHeadline (self,s,i):

    '''Set headline to the rest of the line.
    Don't strip leading whitespace.'''

    at = self

    if len(at.endSentinelComment) == 0:
        h = s[i:-1].rstrip()
    else:
        k = s.rfind(at.endSentinelComment,i)
        h = s[i:k].rstrip() # works if k == -1

    # Undo the CWEB hack: undouble @ signs if\
    # the opening comment delim ends in '@'.
    if at.startSentinelComment[-1:] == '@':
        h = h.replace('@@','@')

    return h
</t>
<t tx="ekr.20100625085138.5957">def createNewThinNode (self,gnx,headline,level):

    at = self
    trace = False and at.readVersion5 and not g.unitTesting

    if at.thinNodeStack:
        if at.readVersion5:
            oldLevel = len(at.thinNodeStack)
            newLevel = level - 1
            assert newLevel &gt;= 0,'newLevel &gt;= 0'
            if trace: g.trace('old',oldLevel,'new',newLevel,headline)
            at.changeLevel(oldLevel,newLevel)
            v = at.createThinChild4(gnx,headline)
            at.thinNodeStack.append(v)
            # Terminate a previous clone if it exists.
            # Do not use the full terminateNode logic!
            if hasattr(v,'tempBodyList'):
                v.tempBodyString = ''.join(v.tempBodyList)
                delattr(v,'tempBodyList')
            else:
                # Major bug fix: 2010/07/6:
                # Do *not* create v.tempBodyString here!
                # That would tell at.copyAllTempBodyStringsToVnodes
                # that an older (empty) version exists!
                pass
        else:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
    else:
        v = at.root.v
        at.thinNodeStack.append(v)

    at.lastThinNode = v
    return v
</t>
<t tx="ekr.20100625092449.5963">def appendToOut (self,s):

    '''Append s to at.out (old sentinels) or
       at.v.tempBodyList (new sentinels).'''

    at = self
    trace = False and at.readVersion5 and not g.unitTesting

    if at.readVersion5:
        if not at.v: at.v = at.root.v
        if hasattr(at.v,"tempBodyList"):
            at.v.tempBodyList.append(s)
        else:
            at.v.tempBodyList = [s]
    else:
        at.out.append(s)

    if trace:
        g.trace('%4s %25s %s' % (
            g.choose(at.inCode,'code','doc'),at.v.h,repr(s)))
</t>
<t tx="ekr.20100625140824.5968">def readEndRef (self,unused_s,unused_i):

    """Read an @-&lt;&lt; sentinel."""

    at = self

    at.popSentinelStack(at.endRef)

    if at.readVersion5:
        # Terminate the *previous* doc part if it exists.
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
            at.docOut = []
            at.inCode = True

        # Restore the node containing the section reference.
        # *Never* terminate new-sentinel nodes until the post-pass.
        at.raw = False # End raw mode.
        at.lastRefNode = at.v # A kludge for at.readAfterRef
        at.v = at.endSentinelNodeStack.pop()
        at.indent = at.endSentinelIndentStack.pop()
        oldLevel = len(at.thinNodeStack)
        newLevel = at.endSentinelLevelStack.pop()
        at.changeLevel(oldLevel,newLevel)
</t>
<t tx="ekr.20100625184546.5979">def parseNodeSentinel (self,s,i,middle):

    at = self

    if middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        if not g.match(s,i,'+node:'): g.trace(repr(s[i:i+40]),g.callers(5))
        assert g.match(s,i,"+node:"),'missing +node:'
        i += 6

    # Get the gnx and the headline.
    if at.thinFile:
        gnx,i,level,ok = at.parseThinNodeSentinel(s,i)
        if not ok: return None,None,None,False
    else:
        gnx,level = None,None

    headline = at.getNodeHeadline(s,i)
    return gnx,headline,i,level,True
</t>
<t tx="ekr.20100628072537.5814">def terminateNode (self,middle=False,v=None):

    '''Set the body text of at.v, and issue warning if it has changed.

    This is called as follows:

    old sentinels: when handling a @-node sentinel.
    new sentinels: from the post-pass when v.tempBodyList exists.'''

    at = self
    trace = False and at.readVersion5 and not g.unitTesting
    postPass = v is not None
        # A little kludge: v is given only when this is called
        # from copyAllTempBodyStringsToVnodes.
    if not v: v = at.v

    if at.readVersion5:
        # A vital assertion.
        # We must *never* terminate a node before the post pass.
        assert postPass,'terminateNode'

    # Get the temp attributes.
    hasString  = hasattr(v,'tempBodyString')
    hasList    = hasattr(v,'tempBodyList')
    tempString = hasString and v.tempBodyString or ''
    tempList   = hasList and ''.join(v.tempBodyList) or ''

    # Compute the new text.
    new = g.choose(at.readVersion5,tempList,''.join(at.out))
    new = g.toUnicode(new)
    if trace: g.trace('%28s %s' % (v.h,repr(new)))

    if at.importing:
        v._bodyString = new # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        at.terminateBody(v,postPass)

    # *Always delete tempBodyList.  Do not leave this lying around!
    if hasattr(v,'tempBodyList'): delattr(v,'tempBodyList')
</t>
<t tx="ekr.20100628124907.5816">def indicateNodeChanged (self,old,new,postPass,v):

    at = self ; c = at.c

    if at.perfectImportRoot:
        if not postPass:
            at.correctedLines += 1
            at.reportCorrection(old,new,v)
            v._bodyString = new # Allowed use of _bodyString.
                # Just setting v.tempBodyString won't work here.
            v.setDirty()
                # Mark the node dirty. Ancestors will be marked dirty later.
            c.setChanged(True)
    else:
        # Do nothing if only trailing whitespace is involved.
        if new.endswith('\n') and old == new[:-1]: return
        if old.endswith('\n') and new == old[:-1]: return
        # if old == new.rstrip(): return
        # if new == old.rstrip(): return

        c.nodeConflictList.append(g.bunch(
            tag='(uncached)',
            gnx=v.gnx,
            fileName = at.root.h,
            b_old=old,
            b_new=new,
            h_old=v._headString,
            h_new=v._headString,
        ))

        if not g.unitTesting:
            g.es_print("uncached read node changed",v.h,color="red")

        v.setDirty()
            # Just set the dirty bit. Ancestors will be marked dirty later.
        c.changed = True
            # Important: the dirty bits won't stick unless we set c.changed here.
            # Do *not* call c.setChanged(True) here: that would be too slow.
</t>
<t tx="ekr.20100628124907.5818">def reportCorrection (self,old,new,v):

    at = self
    found = False
    for p in at.perfectImportRoot.self_and_subtree():
        if p.v == v:
            found = True ; break

    if found:
        if 0: # For debugging.
            g.pr('\n','-' * 40)
            g.pr("old",len(old))
            for line in g.splitLines(old):
                #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
                g.pr(repr(str(line)))
            g.pr('\n','-' * 40)
            g.pr("new",len(new))
            for line in g.splitLines(new):
                #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
                g.pr(repr(str(line)))
            g.pr('\n','-' * 40)
    else:
        # This should never happen.
        g.es("correcting hidden node: v=",repr(v),color="red")
</t>
<t tx="ekr.20100629190353.5831">at.putIndent(at.indent)

if not at.endSentinelComment:
    at.os(at.startSentinelComment) ; at.oblank()

at.os(s)
if not s.endswith('\n'): at.onl()
</t>
<t tx="ekr.20100630144047.5783">def changeLevel (self,oldLevel,newLevel):

    '''Update data structures when changing node level.'''

    at = self ; c = at.c

    # Crucial: we must be using new-style sentinels.
    assert at.readVersion5,'at.readVersion5'
    assert at.thinFile,'at.thinFile'
    assert not at.importing,'not at.importing'

    if newLevel &gt; oldLevel:
        assert newLevel == oldLevel + 1,'newLevel == oldLevel + 1'
    else:
        while oldLevel &gt; newLevel:
            oldLevel -= 1
            at.indentStack.pop()
            at.thinNodeStack.pop()
            at.vStack.pop()
        assert oldLevel == newLevel,'oldLevel == newLevel'
        assert len(at.thinNodeStack) == newLevel,'len(at.thinNodeStack) == newLevel'

    # The last node is the node at the top of the stack.
    at.lastThinNode = at.thinNodeStack[-1]
</t>
<t tx="ekr.20100701112151.5959">def getDiff (self,s1,s2):

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diffLines = difflib.Differ.compare(lines1,lines2)
    return diffLines
</t>
<t tx="ekr.20100702062857.5824">def terminateBody (self,v,postPass=False):

    '''Terminate the scanning of body text for node v.'''

    trace = False and not g.unitTesting
    at = self

    hasString  = hasattr(v,'tempBodyString')
    hasList    = hasattr(v,'tempBodyList')
    tempString = hasString and v.tempBodyString or ''
    tempList   = hasList and ''.join(v.tempBodyList) or ''

    # The old temp text is *always* in tempBodyString.
    new = g.choose(at.readVersion5,tempList,''.join(at.out))
    new = g.toUnicode(new)
    old = tempString or v.getBody()
        # v.getBody returns v._bodyString.

    # Warn if the body text has changed.
    # Don't warn about the root node.
    if v != at.root.v and old != new:
        if postPass:
            warn = old # The previous text must exist.
        else:
            warn = old and new # Both must exit.
        if warn:
            at.indicateNodeChanged(old,new,postPass,v)

    # *Always* put the new text into tempBodyString.
    v.tempBodyString = new

    if trace: g.trace(
        v.gnx,
        'tempString %3s getBody %3s old %3s new %3s' % (
            len(tempString),len(v.getBody()),len(old),len(new)),
        v.h,at.root.h)
        # '\n* callers',g.callers(4))

    # *Always delete tempBodyList.  Do not leave this lying around!
    if hasList: delattr(v,'tempBodyList')
</t>
<t tx="ekr.20100705083838.5740">def reportChangedClone (self,child_v,b,h,gnx):

    trace = False and not g.unitTesting
    c = self.c
    fileName=c.cacheListFileName
    old,new = child_v.b,b

    same = (
        old == new or
        new.endswith('\n') and old == new[:-1] or
        old.endswith('\n') and new == old[:-1])

    # if trace and not same:
    if trace and (not same or h == 'writeException'):
        g.trace('same %s old %s new %s %s %s' % (
            same,len(old),len(new),h,fileName))

    # This would make it impossible to clear nodes!
    # if not new: return same

    if same: return

    c.nodeConflictList.append(g.bunch(
        tag='(cached)',
        fileName=fileName,
        gnx=gnx,
        b_old=child_v.b,
        h_old=child_v.h,
        b_new=b,
        h_new=h,
    ))

    # Always issue the warning.
    g.es_print("cached read node changed:",child_v.h,color="red")

    child_v.h,child_v.b = h,b
    child_v.setDirty()
    c.changed = True # Tell getLeoFile to propegate dirty nodes.
</t>
<t tx="ekr.20100709113505.6291"></t>
<t tx="ekr.20100728074713.5840">@nocolor-node
@

This discussion is adapted from a thread on the leo-editor group:
http://groups.google.com/group/leo-editor-users/msg/b148d8fb3338e6a9
of January 22, 2010.  Feel free to ask more questions there.

leoImport.py contains a set of "importers" all based on the
baseScannerClass class. You can define your own importer by creating a
subclass. With luck, your subclass might be very simple, as with class
cScanner. In other words, baseScannerClass is supposed to do almost
all the work.

**Important**  As I write this, I realize that I remember very little
about the code, but I do remember its general organization and the
process of creating a new importer. Here is all I remember, and it
should be all you need to write any importer.

This base class has two main parts:

1. The "parser" that recognizes where nodes begin and end.

2. The "code generator" the actually creates the imported nodes.

You should never have to change the code generators.  Confine your
attention to the parser.

The parser thinks it is looking for classes, and within classes,
method definitions.  Your job is to tell the parser how to do this.
Let's look at the ctor for baseScannerClass for clues:

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.

Yes, this looks like gibberish at first. I do *not* remember what all
these things do in detail, although obviously the names mean
something. What I *do* remember is that these ivars control the
operation of the startsFunction and startsClass methods and their
helpers (children) *especially startsHelper* and the methods that call
them, scan and scanHelper. Oh, and one more thing. You may want to set
hasClasses = False.

Most of these methods have a trace var that will enable tracing during
importing. The high-level strategy is simple: study startsHelper in
detail, set the ivars above to make startsHelper do what you want, and
trace until things work as you want :-)

There is one more part of this high-level strategy. Sometimes the
ivars above are not sufficient to make startsHelper work properly. In
that case, subclasses will override various methods of the parser, but
*not* the code generator.

For example, if indentation affects parsing, you will want to look at
the Python importer to see how it works--it overrides skipCodeBlock, a
helper of startsHelper. Others common overrides redefine what a
comment or string is. For more details, look at the various scanners
to see the kinds of tricks they use.

That's it. It would be pointless to give you more details, because
those details would lead you *away* from the process you need to
follow.  It's this process/strategy that is important.
</t>
<t tx="ekr.20100728074713.5843">def removeLevelStars (self,s):

    i = g.skip_ws(s,0)

    # Remove leading stars.
    while i &lt; len(s) and s[i] == '*':
        i += 1
    # Remove optional level number.
    while i &lt; len(s) and s[i].isdigit():
        i += 1
    # Remove trailing stars.
    while i &lt; len(s) and s[i] == '*':
        i += 1
    # Remove one blank.
    if i &lt; len(s) and s[i] == ' ':
        i += 1

    return s[i:]
</t>
<t tx="ekr.20100802121531.5804">def deletePositionsInList (self,aList,callback=None):

    '''Traverse the tree starting from self until all nodes in aList have been
    found.

    This method calls the callback for any position in aList found in the range,
    excluding any node whose ancestor has already been passed to the callback.

    The callback takes one explicit argument, p. As usual, the callback can bind
    values using keyword arguments. The callback may delete p or move p out of
    the range. The callback **must not** move p within range of the traversal.
    If no callback is given, this method deletes all found nodes.
    '''

    if callback is None:
        def callback(p):
            p.doDelete(newNode=None)

    p = self.copy()
    while p and aList:
        # g.trace(repr(p))
        if p in aList:
            aList.remove(p)
            for z in aList:
                if p.isAncestorOf(z):
                    aList.remove(z)
            next = p.nodeAfterTree()
            callback(p.copy())
            p = next
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20100803073751.5817">def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
</t>
<t tx="ekr.20100803073751.5818">def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


</t>
<t tx="ekr.20100803231223.5807">class iniScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,
            importCommands,atAuto=atAuto,language='ini')

        # Override defaults defined in the base class.
        self.classTags = []
        self.functionTags = []
        self.hasClasses = False
        self.hasFunctions = True
        self.lineCommentDelim = ';'

    def startsString(self,s,i):
        return False

    @others
</t>
<t tx="ekr.20100803231223.5808">def scanIniText (self,s,parent,atAuto=False):

    scanner = iniScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
</t>
<t tx="ekr.20100803231223.5810">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    sigStart = i
    ok,sigId,i = self.isSectionLine(s,i)
    if not sigId or not ok:
        # if trace: g.trace('fail',repr(g.getLine(s,i)))
        return False

    i = sigEnd = g.skip_line(s,i)

    # Skip everything until the next section.
    while i &lt; len(s):
        progress = i
        ok,junk,junk = self.isSectionLine(s,i)
        if ok: break # don't change i.
        i = g.skip_line(s,i)
        assert progress &lt; i

    # Success: set the ivars.
    self.sigStart = sigStart
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = None

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    if trace: g.trace(sigId,'returns\n'+s[self.sigStart:i]+'\nEND')
    return True
</t>
<t tx="ekr.20100803231223.5815">def isSectionLine(self,s,i):

    i = g.skip_ws(s,i)
    if not g.match(s,i,'['):
        return False,None,i
    k = s.find('\n',i+1)
    if k == -1: k = len(s)
    j = s.find(']',i+1)
    if -1 &lt; j &lt; k:
        return True,s[i:j+1],i
    else:
        return False,None,i
</t>
<t tx="ekr.20100804095820.5812">@nocolor-node

Fix in g.os_path_isabs

Edward, not sure if you're following this thread, but the fix turned out to be
entangled with a lot of @&lt;file&gt; stuff, so I don't want to push it without your
inspection.

Repeating the basic problem: for an @&lt;file&gt; node there is some parent path in
effect at the point where you reach the node, based on the location of the .leo
file and any relevant @path directives. For determination of the full path to
the target file, the @&lt;file&gt; node can either extend the parent path with a
relative path (simplest case, just the filename), or discard the parent path
with an absolute path of its own. The problem arises when the @&lt;file&gt; introduces
a Windows drive specific \absolute\path without specifying the drive. In that
case the drive should come from the original parent path.

I think the diff below does that ok. It might do it in more places than was
needed to fix the original problem, but I don't think it does it in any places
where it shouldn't.

Also, I think the same issue would affect the scanning of @path directives, this
diff doesn't address that, although the fix_windows_absolute() method it
introduces could probably be used for that application also. Here's the diff:

=== modified file 'leo/core/leoAtFile.py'
--- leo/core/leoAtFile.py 2010-08-03 22:26:10 +0000
+++ leo/core/leoAtFile.py 2010-08-05 22:24:42 +0000
@@ -688,6 +688,8 @@
         else:
             fileName = None

+ fileName = g.fix_windows_absolute(self.c, root, fileName)
+
         return fileName
     #@+node:ekr.20100224050618.11547: *5* at.isFileLike
     def isFileLike (self,s):
@@ -2815,7 +2817,10 @@
                 at.targetFileName = root.atFileNodeName()
         else:
             at.targetFileName = root.atFileNodeName()
+
+ at.targetFileName = g.fix_windows_absolute(at.c, root, at.targetFileName)
         #@-&lt;&lt; set at.targetFileName &gt;&gt;
+
         at.initWriteIvars(root,at.targetFileName,
             nosentinels = nosentinels, thinFile = thinFile,
             scriptWrite = scriptWrite, toString = toString)
@@ -5166,7 +5171,9 @@
         else:
             fn = p.anyAtFileNodeName()
         if fn:
+ fn = g.fix_windows_absolute(c, p, fn)
             path = g.os_path_finalize_join(path,fn)
+
         else:
             g.trace('can not happen: not an @&lt;file&gt; node:',g.callers(4))
             for p2 in p.self_and_parents():

=== modified file 'leo/core/leoCommands.py'
--- leo/core/leoCommands.py 2010-08-01 17:16:51 +0000
+++ leo/core/leoCommands.py 2010-08-05 22:59:13 +0000
@@ -559,6 +559,7 @@
             if name: break

         if name:
+ name = g.fix_windows_absolute(self, p, name)
             name = g.os_path_finalize_join(path,name)
         return name
     #@+node:ekr.20091211111443.6265: *3* c.doBatchOperations &amp; helpers

=== modified file 'leo/core/leoGlobals.py'
--- leo/core/leoGlobals.py 2010-07-31 12:00:58 +0000
+++ leo/core/leoGlobals.py 2010-08-05 22:52:47 +0000
@@ -936,6 +936,9 @@
     if name:
         theDir = g.os_path_dirname(name)
         if theDir and g.os_path_isabs(theDir):
+
+ theDir = g.fix_windows_absolute(c,p,theDir)
+
             if g.os_path_exists(theDir):
                 default_di...

=========================

Ville M. Vainio wrote on 2010-08-06: 	#18

For performance reasons the first thing you check before doing
anything else should be:

 if path[0] != "\\": return path

</t>
<t tx="ekr.20100812082517.5939">def write_code_tree (self,p,fn):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % fn)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
</t>
<t tx="ekr.20100812082517.5945">def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None,toString=False):

    '''Format the presently selected node as computer code.

    Settings from scriptSettingsDict override normal settings.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p
    self.topNode = p.copy()
    self.topLevel = p.level()

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # Init options...
    self.preprocessTree(p)
    self.init_write(p) # scanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    fn = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,ext = g.os_path_splitext(fn)

    # Write the rst sources to self.sources...
    self.outputFile = StringIO()
    self.write_code_tree(p,fn)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
</t>
<t tx="ekr.20100812082517.5963">def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
</t>
<t tx="ekr.20100812082517.5964">def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                    part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
</t>
<t tx="ekr.20100812082517.5965">def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
</t>
<t tx="ekr.20100812082517.5966">def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
</t>
<t tx="ekr.20100812082517.5967">def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20100812082517.5968">def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20100812172650.5909">def findTestScript(c,h,where=None):

    if where:
        p = g.findNodeAnywhere(c,where)
        if p:
            p = g.findNodeInTree(c,p,h)
    else:
        p = g.findNodeAnywhere(c,h)

    if p:
        return g.getScript(c,p)
    else:
        return None
</t>
<t tx="ekr.20100813041139.5912">def createIntermediateFile(self,fn,s):

    '''Write s to to the file whose name is fn.'''

    ext = self.getOption('write_intermediate_extension')
    ext = ext or '.txt' # .txt by default.
    if not ext.startswith('.'): ext = '.' + ext

    fn = fn + ext

    # g.trace('intermediate file',fn)
    if g.isPython3:
        f = open(fn,'w',encoding=self.encoding)
    else:
        f = open(fn,'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
    f.write(s)
    f.close()
    self.report(fn)
</t>
<t tx="ekr.20100813041139.5913">def addTitleToHtml(self,s):

    '''Replace an empty &lt;title&gt; element by the contents of
    the first &lt;h1&gt; element.'''

    i = s.find('&lt;title&gt;&lt;/title&gt;')
    if i == -1: return s

    m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', s)
    if not m:
        m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', s)
    if m:
        s = s.replace('&lt;title&gt;&lt;/title&gt;',
            '&lt;title&gt;%s&lt;/title&gt;' % m.group(1))

    return s
</t>
<t tx="ekr.20100813041139.5914">def createDirectoryForFile(self, fn):

    '''Create the directory for fn if
    a) it doesn't exist and
    b) the user options allow it.

    Return True if the directory existed or was made.'''

    c = self.c

    # Create the directory if it doesn't exist.
    theDir, junk = g.os_path_split(fn)
    theDir = c.os_path_finalize(theDir)

    if g.os_path_exists(theDir):
        return True
    else:
        ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
        if not ok:
            g.es_print('did not create:',theDir,color='red')
        return ok
</t>
<t tx="ekr.20100813041139.5919">def write_files (self,ext,fn,callDocutils,toString,writeIntermediateFile):

    isHtml = ext in ('.html','.htm')
    fn = self.computeOutputFileName(fn)
    if not toString:
        if not self.createDirectoryForFile(fn):
            return

    if writeIntermediateFile:
        if not toString:
            self.createIntermediateFile(fn,self.source)

    if callDocutils and ext in ('.htm','.html','.tex','.pdf'):
        self.stringOutput = s = self.writeToDocutils(self.source,ext)
        if s and isHtml:
             self.stringOutput = s = self.addTitleToHtml(s)
        if not s: return

        if not toString:
            f = open(fn,'w')
            f.write(s)
            f.close()
            self.report(fn)
            # self.http_endTree(fn,p,justOneFile=justOneFile)
</t>
<t tx="ekr.20100813041139.5920"></t>
<t tx="ekr.20100817125519.5833">def deleteWord(self,event=None):
    self.deleteWordHelper(event,forward=True)

def backwardDeleteWord(self,event=None):
    self.deleteWordHelper(event,forward=False)

def deleteWordHelper(self,event,forward):
    c = self.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType="delete-word")
    if w.hasSelection():
        from_pos,to_pos = w.getSelectionRange()
    else:
        from_pos = w.getInsertPoint()
        self.moveWordHelper(event,extend=False,forward=forward)
        to_pos = w.getInsertPoint()

    # For Tk GUI, make sure to_pos &gt; from_pos
    if from_pos &gt; to_pos:
        from_pos,to_pos = to_pos,from_pos

    w.delete(from_pos,to_pos)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20100822092546.5835">def write_slides (self,p,toString=False):

    '''Convert p's children to slides.'''

    c = self.c ; p = p.copy() ; h = p.h
    i = g.skip_id(h,1) # Skip the '@'
    kind,fn = h[:i].strip(),h[i:].strip()
    if not fn: return g.es('%s requires file name' % (kind),color='red')
    title = p and p.firstChild().h or '&lt;no slide&gt;'
    title = title.strip().capitalize()
    n_tot = p.numberOfChildren()

    n = 1
    for child in p.children():
        self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
        self.scanAllOptions(child) # Settings for child are valid after this call.
        # Compute the slide's file name.
        fn2,ext = g.os_path_splitext(fn)
        fn2 = '%s-%03d%s' % (fn2,n,ext) # Use leading zeros for :glob:.
        n += 1
        # Write the rst sources to self.source.
        self.outputFile = StringIO()
        self.writeSlideTitle(title,n-1,n_tot)
        self.writeBody(child)
        self.source = self.outputFile.getvalue() # the rST sources.
        self.outputFile,self.stringOutput = None,None
        self.write_files(ext,fn2,
            callDocutils=self.getOption('call_docutils'),
            toString=toString,
            writeIntermediateFile=self.getOption('write_intermediate_file'))
</t>
<t tx="ekr.20100822174725.5836">def writeSlideTitle (self,title,n,n_tot):

    '''Write the title, underlined with the '#' character.'''

    if n != 1:
        title = '%s (%s of %s)' % (title,n,n_tot)

    width = max(4,len(g.toEncodedString(title,
        encoding=self.encoding,reportErrors=False)))

    self.write('%s\n%s \n\n' % (title,('#'*width)))
</t>
<t tx="ekr.20100826110728.5839">@nocolor-node

2008

http://groups.google.com/group/leo-editor/browse_thread/thread/b738e3f8d164f9fc

May 10, 2010

Kent

I think there could be quite a bit of interest in moving
the shadow files to their own tree, avoiding what might
be considered 'pollution' of a tree of files in @shadow nodes.

Edward has said that this would add a lot of complexity to Leo.

It seems that a VCS back end for Leo might simplify the
task of arbitrary shadow file location, as well as adding
versioning capability.


Those of us old enough to remember the Groucho Marx show will know what I am ...

bogomil
 to me

In order to relocate .leo_shadow directories in home dir, I have made
the following changes leoShadow.py:
1. Introduce new setting 'shadow_in_home_dir':
   x.ctor:
     ...
     self.shadow_prefix = c.config.getString('shadow_prefix') or ''

=&gt;  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir')
or False
    ...

2. Make the following line:
   x.shadowDirName and shadowPathName:
      ...
      fileDir = g.os_path_dirname(filename)

=&gt;   if self.shadow_in_home_dir:
        fileDir = "//".join([baseDir, fileDir.replace(':','%')])

In this way I keep .leo_shadow dirs in a tree and it is ok if the user
reorgs the original tree.

=====================
Edward K. Ream
 to bogomil

Thanks for these suggestions.  I'll try them soon.

A few minor comments about the code.

&gt;  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir') or False

This works (because c.config.getBool returns None if the setting does
not exist). Thus, the "or False" part merely replaces None by False.
I prefer the following:

self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir',default=False)

&gt;   if self.shadow_in_home_dir:
&gt;         fileDir = "//".join([baseDir, fileDir.replace(':','%')])

This looks like a Windows-only solution because of ':'.  It might fail
in strange ways on other platforms.
</t>
<t tx="ekr.20100826110728.5840">@nocolor-node

derwish

It seems that this option only works as expected for comments at the
beginning of a node.

A Leo file with the following contents would be rendered with  the
second comment inside the PRE-element of the code paragraph.

I am using Leo 4.7b2, build 2404

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0"
clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5"&gt;
       &lt;global_window_position top="30" left="12" height="600" width="800"/&gt;
       &lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes&gt;
&lt;v t="huesingjohannes.20090706083342.1221"
str_leo_pos="2,0"&gt;&lt;vh&gt;@chapters&lt;/vh&gt;&lt;/v&gt;
&lt;v t="huesingjohannes.20091022082006.1227"&gt;&lt;vh&gt;@url U:/leo/hello.html&lt;/
vh&gt;&lt;/v&gt;
&lt;v t="huesingjohannes.20090706083342.1220" a="E"&gt;&lt;vh&gt;@rst U:\leo
\hello.html&lt;/vh&gt;
&lt;v t="huesingjohannes.20090706083342.5924"&gt;&lt;vh&gt;Greet the world&lt;/vh&gt;&lt;/
v&gt;
&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="huesingjohannes.20090706083342.1220"&gt;@ @rst-options
verbose=True
code_mode=True
show_doc_parts_as_paragraphs=True
number_code_lines=False

@c

&lt;/t&gt;
&lt;t tx="huesingjohannes.20090706083342.1221"&gt;&lt;/t&gt;
&lt;t tx="huesingjohannes.20090706083342.5924"&gt;@
    Greet the world, politely
@c

g.es ("Hello, world")

@
   Was that polite enough?
@c&lt;/t&gt;
&lt;t tx="huesingjohannes.20091022082006.1227"&gt;&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;

========================

Is there anyone here who could help me on this? It would be really nice if I
didn't have to restrain myself to comments only at the top of a node.


==========================
Thanks for this report.  Sorry for the delay in responding.  Please
file an official bug report.  It does seem like a real bug.


If I can fix it cleanly tomorrow before Leo 4.7 final I shall. Otherwise soon.

=======================
Ok. I have simple fixes, but none are safe enough to include in Leo 4.7 final...

In the meantime, removing the leading whitespace from the first line
of the second @doc part should be a good enough workaround.

There are three possible fixes, all similar:

1. In getDocPart (in leoRst.py), change::

   result.append(s)

to:

   result.append(s.lstrip())

There are two such lines in getDocPart.  Probably both should be
changed.

2. The same fix, conditional on a new 'stripLines' keyword arg.  Like
this:

   if stripLines:
       result.append(s.lstrip())
   else:
       result.append(s)

Again, this change affects two lines in getDocPart.

The idea is that handleCodeMode would be the only method to set the
stripLines arg:

   n, lines2 = self.getDocPart(lines,n)

3. A change to handleCodeMode.  After the line:

   n, lines2 = self.getDocPart(lines,n)

add the line:

   lines2 = [z.lstrip() for z in lines2]

As I write this, I am thinking that change #3 is the simplest change,
with the fewest side effects.

We can test any one of these solutions starting early in the Leo 4.8
release cycle, but none  is safe enough to include in Leo 4.7 final.

If you would, please test fix #3 and report your results.  Thanks.
</t>
<t tx="ekr.20100827095120.5861">http://groups.google.com/group/leo-editor/browse_thread/thread/be5052957b21ad97

Maybe for Leo 4.9.
</t>
<t tx="ekr.20100827114047.5892">Should preserve scrollbar location and appropriate window ratio.

https://bugs.launchpad.net/leo-editor/+bug/581031/+editstatus
</t>
<t tx="ekr.20100827114047.5893">@nocolor-node

Reported by TL:

When editing a Docutils file in an external editor (exported from
Leo), I always get a "Replace changed outline with external changes?"
dialog box when I save the file in the external editor. This appears
to occur because a newline is added to the end of the file when it is
imported back into Leo.

Note: The addition of a newline occurs even if the imported file
already has a newline at the end of the file.

There appears to be two problems:

1) Leo always adds a newline even if the already has one.
2) After Leo has added the newline it mistakenly marks the buffer as
modified.
</t>
<t tx="ekr.20100827114047.5895"></t>
<t tx="ekr.20100828074347.5827"></t>
<t tx="ekr.20100828074347.5828">http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/

http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. 
</t>
<t tx="ekr.20100830120622.5829">@nocolor-node

&gt; &gt; Hmm, I guess that would be more clear, although I think I'd like an option
to include it in the following def to avoid

&gt; &gt; Decoration
&gt; &gt; index
&gt; &gt; Decoration
&gt; &gt; add_user
&gt;
&gt; Sure.  Decorations must always be part of a definition.

Well, personally I'd like to have them included in the definition, but I think
Kent's preference for a separate node is reasonable to. If your function and
hence definition node is called "pluralize", and it's decorated with something
like "@authenticate_user", you may never check the innocent looking pluralize
definition to find out what on earth's triggering the mysterious network
database call. And this isn't a completely specious example, authentication may
have been added to stop pluralize being used in a user existence detection
exploit or something. OTOH in well behaved code like CherryPy apps you don't
want a separate node for every @cherrypy.expose.

Bottom line is I think we're asking for a set of @settings to fine tune python
import behavior:

@python_import_interdef = previous | next | own_node | ai
@python_import_decoration = next | own_node

I'm not sure I believe the AI option is possible / practical, and am not asking
for it, just listing it :-)

I'd also like

@python_import_init_in_class_node = true | false

as often there's more docs on a class in the __init__ than the class docstring.

I think that's really all we're talking about, some @settings to test during import.
</t>
<t tx="ekr.20100831090251.5838"></t>
<t tx="ekr.20100831090251.5840">def createCursesGui (self,fileName='',verbose=False):

    app = self

    app.pluginsController.loadOnePlugin('leo.plugins.cursesGui',verbose=verbose)
</t>
<t tx="ekr.20100901080826.5850">@pagewidth 45

def aproposAbbreviations (self,event=None):

    s = '''\

apropos-abbreviations
=====================

When abbreviation mode is on (abbrev-mode
toggles this mode) Leo will expand
abbreviations as you type. Type the name of
an abbreviation, followed by a space. As soon
as you type the space, Leo will replace the
name by the abbreviations value. You can undo
the replacement as usual.

Note that defining any abbreviation
automatically turns on abbreviation mode.

The add-global-abbreviation command
(&lt;alt-x&gt;add-gl&lt;tab&gt;&lt;return&gt;) takes the
selected text as the replacement value of the
abbreviation. The minibuffer prompts you for
the name of the abbreviation.

Settings
========

As usual, the following settings have effect
only in @settings trees:

@bool enable-abbreviations (default: False)

When true, enables substitution of
abbreviations.

@data global-abbreviations
@data abbreviations

In both cases, body text contains lines of
the form::

   name=value

name is the abbreviation name, value is the
substituted text. Whitespace is ignore around
the name, but is significant in the value.
Abbreviation names may contain only
alphabetic characters, but may start with the
'@' sign.

By *convention* @data global-abbreviations
setting should be defined in
myLeoSettings.leo, while @data abbreviations
should be defined in other .leo files.
Regardless of where they are defined,
abbreviations in @data abbreviation nodes
will override settings (with the same name)
in @data global-abbreviations nodes.

Commands
========

apropos-abbreviations

Prints this summary.

dabbrev-completion

Insert the common prefix of all dynamic
abbreviations matching the present word.
Similar C-M-/ in Emacs.

dabbrev-expands

Expand the word in the buffer before point as
a dynamic abbrev, by searching in the buffer
for words starting with that abbreviation
(dabbrev-expand). Similar to M-/ in Emacs

abbrev-mode

Toggles abbreviation mode. Abbreviations are
only active when this mode is on.

add-global-abbrev

Adds an abbreviation for the selected text.
The minibuffer prompts for the abbreviation
name.

inverse-add-global-abbrev

Adds an abbreviation. The selected text is
the abbreviation name. The minibuffer prompts
for the value of the abbreviation.

kill-all-abbrevs

Removes all abbreviations.

list-abbrevs

Lists all active abbreviations.

read-abbrev-file

Read an external file containing
abbreviations.

write-abbrev-file

Writes abbreviations to an external file.

Scripting
=========

Leo scripts may read abbreviations from a file with::

    c.abbrevCommands.readAbbreviationsFromFile(fn)

'''

    if not g.app.unitTesting:
        g.es(g.adjustTripleString(s.rstrip(),
            self.c.tab_width))
</t>
<t tx="ekr.20100901080826.6001">def addAbbrevHelper (self,s,tag=''):

    if not s.strip(): return

    try:
        d = self.abbrevs
        data = s.split('=')
        name = data[0].strip()
        val = '='.join(data[1:])
        if val.endswith('\n'): val = val[:-1]
        val = val.replace('\\n','\n')
        old,tag = d.get(name,(None,None),)
        if old and old != val and not g.unitTesting:
            g.es_print('redefining abbreviation',name,
                '\nfrom',repr(old),'to',repr(val))
        d [name] = val,tag
    except ValueError:
        g.es_print('bad abbreviation: %s' % s)
</t>
<t tx="ekr.20100901080826.6002"></t>
<t tx="ekr.20100901080826.6003">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # Set local ivars.
    self.abbrevs ={} # Keys are names, values are (abbrev,tag).
    self.daRanges = []
    self.event = None
    self.dynaregex = re.compile( # For dynamic abbreviations
        r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.w = None
</t>
<t tx="ekr.20100901080826.6004">def finishCreate(self):

    baseEditCommandsClass.finishCreate(self)

    c = self.c ; k = c.k
    table = (
        ('global-abbreviations','global'),
        ('abbreviations','local'),
    )
    for source,tag in table:
        aList = c.config.getData(source)
        if aList:
            for s in aList:
                self.addAbbrevHelper(s,tag)

    if 0: # Quickly becomes annoying.
        if self.abbrevs:
            self.listAbbrevs()

    k.abbrevOn = c.config.getBool('enable-abbreviations',default=False)
    if k.abbrevOn and not g.unitTesting and not g.app.batchMode:
        g.es('Abbreviations are on',color='red')
</t>
<t tx="ekr.20100901080826.6155"></t>
<t tx="ekr.20100901080826.6156">def readAbbreviationsFromFile(self,fileName):

    k = self.c.k

    try:
        f = open(fileName)
        for s in f:
            self.addAbbrevHelper(s,'file')
        f.close()
        k.abbrevOn = True
        g.es("Abbreviations on")
        # self.listAbbrevs()
    except IOError:
        g.es('can not open',fileName)
</t>
<t tx="ekr.20100902154544.5872"></t>
<t tx="ekr.20100904095239.5914">class EnchantClass:

    """A wrapper class for PyEnchant spell checker"""

    @others
</t>
<t tx="ekr.20100904095239.5916">def __init__ (self,c):

    """Ctor for the EnchantClass class."""

    self.c = c
    language = c.config.getString('enchant_language')

    # Set the base language
    if language and not enchant.dict_exists(language):
        g.es_print('Invalid language code for Enchant',language_code,color='blue')
        g.es('Using "en_US" instead')
        language = 'en_US'

    # Compute fn, the full path to the local dictionary.
    fn = g.os_path_finalize(
        c.config.getString('enchant_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if fn and g.os_path_exists(fn):
        # Merge the local and global dictionaries.
        try:
            self.d = enchant.DictWithPWL(language,fn)
        except Exception:
            g.es_exception()
            g.es_print('not a valid dictionary file',fn,color='red')
            self.d = enchant.Dict(language) 
    else:
        self.d = enchant.Dict(language) 
</t>
<t tx="ekr.20100904095239.5920">def processWord(self, word):

    """Check the word. Return None if the word is properly spelled.
    Otherwise, return a list of alternatives."""

    d = self.d 

    if not d:
        return None
    elif d.check(word):
        return None
    else:
        return d.suggest(word)
</t>
<t tx="ekr.20100904095239.5927">def add (self,word):

    '''Add a word to the user dictionary.'''

    self.d.add(word)
</t>
<t tx="ekr.20100904095239.5928">def ignore (self,word):

    self.d.add_to_session(word)
</t>
<t tx="ekr.20100904134301.8336">El 01/05/09 15:12, Ville M. Vainio escribió:

- make latex
- cd _build/latex
- make all-pdf
</t>
<t tx="ekr.20100906165118.5915">ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
</t>
<t tx="ekr.20100907092144.5901"># These are intended to be temporary tests,
# to be copied eventually to unitTest.leo</t>
<t tx="ekr.20100907115157.5905"></t>
<t tx="ekr.20100908120927.5971">import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest
import leo.core.leoCommands as commands

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    docutils = None

import os

import pprint
import re

if g.isPython3:
    import io
    StringIO = io.StringIO
else:
    import StringIO
    StringIO = StringIO.StringIO

import tempfile

import sys

try:
    import leo.plugins.mod_http as mod_http
except ImportError:
    mod_http = None
except Exception:
    # Don't let a problem with a plugin crash Leo's core!
    g.es_print('leoRst: can not import leo.plugins.mod_http')
    g.es_exception()
    mod_http = None

try:
    import SilverCity
except ImportError:
    SilverCity = None
</t>
<t tx="ekr.20100908125007.6007">class LeoPluginsController:

    @others
</t>
<t tx="ekr.20100908125007.6009">class baseLeoPlugin(object):
    &lt;&lt;docstring&gt;&gt;
    import leo.core.leoGlobals as g
    @others
</t>
<t tx="ekr.20100908125007.6010">"""A Convenience class to simplify plugin authoring

.. contents::

Usage
=====


Initialization
--------------

- import the base class::

    from leoPlugins import leo.core.leoBasePlugin as leoBasePlugin

- create a class which inherits from leoBasePlugin::

    class myPlugin(leoBasePlugin):

- in the __init__ method of the class, call the parent constructor::

    def __init__(self, tag, keywords):
        leoBasePlugin.__init__(self, tag, keywords)

- put the actual plugin code into a method; for this example, the work
  is done by myPlugin.handler()

- put the class in a file which lives in the &lt;LeoDir&gt;/plugins directory
    for this example it is named myPlugin.py

- add code to register the plugin::

    leoPlugins.registerHandler("after-create-leo-frame", Hello)

Configuration
-------------

baseLeoPlugins has 3 *methods* for setting commands

- setCommand::

        def setCommand(self, commandName, handler, 
                shortcut = None, pane = 'all', verbose = True):

- setMenuItem::

        def setMenuItem(self, menu, commandName = None, handler = None):

- setButton::

        def setButton(self, buttonText = None, commandName = None, color = None):

*variables*

:commandName:  the string typed into minibuffer to execute the ``handler``

:handler:  the method in the class which actually does the work

:shortcut:  the key combination to activate the command

:menu:  a string designating on of the menus ('File', Edit', 'Outline', ...)

:buttonText:  the text to put on the button if one is being created.

Example
=======

Contents of file ``&lt;LeoDir&gt;/plugins/hello.py``::

    class Hello(baseLeoPlugin):
        def __init__(self, tag, keywords):

            # call parent __init__
            baseLeoPlugin.__init__(self, tag, keywords)

            # if the plugin object defines only one command, 
            # just give it a name. You can then create a button and menu entry
            self.setCommand('Hello', self.hello)
            self.setButton()
            self.setMenuItem('Cmds')

            # create a command with a shortcut
            self.setCommand('Hola', self.hola, 'Alt-Ctrl-H')

            # create a button using different text than commandName
            self.setButton('Hello in Spanish')

            # create a menu item with default text
            self.setMenuItem('Cmds')

            # define a command using setMenuItem 
            self.setMenuItem('Cmds', 'Ciao baby', self.ciao)

        def hello(self, event):
            g.pr("hello from node %s" % self.c.p.h)

        def hola(self, event):
            g.pr("hola from node %s" % self.c.p.h)

        def ciao(self, event):
            g.pr("ciao baby (%s)" % self.c.p.h)


    leoPlugins.registerHandler("after-create-leo-frame", Hello)

"""
</t>
<t tx="ekr.20100908125007.6012">def __init__(self, tag, keywords):

    """Set self.c to be the ``commander`` of the active node
    """

    self.c = keywords['c']
    self.commandNames = []
</t>
<t tx="ekr.20100908125007.6013">def setCommand(self, commandName, handler, 
                shortcut = None, pane = 'all', verbose = True):

    """Associate a command name with handler code, 
    optionally defining a keystroke shortcut
    """

    self.commandNames.append(commandName)

    self.commandName = commandName
    self.shortcut = shortcut
    self.handler = handler
    self.c.k.registerCommand (commandName, shortcut, handler, 
                            pane, verbose)
</t>
<t tx="ekr.20100908125007.6014">def setMenuItem(self, menu, commandName = None, handler = None):

    """Create a menu item in 'menu' using text 'commandName' calling handler 'handler'
    if commandName and handler are none, use the most recently defined values
    """

    # setMenuItem can create a command, or use a previously defined one.
    if commandName is None:
        commandName = self.commandName
    # make sure commandName is in the list of commandNames                        
    else:
        if commandName not in self.commandNames:
            self.commandNames.append(commandName) 

    if handler is None:
        handler = self.handler

    table = ((commandName, None, handler),)
    self.c.frame.menu.createMenuItemsFromTable(menu, table)
</t>
<t tx="ekr.20100908125007.6015">def setButton(self, buttonText = None, commandName = None, color = None):

    """Associate an existing command with a 'button'
    """

    if buttonText is None:
        buttonText = self.commandName

    if commandName is None:
        commandName = self.commandName       
    else:
        if commandName not in self.commandNames:
            raise NameError("setButton error, %s is not a commandName" % commandName)

    if color is None:
        color = 'grey'
    script = "c.k.simulateCommand('%s')" % self.commandName
    g.app.gui.makeScriptButton(
        self.c,
        args=None,
        script=script, 
        buttonText = buttonText, bg = color)
</t>
<t tx="ekr.20100908125007.6016">def callTagHandler (self,bunch,tag,keywords):

    handler = bunch.fn ; moduleName = bunch.moduleName

    # if tag != 'idle': g.pr('callTagHandler',tag,keywords.get('c'))

    # Make sure the new commander exists.
    if True: # tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    g.pr('skipping tag %s: c does not exists or does not have a frame.' % tag)
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    self.loadingModuleNameStack.append(moduleName)
    try:
        result = handler(tag,keywords)
    except:
        g.es("hook failed: %s, %s, %s" % (tag, handler, moduleName))
        g.es_exception()
        result = None
    self.loadingModuleNameStack.pop()
    return result
</t>
<t tx="ekr.20100908125007.6017">def doHandlersForTag (self,tag,keywords):

    """Execute all handlers for a given tag, in alphabetical order.

    All exceptions are caught by the caller, doHook."""

    if g.app.killed:
        return None

    if tag in self.handlers:
        bunches = self.handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = self.callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if 'all' in self.handlers:
        bunches = self.handlers.get('all')
        for bunch in bunches:
            self.callTagHandler(bunch,tag,keywords)

    return None
</t>
<t tx="ekr.20100908125007.6018">def doPlugins(self,tag,keywords):

    if g.app.killed:
        return

    if tag in ('start1','open0'):
        self.loadHandlers(tag,keywords)

    return self.doHandlersForTag(tag,keywords)
</t>
<t tx="ekr.20100908125007.6019">def getHandlersForTag(self,tags):

    if type(tags) in (type((),),type([])):
        result = []
        for tag in tags:
            aList = self.getHandlersForOneTag(tag) 
            result.extend(aList)
        return result
    else:
        return self.getHandlersForOneTag(tags)

def getHandlersForOneTag (self,tag):

    aList = self.handlers.get(tag,[])
    return aList
</t>
<t tx="ekr.20100908125007.6020">def getPluginModule (self,moduleName):

    return self.loadedModules.get(moduleName)
</t>
<t tx="ekr.20100908125007.6021">def isLoaded (self,fn):

    return self.regularizeName(fn) in self.loadedModules
</t>
<t tx="ekr.20100908125007.6022">def loadHandlers(self,tag,keys):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    s = g.app.config.getEnabledPlugins()
    if not s: return

    if tag == 'open0' and not g.app.silentMode and not g.app.batchMode:
        if 0:
            s2 = '@enabled-plugins found in %s' % (
                g.app.config.enabledPluginsFileName)
            g.es_print(s2,color='blue')
            # g.trace(keys,g.callers())

    for plugin in s.splitlines():
        if plugin.strip() and not plugin.lstrip().startswith('#'):
            self.loadOnePlugin(plugin.strip(), tag = tag)
</t>
<t tx="ekr.20100908125007.6024">def loadOnePlugin (self,moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    if moduleOrFileName.startswith('@'):
        if trace: g.trace('ignoring Leo directive')
        return False # Allow Leo directives in @enabled-plugins nodes.

    moduleName = self.regularizeName(moduleOrFileName)

    if self.isLoaded(moduleName):
        module = self.loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    moduleName = g.toUnicode(moduleName)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    self.loadingModuleNameStack.append(moduleName)

    try:
        toplevel = __import__(moduleName)
        # need to look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]

    except g.UiTypeException:
        if not g.unitTesting and not g.app.batchMode:
            g.es_print('Plugin %s does not support %s gui' % (
                moduleName,g.app.gui.guiName()))
        result = None

    except ImportError:
        if trace or tag == 'open0': # Just give the warning once.
            g.es_print('plugin does not exist:',moduleName,color='red')
        result = None

    except Exception as e:
        g.es_print('exception importing plugin ' + moduleName,color='red')
        g.es_exception()
        result = None

    self.loadingModuleNameStack.pop()

    if result:
        self.signonModule = result # for self.plugin_signon.
        self.loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                if init_result:
                    self.loadedModules[moduleName] = result
                    self.loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                self.loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                self.loadedModules[moduleName] = result
        self.loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or self.warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
</t>
<t tx="ekr.20100908125007.6025">def printHandlers (self,c,moduleName=None):

    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    if moduleName:
        s = 'handlers for %s...\n' % (moduleName)
    else:
        s = 'all plugin handlers...\n'
    g.es(s+'\n',tabName=tabName)

    data = []
    modules = {}
    for tag in self.handlers:
        bunches = self.handlers.get(tag)
        for bunch in bunches:
            name = bunch.moduleName
            tags = modules.get(name,[])
            tags.append(tag)
            modules[name] = tags

    n = 4
    for key in sorted(modules):
        tags = modules.get(key)
        if moduleName in (None,key):
            for tag in tags:
                n = max(n,len(tag))
                data.append((tag,key),)

    lines = ['%*s %s\n' % (-n,s1,s2) for (s1,s2) in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20100908125007.6026">def printPlugins (self,c):

    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    data = []
    data.append('enabled plugins...\n')
    for z in sorted(self.loadedModules):
        data.append(z)

    lines = ['%s\n' % (s) for s in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20100908125007.6027">def printPluginsInfo (self,c):

    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''

    d = self.loadedModulesFilesDict
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    data = [] ; n = 4
    for moduleName in d:
        fileName = d.get(moduleName)
        n = max(n,len(moduleName))
        data.append((moduleName,fileName),)

    lines = ['%*s %s\n' % (-n,s1,s2) for (s1,s2) in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20100908125007.6028">def registerExclusiveHandler(self,tags, fn):

    """ Register one or more exclusive handlers"""

    if type(tags) in (type((),),type([])):
        for tag in tags:
            self.registerOneExclusiveHandler(tag,fn)
    else:
        self.registerOneExclusiveHandler(tags,fn)

def registerOneExclusiveHandler(self,tag, fn):

    """Register one exclusive handler"""

    try:
        moduleName = self.loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '&lt;no module&gt;'

    if 0:
        if g.app.unitTesting: g.pr('')
        g.pr('%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__))

    if g.app.unitTesting: return

    if tag in self.handlers:
        g.es("*** Two exclusive handlers for","'%s'" % (tag))
    else:
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        self.handlers = [bunch]
</t>
<t tx="ekr.20100908125007.6029">def registerHandler(self,tags,fn):

    """ Register one or more handlers"""

    if type(tags) in (type((),),type([])):
        for tag in tags:
            self.registerOneHandler(tag,fn)
    else:
        self.registerOneHandler(tags,fn)

def registerOneHandler(self,tag,fn):

    """Register one handler"""

    try:
        moduleName = self.loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '&lt;no module&gt;'

    if 0:
        if g.app.unitTesting: g.pr('')
        g.pr('%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__))

    items = self.handlers.get(tag,[])
    if fn not in items:
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)

    self.handlers[tag] = items
</t>
<t tx="ekr.20100908125007.6030">def unloadOnePlugin (self,moduleOrFileName,verbose=False):

    moduleName = self.regularizeName(moduleOrFileName)

    if self.isloaded(moduleName):
        if verbose:
            g.pr('unloading',moduleName)
        del self.loadedModules[moduleName]

    for tag in self.handlers:
        bunches = self.handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.moduleName != moduleName]
        self.handlers[tag] = bunches
</t>
<t tx="ekr.20100908125007.6031">def unregisterHandler(self,tags,fn):

    if type(tags) in (type((),),type([])):
        for tag in tags:
            self.unregisterOneHandler(tag,fn)
    else:
        self.unregisterOneHandler(tags,fn)

def unregisterOneHandler (self,tag,fn):

    bunches = self.handlers.get(tag)
    bunches = [bunch for bunch in bunches if bunch.fn != fn]
    self.handlers[tag] = bunches
</t>
<t tx="ekr.20100908125007.6033">class CommandChainDispatcher:
    """ Dispatch calls to a chain of commands until some func can handle it

    Usage: instantiate, execute "add" to add commands (with optional
    priority), execute normally via f() calling mechanism.

    """
    def __init__(self,commands=None):
        if commands is None:
            self.chain = []
        else:
            self.chain = commands

    def __call__(self,*args, **kw):
        """ Command chain is called just like normal func. 

        This will call all funcs in chain with the same args as were given to this
        function, and return the result of first func that didn't raise
        TryNext """

        for prio,cmd in self.chain:
            #print "prio",prio,"cmd",cmd #dbg
            try:
                ret = cmd(*args, **kw)
                return ret
            except TryNext as exc:
                if exc.args or exc.kwargs:
                    args = exc.args
                    kw = exc.kwargs

        # if no function will accept it, raise TryNext up to the caller
        raise TryNext

    def __str__(self):
        return str(self.chain)

    def add(self, func, priority=0):
        """ Add a func to the cmd chain with given priority """
        bisect.insort(self.chain,(priority,func))

    def __iter__(self):
        """ Return all objects in chain.

        Handy if the objects are not callable.
        """
        return iter(self.chain)
</t>
<t tx="ekr.20100908125007.6034">def __init__ (self):

    # g.trace('LeoPluginsController',g.callers())

    self.handlers = {}
    self.loadedModulesFilesDict = {}
        # Keys are regularized module names, values are the names of .leo files
        # containing @enabled-plugins nodes that caused the plugin to be loaded
    self.loadedModules = {}
        # Keys are regularized module names, values are modules.
    self.loadingModuleNameStack = []
        # The stack of module names.
        # The top is the module being loaded.
    self.signonModule = [] # A hack for plugin_signon.

    # Settings.  Set these here in case finishCreate is never called.
    self.warn_on_failure = True

    assert(g)
    g.act_on_node = CommandChainDispatcher()
    g.visit_tree_item = CommandChainDispatcher()
    g.tree_popup_handlers = []
</t>
<t tx="ekr.20100908125007.6041">def init():

    '''Init g.app.pluginsController.'''

    g.app.pluginsController = LeoPluginsController()

def registerHandler(tags,fn):

    '''A wrapper so plugins can still call leoPlugins.registerHandler.'''

    return g.app.pluginsController.registerHandler(tags,fn)
</t>
<t tx="ekr.20100909065501.5949">def regularizeName (self,fn):

    '''Return the name used as a key to this modules dictionaries.'''

    if fn.endswith('.py'):
        fn = fn [:-3]

    if not fn.startswith('leo.plugins.'):
        fn = 'leo.plugins.' + fn

    return fn
</t>
<t tx="ekr.20100909065501.5950"></t>
<t tx="ekr.20100909065501.5951"></t>
<t tx="ekr.20100909065501.5952"></t>
<t tx="ekr.20100909065501.5953"></t>
<t tx="ekr.20100909065501.5954"></t>
<t tx="ekr.20100909065501.5974">def finishCreate (self):

    '''Set configuration settings for LeoPluginsController.

    Nothing bad will happen if this is never called.'''

    self.warn_on_failure = g.app.config.getBool(c=None,
        setting='warn_when_plugins_fail_to_load')
</t>
<t tx="ekr.20100909104341.5979">def setLoaded (self,fn,m):

    self.loadedModules[self.regularizeName(fn)] = m

</t>
<t tx="ekr.20100910075900.10204">def getLoadedPlugins (self):

    return list(self.loadedModules.keys())
</t>
<t tx="ekr.20100910075900.5950"># Important: we can not define g.pc here!

</t>
<t tx="ekr.20100910075900.5951">def loadOnePlugin (pluginName):
    pc = g.app.pluginsController
    return pc.loadOnePlugin(pluginName)

def registerExclusiveHandler(tags,fn):
    pc = g.app.pluginsController
    return pc.registerExclusiveHandler(tags,fn)

def registerHandler (tags,fn):
    pc = g.app.pluginsController
    return pc.registerHandler(tags,fn)

def plugin_signon(module_name,verbose=False):
    pc = g.app.pluginsController
    return pc.plugin_signon(module_name,verbose)

def unloadOnePlugin (moduleOrFileName,verbose=False):
    pc = g.app.pluginsController
    return pc.unloadOnePlugin(moduleOrFileName,verbose)

def unregisterHandler (tags,fn):
    pc = g.app.pluginsController
    return pc.unregisterHandler(tags,fn)
</t>
<t tx="ekr.20100910075900.5952">def getHandlersForTag(tags):
    pc = g.app.pluginsController
    return pc.getHandlersForTag(tags)

def getLoadedPlugins():
    pc = g.app.pluginsController
    return pc.getLoadedPlugins()

def getPluginModule(moduleName):
    pc = g.app.pluginsController
    return pc.getPluginModule(moduleName)

def pluginIsLoaded(fn):
    pc = g.app.pluginsController
    return pc.isLoaded(fn)

</t>
<t tx="ekr.20100913171604.5885">def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
</t>
<t tx="ekr.20100913171604.5888">def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
</t>
<t tx="ekr.20100913171604.5889">def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
</t>
<t tx="ekr.20100914094836.5892">def error (*args,**keys):
    g.es_print('Error:',color='red',*args,**keys)

def note (*args,**keys):
    g.es_print(*args,**keys)

def warning (*args,**keys):
    g.es_print('Warning:',color='blue',*args,**keys)
</t>
<t tx="ekr.20100914142850.5892">def createGui(pymacs,options):

    gui = options.get('gui')
    windowFlag = options.get('windowFlag')
    script = options.get('script')

    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)

</t>
<t tx="ekr.20100914142850.5894">def make_screen_shot(fn):

    '''Create a screenshot of the present Leo outline and save it to path.'''

    # g.trace('runLeo.py',fn)

    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
</t>
<t tx="ekr.20100929121021.13743">def skipBlock(self,s,i,delim1=None,delim2=None):

    # Call the base class
    i = baseScannerClass.skipBlock(self,s,i,delim1,delim2)

    # Skip the closing parens of enclosing constructs.
    # This prevents the "does not end in a newline error.
    while i &lt; len(s) and s[i] == ')':
        i += 1

    return i
</t>
<t tx="ekr.20100929121021.13745">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    if s.startswith('?',i):
        return min(len(s),i + 3)
    else:
        return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20101002113936.5833">def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)
        # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
</t>
<t tx="ekr.20101002113936.5834">def scan (self):

    '''Build the database from the outline'''

    trace = True and not g.unitTesting
    verbose = True
    if trace: t1 = time.time()
    c = self.c
    for p in c.all_unique_positions():
        self.scanForAutoCompleter(p.b)

    p = c.rootPosition()
    seen = {}
    while p:
        key = p.key()
        if not key in seen:
            seen[key] = True
            if p.isAnyAtFileNode():
                # scanForAtLanguage is expensive!
                language = g.scanForAtLanguage(c,p)
                for p2 in p.self_and_subtree():
                    seen[p2.key()] = True
                    self.scanForCallTip(p2.b,language)
        p.moveToThreadNext()

    if trace:
        t2 = time.time()
        if verbose:
            # self.dumpTips()
            self.dumpWords()
        self.printSummary(t2-t1)

</t>
<t tx="ekr.20101002113936.5835">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        if language == 'python':
            z = self.cleanPythonTip(z)
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if z not in aList:
            aList.append(z)
            d [a] = aList

    self.calltips [language] = d
</t>
<t tx="ekr.20101002113936.5836">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = []
    strings = s.split('.')
    if not strings: return

    for i in range(len(strings)-1):
        self.makeAutocompletionList(strings[i],strings[i+1],aList)

    if aList:
        for key,val in aList:
            aList2 = self.watchwords.get(key,[])
            # val = str(val)
            if val not in aList2:
                aList2.append(val)
                self.watchwords [key] = aList2
</t>
<t tx="ekr.20101002113936.5837">def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    # Compute reverseFindWhitespace inline.
    i = len(a) -1
    while i &gt;= 0:
        # if a[i].isspace() or a [i] == '.':
        if a[i] not in self.okchars:
            a1 = a [i+1:] ; break
        i -= 1
    else:
        a1 = a

    # Compute getCleanString inline.
    i = 0
    for ch in b:
        if ch not in self.okchars:
            b1 = b[:i] ; break
        i += 1
    else:
        b1 = b

    if b1:
        glist.append((a1,b1),)
</t>
<t tx="ekr.20101002113936.5842">def __init__ (self,c):

    self.c = c

    # Set by definePatterns...
    self.okchars = None
    self.pats = {}

    # Set by scanners...
    self.calltips = {}
    self.watchwords = {}

    self.definePatterns()
</t>
<t tx="ekr.20101002120446.5841">def dumpWords (self):

    print('autocompleter words...\n\n')
    show = ['aList','c','d','f','g','gui','k','m','p','s','t','v','w']
    keys = show or sorted(self.watchwords)
    for key in keys:
        aList = self.watchwords.get(key)
        aList.sort()
        print('\n%s:' % (key),g.listToString(aList)) #repr(aList))
    print()
</t>
<t tx="ekr.20101002120446.5842">def dumpTips (self):

    print('calltips...\n\n')
    for key in sorted(self.calltips):
        d = self.calltips.get(key)
        if d:
            if 1:
                d2 = {}
                for key2 in list(d.keys()):
                    aList = d.get(key2)
                    if len(aList) == 1:
                        s = aList[0]
                        if s.startswith(key2):
                            s = s[len(key2):].strip()
                        d2[key2] = s
                    else:
                        aList2 = []
                        for s in aList:
                            if s.startswith(key2):
                                s = s[len(key2):].strip()
                            aList2.append(s)
                        d2[key2] = aList2
                print('\n%s:\n\n' % (key),g.dictToString(d2))
            else:
                print('\n%s:\n\n' % (key),g.dictToString(d))
</t>
<t tx="ekr.20101002133920.5845">def cleanPythonTip (self,s):

    result = []
    i = g.skip_ws(s,3)
    while i &lt; len(s):
        ch = s[i]
        if ch in ' \t\n':
            i += 1
        elif ch == '#':
            # Remove comment.
            i += 1
            while i &lt; len(s):
                i += 1
                if s[i-1] == '\n': break
        else:
            result.append(ch)
            i += 1
    return ''.join(result)
</t>
<t tx="ekr.20101002134934.5847">def printSummary (self,t):

    n  = len(list(self.watchwords.keys()))

    n2 = 0
    for language in list(self.calltips.keys()):
        d = self.calltips.get(language)
        n2 += len(list(d.keys()))

    g.es_print('scanned %s words, %s tips in %3.2fs sec.' % (
        n,n2,t))
</t>
<t tx="ekr.20101002134934.5848">class AutoCompleterScanner:

    '''A class that scans for autocompleter completions.'''

    @others
</t>
<t tx="ekr.20101002144536.5831">import leo.core.leoKeys as leoKeys

leoKeys.AutoCompleterScanner(c).scan()
</t>
<t tx="ekr.20101002192824.5843"># To do:
# - Fix findAnchor.
# - Report duck type in completion tab: callable if calltips exist.
# - What to do about library files and imports?

import re
import string
import sys
import time

@others

ac = NewAutoCompleter(c.k)
w = c.frame.body.bodyCtrl
event = g.bunch(char='e',keysym='e')
n = len(p.b)
if 0:
    w.setSelectionRange(n-7,n)
else:
    w.setInsertPoint(n)

ac.start(event=event,w=w)

# The cursor must be at the end
# p.s
</t>
<t tx="ekr.20101002192824.5915">class NewAutoCompleter:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20101002192824.5916">def __init__ (self,k):

    self.c = k.c
    self.k = k
    self.calltips = {}
        # Keys are language, values are dicts:
        # keys are ids, values are signatures.
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.prefix = None
    self.prefixes = []
    self.scanned = False
    self.selection = None # The selection range on entry.
    self.selectedText = None # The selected text on entry.
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
</t>
<t tx="ekr.20101002192824.5919"></t>
<t tx="ekr.20101002192824.5920">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    g.trace()

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return 'break'

    self.language = g.scanForAtLanguage(c,c.p)
    if w and self.language == 'python' and (k.enable_autocompleter or force):
        self.start(event=event,w=w)

    return 'break'
</t>
<t tx="ekr.20101002192824.5921">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20101002192824.5922">def autoCompleterStateHandler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    ch = gui.eventChar(event)
    keysym = gui.eventKeysym(event)

    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym in ('\b','BackSpace'): # Horrible hack for qt plugin.
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    ###elif keysym == '?':
    ###    self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        # if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20101002192824.5924">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20101002192824.5925">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
</t>
<t tx="ekr.20101002192824.5926">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20101002192824.5927">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    if not g.unitTesting:
        s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
        g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if not g.unitTesting:
        s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
        g.es(s,color='red')
</t>
<t tx="ekr.20101002192824.5928"></t>
<t tx="ekr.20101002192824.5929">def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    ### self.clear()
    ### self.theObject = None
</t>
<t tx="ekr.20101002192824.5930">def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    ### if word == 'self' and self.selfClassName:
    ###    word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20101002192824.5931">def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
</t>
<t tx="ekr.20101002192824.5940">def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        g.es('','\n'.join(self.tabList),tabName=self.tabName)
</t>
<t tx="ekr.20101002192824.5941">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    s = self.prefixes and self.prefixes.pop() or ''
    self.setSelection(s)
    self.computeCompletionList()
</t>
<t tx="ekr.20101002192824.5942">def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20101002192824.5943">def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20101002192824.5944">def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i &gt; 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
</t>
<t tx="ekr.20101002192824.5945">def findAnchor (self,w):

    '''
    Scan backward for the word before the last period.
    Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # Scan backward for the next '.'
    while i &gt; 1 and s[i-1] != '.':
        # g.trace(i-1,s[i-1])
        i -= 1

    if i &lt;= 0 or s[i-1] != '.':
        return 0,''

    i,j = g.getWord(s,i-2)
    word = s[i:j]
    if word == '.':
        # g.trace('word is dot')
        return 0,''
    else:
        # g.trace(i,j,repr(word))
        return j,word
</t>
<t tx="ekr.20101002192824.5946">def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    ### self.clear()
    ### self.theObject = None
</t>
<t tx="ekr.20101002192824.5948">def getLeadinWord (self,w):

    i,word = self.findAnchor(w)

    if word and not word.isdigit():
        self.setMembersList(word)
        self.beginTabName(word)
        self.leadinWord = word
        return True
    else:
        self.membersList = []
        self.leadinWord = None
        return False
</t>
<t tx="ekr.20101002192824.5949">def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
</t>
<t tx="ekr.20101002192824.5951">def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    g.trace(ch,self.prefix)

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        #g.trace('tabList',repr(tabList))
        #g.trace('common_prefix',repr(common_prefix))
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    elif ch == '(':
        self.calltip()
    else:
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20101002192824.5952">if 0:
    def push (self,obj):
        if obj is not None:
            self.prevObjects.append(obj)

    def pop (self):
        obj = self.prevObjects.pop()
        return obj

    def clear (self):
        self.prevObjects = []

    def stackNames (self):
        aList = []
        for z in self.prevObjects:
            if hasattr(z,'__name__'):
                aList.append(z.__name__)
            elif hasattr(z,'__class__'):
                aList.append(z.__class__.__name__)
            else:
                aList.append(str(z))
        return aList
</t>
<t tx="ekr.20101002192824.5953">def setMembersList (self,word):

    self.membersList = self.watchwords.get(word)
    self.membersList.sort()

    # g.trace(word,self.membersList)
</t>
<t tx="ekr.20101002192824.5954">def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
</t>
<t tx="ekr.20101002192824.5956">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20101002192824.5957">def setSelection (self,s):

    g.trace(s,g.callers(2))

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor(c.p,incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20101002192824.5958">def start (self,event=None,w=None,prefix=None,chain=False):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.scanned:
        self.scanned = True
        # scanner = leoKeys.AutoCompleterScanner(c)
        scanner = AutoCompleterScanner(c)
        scanner.scan()
        self.calltips = scanner.calltips
        self.watchwords = scanner.watchwords

    self.selection = w.getSelectionRange()
    self.prefix = prefix or w.getSelectedText()
    if chain:
        if self.prefix not in self.prefixes:
            self.prefixes.append(self.prefix)
    else:
        self.prefixes = [self.prefix]
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    # g.trace(flag,self.membersList)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i &gt; 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
</t>
<t tx="ekr.20101002192824.5988">def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    i,j = w.getSelectionRange()
    w.insert(j,'.')
    w.setInsertPoint(j+1)
    self.finish()
    self.start(chain=True)
</t>
<t tx="ekr.20101002192824.5989"># Search for ###
</t>
<t tx="ekr.20101002192824.5997">def calltip (self):

    c = self.c
    w = self.widget
    word = w.getSelectedText()
    language = g.scanForAtLanguage(c,c.p)
    d = self.calltips.get(language)
    s = '()'
    if d:
        aList = d.get(word,[])
        g.trace(word,repr(aList))
        if aList:
            s = aList[0]
    s = s.replace(word,'').replace('(self,','(').replace('(self)','()').strip()

    # insert the text and set j1 and j2
    junk,j = w.getSelectionRange() # Returns insert point if no selection.
    w.insert(j,s)
    c.frame.body.onBodyChanged('Typing')
    j1,j2 = j + 1, j + len(s)

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    w.setSelectionRange(j1,j2,insert=j2)
</t>
<t tx="ekr.20101002192824.6005">def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
</t>
<t tx="ekr.20101002192824.6019">class AutoCompleterScanner:

    '''A class that scans for autocompleter completions.'''

    @others
</t>
<t tx="ekr.20101002192824.6020">def __init__ (self,c):

    self.c = c

    # Set by definePatterns...
    self.okchars = None
    self.pats = {}

    # Set by scanners...
    self.calltips = {}
    self.watchwords = {}

    self.definePatterns()
</t>
<t tx="ekr.20101002192824.6021">def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)
        # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
</t>
<t tx="ekr.20101002192824.6022">def scan (self):

    '''Build the database from the outline'''

    trace = True and not g.unitTesting
    verbose = False
    if trace: t1 = time.time()
    c = self.c
    for p in c.all_unique_positions():
        self.scanForAutoCompleter(p.b)

    p = c.rootPosition()
    seen = {}
    while p:
        key = p.key()
        if not key in seen:
            seen[key] = True
            if p.isAnyAtFileNode():
                # scanForAtLanguage is expensive!
                language = g.scanForAtLanguage(c,p)
                for p2 in p.self_and_subtree():
                    seen[p2.key()] = True
                    self.scanForCallTip(p2.b,language)
        p.moveToThreadNext()

    if trace:
        t2 = time.time()
        if verbose:
            self.dumpTips()
            self.dumpWords()
        self.printSummary(t2-t1)

</t>
<t tx="ekr.20101002192824.6023">def dumpTips (self):

    print('calltips...\n\n')
    for key in sorted(self.calltips):
        d = self.calltips.get(key)
        if d:
            if 1:
                d2 = {}
                for key2 in list(d.keys()):
                    aList = d.get(key2)
                    if len(aList) == 1:
                        s = aList[0]
                        if s.startswith(key2):
                            s = s[len(key2):].strip()
                        d2[key2] = s
                    else:
                        aList2 = []
                        for s in aList:
                            if s.startswith(key2):
                                s = s[len(key2):].strip()
                            aList2.append(s)
                        d2[key2] = aList2
                print('\n%s:\n\n' % (key),g.dictToString(d2))
            else:
                print('\n%s:\n\n' % (key),g.dictToString(d))
</t>
<t tx="ekr.20101002192824.6024">def dumpWords (self):

    print('autocompleter words...\n\n')
    show = ['aList','c','d','f','g','gui','k','m','p','s','t','v','w']
    keys = show or sorted(self.watchwords)
    for key in keys:
        aList = self.watchwords.get(key)
        aList.sort()
        print('\n%s:' % (key),g.listToString(aList)) #repr(aList))
    print()
</t>
<t tx="ekr.20101002192824.6025">def printSummary (self,t):

    n  = len(list(self.watchwords.keys()))

    n2 = 0
    for language in list(self.calltips.keys()):
        d = self.calltips.get(language)
        n2 += len(list(d.keys()))

    g.es_print('scanned %s words, %s tips in %3.2fs sec.' % (
        n,n2,t))
</t>
<t tx="ekr.20101002192824.6026">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = []
    strings = s.split('.')
    if not strings: return

    for i in range(len(strings)-1):
        self.makeAutocompletionList(strings[i],strings[i+1],aList)

    if aList:
        for key,val in aList:
            aList2 = self.watchwords.get(key,[])
            # val = str(val)
            if val not in aList2:
                aList2.append(val)
                self.watchwords [key] = aList2
</t>
<t tx="ekr.20101002192824.6027">def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    # Compute reverseFindWhitespace inline.
    i = len(a) -1
    while i &gt;= 0:
        # if a[i].isspace() or a [i] == '.':
        if a[i] not in self.okchars:
            a1 = a [i+1:] ; break
        i -= 1
    else:
        a1 = a

    # Compute getCleanString inline.
    i = 0
    for ch in b:
        if ch not in self.okchars:
            b1 = b[:i] ; break
        i += 1
    else:
        b1 = b

    if b1:
        glist.append((a1,b1),)
</t>
<t tx="ekr.20101002192824.6028">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        if language == 'python':
            z = self.cleanPythonTip(z)
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if z not in aList:
            aList.append(z)
            d [a] = aList

    self.calltips [language] = d
</t>
<t tx="ekr.20101002192824.6029">def cleanPythonTip (self,s):

    result = []
    i = g.skip_ws(s,3)
    while i &lt; len(s):
        ch = s[i]
        if ch in ' \t\n':
            i += 1
        elif ch == '#':
            # Remove comment.
            i += 1
            while i &lt; len(s):
                i += 1
                if s[i-1] == '\n': break
        else:
            result.append(ch)
            i += 1
    return ''.join(result)
</t>
<t tx="ekr.20101004092958.5914">@ treepad.py is from the treepad website
</t>
<t tx="ekr.20101004092958.5939">@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

</t>
<t tx="ekr.20101004092958.5940">import sys, os, re, string

# constants
VERSION = "&lt;Treepad version 2.7&gt;"

# regexes
END_RE = re.compile(r'^&lt;end node&gt; ([^ ]+)$')
</t>
<t tx="ekr.20101004092958.5941">class Node:
    @others
</t>
<t tx="ekr.20101004092958.5942">def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
</t>
<t tx="ekr.20101004092958.5943">def __str__(self):
    return "%s/%d" % (self.title, self.level)
</t>
<t tx="ekr.20101004092958.5944">def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
</t>
<t tx="ekr.20101004092958.5945">def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
</t>
<t tx="ekr.20101004092958.5946">def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("&lt;node&gt;\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("&lt;end node&gt; %s\n" % self.end)
</t>
<t tx="ekr.20101004092958.5947">def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

</t>
<t tx="ekr.20101004092958.5948">class NodeReader:
    @others
</t>
<t tx="ekr.20101004092958.5949">def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
</t>
<t tx="ekr.20101004092958.5950">def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
</t>
<t tx="ekr.20101004092958.5951">def readstart(self):
    self.expect(VERSION)
</t>
<t tx="ekr.20101004092958.5952">def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) &lt; 1:
        return None
    self.expect("dt=Text", line)
    self.expect("&lt;node&gt;")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

</t>
<t tx="ekr.20101004092958.5953">class TreeReader:
    @others
</t>
<t tx="ekr.20101004092958.5954">def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
</t>
<t tx="ekr.20101004092958.5955">def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level &gt; 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
</t>
<t tx="ekr.20101004092958.5956">def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

</t>
<t tx="ekr.20101004092958.5957">class TreeWriter:
    @others
</t>
<t tx="ekr.20101004092958.5958">def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
</t>
<t tx="ekr.20101004092958.5959">def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

</t>
<t tx="ekr.20101004092958.5960">class Main:
    @others
</t>
<t tx="ekr.20101004092958.5961">def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
</t>
<t tx="ekr.20101004092958.5962">
def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

</t>
<t tx="ekr.20101004092958.5964">
c:\leo.repo\trunk&gt;python -m codewise setup

c:\leo.repo\trunk&gt;c:\Python31\python.exe -m codewise setup
Creating template c:\Users\edreamleo/.ctags
Initializing CodeWise db at c:\Users\edreamleo/.codewise.db
c:\Users\edreamleo/.codewise.db
&lt;sqlite3.Connection object at 0x02B881A0&gt;

c:\leo.repo\trunk&gt;python -m codewise init

c:\leo.repo\trunk&gt;c:\Python31\python.exe -m codewise init
Initializing CodeWise db at c:\Users\edreamleo/.codewise.db
c:\Users\edreamleo/.codewise.db
&lt;sqlite3.Connection object at 0x02BA21A0&gt;

c:\leo.repo\trunk&gt;python -m codewise parse c:\leo.repo\trunk

c:\leo.repo\trunk&gt;c:\Python31\python.exe -m codewise parse
Traceback (most recent call last):
  File "c:\Python31\lib\runpy.py", line 128, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "c:\Python31\lib\runpy.py", line 34, in _run_code
    exec(code, run_globals)
  File "c:\Python31\lib\site-packages\codewise.py", line 454, in &lt;module&gt;
    main()
  File "c:\Python31\lib\site-packages\codewise.py", line 440, in main
    cmd_parse(args)
  File "c:\Python31\lib\site-packages\codewise.py", line 368, in cmd_parse
    assert args
AssertionError

c:\leo.repo\trunk&gt;scripts

c:\leo.repo\trunk&gt;cd c:\Scripts

c:\Scripts&gt;ed python.bat

c:\Scripts&gt;echo off
Could Not Find c:\Scripts\*.~?~

c:\Scripts&gt;tr

c:\Scripts&gt;cd c:\leo.repo\trunk

c:\leo.repo\trunk&gt;python -m codewise parse c:\leo.repo\trunk

c:\leo.repo\trunk&gt;c:\Python31\python.exe -m codewise parse c:\leo.repo\trunk
c:\Users\edreamleo/.codewise.db
ctags -R --sort=no -f - c:\leo.repo\trunk

c:\leo.repo\trunk&gt;python -m codewise parse c:\python31\lib

c:\leo.repo\trunk&gt;c:\Python31\python.exe -m codewise parse c:\python31\lib
c:\Users\edreamleo/.codewise.db
ctags -R --sort=no -f - c:\python31\lib
Traceback (most recent call last):
  File "c:\Python31\lib\runpy.py", line 128, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "c:\Python31\lib\runpy.py", line 34, in _run_code
    exec(code, run_globals)
  File "c:\Python31\lib\site-packages\codewise.py", line 454, in &lt;module&gt;
    main()
  File "c:\Python31\lib\site-packages\codewise.py", line 440, in main
    cmd_parse(args)
  File "c:\Python31\lib\site-packages\codewise.py", line 370, in cmd_parse
    cw.parse(args)
  File "c:\Python31\lib\site-packages\codewise.py", line 307, in parse
    self.feed_ctags(f)
  File "c:\Python31\lib\site-packages\codewise.py", line 250, in feed_ctags
    fil = fields[1]
IndexError: list index out of range

c:\leo.repo\trunk&gt;
</t>
<t tx="ekr.20101004092958.6008"></t>
<t tx="ekr.20101004092958.6009">@first #!/usr/bin/env python

&lt;&lt; docstring &gt;&gt;
&lt;&lt; usage &gt;&gt;
&lt;&lt; decls &gt;&gt;

@language python
@tabwidth -4

@others

if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20101004092958.6010">""" CodeWise - global code intelligence database

Why codewise:

- Exuberant ctags is an excellent code scanner
- Unfortunately, TAGS file lookup sucks for "find methods of this class"
- TAGS files can be all around the hard drive. CodeWise database is
  just one file (by default ~/.codewise.db)
- I wanted to implement modern code completion for Leo editor

- This is usable as a python module, or a command line tool.

"""
</t>
<t tx="ekr.20101004092958.6011">USAGE = """
codewise setup
 (Optional - run this first to create template ~/.ctags)

codewise init
 Create/recreate the global database

codewise parse /my/project /other/project
 Parse specified directories (with recursion) and add results to db

codewise m
 List all classes

codewise m MyClass
 Show all methods in MyClass

codewise f PREFIX
 Show all symbols (also nonmember functiosn) starting with PREFIX.
 PREFIX can be omitted to get a list of all symbols

codewise parseall
 Clear database, reparse all paths previously added by 'codewise parse'

codewise sciapi pyqt.api
 Parse an api file (as supported by scintilla, eric4...)

Commands you don't probably need:

codewise tags TAGS
 Dump already-created tagfile TAGS to database

""" 
</t>
<t tx="ekr.20101004092958.6012">import os,sys
import sqlite3

isPython3 = sys.version_info &gt;= (3,0,0) # EKR.

DEFAULT_DB = os.path.expanduser("~/.codewise.db")

DB_SCHEMA = """
BEGIN TRANSACTION;
CREATE TABLE class (id INTEGER PRIMARY KEY, file INTEGER,  name TEXT, searchpattern TEXT);
CREATE TABLE file (id INTEGER PRIMARY KEY, path TEXT);
CREATE TABLE function (id INTEGER PRIMARY KEY, class INTEGER, file INTEGER, name TEXT, searchpattern TEXT);
CREATE TABLE datasource (type TEXT, src TEXT);

CREATE INDEX idx_class_name ON class(name ASC);
CREATE INDEX idx_function_class ON function(class ASC);

COMMIT;
"""

</t>
<t tx="ekr.20101004092958.6013"></t>
<t tx="ekr.20101004092958.6014"></t>
<t tx="ekr.20101004092958.6015">def cmd_functions(args):
    cw = CodeWise()

    if args:
        funcs = cw.get_functions(args[0])
    else:
        funcs = cw.get_functions()
    lines = list(set(el[0] + "\t" + el[1] for el in funcs))
    lines.sort()
    printlines(lines)
    return lines # EKR
</t>
<t tx="ekr.20101004092958.6016">def cmd_init(args):

    print("Initializing CodeWise db at", DEFAULT_DB)
    if os.path.isfile(DEFAULT_DB):
        os.remove(DEFAULT_DB)

    cw = CodeWise()
</t>
<t tx="ekr.20101004092958.6017">def cmd_members(args):
    cw = CodeWise()
    if not args:
        lines = cw.classcache.keys()
        lines.sort()
        printlines(lines)        
        return [] # EKR

    mems = cw.get_members([args[0]])
    lines = list(set(el + "\t" + pat for el, pat in mems))
    lines.sort()
    printlines(lines)
    return lines # EKR
</t>
<t tx="ekr.20101004092958.6018">def cmd_parse(args):
    assert args
    cw = CodeWise()
    cw.parse(args)
</t>
<t tx="ekr.20101004092958.6019">def cmd_parseall(args):
    cw = CodeWise()
    cw.parseall()
</t>
<t tx="ekr.20101004092958.6020">def cmd_scintilla(args):
    cw = CodeWise()
    for fil in args:
        f = open(fil)
        cw.feed_scintilla(f)
        f.close()
</t>
<t tx="ekr.20101004092958.6021">def cmd_setup(args):

    ctagsfile = os.path.expanduser("~/.ctags")
    print("Creating template",ctagsfile)
    assert not os.path.isfile(ctagsfile)
    open(ctagsfile, "w").write("--exclude=*.html\n--exclude=*.css\n")
    cmd_init(args)
</t>
<t tx="ekr.20101004092958.6022">def cmd_tags(args):
    cw = CodeWise()
    cw.feed_ctags(open(args[0]))
</t>
<t tx="ekr.20101004092958.6023">def main():
    if len(sys.argv) &lt; 2:
        print(USAGE)
        return
    cmd = sys.argv[1]
    #print "cmd",cmd
    args = sys.argv[2:]
    if cmd == 'tags':
        cmd_tags(args)
    elif cmd == 'm':
        cmd_members(args)
    elif cmd == 'f':
        cmd_functions(args)        
    elif cmd =='parse':
        cmd_parse(args)
    elif cmd =='parseall':
        cmd_parseall(args)
    elif cmd =='sciapi':
        cmd_scintilla(args)
    elif cmd == 'init':
        cmd_init(args)
    elif cmd == 'setup':
        cmd_setup(args)
</t>
<t tx="ekr.20101004092958.6024">def printlines(lines):
    for l in lines:
        try:
            print(l)
        except Exception: # EKR: UnicodeEncodeError:            
            pass
</t>
<t tx="ekr.20101004092958.6025">def run_ctags(paths):
    cm = 'ctags -R --sort=no -f - ' + " ".join(paths)
    print(cm)
    f = os.popen(cm)
    return f
</t>
<t tx="ekr.20101004092958.6026">class CodeWise:
    @others
</t>
<t tx="ekr.20101004092958.6027">def __init__(self, dbpath = None):

    if dbpath is None:
        # use "current" db from env var
        dbpath = DEFAULT_DB

    print(dbpath)

    self.reset_caches()

    if not os.path.exists(dbpath):
        self.createdb(dbpath)
    else:
        self.dbconn = c = sqlite3.connect(dbpath)
        self.create_caches()
</t>
<t tx="ekr.20101004092958.6028">def createdb(self, dbpath):

    self.dbconn = c = sqlite3.connect(dbpath)
    print(self.dbconn)
    c.executescript(DB_SCHEMA)
    c.commit()
    c.close()
</t>
<t tx="ekr.20101004092958.6029">def create_caches(self):
    """ read existing db and create caches """

    c = self.cursor()

    c.execute('select id, name from class')
    for idd, name in c:
        self.classcache[name] = idd

    c.execute('select id, path from file')
    for idd, name in c:
        self.filecache[name] = idd

    c.close()
    #print self.classcache
</t>
<t tx="ekr.20101004092958.6030">def reset_caches(self):
    self.classcache = {}
    self.filecache = {}

    self.fileids_scanned = set()
</t>
<t tx="ekr.20101004092958.6031">def cursor(self):
    return self.dbconn.cursor()
</t>
<t tx="ekr.20101004092958.6032">def class_id(self, classname):
    """ return class id. May create new class """

    if classname is None:
        return 0

    idd = self.classcache.get(classname)
    if idd is None:
        c = self.cursor()
        c.execute('insert into class(name) values (?)' , [classname])
        c.close()
        idd = c.lastrowid
        self.classcache[classname] = idd
    return idd
</t>
<t tx="ekr.20101004092958.6033">def get_members(self, classnames):

    clset = set(classnames)

    class_by_id = dict((v,k) for k,v in self.classcache.items())
    file_by_id = dict((v,k) for k,v in self.filecache.items())


    res = []
    for name, idd in self.classcache.items():
        if name in clset:
            c = self.cursor()
            #print idd
            c.execute('select name, class, file, searchpattern from function where class = (?)',(idd,))

            for name, klassid, fileid, pat in c:
                res.append((name, pat))

    return res
</t>
<t tx="ekr.20101004092958.6034">def get_functions(self, prefix = None):

    c = self.cursor()

    if prefix is not None:
        c.execute('select name, class, file, searchpattern from function where name like (?)',( prefix + '%',))
    else:
        c.execute('select name, class, file, searchpattern from function')

    return [(name, pat, klassid, fileid) for name, klassid, fileid, pat in c]
</t>
<t tx="ekr.20101004092958.6035">def file_id(self, fname):
    if fname == '':
        return 0

    idd = self.filecache.get(fname)
    if idd is None:
        c = self.cursor()
        c.execute('insert into file(path) values (?)', [fname] )
        idd = c.lastrowid

        self.filecache[fname] = idd
        self.fileids_scanned.add(idd)
    else:
        if idd in self.fileids_scanned:
            return idd

        # we are rescanning a file with old entries - nuke old entries
        #print "rescan", fname
        c = self.cursor()
        c.execute("delete from function where file = (?)", (idd, ))
        #self.dbconn.commit()
        self.fileids_scanned.add(idd)

    return idd
</t>
<t tx="ekr.20101004092958.6036">def feed_function(self, func_name, class_name, file_name, aux):
    """ insert one function

    'aux' can be a search pattern (as with ctags), signature, or description.
    """
    clid = self.class_id(class_name)
    fid = self.file_id(file_name)
    c = self.cursor()
    c.execute('insert into function(class, name, searchpattern, file) values (?, ?, ?, ?)',
              [clid, func_name, aux, fid])
</t>
<t tx="ekr.20101004092958.6037">def feed_scintilla(self, apifile_obj):
    """ handle scintilla api files

    Syntax is like:

    qt.QApplication.style?4() -&gt; QStyle
    """

    for l in apifile_obj:
        if not isPython3:
            l = unicode(l, 'utf8', 'replace')
        parts = l.split('?')
        fullsym = parts[0].rsplit('.',1)
        klass, func = fullsym

        if len(parts) == 2:
            desc = parts[1]
        else:
            desc = ''

        # now our class is like qt.QApplication. We do the dirty trick and
        # remove all but actual class name

        shortclass = klass.rsplit('.',1)[-1]

        #print func, klass, desc
        self.feed_function(func.strip(), shortclass.strip(), '', desc.strip())
    self.dbconn.commit()
</t>
<t tx="ekr.20101004092958.6038">def feed_ctags(self,tagsfile_obj):
    for l in tagsfile_obj:
        #print l
        if not isPython3:
            l = unicode(l, 'utf8', 'replace')
        if l.startswith('!'):
            continue
        fields = l.split('\t')
        m = fields[0]
        fil = fields[1]
        pat = fields[2]
        typ = fields[3]
        klass = None
        try:
            ext = fields[4]
            if ext and ext.startswith('class:'):
                klass = ext.split(':',1)[1].strip()
                idd = self.class_id(klass)
                #print "klass",klass, idd

        except IndexError:
            ext = None
            # class id 0 = function
            idd = 0

        c = self.cursor()
        #print fields

        fid = self.file_id(fil)

        c.execute('insert into function(class, name, searchpattern, file) values (?, ?, ?, ?)',
                  [idd, m, pat, fid])

    self.dbconn.commit()
    #c.commit()
</t>
<t tx="ekr.20101004092958.6039">def add_source(self, type, src):
    c = self.cursor()
    c.execute('insert into datasource(type, src) values (?,?)', (type,src))
    self.dbconn.commit()
</t>
<t tx="ekr.20101004092958.6040">def sources(self):
    c = self.cursor()
    c.execute('select type, src from datasource')
    return list(c)
</t>
<t tx="ekr.20101004092958.6041">def zap_symbols(self):
    c = self.cursor()
    tables = ['class', 'file', 'function']
    for t in tables:
        c.execute('delete from ' + t)
    self.dbconn.commit()
</t>
<t tx="ekr.20101004092958.6042"># high level commands        
def parseall(self):
    sources = self.sources()
    self.reset_caches()
    self.zap_symbols()
    tagdirs = [td for typ, td in sources if typ == 'tagdir']
    self.parse(tagdirs)
    self.dbconn.commit()
</t>
<t tx="ekr.20101004092958.6043">def parse(self, paths):
    paths = set(os.path.abspath(p) for p in paths)
    f = run_ctags(paths)
    self.feed_ctags(f)
    sources = self.sources()
    for a in paths:
        if ('tagdir', a) not in sources:            
            self.add_source('tagdir', a)
</t>
<t tx="ekr.20101004092958.6044">class ContextSniffer:
    """ Class to analyze surrounding context and guess class

    For simple dynamic code completion engines

    """
    @others
</t>
<t tx="ekr.20101004092958.6045">def __init__(self):
    # var name =&gt; list of classes
    self.vars = {}
</t>
<t tx="ekr.20101004092958.6046">def declare(self, var, klass):
    print("declare",var,klass)
    vars = self.vars.get(var, [])
    if not vars:
        self.vars[var] = vars
    vars.append(klass)
</t>
<t tx="ekr.20101004092958.6047">def push_declarations(self, body):
    for l in body.splitlines():
        l = l.lstrip()
        if not l.startswith('#'):
            continue
        l = l.lstrip('#')
        parts = l.strip(':')
        if len(parts) != 2:
            continue
        self.declare(parts[0].strip(), parts[1].strip())
</t>
<t tx="ekr.20101004092958.6048">def set_small_context(self, body):
    """ Set immediate function """
    self.push_declarations(body)
</t>
<t tx="ekr.20101004092958.6049">import codewise as cw
# print(dir(cw))

cw.cmd_init()
</t>
<t tx="ekr.20101004092958.6050">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/a1558a10eb8537c0?lnk=gst&amp;q=codewise#a1558a10eb8537c0

1. Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. You need a recent trunk version of leo to get the plugin which uses
the above module.

4. Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
with 'op' etc.

Nice work Ville, thanks.

==================

Thanks for this, I hope others will take a stab at it as well, given
sane instructions (I burned my free cycles frantically coding this
thing and neglected the all-important HOWTO). This is important
because functional completion is the single most important thing still
missing from Leo. Or, well, was ;-).

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

&gt; Then, after restarting leo if necessary, type

&gt; c.op&lt;Alt-0&gt; in the body editor to find all the c. methods starting
&gt; with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.&lt;alt+0&gt;

And self.&lt;alt+0&gt; 
</t>
<t tx="ekr.20101020125657.5976">def getFiles(fileName):

    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if not arg.startswith('-'):
            files.append(arg)

    files = [completeFileName(z) for z in files]
    return files
</t>
<t tx="ekr.20101021041958.6004">def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        path = g.os_path_finalize(fileName)
        theDir = g.os_path_dirname(fileName)
        myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
        local_table = (
            (localConfigFile,False),
            (myLocalConfigFile,False),
        )
        if trace:
            g.trace('localConfigFile:  ',localConfigFile)
            g.trace('myLocalConfigFile:',myLocalConfigFile)

        table1 = [z for z in local_table if z not in global_table]
        table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),table)
    return table
</t>
<t tx="ekr.20101021041958.6005"></t>
<t tx="ekr.20101021041958.6008"># This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
</t>
<t tx="ekr.20101021101942.6010">def getDefaultFile ():

    # Get the name of the workbook.
    fn = g.app.config.getString(c=None,setting='default_leo_file')
    fn = g.os_path_finalize(fn)

    if fn and g.os_path_exists(fn):
        return fn
    else:
        return None
</t>
<t tx="ekr.20101021101942.6011"></t>
<t tx="ekr.20101021160326.5948">@nocolor-node

on doing an Alt-X rst3 command

Traceback (most recent call last):
  File "leoCommands.py", line 359, in doCommand
    val = command(event)
  File "leoCommands.py", line 764, in minibufferCallback
    retval = function(keywords)
  File "mod_scripting.py", line 642, in __call__
    self.controller.executeScriptFromButton(self.p,self.b,self.buttonText)
  File "mod_scripting.py", line 667, in executeScriptFromButton
    c.executeScript(args=args,p=p,silent=True)
  File "leoCommands.py", line 1991, in executeScript
    script = g.getScript(c,p,useSelectedText=useSelectedText)
  File "leoGlobals.py", line 4358, in getScript
    at = leoAtFile.atFile(c)
  File "leoAtFile.py", line 145, in __init__
    'check-python-code-on-write',default=True)
  File "leoCommands.py", line 7436, in getBool
    return g.app.config.getBool(self.c,setting,default=default)
  File "leoConfig.py", line 1445, in getBool
    val = self.get(c,setting,"bool")
  File "leoConfig.py", line 1337, in get
    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')
  File "leoCommands.py", line 6673, in shortFileName
    return g.shortFileName(self.mFileName)
  File "leoGlobals.py", line 2548, in shortFileName
    return g.os_path_basename(fileName)
  File "leoGlobals.py", line 3401, in os_path_basename
    path = g.toUnicodeFileEncoding(path)
  File "leoGlobals.py", line 3643, in toUnicodeFileEncoding
    return g.toUnicode(path)
  File "leoGlobals.py", line 4636, in toUnicode
    elif mustConvert(s):
  File "leoGlobals.py", line 4632, in mustConvert
    return type(s) != types.UnicodeType
RuntimeError: maximum recursion depth exceeded while calling a Python object
</t>
<t tx="ekr.20101022124309.6127"># Called **only** from ic/at.scanDefaultDirectory.

def OLDsetDefaultDirectory(c,p,importing=False):

    ''' Compute a default directory by scanning @path directives.
    Return (default_dir,error_message).'''

    if not p: return '',''

    error = ''
    default_dir = g.getAbsPathFromNode(c,p)
        ### This calls g.makeAllNonExistentDirectories (!!)

    if not default_dir:
        default_dir,error = g.getPathFromDirectives(c,p)
            ### This calls g.makeAllNonExistentDirectories (!!)
            ### Sets error if the path does not exist.

    if c and c.frame and not default_dir and not error:
        default_dir = g.findDefaultDirectory(c)

    if not default_dir and not importing and not error:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    return default_dir, error
</t>
<t tx="ekr.20101022124309.6132">def checkOpenDirectory (c):

    if c.openDirectory != c.frame.openDirectory:
        g.error(
            'c.openDirectory != c.frame.openDirectory\n'
            'c.openDirectory: %s\n'
            'c.frame.openDirectory: %s' % (
                c.openDirectory,c.frame.openDirectory))

    if not g.os_path_isabs(c.openDirectory):
        g.error ('relative c.openDirectory: %s' % (
            c.openDirectory))
</t>
<t tx="ekr.20101022172109.6108">def scanAtPathDirectives(c,aList):

    path = c.scanAtPathDirectives(aList)
    return path

def scanAllAtPathDirectives(c,p):

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
</t>
<t tx="ekr.20101023095329.6115"></t>
<t tx="ekr.20101023095329.6116"></t>
<t tx="ekr.20101023095329.6118"></t>
<t tx="ekr.20101024062147.5991">@nocolor-node

see thread http://www.mail-archive.com/leo-editor@googlegroups.com/msg12137.html
for details.

- no keyboard method to swing focus away from the options panel

- inconsistent shortcuts for options, some use [Alt-*], others [Alt-*][space]

(perhaps nothing
can be done here, but it does make the user experience more awkward)
</t>
<t tx="ekr.20101024062147.5994"></t>
<t tx="ekr.20101024062147.5995"></t>
<t tx="ekr.20101024062147.5996"></t>
<t tx="ekr.20101024062147.5999"></t>
<t tx="ekr.20101024062147.6004"></t>
<t tx="ekr.20101024062147.6011"></t>
<t tx="ekr.20101024062147.6012"></t>
<t tx="ekr.20101024062147.6014"># These will be moved to 4.8 final, time permitting.
</t>
<t tx="ekr.20101024062147.6024">@nocolor-node

Ctrl-Shift movement (back-word-extend-selection, forward-word-extend-selection)
is incorrect when there is an existing selection, which was created by some
method other than Ctrl-Shift movement.

Expected behavior: it should extend/contract the existing selection

Actual behavior: it creates a new selection from the cursor position
</t>
<t tx="ekr.20101024062147.6025"></t>
<t tx="ekr.20101024235225.5863">@nocolor-node

It is needed to set g.app.nodeIndices, which is used in the read logic for outlines,
so it *must* be set before we load any Leo file!  Thus, alas, it is not possible.
</t>
<t tx="ekr.20101024235225.5864">@nocolor
</t>
<t tx="ekr.20101024235225.5866">@nocolor-node

g.app.setLeoID now calls createDefaultGui instead of createTkGui.
</t>
<t tx="ekr.20101024235225.5894">@nocolor-node

There are some tricky issues here:

http://groups.google.com/group/leo-editor/browse_thread/thread/4da36f0d897a25e8

Important: g.loadOnePlugin calls the plugins onCreate method to make up for
events that have already been generated. pc.loadOnePlugin does not.
</t>
<t tx="ekr.20101024235225.5925">Command-line args
</t>
<t tx="ekr.20101024235225.5956"># Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
</t>
<t tx="ekr.20101024235225.5957"></t>
<t tx="ekr.20101024235225.5959">https://bugs.launchpad.net/leo-editor/+bug/532085

auto-rst isn't switching to a new title underline char. going from level 2 to 3
in the outline.

Changing to regular @rst and using the rst3 command to export works.

Tree:

Foo
    Bar
        This
        That
    Etc

Output:

Foo
===

Bar
+++

This
++++ &lt;- still using '+' one level down

--------------------------------------------------


Another test and this seems as bad or worse,

A-+
    |
   C-+
       |
      D

is using '=' to underline all three levels.
</t>
<t tx="ekr.20101024235225.5962">@nocolor-node

This is now a wishlist item.  @thin works the same way.

</t>
<t tx="ekr.20101024235225.5963">@nocolor-node

This is now a wishlist item.  @thin works the same way.

1. Create the following tree (node content prefixed with -, subnode
with +, [] denotes clones) and save.

@shadow file1.c
-@others
+ [clone]
-Content (clone)
+ [clone] (of course same clone content)

Instead of the expected test1.c file of:

Content (clone)
Content (clone)

I got just:

Content (clone)

I believe it to be a bug.

2. Now copy and paste one of the clones as a regular node, delete the
clone and save. We are left with two regular subnodes having the same
content, and this time the expected derived file is generated.

3. Undo to the state of having only the 2 clones (undo twice) and
save. Leo does not recognize any change in the file.

4. Edit the content of one clone and save. We are back to the 1st case
(missing content in the derived).
</t>
<t tx="ekr.20101025100847.5852">http://mail.google.com/mail/#inbox/12b7463d6c339406
</t>
<t tx="ekr.20101026125532.5968">@nocolor-node

** After best attempts  can't get Leo to recognize PyQt

- Is it significant that PyQt installer wants to install at::
D:\Lang\Python27\Lib\site-packages\PyQt4
- but (per a registry search) tk appears to have been installed by the Python installer
  one level up at: D:\Lang\Python27\Lib\lib-tk\

*** remainder are notes made while installing *** probably not relevant

Python page suggests either Python27 or Python31
(I already had Python25 and Python26 - though essentially unused)
I first installed Python31 - setting as default per installer,
then installed Python27 - also setting it as default (ie. to override Python31 choice)

Now installed Leo: LeoSetup-4.7.1-final.exe
Installer said "Found Python at D:\Lang\Python26\" (s/b Python27 ?)
and suggested location:
D:\Lang\Python27\Lib\site-packages\Leo-4.7.1-final

Instead I put it at D:\Lang\Leo\Leo-4.7.1-final

No mention of PyQt in the installer slides for Windows?
per Matt and his description of "site package" in
http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476/d5e62fa67bcdaaeb?lnk=gst&amp;q=install+qt#d5e62fa67bcdaaeb &lt;http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476/d5e62fa67bcdaaeb?lnk=gst&amp;q=install+qt#d5e62fa67bcdaaeb&gt;

 - I put a junction from D:\Lang\Leo\Leo-4.7.1-final to
   D:\Lang\Python27\Lib\site-packages\Leo-4.7.1-final

 - installed PyQt first to D:\Lang\PyQt\PyQt27
 but running "launchLeo.py" runs the Python27 (GOOD)
 but still doesn't find PyQt and says PyQt not installed -
 reverting to Tk UI so I reinstalled PyQt to the "default"  location:
 D:\Lang\Python27\Lib\site-packages\PyQt4

Now that I've created the junction for Leo-4.7.1-final trying to execute
"launchLeo.py" now stalls
Instead run it from the junction link in ...\site packages\...
I still does not recognize PyQt

    *** isPython3: False
    PyQt not installed - reverting to Tk UI
    Leo 4.7.1 final, build 3005, February 26, 2010
    Python 2.7.0, Tk 8.5, Pmw 1.3
    Windows 5, 1, 2600, 2, Service Pack 3
    reading settings in D:\Lang\Python27\Lib\site-packages\Leo-4.7.1-final\leo\confi
    g\leoSettings.leo
    using menus from: leoSettings.leo
    reading C:\Documents and Settings\Alec\.leo\.leoRecentFiles.txt
    Ui type not compatible for plugin (quicksearch)
    Can not import quicksearch from plugin quicksearch
    Ui type not compatible for plugin (contextmenu)
    Can not import contextmenu from plugin contextmenu
    Ui type not compatible for plugin (nav_qt)
    Can not import nav_qt from plugin nav_qt
    Can not load c:\aspell\bin\aspell-15.dll
    file not found: C:\Documents and Settings\Alec\.leo\workbook.leo
</t>
<t tx="ekr.20101027055033.5967">def scanNSIText (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    # body = g.choose(atAuto,'','@ignore\n')
    # if ext in ('.html','.htm'):   body += '@language html\n'
    # elif ext in ('.txt','.text'): body += '@nocolor\n'
    # else:
        # language = self.languageForExtension(ext)
        # if language: body += '@language %s\n' % language

    assert self.rootLine == ''

    body = '@language ini\n\n'

    self.setBodyString(p,body + self.escapeFalseSectionReferences(s))
    if atAuto:
        p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
</t>
<t tx="ekr.20101027055033.5968"></t>
<t tx="shadow.20080825171547.2">def textOffset(self):
    '''
        See http://tinyurl.com/5nescw for details
    '''

    p = self

    # caching of p.textOffset, we need to calculate it only once
    if p.txtOffset is not None:
        return p.txtOffset

    p.txtOffset = 0
    # walk back from the current position
    for cursor in p.self_and_parents():
        # we also need the parent, the "text offset" is relative to it
        parent = cursor.parent()
        if parent == None: # root reached
            break
        parent_bodyString = parent.b
        if parent_bodyString == '': # organizer node
            continue
        parent_lines = parent_bodyString.split('\n')
        # check out if the cursor node is a section
        cursor_is_section = False
        cursor_headString = cursor.h
        if cursor_headString.startswith('&lt;&lt;'):
            cursor_is_section = True # section node
        for line in parent_lines:
            if cursor_is_section == True:
                # find out the section in the bodyString of the parent
                pos = line.find(cursor_headString)
            else:
                # otherwise find the "@others" directive in the bodyString of the parent
                pos = line.find('@others')
            if pos &gt; 0:
                # break the iteration over lines if something is found 
                break
        if pos &gt; 0:
            p.txtOffset += pos
        if parent.v.isAnyAtFileNode(): # do not scan upper
            break

    return p.txtOffset         
</t>
<t tx="sps.20081111154528.5">def escapeFalseSectionReferences(self,s):

    result = []
    for line in g.splitLines(s):
        r1 = line.find('&lt;&lt;')
        r2 = line.find('&gt;&gt;')
        if r1&gt;=0 and r2&gt;=0 and r1&lt;r2:
            result.append("@verbatim\n")
            result.append(line)
        else:
            result.append(line)
    return ''.join(result)
</t>
<t tx="sps.20081112093624.1">class scanUtility:

    @others
</t>
<t tx="sps.20081213155951.1">self.ruby_keywords = [
# ruby keywords
# based on "Ruby in a Nutshell"
"BEGIN",    "do",     "next",   "then",
"END",      "else",   "nil",    "true",
"alias",    "elsif",  "not",    "undef",
"and",      "end",    "or",     "unless",
"begin",    "ensure", "redo",   "until",
"break",    "false",  "rescue", "when",
"case",     "for",    "retry",  "while",
"class",    "if",     "return", "yield",
"def",      "in",     "self",   "__FILE__",
"defined?", "module", "super",  "__LINE__",
]
</t>
<t tx="sps.20100531175334.10307">def runRootFileTangleTest(c,p):

    """Code for testing tangle of @root.  The first child is the top node of the
    outline to be processed; the remaining siblings have headlines corresponding to
    the file names that should be generated, with the bodies containing the intended
    contents of the corresponding file."""

    rootTestBeforeP = p.firstChild()
    rootTestAfterP = rootTestBeforeP.copyTreeAfter()
    resultNodeP = rootTestAfterP.copy()
    expected={}
    while resultNodeP.hasNext():
        resultNodeP.moveToNext()
        expected[resultNodeP.h]=resultNodeP.b

    c.tangleCommands.tangle_output = {}
    c.tangleCommands.tangle(event=None,p=rootTestAfterP)

    try:
        expectList = sorted(expected)
        resultList = sorted(c.tangleCommands.tangle_output)
        assert(expectList == resultList)
    except AssertionError:
        &lt;&lt; dump result file names and expected &gt;&gt;
        rootTestAfterP.doDelete()
        raise

    tu = testUtils(c)
    try:
        for t in expectList:
            result = g.toUnicode(c.tangleCommands.tangle_output[t])
            assert(expected[t] == result)
    except AssertionError:
        tu.showTwoBodies(t,expected[t],result)
        rootTestAfterP.doDelete()
        raise

    try:
        if not (c.tangleCommands.print_mode in ("quiet","silent")):
            # untangle relies on c.tangleCommands.tangle_output filled by the above
            c.tangleCommands.untangle(event=None, p=rootTestAfterP)
            assert(tu.compareOutlines(rootTestBeforeP, rootTestAfterP))
            # report produced by compareOutlines() if appropriate
    finally:
        rootTestAfterP.doDelete()
</t>
<t tx="sps.20100531175334.10309">print('\n','-' * 20)
print("expected files:")
for n in expectList:
    print("[%s]" % n, n.__class__)
print('-' * 20)
print("result files:")
for n in resultList:
    print("[%s]" % n, n.__class__)
print('-' * 20)
</t>
<t tx="sps.20100608083657.20937">if g.unitTesting:
    # complications to handle testing of multiple @root directives together with
    # @path directives
    file_name_path = file_name
    if (file_name_path.find(c.openDirectory) == 0):
        relative_path = file_name_path[len(c.openDirectory):]
        # don't confuse /u and /usr as having common prefixes
        if (relative_path[:len(os.sep)] == os.sep):
             file_name_path = relative_path[len(os.sep):]
    self.tangle_output[file_name_path] = self.output_file.get()
</t>
<t tx="sps.20100608083657.20938">if g.unitTesting:
    assert self.errors == 0
    g.app.unitTestDict ['tangle'] = True
    g.app.unitTestDict ['tangle_directory'] = self.tangle_directory
    if g.app.unitTestDict.get('tangle_output_fn'):
        g.app.unitTestDict['tangle_output_fn'] += "\n" + file_name
    else:
        g.app.unitTestDict ['tangle_output_fn'] = file_name
    continue
</t>
<t tx="sps.20100608083657.20939"># complications to handle testing of multiple @root directives together with
# @path directives
file_name_path = c.os_path_finalize_join(self.tangle_directory,path)
if (file_name_path.find(c.openDirectory) == 0):
    relative_path = file_name_path[len(c.openDirectory):]
    # don't confuse /u and /usr as having common prefixes
    if (relative_path[:len(os.sep)] == os.sep):
        file_name_path = relative_path[len(os.sep):]

# find the node with the right title, and load self.tangle_output and file_buf
file_buf = self.tangle_output.get(file_name_path)
</t>
<t tx="sps.20100618004337.16260">def runRootFileUntangleTest(c,p):

    """Code for testing untangle into @root.  The first child is the top node of the
    outline to be processed; it gets copied to a sibling that gets modified by the
    untangle.  The (pre-first child copy) second child represents the resulting tree
    which should result from the untangle.  The remaining siblings have headlines
    corresponding to the file names that should be untangled, with the bodies
    containing the intended contents of the corresponding file.  As a final check, the
    result of the untangle gets tangled, and the result gets compared to the (pseudo)
    files."""

    trace_test = 0
    rootTestBeforeP = p.firstChild()
    # rootTestBeforeP -&gt; before tree
    # after tree
    # unit test "files"
    if trace_test:
        g.es("rootTestBeforeP: "+rootTestBeforeP.h+"\n")

    rootResultP = rootTestBeforeP.copy()
    rootResultP.moveToNext()
    # rootTestBeforeP -&gt; before tree
    # rootReultP -&gt; after tree
    # unit test "files"
    if trace_test:
        g.es("rootTestBeforeP: "+rootTestBeforeP.h)
        g.es("rootResultP: "+rootResultP.h+"\n")

    rootTestToChangeP = rootResultP.insertAfter()
    # rootTestBeforeP -&gt; before tree
    # rootResultP -&gt; after tree
    # rootTestToChangeP -&gt; empty node
    # unit test "files"
    if trace_test:
        g.es("rootTestBeforeP: "+rootTestBeforeP.h)
        g.es("rootResultP: "+rootResultP.h)
        g.es("rootTestToChangeP: "+rootTestToChangeP.h+"\n")

    rootTestBeforeP.copyTreeFromSelfTo(rootTestToChangeP)
    # rootTestBeforeP -&gt; before tree
    # rootResultP -&gt; after tree
    # rootTestToChangeP -&gt; copy of before tree
    # unit test "files"
    if trace_test:
        g.es("rootTestBeforeP: "+rootTestBeforeP.h)
        g.es("rootResultP: "+rootResultP.h)
        g.es("rootTestToChangeP: "+rootTestToChangeP.h+"\n")

    untangleInputP = rootTestToChangeP.copy()
    inputSet={}

    while untangleInputP.hasNext():
        untangleInputP.moveToNext()
        inputSet[untangleInputP.h]=untangleInputP.b
        if trace_test:
            g.es("test file name: %s\ntest file contents: %s" % (untangleInputP.h,untangleInputP.b))

    c.tangleCommands.untangle(event=None,p=rootTestToChangeP)

    try:
        t = testUtils(c)
        assert t.compareOutlines(rootTestToChangeP, rootResultP), "Expected outline not created"
        c.tangleCommands.tangle(event=None,p=rootTestToChangeP)
        inputSetList = sorted(inputSet)
        resultList = sorted(c.tangleCommands.tangle_output)
        assert inputSetList == resultList, "Expected tangled file list %s, got %s" % (repr(resultList),repr(inputSetList))
        for t in inputSet:
            result = g.toUnicode(c.tangleCommands.tangle_output[t])
            assert inputSet[t] == result, "Expected %s with content %s, got %s" % (t,inputSet[t],result)
    finally:
        rootTestToChangeP.doDelete()
</t>
<t tx="sps.20100618004337.16262">if g.unitTesting:
    p2 = p.copy()
    while (p2.hasNext()):
        p2.moveToNext()
        self.tangle_output[p2.h] = p2.b
</t>
<t tx="sps.20100618004337.20865"># Traverses the tree whose root is given, handling each headline and associated body text.

def tanglePass1(self,p_in,delims):

    """The main routine of tangle pass 1"""

    p = self.p = p_in.copy() # self.p used by update_def in untangle
#    g.trace(p)
    self.setRootFromHeadline(p)
    theDict = g.get_directives_dict(p,[self.head_root])
    if ('ignore' in theDict):
        return
    self.scanAllDirectives(p) # calls init_directive_ivars.
    # Scan the headline and body text.
    # @language and @comment are not recognized in headlines
    self.skip_headline(p)
    delims = self.skip_body(p, delims)
    if self.errors + g.app.scanErrors &gt;= max_errors:
        self.warning("----- Halting Tangle: too many errors")
    elif p.hasChildren():
        p.moveToFirstChild()
        self.tanglePass1(p,delims)
        while p.hasNext() and (self.errors + g.app.scanErrors &lt; max_errors):
            p.moveToNext()
            self.tanglePass1(p,delims)
</t>
<t tx="sps.20100618004337.20951"># This method handles all the body text.

def skip_body (self,p,delims):

    # g.trace(p)
    # g.trace("****start****\n"+self.st_dump())
    c = self.c
    s = p.b
    code = doc = None ; i = 0
    anyChanged = False

    if self.start_mode == "code":
        j = g.skip_blank_lines(s,i)
        i,code,new_delims,reflist = self.skip_code(s,j,delims)
        if code:
            &lt;&lt; Define a section for a leading code part &gt;&gt;
        delims = new_delims

    if not code:
        i,doc,delims = self.skip_doc(s,i,delims) # Start in doc section by default.
        if i &gt;= len(s) and doc:
            &lt;&lt; Define a section containing only an @doc part &gt;&gt;

    while i &lt; len(s):
        progress = i # progress indicator
        # line = g.get_line(s,i) ; g.trace(line)
        kind, end = self.token_type(s,i,report_errors=True)
        # if g.is_nl(s,i): i = g.skip_nl(s,i)
        i = g.skip_ws(s,i)
        if kind == section_def:
            &lt;&lt; Scan and define a section definition &gt;&gt;
            # g.trace("****after section def****\n"+self.st_dump())
        elif kind == at_code:
            i = g.skip_line(s,i)
            &lt;&lt; Scan and define an @code defininition &gt;&gt;
            # g.trace("****after @code****\n"+self.st_dump())
        elif kind == at_root:
            i = g.skip_line(s,i)
            &lt;&lt; Scan and define a root section &gt;&gt;
            # g.trace("****after @root****\n"+self.st_dump())
        elif kind in (at_doc, at_chapter, at_section):
            i = g.skip_line(s,i)
            i, more_doc, delims = self.skip_doc(s,i,delims)
            doc = doc + more_doc
        else:
            i = g.skip_line(s,i)
        assert(progress &lt; i) # we must make progress!
    # Only call trimTrailingLines if we have changed its body.
    if anyChanged:
        c.trimTrailingLines(p)

    return delims
</t>
<t tx="sps.20100618004337.20952">if self.header_name:
    # Tangle code.
    part = self.st_enter_section_name(
        self.header_name,code,doc,delims,new_delims)
    if not self.tangling:
        # Untangle code.
        if self.untangle_stage1:
            section = self.st_lookup(self.header_name)
            section.parts[part-1].reflist(refs=reflist)
        else:
            head = s[:j] ; tail = s[i:]
            s,i,changed = self.update_def(self.header,part,head,code,tail)
            if changed: anyChanged = True
    code = doc = None

# leading code without a header name gets silently dropped
</t>
<t tx="sps.20100618004337.20953">@
It's valid for an @doc directive to appear under a headline that does
not contain a section name. In that case, no section is defined.
@c

if self.header_name:
    # Tangle code.
    part = self.st_enter_section_name(self.header_name,code,doc,delims,delims)
    # Untangle code.
    if not self.tangling: 
        # Untangle no longer updates doc parts.
        # 12/03/02: Mark the part as having been updated to suppress warning.
        junk,junk = self.ust_lookup(self.header_name,part,update_flag=True)

doc = None
</t>
<t tx="sps.20100618004337.20954"># We enter the code part and any preceding doc part into the symbol table.

# Skip the section definition line.
k = i ; i, kind, junk = self.skip_section_name(s,i)
section_name = s[k:i]
assert(kind == section_def)
i = g.skip_to_end_of_line(s,i)

# Tangle code: enter the section name even if the code part is empty.
&lt;&lt;process normal section&gt;&gt;

code = None
doc = ''
</t>
<t tx="sps.20100618004337.20955"># All @c or @code directives denote &lt; &lt; headline_name &gt; &gt; =
if self.header_name:
    section_name = self.header_name
    &lt;&lt;process normal section&gt;&gt;
else:
    self.error("@c expects the headline: " + self.header + " to contain a section name")

code = None
doc = ''
</t>
<t tx="sps.20100618004337.20956"># We save the file name in case another @root ends the code section.
old_root_name = self.root_name

# g.trace("Scan and define a root section: %s tangle %s" % (old_root_name,repr(self.tangling)))

# Tangle code.
j = g.skip_blank_lines(s,i)
k, code, new_delims, reflist = self.skip_code(s,j,delims)

# g.trace("reflist: " + repr(reflist))

self.st_enter_root_name(old_root_name,code,doc,delims,new_delims)
delims = new_delims

# g.trace("self.tangling: "+repr(self.tangling))
if not self.tangling: # Untangle code.
    # g.trace("untangle_stage1: "+repr(self.untangle_stage1))
    if self.untangle_stage1:
        root_section = self.st_lookup(old_root_name)
        assert(root_section)
        root_first_part = root_section.parts[0]
        assert(root_first_part)
        root_first_part.reflist(refs = reflist)
    else:
        part = 1 # Use 1 for root part.
        head = s[:j] ; tail = s[k:]
        # g.trace("old_root_name &lt;%s&gt; part &lt;%d&gt; head &lt;%s&gt; code &lt;%s&gt; tail &lt;%s&gt;" % (old_root_name,part,head,code,tail))
        s,i,changed = self.update_def(old_root_name,part,head,code,tail,is_root_flag=True)
        if changed: anyChanged = True

# g.trace(self.st_dump())

code = None
doc = ''
</t>
<t tx="sps.20100618004337.20957">@
The following subsections contain the interface between the Tangle and
Untangle commands. This interface is an important hack, and allows
Untangle to avoid duplicating the logic in skip_tree and its allies.

The aha is this: just at the time the Tangle command enters a
definition into the symbol table, all the information is present that
Untangle needs to update that definition.

To get whitespace exactly right we retain the outline's leading
whitespace and remove leading whitespace from the updated definition.
</t>
<t tx="sps.20100618004337.20965">@
This method skips an entire code section. The caller is responsible
for entering the completed section into the symbol table. On entry, i
points at the line following the @directive or section definition that
starts a code section. We skip code until we see the end of the body
text or the next @ directive or section defintion that starts a code
or doc part.
@c

def skip_code(self,s,i,delims):

    reflist = []
    # g.trace(g.get_line(s,i))
    code1 = i
    nl_i = i # For error messages
    done = False # True when end of code part seen.
    &lt;&lt; skip a noweb code section &gt;&gt;
    code = s[code1:i]
    # g.trace("returns:",code)
    return i,code,delims,reflist
</t>
<t tx="sps.20100618004337.20966">@
This code handles the following escape conventions: double at-sign at
the start of a line and at-&lt;&lt; and at.&gt;.
@c

i, done, delims = self.handle_newline(s,i,delims)
while not done and i &lt; len(s):
    ch = s[i]
    if g.is_nl(s,i):
        nl_i = i = g.skip_nl(s,i)
        i, done, delims = self.handle_newline(s,i,delims)
    elif ch == '@' and (g.match(s,i+1,"&lt;&lt;") or # must be on different lines
        g.match(s,i+1,"&gt;&gt;")):
        i += 3 # skip the noweb escape sequence.
    elif ch == '&lt;':
        &lt;&lt; handle possible noweb section reference &gt;&gt;
    else: i += 1
</t>
<t tx="sps.20100618004337.20967">j, kind, end = self.is_section_name(s,i)
if kind == section_def:
    k = g.skip_to_end_of_line(s,i)
    # We are in the middle of a line.
    i += 1
    self.error("chunk definition not valid here\n" + s[nl_i:k])
elif kind == bad_section_name:
    i += 1 # This is not an error.  Just skip the '&lt;'.
else:
    assert(kind == section_ref)
    # Enter the reference into the symbol table.
    # Appropriate comment delimiters get specified
    # at the time the section gets defined.
    name = s[i:end]
    self.st_enter_section_name(name,None,None,None,None)
    reflist.append(self.st_lookup(name))
    i = end
</t>
<t tx="sps.20100618004337.20969">@
This method handles newline processing while skipping a code section.
It sets 'done' if the line contains an @directive or section
definition that terminates the present code section. On entry: i
should point to the first character of a line. This routine scans past
a line only if it could not contain a section reference.

Returns (i, done)
@c

def handle_newline(self,s,i,delims):

    assert(delims)
    # g.trace(s[i:g.skip_to_end_of_line(s,i)])
    j = i ; done = False
    kind, end = self.token_type(s,i,report_errors=False)
    # token_type will not skip whitespace in noweb mode.
    i = g.skip_ws(s,i)
    # g.trace(kind,g.get_line(s,i))

    if kind == plain_line:
        pass
    elif (kind == at_code or kind == at_doc or
        kind == at_root or kind == section_def):
        i = j ; done = True # Terminate this code section and rescan.
    elif kind == section_ref:
        # Enter the reference.
        ref = s[i:end]
        self.st_enter_section_name(ref,None,None,None,None)
    elif kind == at_other:
        k = g.skip_to_end_of_line(s,i)
        if g.match_word(s,j,"@language"):
            lang,d1,d2,d3 = g.set_language(s,j)
            delims = (d1,d2,d3)
        elif g.match_word(s,j,"@comment"):
            delims = g.set_delims_from_string(s[j:k])
        i = k
    elif kind == at_chapter or kind == at_section:
        # We don't process chapter or section here
        i = g.skip_to_end_of_line(s,i)
    elif kind == bad_section_name:
        pass
    elif kind == at_web or kind == at_at:
        i += 2 # Skip a CWEB control code.
    else: assert(False)

    return i, done, delims
</t>
<t tx="sps.20100621105534.16896">self.onl() ; self.put_leading_ws(self.tangle_indent)

if self.print_mode != "silent":
    if delims[0]:
        self.os(delims[0])
        self.os(" undefined section: ") ; self.os(name) ; self.onl()
    else:
        self.os(delims[1])
        self.os(" undefined section: ") ; self.os(name)
        self.oblank() ; self.os(delims[2]) ; self.onl()

self.error("Undefined section: " + name)
</t>
<t tx="sps.20100622084732.12299">if self.line_comment or self.comment:
    line = g.choose(self.line_comment,self.line_comment,self.comment) + " Created by Leo from" 
    if g.match(s,i,line):
        # Even a block comment will end on the first line.
        i = g.skip_to_end_of_line(s,i)
</t>
<t tx="sps.20100622084732.12308"># g.trace("copy a multiline comment:"+g.get_line(s,i))
assert(self.comment_end)

j = i
i += len(self.comment)
if self.sentinel == self.comment:
    # g.trace("sentinel == comment: "+self.sentinel)
    # Scan for the ending delimiter.
    while i &lt; len(s) and not g.match(s,i,self.comment_end):
        i += 1
    if g.match(s,i,self.comment_end):
        i += len(self.comment_end)
    self.copy(s[j:i])
else:
    # g.trace("sentinel != comment: &lt;%s&gt; &lt;%s&gt;" % (self.sentinel, self.comment))
    # Copy line by line, looking for a sentinel within the
    # comment
    while i &lt; len(s):
        if g.match(s,i,self.comment_end):
            i += len(self.comment_end)
            break
        elif g.is_nl(s,i):
            k = g.skip_nl(s,i)
            k = g.skip_ws(s,k)
            if self.is_sentinel_line(s,k):
                break
            else:
                i = g.choose(k+1 &lt;= len(s), k+1, len(s))
        else:
            i += 1
self.copy(s[j:i])
</t>
<t tx="sps.20100622084732.16656">def reflist(self, refs=False):
    if refs:
        self.refs = refs
    return self.refs
</t>
<t tx="sps.20100623125751.16367"># The next sentinel will be either
# (a) a section part reference, using the "before" comment style for that part
# - when there are section references yet to interpolate for this part
# - when we're followed by another part for this section
# (b) an end sentinel using the "after" comment style for the current part
# - when we've exhausted the parts for this section
# or (c) end of file for the root section
# The above requires that the parts in the tst be aware of the section
# interpolations each part will make
def select_next_sentinel(self, part_start_flag=True):
    # g.trace(self.st_dump())

    # keep a "private" copy of the tst table so that it doesn't get
    # corrupted by a subsequent tanglePass1 run
    if not self.delims_table:
        self.delims_table = self.tst
        restore_tst = self.tst
    else:
        restore_tst = self.tst
        self.tst = self.delims_table

    # g.trace(self.refpart_stack_dump())
    if self.refpart_stack == []:

        # beginning a new file
        section = self.st_lookup(self.root_name)
        assert section.__class__ == tst_node
        assert len(section.parts) == 1
        # references to sections within the part were noted by tanglePass1
        root_part = section.parts[0]
        assert root_part.__class__ == part_node
        reflist = root_part.reflist()
        &lt;&lt; push each part for each reference expected &gt;&gt;
        # set the delimiters for the root section
        delims = section.parts[0].delims
    else:
        # we've just matched a sentinel
        if part_start_flag:
            part = self.refpart_stack.pop()
            assert part.__class__ == part_node, "expected type part_node, got %s" % repr(part.__class__)
            reflist = part.reflist()
            &lt;&lt; push each part for each reference expected &gt;&gt;
        else:
            s = self.refpart_stack.pop()
            assert s.__class__ == tst_node

        if len(self.refpart_stack)&gt;0:
            delims = self.refpart_stack[-1].delims
        else:
            section = self.st_lookup(self.root_name)
            delims = section.delims


    if delims[0]:
        self.line_comment = delims[0]
        self.sentinel = delims[0]
        self.sentinel_end = False
    else:
        self.line_comment = None
        self.sentinel = delims[1]
        self.sentinel_end = delims[2]
    # g.trace("looking for %s with sentinel start %s" % (repr(self.refpart_stack[-1]),self.sentinel))

    # don't change multiline comment until after a comment convention transition is finished
    if len(self.refpart_stack)&lt;2 or (
        self.refpart_stack[-2].delims[1] == self.refpart_stack[-1].delims[1] and
        self.refpart_stack[-2].delims[1] == self.refpart_stack[-1].delims[2]):
            self.comment = delims[1]
            self.comment_end = delims[2]
    # g.trace(self.refpart_stack_dump())

    self.tst = restore_tst
</t>
<t tx="sps.20100623125751.16368">if len(reflist)&gt;0:
    for i in range(-1,-(len(reflist)+1),-1):
        # g.trace("section i:",i)
        # push each part start delims for each reference expected
        r = reflist[i]
        # cope with undefined sections
        count = len(r.parts)
        # g.trace("parts in section i:",count)
        if count&gt;0:
            # push the section for the end sentinel
            self.refpart_stack.append(r)
            for j in range(-1,-(count+1),-1):
                self.refpart_stack.append(r.parts[j])
</t>
<t tx="sps.20100623164631.12028">def refpart_stack_dump(self):
    s = "top of stack:"
    for i in range(-1,-(len(self.refpart_stack)+1),-1):
        if self.refpart_stack[i].__class__ == part_node:
            s += "\nnode: " + self.refpart_stack[i].name + " delims: " + repr(self.refpart_stack[i].delims)
        elif self.refpart_stack[i].__class__ == tst_node:
            s += "\nsection: " + self.refpart_stack[i].name + " delims: " + repr(self.refpart_stack[i].delims)
        else:
            s += "\nINVALID ENTRY of type " + repr(self.refpart_stack[i].__class__)
    s += "\nbottom of stack.\n"
    return s
</t>
<t tx="sps.20100624113712.16401">while g.match_word(s,i,"@comment") or g.match_word(s,i,"@language"):
    i = g.skip_line(s,i)
</t>
<t tx="sps.20100624231018.12083">def dump(self):
    s = ("\nsection: " + self.name +
        ", referenced:" + str(self.referenced) +
        ", is root:" + str(self.is_root))

    if len(self.parts) &gt; 0:
        s += "\n----- parts of " + g.angleBrackets(self.name)
        n = 1 # part list is in numeric order
        for part in self.parts:
            s += "\n----- Part " + str(n)
            n += 1
            s += "\ndoc:  [" + repr(part.doc)  + "]"
            s += "\ncode: [" + repr(part.code) + "]"
            s += "\ndelims: &lt;%s&gt;&lt;%s&gt;&lt;%s&gt;" % part.delims
            for ref in part.reflist():
                s += "\n    ref: [" + repr(ref.name) + "]"
        s += "\n----- end of partList\n"
    return s
</t>
<t tx="sps.20100624231018.12084">def dump(self):
    s = "name: %s" % repr(self.name)
    for part in self.parts.values():
        # assert(part.of == self.of)
        s += "\n----- part %s of %s -----\n" % (repr(part.part),repr(part.of))
        s += repr(g.get_line(part.code,0))
        s += "\nupdate_flag: %s" % repr(part.update_flag)
    return s
</t>
<t tx="sps.20100625103124.16437"># side effect: sets the values within lang_dict
# *might* lower case c.target_language
def parent_language_comment_settings(self,p,lang_dict):
    import re
    c = self.c
    if p.hasParent():
        p1 = p.parent()
        for s in (p1.b, p1.h):
            m = self.RegexpForLanguageOrComment.regex.match(s)
            if not lang_dict['delims']:
                if m.group('language'):
                    lang, d1, d2, d3 = g.set_language(m.group('language'),0)
                    lang_dict['language'] = lang
                    lang_dict['delims'] = (d1, d2, d3)
                    if m.group('comment') and (m.start('comment')&gt;m.start('language')):
                        lang_dict['delims'] = g.set_delims_from_string(m.group('comment'))
                    break
                if m.group('comment'):
                    lang_dict['delims'] = g.set_delims_from_string(m.group('comment'))
            elif not lang_dict['language']:
                # delims are already set, only set language
                if m.group('language'):
                    lang, d1, d2, d3 = g.set_language(m.group('language'))
                    lang.dict['language'] = lang
                    break
        if not lang_dict['language']:
            self.parent_language_comment_settings(p1,lang_dict)
    else:
        if not lang_dict['language']:
            if c.target_language:
                c.target_language = c.target_language.lower()
                lang, d1, d2, d3 = g.set_language(c.target_language,0)
                lang_dict['language'] = lang
                if not lang_dict['delims']:
                    lang_dict['delims'] = (d1, d2, d3)
</t>
<t tx="sps.20100629094515.16518">if g.match_word(s1,p1+1,"language") or g.match_word(s1,p1+1,"comment"):
    p1 = g.skip_line(s1,p1+7)
else:
    &lt;&lt; Compare single characters &gt;&gt;

</t>
<t tx="sps.20100629094515.20939">code2 = code.rstrip()
trail_ws = code[len(code2):]
ucode = ucode + trail_ws
</t>
<t tx="sps.20100629094515.20940"># split the code into lines, collecting the @language and @comment lines specially
# if @language or @comment are present, they get added at the end
if code[-1] == '\n':
    leading_newline = ''
    trailing_newline = '\n'
else:
    leading_newline = '\n'
    trailing_newline = ''
m = self.RegexpForLanguageOrComment.regex.match(code)
# g.trace(repr(m.groupdict()))
if m.group('language'):
    ucode = ucode + leading_newline
    if m.group('comment') and (m.start('language') &lt; m.start('comment')):
        ucode = ucode + m.group('language') + "\n" + m.group('comment')
    else:
        ucode = ucode + m.group('language')
    ucode = ucode + trailing_newline
else:
    if m.group('comment'):
        ucode = ucode + leading_newline + m.group('comment') + trailing_newline
</t>
<t tx="sps.20100629094515.20943">class RegexpForLanguageOrComment:
    import re
    regex = re.compile(r'''
        ^(
            (?P&lt;language&gt;
                @language\s[^\n]*
            ) |
            (?P&lt;comment&gt;
                @comment\s[^\n]*
            ) |
            (
                [^\n]*\n
            )
        )*''', re.VERBOSE)
</t>
<t tx="sps.20100716120121.12132"># Tangle code.
j = g.skip_blank_lines(s,i)
i, code, new_delims, reflist = self.skip_code(s,j,delims)
if False: #debug
    g.trace('=======\n%s======' % code)
part = self.st_enter_section_name(section_name,code,doc,delims,new_delims)
delims = new_delims

# Untangle code
if not self.tangling:
    # part may be zero if there was an empty code section (doc part only)
    # In untangle stage1 such code produces no reference list,
    #    thus nothing to do.
    # In untangle stage2, such code cannot be updated because it
    # was either not emitted to the external file or emitted as a doc part only
    #     in either case, there is no code section to update, and we don't
    #     update doc parts.
    if part &gt; 0:
        if self.untangle_stage1:
            section = self.st_lookup(section_name)
            section.parts[part-1].reflist(refs=reflist)
        else:
            head = s[:j] ; tail = s[i:]
            s,i,changed = self.update_def(section_name,part,head,code,tail)
            if changed: anyChanged = True
</t>
<t tx="sps.20100720205345.26316">def showTwoBodies(self,t,b1,b2):
    print('\n','-' * 20)
    print("expected for %s..." % t)
    for line in g.splitLines(b1):
        print("%3d" % len(line),repr(line))
    print('-' * 20)
    print("result for %s..." % t)
    for line in g.splitLines(b2):
        print("%3d" % len(line),repr(line))
    print('-' * 20)
</t>
<t tx="tbrown.20080119085249">def getIconList(self, p):
    """Return list of icons for position p, call setIconList to apply changes"""

    trace = False and not g.unitTesting
    if trace:
        if p == self.c.rootPosition(): g.trace('='*40)
        g.trace(p.h)

    fromVnode = []
    if hasattr(p.v,'unknownAttributes'):
        if trace: g.trace(p.v.u)
        fromVnode = [dict(i) for i in p.v.u.get('icons',[])]
        for i in fromVnode: i['on'] = 'vnode'

    if trace and fromVnode: g.trace('fromVnode',fromVnode,p.h)

    return fromVnode
</t>
<t tx="tbrown.20080119085249.1">def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    trace = False and not g.unitTesting

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return

    if trace: g.trace(l)

    self._setIconListHelper(p, l, p.v)

</t>
<t tx="tbrown.20080509212202.6">def cleanRecentFiles(self,event=None):

    c = self

    dat = c.config.getData('path-demangle')
    if not dat:
        g.es('No @data path-demangle setting')
        return

    changes = []
    replace = None
    for line in dat:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es('%s -&gt; %s' % changes[-1])

    orig = [i for i in c.recentFiles if i.startswith("/")]
    c.clearRecentFiles()

    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)

        c.updateRecentFiles(t)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
</t>
<t tx="tbrown.20080509212202.7">def deleteRecentFilesMenuItems(self,menu):
    """Delete recent file menu entries"""

    toDrop = len(self.c.recentFiles)
    if hasattr(self, 'recentFilesStatic'):
        toDrop += len(self.recentFilesStatic)

    self.delete_range(menu,0,toDrop)

    if hasattr(self, 'groupedMenus'):
        for i in self.groupedMenus:
            menu = self.getMenu(i)
            if menu:
                self.destroy(menu)
                self.destroyMenu(i)
</t>
<t tx="tbrown.20080509212202.8">def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()

    def key(s):
        return g.os_path_basename(s).lower()
    orig.sort(key=key) # 2010/01/12
    orig.reverse() # 2010/01/12
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
</t>
<t tx="tbrown.20080514112857.124">def doMenuat (self,p,kind,name,val):

    if g.app.config.menusList:
        g.es_print("Patching menu tree: " + name)

        # get the patch fragment
        patch = []
        if p.hasChildren():
            # self.doMenus(p.copy().firstChild(),kind,name,val,storeIn=patch)
            self.doItems(p.copy(),patch)
            self.dumpMenuTree(patch)

        # setup        
        parts = name.split()
        if len(parts) != 3:
            parts.append('subtree')
        targetPath,mode,source = parts
        if not targetPath.startswith('/'): targetPath = '/'+targetPath

        ans = self.patchMenuTree(g.app.config.menusList, targetPath)

        if ans:
            g.es_print("Patching ("+mode+' '+source+") at "+targetPath)

            list_, idx = ans

            if mode not in ('copy', 'cut'):
                if source != 'clipboard':
                    use = patch # [0][1]
                else:
                    if isinstance(self.clipBoard, list):
                        use = self.clipBoard
                    else:
                        use = [self.clipBoard]
                g.es_print(str(use))
            if mode == 'replace':
                list_[idx] = use.pop(0)
                while use:
                    idx += 1
                    list_.insert(idx, use.pop(0))
            elif mode == 'before':
                while use:
                    list_.insert(idx, use.pop())
            elif mode == 'after':
                while use:
                    list_.insert(idx+1, use.pop())
            elif mode == 'cut':
                self.clipBoard = list_[idx]
                del list_[idx]
            elif mode == 'copy':
                self.clipBoard = list_[idx]
                g.es_print(str(self.clipBoard))
            else:  # append
                list_.extend(use)
        else:
            g.es_print("ERROR: didn't find menu path " + targetPath)

    else:
        g.es_print("ERROR: @menuat found but no menu tree to patch")
</t>
<t tx="tbrown.20080514180046.2">def dumpMenuTree (self,aList,level=0,path=''):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            name = self.getName(val, val2)
            g.es_print('%s %s (%s) [%s]' % ('    '*(level+0), val, val2, path+'/'+name))
        else:
            name = self.getName(kind.replace('@menu ',''))
            g.es_print('%s %s... [%s]' % ('    '*(level), kind, path+'/'+name))
            self.dumpMenuTree(val,level+1,path=path+'/'+name)
</t>
<t tx="tbrown.20080514180046.8">def patchMenuTree(self, orig, targetPath, path=''):

    for n,z in enumerate(orig):
        kind,val,val2 = z
        if kind == '@item':
            name = self.getName(val, val2)
            curPath = path+'/'+name
            if curPath == targetPath:
                g.es_print('Found '+targetPath)
                return orig, n
        else:
            name = self.getName(kind.replace('@menu ',''))
            curPath = path+'/'+name
            if curPath == targetPath:
                g.es_print('Found '+targetPath)
                return orig, n
            ans = self.patchMenuTree(val, targetPath, path=path+'/'+name)
            if ans:
                return ans

    return None
</t>
<t tx="tbrown.20080514180046.9">def getName(self, val, val2=None):
    if val2 and val2.strip(): val = val2
    val = val.split('\n',1)[0]
    for i in "*.-&amp; \t\n":
        val = val.replace(i,'')
    return val.lower()
</t>
<t tx="tbrown.20090219095555.61">def handleUrlInUrlNode(url):

    # Note 1: the UNL plugin has its own notion of what a good url is.

    # Note 2: tree.OnIconDoubleClick now uses the body text of an @url
    #         node if it exists.

    if g.unitTesting: return
    &lt;&lt; check the url; return if bad &gt;&gt;
    &lt;&lt; pass the url to the web browser &gt;&gt;
</t>
<t tx="tbrown.20090219095555.62">@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url:",url)
    return
</t>
<t tx="tbrown.20090219095555.63">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],None)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening",url)
    g.es_exception()
</t>
<t tx="tbrown.20091206142842.10296">def vnode2allPositions (self,v):

    '''Given a vnode v, find all valid positions p such that p.v = v.

    Not really all, just all for each of v's distinct immediate parents.
    '''

    c = self
    context = v.context # v's commander.
    root = c.hiddenRootNode
    assert (c == context)

    positions = []
    for immediate in v.parents:
        if v in immediate.children:
            n = immediate.children.index(v)
        else:
            continue
        stack = [(v,n)]
        while immediate.parents:
            parent = immediate.parents[0]
            if immediate in parent.children:
                n = parent.children.index(immediate)
            else:
                break
            stack.insert(0,(immediate,n),)
            immediate = parent
        else:
            v,n = stack.pop()
            p = leoNodes.position(v,n,stack)
            positions.append(p)

    return positions

</t>
<t tx="ville.20090222141717.2">class TryNext(Exception):

    """Try next hook exception.

    Raise this in your hook function to indicate that the next hook handler
    should be used to handle the operation.  If you pass arguments to the
    constructor those arguments will be used by the next hook instead of the
    original ones.
    """

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs
</t>
<t tx="ville.20090222184600.2">def actOnNode(self, event):
    """ Execute node-specific action (typically defined by plugins)

    Actual behaviour is to be defined by plugins.

    Here's how to define actions for nodes in your plugins::

        import leo.core.leoPlugins
        def act_print_upcase(c,p,event):
            if not p.h.startswith('@up'):
                raise leo.core.leoPlugins.TryNext
            p.h = p.h.upper()

        g.act_on_node.add(act_print_upcase)        

    This will upcase the headline when it starts with @up.            

    """
    g.act_on_node(self.c,self.c.p,event)
</t>
<t tx="ville.20090311190405.68">class poslist(list):
    """ List of positions 

    This behaves like a normal list, with the distinction that it 
    has select_h and select_b methods that can be used 
    to search through immediate children of the nodes.

    """
    @others
</t>
<t tx="ville.20090311190405.69">def select_h(self, regex, flags = re.IGNORECASE):
    """ Find immediate child nodes of nodes in poslist with regex.

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

        pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')

    """
    pat = re.compile(regex, flags)
    res = poslist()
    for p in self:
        for child_p in p.children():            
            m = re.match(pat, child_p.h)
            if m:
                pc = child_p.copy()
                pc.mo = m
                res.append(pc)
    return res
</t>
<t tx="ville.20090311190405.70">def find_h(self, regex, flags = re.IGNORECASE):
    """ Return list (a poslist) of all nodes whose headline matches the regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

    pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')    
    """
    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.poslist()
    for p in c.all_positions():
        m = re.match(pat, p.h)
        if m:
            pc = p.copy()
            pc.mo = m
            res.append(pc)
    return res

</t>
<t tx="ville.20090311195550.1">def select_b(self, regex, flags = re.IGNORECASE ):
    """ Find all the nodes in poslist where body matches regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

        pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')
    """
    pat = re.compile(regex, flags)
    res = poslist()
    for p in self:
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
            # if does not raise StopIteration...
            pc = p.copy()
            pc.matchiter = t2
            res.append(pc)

        except StopIteration:
            pass

    return res
</t>
<t tx="ville.20090311200059.1">def find_b(self, regex, flags = re.IGNORECASE | re.MULTILINE):
    """ Return list (a poslist) of all nodes whose body matches the regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

    pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')    
    """

    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.poslist()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
</t>
<t tx="ville.20090521164644.5924">class command:
    """ Decorator to create global commands """
    def __init__(self, name, **kwargs):
        """ Registration for command 'name'

        kwargs reserved for future use (shortcut, button, ...?)

        """
        self.name = name
        self.args = kwargs

    def __call__(self,func):
        # register command for all future commanders
        g.app.global_commands_dict[self.name] = func

        # ditto for all current commanders
        for co in g.app.commanders():
            co.k.registerCommand(self.name,shortcut = None, func = func, pane='all',verbose=False)        

        return func


</t>
<t tx="ville.20090525205736.12325">def getSelectedPositions(self):
    """ Get list (poslist) of currently selected positions

    So far only makes sense on qt gui (which supports multiselection)
    """
    c = self
    return c.frame.tree.getSelectedPositions()
</t>
<t tx="ville.20090602181814.6219">def commanders(self):
    """ Return list of currently active controllers """

    return [f.c for f in g.app.windowList]    
</t>
<t tx="ville.20090620122043.6275">def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """

    g.app.db = leoCache.cacher()
    g.app.db.initGlobalDB()

</t>
<t tx="ville.20090701144325.14942">def guessExternalEditor(c=None):
    """ Return a 'sensible' external editor """

    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db.db.get("LEO_EDITOR") or
        g.app.config.getString(c,'external_editor'))

    if editor: return editor

    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    elif platform.startswith('linux'):
        return 'gedit'
    else:
        g.es('''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db.db['LEO_EDITOR'] = "gvim"''')
        return None
</t>
<t tx="ville.20090703102253.6160">if path.endswith('pyc'):
    srcfile = path[:-1]
    if os.path.islink(srcfile):
        path = os.path.realpath(srcfile)    
</t>
<t tx="ville.20090724234020.14676">def update (self,p):

    c = self.c
    if self.skipBeadUpdate:
        return

    p = p.copy()
    if self.beadList and self.beadList[-1][0] == p:
        # do not re-append the same node
        return

    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    data = (p,theChapter)

    if self.beadPointer &lt; len(self.beadList) - 1:
        # if we came to new node, truncate bead list
        self.beadList = self.beadList[0:self.beadPointer]

    self.beadList.append(data)
    self.beadPointer = len(self.beadList) - 1

    if self.trace:    
        g.trace('bead list',p.h)
        g.pr([z[0].h for z in self.beadList])
</t>
<t tx="ville.20090827174345.9963">class UiTypeException(Exception):
    pass

def assertUi(uitype):
    if not g.app.gui.guiName() == uitype:
        raise UiTypeException
</t>
<t tx="ville.20091009234538.1373"># todo move out qt dep
from PyQt4 import QtCore, QtNetwork
import socket
import struct
</t>
<t tx="ville.20091009234538.1374">class LProtoServer:
    @others
</t>
<t tx="ville.20091009234538.1380">def __init__(self):
    self.srv = QtNetwork.QLocalServer()
    self.srv.connect(self.srv, QtCore.SIGNAL("newConnection()"),
        self.connected)
    self.receiver = None

    self.ses = {}  

def listen(self, name):
    self.srv.listen(name)
    print("listen on",self.srv.fullServerName())

def msg_received(self, msg, ses):
    if self.receiver:
        self.receiver(msg, ses)

def set_receiver(self, receiver):
    self.receiver = receiver

def connected(self):
    print("hnd con")
    lsock = self.srv.nextPendingConnection()
    print("conn", lsock)
    buf =  LProtoBuf()

    self.ses[lsock] = ses_ent = {'_sock' : lsock, '_buf' : buf }

    def msg_recv_cb(msg):
        self.msg_received(msg, ses_ent)

    buf.set_recv_cb( msg_recv_cb )


    def readyread_cb():
        print("read ready")
        allbytes = lsock.readAll()
        buf = ses_ent['_buf']
        buf.push_bytes(allbytes)

    lsock.connect(lsock, QtCore.SIGNAL('readyRead()'), readyread_cb)
    #self.connect(self.qsock, SIGNAL('connectionClosed()'), self.handleClosed)


def readyread(self):
    pass

</t>
<t tx="ville.20091010205847.1360">class LProtoObsoleteClient:
    @others
</t>
<t tx="ville.20091010205847.1361">def __init__(self):
    self.cl = QtNetwork.QLocalSocket()

def connect(self, name):
    self.cl.connectToServer(name)
    print("client connected")
</t>
<t tx="ville.20091010205847.1362">class LProtoBuf:
    def __init__(self):

        self.plen = -1
        self.buf = ""

    def set_recv_cb(self, cb):
        """ set func to call with received messages """
        self.recv_cb = cb
    def get_rlen(self):
        # read pkg length
        if self.plen == -1:
            return 4
        return self.plen - len(self.buf)

    def push_bytes(self, allbytes):
        while allbytes:
            rlen = self.get_rlen()
            byts = allbytes[0:rlen]
            self.push_bytes_one(byts)
            allbytes = allbytes[rlen:]

    def push_bytes_one(self, byts):
        if self.plen == -1:
            lendesc = byts[0:4]
            intlen = struct.unpack('I', lendesc)[0]
            print("have", intlen, "bytes")
            self.plen = intlen
            self.buf = byts[4:]
        else:
            self.buf = self.buf + byts

        if len(self.buf) == self.plen:
            print("dispatch msg", self.buf)
            self.recv_cb(self.buf)
            self.buf = ""
            self.plen = -1
            return

        print("in buf",self.buf)
</t>
<t tx="ville.20091010205847.1363">def mk_send_bytes(msg):
    lendesc = struct.pack('I', len(msg))
    return lendesc + msg

</t>
<t tx="ville.20091010205847.1364">""" lproto - simple local socket protocol dispatcher (reactor) for PyQt 

Author: Ville M. Vainio &lt;vivainio@gmail.com&gt;

"""
</t>
<t tx="ville.20091010232339.6117">@language python

&lt;&lt; docstring &gt;&gt;

&lt;&lt; imports &gt;&gt;

@others
</t>
<t tx="ville.20091010233144.10051">class LProtoClient:

    def __init__(self,fname):

        if hasattr(socket,'AF_UNIX'):
            self.socket = socket.socket(socket.AF_UNIX,socket.SOCK_STREAM)
            self.socket.connect(fname)
        else:
            host = '172.16.0.0' # host is a local address.
            port = 1
            self.socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            self.socket.connect((host,port),)

        self.recvbuf = LProtoBuf()

    def send(self, msg):
        byts = mk_send_bytes(msg)
        self.socket.sendall(byts)

</t>
</tnodes>
</leo_file>
