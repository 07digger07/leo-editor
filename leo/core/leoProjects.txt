#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090714085726.5991:Leo 4.7
#@+node:ekr.20090717092906.12764:Bugs
#@+node:ekr.20090717092906.6000:How does Leo write encoding in the first line?
@nocolor-node

There was a documentation bug related to the new_leo_file_encoding setting.
#@nonl
#@+node:ekr.20031218072017.1247:putXMLLine
def putXMLLine (self):

    '''Put the **properly encoded** <?xml> element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
#@nonl
#@-node:ekr.20031218072017.1247:putXMLLine
#@+node:ekr.20090218115025.5:initIvars
def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
    self.vnodesDict = {}
        # keys are gnx strings; values are ignored
#@-node:ekr.20090218115025.5:initIvars
#@-node:ekr.20090717092906.6000:How does Leo write encoding in the first line?
#@-node:ekr.20090717092906.12764:Bugs
#@+node:ekr.20090717112235.10330:Features
#@+node:ekr.20090715082137.5989:Added leoVersion.py
#@+node:ekr.20090717112235.6007:app.computeSignon
def computeSignon (self):

    app = self
    # buildNumber = leoVersion.buildNumber
    date        = leoVersion.date
    guiVersion  = app.gui.getFullVersion()
    leoVer      = leoVersion.version
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            sysVersion += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: sysVersion = sys.platform

    # app.signon = 'Leo %s build %s, %s' % (
        # leoVer,buildNumber,date)
    app.signon = 'Leo %s, %s' % (
        leoVer,date)
    app.signon2 = 'python %s.%s.%s, %s\n%s' % (
        n1,n2,n3,guiVersion,sysVersion)

    if False and not g.unitTesting:
        print(app.signon)
        print(app.signon2)
#@-node:ekr.20090717112235.6007:app.computeSignon
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self,c):

    # g.trace(c,g.callers(5))

    if self.log:
        # Put the signon lines at the start.
        self.logWaiting.insert(0,(g.app.signon2+'\n','black'),)
        self.logWaiting.insert(0,(g.app.signon+'\n','black'),)
        self.logWaiting.insert(0,('Leo Log Window\n','red'),)

        # The test for isNull would probably interfere with batch mode.
        for s,color in self.logWaiting:
            g.es('',s,color=color,newline=0) # The caller must write the newlines.
        self.logWaiting = []
    else:
        print('writeWaitingLog: still no log!')
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    defaultFileName = None
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')
            defaultFileName = fileName

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    if not fileName: fileName = defaultFileName

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.5:finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")

#@-node:ekr.20080921060401.5:finishInitApp (runLeo.py)
#@-node:ekr.20090715082137.5989:Added leoVersion.py
#@-node:ekr.20090717112235.10330:Features
#@-node:ekr.20090714085726.5991:Leo 4.7
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
