#@+leo-ver=4-thin
#@+node:ekr.20100120072650.6089:@thin leoProjects.txt
#@+at
# This part of the tree shows views of the outline related to specific 
# projects or
# tasks. I put such headlines in parentheses, and that is just my convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the
# cloned headlines under the task headline. This greatly increases my focus. 
# Any
# changes made in a task view to clone headlines affect the other clones 
# scattered
# throughout the outline. In particular, all @file nodes containing changed 
# clones
# become marked as dirty, so they will be written when the entire outline is
# saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20100212095952.5727:4.7 final projects
#@+node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@+node:ekr.20100212095952.5729:changed...
#@+node:ekr.20050415134809.1:c.sortSiblings
# New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self,event=None,key=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20060202161935:printGcAll
def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    if not g.unitTesting:
        g.pr('-' * 30)
        g.pr('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except Exception: pass
        # if type(obj) == type(()):
            # g.pr(id(obj),repr(obj))
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = list(d.items())
        items.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        if not g.unitTesting:
            for z in items:
                g.pr('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        for t in sorted(d):
            g.pr('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20050920084036.118:sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines commands
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()

    def key(s):
        return g.os_path_basename(s).lower()
    orig.sort(key=key) # 2010/01/12
    orig.reverse() # 2010/01/12
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20100212095952.5729:changed...
#@-node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@-node:ekr.20100212095952.5727:4.7 final projects
#@-all
#@-node:ekr.20100120072650.6089:@thin leoProjects.txt
#@-leo
