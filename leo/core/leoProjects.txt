#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090831095817.6067:Leo 4.6.3
- Put caching bug fixes into 46-maint branch
- Fixed bug in g.adjustTripleString.
- Created .nsi script.
#@nonl
#@-node:ekr.20090831095817.6067:Leo 4.6.3
#@+node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090907080624.6083:Added new plugins
@nocolor-node

New command-line option
    --gui=qttabs

new plugins:
    spydershell,
    qtframecommands
    mod_framesize.

Improved plugin:  "show folder" in rclick menu.

Improved plugin: contextmenu.py

    If you rclick on @thin / whatever item, you should see "open
    /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
    that folder (using xdg-open on linux, os.startfile on windows). I have no
    idea what to do with mac, now it runs xdg-open and probably fails.
#@nonl
#@-node:ekr.20090907080624.6083:Added new plugins
#@-node:ekr.20090907080624.6082:Leo 4.6.4
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20091221094815.6383: Urgent (voted up) bugs
#@+node:ekr.20091221145433.6384:Calltips don't work on leo3k
@nocolor-node

They wipe out the newly-inserted selection range.

  File "/home/edreamleo/leo.repo/trunk/leo/core/leoKeys.py", line 545, in calltip
    isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType
AttributeError: 'module' object has no attribute 'StringType'

-----------------

Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/trunk/leo/core/leoKeys.py", line 174, in defineClassesDict
    name = z.__class__.__name__

ReferenceError: weakly-referenced object no longer exists


#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = (
    self.prevObjects and
    # type(self.prevObjects[-1]) == types.StringType
    g.isString(self.prevObjects[-1]))

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfVnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    if g.isPython3:
        for z in gc.get_objects():
            try:
                name = z.__class__.__name__
            except ReferenceError:
                pass
            self.allClassesDict [name] = z
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('<class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self,table=None):

    c = self.c ; k = c.k ; p = c.p

    # g.trace(g.callers(4))

    if table is None: table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p.copy()), # 2009/12/21
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        # (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@-node:ekr.20091221145433.6384:Calltips don't work on leo3k
#@+node:ekr.20091221094815.6385:zpcspm Headline scrolling
@nocolor-node

My biggest annoyance is the invalid bug 409442, I have to use the tk
GUI because of it.

I've also complained about it in this thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/07cdbb... 

----- Ville +1
I feel your pain.

Please try this workaround (run with ctrl+b):

tree = c.frame.tree.treeWidget
tree.setColumnCount(2)

-----
> Isn't it possible to stick this tree.setColumnCount(2) into some
> constructor in the leo qt GUI plugin so the outline pane would have
> the horizontal scrollbar by default?

Yes, but it's not sure we want to have 2 columns in the tree widget -
and it would create scrollbar on many occasions when it's not
necessary.

So this is not a simple fix for your problem, it has implications
beyond your problem. 
#@nonl
#@-node:ekr.20091221094815.6385:zpcspm Headline scrolling
#@+node:ekr.20091221145433.6379:TL Undo renames headline (tk only)
@nocolor-node

Bug 498692: Undo deleted node renames current node's headline

Tested with: Rev2518, Tk GUI, Vim emulation not active

Created three nodes at the same level with Header and body text containing "Node
1", "Node 2", and "Node 3", saved and closed Leo file, opened Leo file, selected
Node 2's headline with the mouse (headline shows blue background). Performed the
following steps:

Delete Node 2 (Ctrl-Shift-X):
 Node 2 deleted
 Node 1 Headline has focus (Blue background)

Undo (Ctrl-Z) Note: Text in undo's menu item showed "Undo typing"
 Node 1's Headline renamed to "Node 2"
 Node 1's body has focus

Undo (Ctrl-Z) Note: Text in undo's menu item showed "Undo delete node"
 Node 2 restored
 Node 2's body has focus
 Node 1's headline remains "Node 2"

Problem 1: The first executed Undo command should not have existed on the "undo
stack". No user "typing" was performed that needs to be undone.

Problem 2: After an Undo of the delete node (the second undo above), the focus
should be in the restored node's headline instead of in its body.
#@+node:ekr.20080514131122.14:c.redrawing...
#@+node:ekr.20090110073010.1:c.redraw
def redraw (self,p=None,setFocus=False):
    '''Redraw the screen immediately.'''

    c = self
    if not p: p = c.p or c.rootPosition()

    c.expandAllAncestors(p)
    c.frame.tree.redraw(p)
    c.selectPosition(p)

    if setFocus: c.treeFocusHelper()

# Compatibility with old scripts
force_redraw = redraw
redraw_now = redraw
#@-node:ekr.20090110073010.1:c.redraw
#@+node:ekr.20090110131802.2:c.redraw_after_contract
def redraw_after_contract (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_contract(p)
        if setFocus: c.treeFocusHelper()
#@-node:ekr.20090110131802.2:c.redraw_after_contract
#@+node:ekr.20090112065525.1:c.redraw_after_expand
def redraw_after_expand (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    if p.isCloned():
        c.redraw(p=p,setFocus=setFocus)
    else:
        c.frame.tree.redraw_after_expand(p)
        if setFocus: c.treeFocusHelper()
#@-node:ekr.20090112065525.1:c.redraw_after_expand
#@+node:ekr.20090110073010.2:c.redraw_after_head_changed
def redraw_after_head_changed(self):

    '''Redraw the screen (if needed) when editing ends.
    This may be a do-nothing for some gui's.'''

    return self.frame.tree.redraw_after_head_changed()
#@-node:ekr.20090110073010.2:c.redraw_after_head_changed
#@+node:ekr.20090110073010.3:c.redraw_afer_icons_changed
def redraw_after_icons_changed(self):

    '''Update the icon for the presently selected node,
    or all icons if the 'all' flag is true.'''

    c = self

    c.frame.tree.redraw_after_icons_changed()

    # c.treeFocusHelper()
#@-node:ekr.20090110073010.3:c.redraw_afer_icons_changed
#@+node:ekr.20090110073010.4:c.redraw_after_select
def redraw_after_select(self,p):

    '''Redraw the screen after node p has been selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(Commands)',p and p.h or '<No p>', g.callers(4))

    c = self

    flag = c.expandAllAncestors(p)
    if flag:
        c.frame.tree.redraw_after_select(p)
#@-node:ekr.20090110073010.4:c.redraw_after_select
#@-node:ekr.20080514131122.14:c.redrawing...
#@+node:ekr.20031218072017.3704:class leoTree
# This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoTree:

    """The base class for the outline pane in Leo windows."""

    @others
#@+node:ekr.20031218072017.3705:  tree.__init__ (base class)
def __init__ (self,frame):

    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widget (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).

    # Debugging.
    self.redrawCount = 0

    # "public" ivars: correspond to setters & getters.
    self.drag_p = None
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.revertHeadline = None
    self.use_chapters = False # May be overridden in subclasses.

    # Define these here to keep pylint happy.
    self.canvas = None
    self.stayInTree = True
    self.trace_select = None
#@+node:ekr.20081005065934.7:leoTree.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
#@nonl
#@-node:ekr.20081005065934.7:leoTree.mustBeDefined
#@+node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
#@nonl
#@-node:ekr.20061109164512:leoTree.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
#@-node:ekr.20061109164610:leoTree.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3705:  tree.__init__ (base class)
#@+node:ekr.20031218072017.3706: Must be defined in subclasses
# Bidings.
def setBindings (self):                         self.oops()

# Fonts.
def getFont(self):                              self.oops()
def setFont(self,font=None,fontName=None):      self.oops()
def setFontFromConfig (self):                   self.oops()

# Drawing & scrolling.
def drawIcon(self,p):                                       self.oops()
def redraw(self,p=None,scroll=True,forceDraw=False):        self.oops()
def redraw_now(self,p=None,scroll=True,forceDraw=False):    self.oops()
def scrollTo(self,p):                           self.oops()
idle_scrollTo = scrollTo # For compatibility.

# Headlines.
def editLabel(self,v,selectAll=False,selection=None): self.oops()
def edit_widget (self,p):                       self.oops() ; return None
def headWidth(self,p=None,s=''):                self.oops() ; return 0
def setEditLabelState(self,v,selectAll=False):  self.oops()
def setSelectedLabelState(self,p):              self.oops()
def setUnselectedLabelState(self,p):            self.oops()
#@nonl
#@-node:ekr.20031218072017.3706: Must be defined in subclasses
#@+node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.h.'''

    trace = False and g.unitTesting
    c = self.c ; k = c.k ; p = c.p

    if trace: g.trace('leoTree',p and p.h,g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.21:tree.injectCallbacks
def injectCallbacks(self):

    c = self.c

    << define callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):

        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event=None,c=c):

    """Callback injected into position class."""

    p = self
    if not c or not c.exists:
        return

    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.selectPosition(p)
            c.redraw()
            c.frame.body.bodyCtrl.setInsertPoint(0) # 2007/10/27
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="green") # 10/27/07
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None,c=c):

    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.body.bodyCtrl.tag_config(p.tagName,background="white") # 2007/20/25

        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:tree.injectCallbacks
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper & test
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.b.split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            z_url = url[i:]
            g.es("ignoring characters after space in url:",z_url)
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20090529205043.6027:@test OnIconDoubleClick
if g.unitTesting:

    c,p = g.getTestVars()

    c.frame.tree.OnIconDoubleClick(p.firstChild())
#@+node:ekr.20060217111834:@url http://docs.python.org/lib/re-syntax.html
#@-node:ekr.20060217111834:@url http://docs.python.org/lib/re-syntax.html
#@-node:ekr.20090529205043.6027:@test OnIconDoubleClick
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper & test
#@-node:ekr.20061109165848:Must be defined in base class
#@+node:ekr.20081005065934.8:May be defined in subclasses
# These are new in Leo 4.6.

def initAfterLoad (self):
    '''Do late initialization.
    Called in g.openWithFileName after a successful load.'''

def afterSelectHint(self,p,old_p):
    '''Called at end of tree.select.'''
    pass

def beforeSelectHint (self,p,old_p):
    '''Called at start of tree.select.'''
    pass

# These are hints for optimization.
# The proper default is c.redraw()
def redraw_after_clone(self):                   self.c.redraw()
def redraw_after_contract(self,p=None):         self.c.redraw()
def redraw_after_expand(self,p=None):           self.c.redraw()
def redraw_after_head_changed(self):            self.c.redraw()
def redraw_after_icons_changed(self,all=False): self.c.redraw()
def redraw_after_select(self,p=None):           self.c.redraw()
#@-node:ekr.20081005065934.8:May be defined in subclasses
#@+node:ekr.20040803072955.128:leoTree.select & helpers
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p:
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:selectHelper
#@+node:ekr.20090608081524.6109:setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = g.toUnicode(p.v._bodyString,"utf-8")
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    if p.v and p.v.scrollBarSpot != None:
        first,last = p.v.scrollBarSpot
        w.setYScrollPosition(first)

    if p.v and p.v.insertSpot != None:
        spot = p.v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
        # g.trace(spot)
    else:
        w.setInsertPoint(0)
#@-node:ekr.20090608081524.6109:setBodyTextAfterSelect
#@-node:ekr.20040803072955.128:leoTree.select & helpers
#@+node:ekr.20031218072017.3718:oops
def oops(self):

    g.pr("leoTree oops:", g.callers(4), "should be overridden in subclass")
#@-node:ekr.20031218072017.3718:oops
#@-node:ekr.20031218072017.3704:class leoTree
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@-node:ekr.20091221145433.6379:TL Undo renames headline (tk only)
#@+node:ekr.20091221145433.6378:TL undo bug: window dirty bit not preserved
@nocolor-node

Bug 498688: Undo back to last saved content still shows file as
modified ("*" in title)

Steps:
   1. Open leo file
   2. Delete node
   3. Perform "Undo"
       Undo works as designed but the file is still a "*" in the title bar
   4. Close Leo
       Leo issues prompt to save file before closing.
#@nonl
#@+node:ekr.20031218072017.3605:class undoer
class undoer:
    """A class that implements unlimited undo and redo."""
    @others
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):

    u = self

    # g.trace(g.callers(5))

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20080623083646.10:dumpBead
def dumpBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n > 0:
        return self.dumpBead(n-1)
    else:
        return '<no top bead>'
#@-node:ekr.20080623083646.10:dumpBead
#@+node:EKR.20040526150818:getBead
def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
#@-node:EKR.20040526150818:getBead
#@+node:EKR.20040526150818.1:peekBead
def peekBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@-node:EKR.20040526150818.1:peekBead
#@+node:ekr.20060127113243:pushBead
def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead >= 0 and u.bead < len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads),g.callers())

        # Recalculate the menu labels.
        u.setUndoTypes()
#@-node:ekr.20060127113243:pushBead
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        g.pr('-' * 40)
        for key in sorted(bunch):
            g.trace(key,bunch.get(key))
        g.pr('-' * 20)

    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()): 
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    v = bunch.v
    v._headString  = bunch.headString
    v._bodyString  = bunch.bodyString
    v.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy. This
looks "elegant" and is WRONG. The problem is that it can not handle clones
properly, especially when some clones were in the "undo" tree and some were not.
Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to
properly restore the vnodes and tnodes. It creates a list of tuples, on tuple
for each vnode in the tree. Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the
nodes. The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to
the old v.copy and t.copy methods.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
#@nonl
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        v = v,
        headString = v._headString,
        bodyString = v._bodyString,
        statusBits = v.statusBits,
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        g.pr(ivar, getattr(self,ivar))
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    marked = g.choose(isOld,u.oldMarked, u.newMarked)

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    # Bug fix: Leo 4.4.6: Undo/redo always set changed/dirty bits
    # because the file may have been saved.
    u.p.setDirty(setDescendentsDirty=False)
    u.p.setAllAncestorAtFileNodesDirty(setDescendentsDirty=False) # Bug fix: Leo 4.4.6
    u.c.setChanged(True)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20080425060424.8:afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.8:afterDemote
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v._headString[:],body=v._bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@+node:ekr.20080425060424.12:afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.12:afterPromote
#@+node:ekr.20080425060424.2:afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20080425060424.2:afterSort
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20080425060424.3:beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@-node:ekr.20080425060424.3:beforeSort
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
        frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.newChanged is None: u.newChanged = True
    c.setChanged(u.newChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.oldChanged is None: u.oldChanged = True
    c.setChanged(u.oldChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@-node:ekr.20091221145433.6378:TL undo bug: window dirty bit not preserved
#@+node:ekr.20091222102020.6532:no log when notebook does not exist
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    defaultFileName = None
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')
            defaultFileName = fileName

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    if not fileName: fileName = defaultFileName

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)

    g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self,c,forceLog=False):

    app = self
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    # print('writeWaitingLog',c,g.callers(4))
    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    if app.log:
        if not app.logInited:
            app.logInited = True # Prevent recursive call.
            print(app.signon)
            print(app.signon2)
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        elif forceLog:
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        # The test for isNull would probably interfere with batch mode.
        for s in app.printWaiting:
            print(s)
        app.printWaiting = []
        for s,color in app.logWaiting:
            g.es('',s,color=color,newline=0)
                # The caller must write the newlines.
        app.logWaiting = []
    else:
        print('writeWaitingLog: still no log!')
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@-node:ekr.20091222102020.6532:no log when notebook does not exist
#@+node:ekr.20091221145433.6380:TL Undo messes with selection & view
@nocolor-node

Bug 362950: during body text undo selection goes nuts and view moves
+1 by Terry Brown.

Ubuntu 8.10, latest leo, qt gui, python 2.5.2

In the Qt gui, when you undo editing in the body text, the selected text does
odd things (selects from start of buffer to current position or something) and
the view jumps about in the body text, assuming it's long enough.

This is very disconcerting, when I undo things I like to see them change back,
but instead you lose track of where you were writing and how much has been
undone. This makes undo almost unusable, because you can't keep track of how
much undoing has been done.

===========

Undoing multi-line edits on body texts too long to fit in a single view results
in odd selection extents and the view returning to the top of the text, both of
which make it impossible to keep track of how much has been undone. After each
step in undoing the cursor needs to be at the end of the region where the undo
occurred, and the view should only shift if necessary to include the cursor.

============

I've posted a small movie of the problem here:

http://131.212.123.124/~tbrown/tmp/out.avi

There's some editing, and then I start undoing it, and when the whole text
becomes selected (which never happened during the editing), that's the problem.

Note, this was done with the editor window detached to make the video small,
although I suppose having the rest of the leo window in frame would make no
difference if it doesn't change, frame compression wise.

=============

Hmm, the only way I'm getting it now (just pulled the trunk prior to trying) is
to use mouse select / drag editing.

- Paste some paras into the body

- Select some text with the mouse

- click-drag the text somewhere else with the mouse

so, I guess that particular kind of editing isn't interacting with the undo
system the same way other editing does.

But undo is working, its just its recreation of the selection / insert point
that's missing. So it's picking up the changes, but perhaps only as whole text
changes?

Maybe, and I'm trying to be as helpful as possible here because I'm sure you'll
want to curse all mouse users and leave it as is :-), maybe, if I'm right that
this style of editing looks like atomic whole text changes to the undo system,
and that can't be addressed directly, and the situation can be detected (one way
would be that the selection is the whole text and the cursor position is the
beginning of the body), a best attempt at not confusing the user would be to (a)
not select the whole text, because it never was wholly selected, and (b), move
the insert point to the first difference between the new and old text.
#@nonl
#@+node:ekr.20090608081524.6109:setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = g.toUnicode(p.v._bodyString,"utf-8")
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    if p.v and p.v.scrollBarSpot != None:
        first,last = p.v.scrollBarSpot
        w.setYScrollPosition(first)

    if p.v and p.v.insertSpot != None:
        spot = p.v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
        # g.trace(spot)
    else:
        w.setInsertPoint(0)
#@-node:ekr.20090608081524.6109:setBodyTextAfterSelect
#@+node:ekr.20070423101911:selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p:
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:selectHelper
#@+node:ekr.20091221145433.6383:Example
@nocolor-node


so, I guess that particular kind of editing isn't interacting with the undo
system the same way other editing does.

But undo is working, its just its recreation of the selection / insert point
that's missing. So it's picking up the changes, but perhaps only as whole text
changes?

Maybe, and I'm trying to be as helpful as possible here because I'm sure you'll
want to curse all mouse users and leave it as is :-), maybe, if I'm right that
this style of editing looks like atomic whole text changes to the undo system,
and that can't be addressed directly, and the situation can be detected (one way
would be that the selection is the whole text and the cursor position is the
beginning of the body), a best attempt at not confusing the user would be to (a)
not select the whole text, because it never was wholly selected, and (b), move
the insert point to the first difference between the new and old text.
#@nonl
#@-node:ekr.20091221145433.6383:Example
#@+node:ekr.20031218072017.3605:class undoer
class undoer:
    """A class that implements unlimited undo and redo."""
    @others
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []

    # Set the following ivars to keep pylint happy.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.dirtyVnodeList = None
    self.followingSibs = None
    self.kind = None
    self.newBack = None
    self.newBody = None
    self.newChanged = None
    self.newChildren = None
    self.newHead = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newTree = None
    self.oldBack = None
    self.oldBody = None
    self.oldChanged = None
    self.oldChildren = None
    self.oldHead = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldRecentFiles = None
    self.oldTree = None
    self.pasteAsClone = None
    self.sortChildren = None

def redoHelper(self):
    pass

def undoHelper(self):
    pass
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):

    u = self

    # g.trace(g.callers(5))

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads),g.callers())
#@-node:ekr.20060127052111.1:cutStack
#@+node:ekr.20080623083646.10:dumpBead
def dumpBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return 'no bead: n = ',n

    bunch = u.beads[n] ; result = []
    result.append('-' * 10)
    result.append('len(u.beads): %s, n: %s' % (len(u.beads),n))
    for ivar in ('kind','newP','newN','p','oldN','undoHelper'):
        result.append('%s = %s' % (ivar,getattr(self,ivar)))
    return '\n'.join(result)

def dumpTopBead(self):

    u = self
    n = len(u.beads)
    if n > 0:
        return self.dumpBead(n-1)
    else:
        return '<no top bead>'
#@-node:ekr.20080623083646.10:dumpBead
#@+node:EKR.20040526150818:getBead
def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
#@-node:EKR.20040526150818:getBead
#@+node:EKR.20040526150818.1:peekBead
def peekBead (self,n):

    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@-node:EKR.20040526150818.1:peekBead
#@+node:ekr.20060127113243:pushBead
def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead >= 0 and u.bead < len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads),g.callers())

        # Recalculate the menu labels.
        u.setUndoTypes()
#@-node:ekr.20060127113243:pushBead
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        g.pr('-' * 40)
        for key in sorted(bunch):
            g.trace(key,bunch.get(key))
        g.pr('-' * 20)

    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()): 
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType
#@+node:ekr.20091221145433.6381:setUndoType
def setUndoType (self,theType):
    trace = False and not g.unitTesting
    if trace: g.trace(theType,g.callers(4))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20091221145433.6381:setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v.children   = bunch.children
    v.parents    = bunch.parents

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):

    v = bunch.v
    v._headString  = bunch.headString
    v._bodyString  = bunch.bodyString
    v.statusBits  = bunch.statusBits

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy. This
looks "elegant" and is WRONG. The problem is that it can not handle clones
properly, especially when some clones were in the "undo" tree and some were not.
Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to
properly restore the vnodes and tnodes. It creates a list of tuples, on tuple
for each vnode in the tree. Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the
nodes. The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to
the old v.copy and t.copy methods.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
#@nonl
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parents    = v.parents[:],
        children   = v.children[:],
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        v = v,
        headString = v._headString,
        bodyString = v._bodyString,
        statusBits = v.statusBits,
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        g.pr(ivar, getattr(self,ivar))
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    marked = g.choose(isOld,u.oldMarked, u.newMarked)

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    # Bug fix: Leo 4.4.6: Undo/redo always set changed/dirty bits
    # because the file may have been saved.
    u.p.setDirty(setDescendentsDirty=False)
    u.p.setAllAncestorAtFileNodesDirty(setDescendentsDirty=False) # Bug fix: Leo 4.4.6
    u.c.setChanged(True)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.b
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20080425060424.8:afterDemote
def afterDemote (self,p,followingSibs,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'

    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote

    bunch.followingSibs = followingSibs

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.8:afterDemote
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(
                g.Bunch(v=v,head=v._headString[:],body=v._bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()

    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@+node:ekr.20080425060424.12:afterPromote
def afterPromote (self,p,children,dirtyVnodeList):

    '''Create an undo node for demote operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'

    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote

    bunch.children = children

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@-node:ekr.20080425060424.12:afterPromote
#@+node:ekr.20080425060424.2:afterSort
def afterSort (self,p,bunch,dirtyVnodeList):

    '''Create an undo node for sort operations'''

    u = self ; c = self.c
    if u.redoing or u.undoing: return

    bunch.dirtyVnodeList = dirtyVnodeList

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20080425060424.2:afterSort
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.b
    bunch.oldHead = oldHead or p.h

    return bunch
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):

    # g.trace(p.h)

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):

    u = self ; p = u.c.p

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20080425060424.3:beforeSort
def beforeSort (self,p,undoType,oldChildren,newChildren,sortChildren):

    '''Create an undo node for sort operations.'''

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType

    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort

    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren # A bool

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    return bunch
#@-node:ekr.20080425060424.3:beforeSort
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w and w.getSelectionRange() or None,
        p = p.copy(),
    )
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
        frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.newChanged is None: u.newChanged = True
    c.setChanged(u.newChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[:n+1]
    u.p.v.children.extend(u.followingSibs)

    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
            # g.trace(v,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]

    parent_v = u.newParent_v
    parent_v.children.insert(u.newN,v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)

    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1

    old_children = parent_v.children[:]
    parent_v.children = old_children[:n]
        # Add children up to the promoted nodes.
    parent_v.children.extend(u.children)
        # Add the promoted nodes.
    parent_v.children.extend(old_children[n:])
        # Add the children up to the promoted nodes.

    # Remove the old children.
    u.p.v.children = []

    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.newChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    trace = False and not g.unitTesting
    u = self ; c = u.c
    w = c.frame.body.bodyCtrl

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.p:
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    if u.oldChanged is None: u.oldChanged = True
    c.setChanged(u.oldChanged) # 2009/12/21
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    c.bodyWantsFocusNow()
    # g.trace(i,j,ins)
    w.setSelectionRange(i,j,insert=ins)
    w.seeInsertPoint()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN,v)

    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)

    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode() # The parent of the all the *promoted* nodes.

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1

    # Adjust the old parents children
    old_children = parent_v.children
    parent_v.children = old_children[:n]
        # Add the nodes before the promoted nodes.
    parent_v.children.extend(old_children[n+len(u.children):])
        # Add the nodes after the promoted nodes.

    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]

    # Adjust the parent links.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.b)

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.children = u.oldChildren
    p = c.setPositionAfterSort(u.sortChildren)
    c.setCurrentPosition(p)
#@nonl
#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.p
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
    w.seeInsertPoint() # 2009/12/21
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20091221145433.6380:TL Undo messes with selection & view
#@+node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ville.20090701144325.14942:g.guessExternalEditor
def guessExternalEditor():
    """ Return a 'sensible' external editor """

    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db.get("LEO_EDITOR"))

    if editor: return editor

    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    elif platform.startswith('linux'):
        return 'gedit'
    else:
        g.es('''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''')
        return None
#@-node:ville.20090701144325.14942:g.guessExternalEditor
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    c.endEditing()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p.h,fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_read = True # Create the attribute

    # Disable caching for test.leo.
    if c.shortFileName() != 'test.leo':
        if cachefile is not None and cachefile in c.db:        
            # g.es('uncache:',p.h)
            aList = c.db[cachefile]
            p.v.createOutlineFromCacheList(c,aList)
            return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545:readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode (leoImport)
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20091227085627.6538:Removed unsettling @auto warning
#@+node:ekr.20091221094815.6386:Fixed at-auto-rst problems
#@+node:ekr.20091227092342.6545:Description
@nocolor-node

I'm not able to import many of the example rst files I've come across. Sometimes
I can figure out what changes to make to the file to get it to import, other
times it's not worth the effort. I just open it in another editor.

Also, @auto-rst is not well documented.

=============================
http://groups.google.com/group/leo-editor/browse_thread/thread/b84659e608ba44d5

- Create @auto myfile.rst
- save, close, open Leo file
- change to @auto-rst myfile.rst
- save Leo file: myfile.rst is now empty

The solution: Do not write @auto files with orphan nodes!

The data is lost because @auto-rst mostly ignores the top-level node.
#@-node:ekr.20091227092342.6545:Description
#@+node:ekr.20031218072017.3348:at...FileNodeName & tests
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self,h=None):
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto","@auto-rst",)
    return self.findAtFileName(names,h=h)

def atAutoRstNodeName (self,h=None):
    names = ("@auto-rst",)
    return self.findAtFileName(names,h=h)

def atEditNodeName (self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atShadowFileNodeName (self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
#@+node:ekr.20090521064955.5905:@test v.atAutoNodeName & v.atAutoRstNodeName
if g.unitTesting:

    c,p = g.getTestVars()

    table = (
        ('@auto-rst rst-file','rst-file','rst-file'),
        ('@auto x','x',''),
        ('xyz','',''),
    )

    for s,expected1,expected2 in table:
        result1 = p.v.atAutoNodeName(h=s)
        result2 = p.v.atAutoRstNodeName(h=s)
        assert result1 == expected1,'fail1: given %s expected %s got %s' % (
            repr(s),repr(expected1),repr(result1))
        assert result2 == expected2,'fail2: given %s expected %s got %s' % (
            repr(s),repr(expected2),repr(result2))
#@-node:ekr.20090521064955.5905:@test v.atAutoNodeName & v.atAutoRstNodeName
#@-node:ekr.20031218072017.3348:at...FileNodeName & tests
#@+node:ekr.20091219132601.6279:Reading
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>
    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:sps.20081111154528.5:escapeFalseSectionReferences
def escapeFalseSectionReferences(self,s):

    result = []
    for line in g.splitLines(s):
        r1 = line.find('<<')
        r2 = line.find('>>')
        if r1>=0 and r2>=0 and r1<r2:
            result.append("@verbatim\n")
            result.append(line)
        else:
            result.append(line)
    return ''.join(result)
#@-node:sps.20081111154528.5:escapeFalseSectionReferences
#@+node:ekr.20070703122141.65:<< class baseScannerClass >>
class baseScannerClass (scanUtility):

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.escapeSectionRefs = True
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20070730093735:compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = False and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090513073632.5735:compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@-node:ekr.20090513073632.5735:compareRstUnderlines
#@-node:ekr.20070730093735:compareHelper & helpers
#@+node:ekr.20071110144948:checkLeadingWhitespace
def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
#@-node:ekr.20071110144948:checkLeadingWhitespace
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i < n: line = repr(lines[i])
            else: line = '<eof>'
            aList.append('%4d %s' % (i,line))
    g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20090512080015.5800:adjustParent
def adjustParent (self,parent,headline):

    '''Return the effective parent.

    This is overridden by the rstScanner class.'''

    return parent
#@-node:ekr.20090512080015.5800:adjustParent
#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.isRst and not self.atAuto:
        return

    if self.treeType == '@file':
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s,encoding)
#@-node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
#@+node:ekr.20090512153903.5806:computeBody (baseScannerClass)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

    return body
#@-node:ekr.20090512153903.5806:computeBody (baseScannerClass)
#@+node:ekr.20090513073632.5737:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '%s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090513073632.5737:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.h,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20090502071837.1:endGen
def endGen (self,s):

    '''Do any language-specific post-processing.'''
    pass
#@-node:ekr.20090502071837.1:endGen
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class,
    and a child of c for each def in the class.'''

    trace = False and not g.unitTesting
    if trace:
        # g.trace('tab_width',self.tab_width)
        g.trace('sig',s[i:sigEnd])

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    if trace: g.trace('undentVal',undentVal,'bodyIndent',bodyIndent)

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070703122141.106:getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@-node:ekr.20070703122141.106:getClassNodeRef
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    trace = False and not g.unitTesting

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None
    if trace: g.trace('bodyIndent',bodyIndent)

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction (baseScannerClass)
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and not g.unitTesting
    verbose = False

    # if trace: g.trace(start,sigStart,self.sigEnd,codeEnd)

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body = self.computeBody(s,start,sigStart,codeEnd)

    if trace:
        g.trace('parent',parent.h)
        if verbose: g.trace('**body...\n',body)

    parent = self.adjustParent(parent,headline)
    self.lastParent = self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction (baseScannerClass)
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20090122201952.5:setBodyString
#@-node:ekr.20090122201952.5:setBodyString
#@+node:ekr.20070703122141.88:undentBody
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    if self.isRst:
        return s # Never unindent rst code.

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result
#@-node:ekr.20070703122141.88:undentBody
#@+node:ekr.20081216090156.1:undentBy
def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    trace = False and not g.app.unitTesting

    if self.isRst:
        return s # Never unindent rst code.

    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws < undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

#@-node:ekr.20081216090156.1:undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error, oops, report and warning
def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print('',s,color='red')
    else:
        g.es_print('error:',s,color='red')

def oops (self):
    g.pr('baseScannerClass oops: %s must be overridden in subclass' % g.callers())

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning:',s,color='red')
#@-node:ekr.20070703122141.78:error, oops, report and warning
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20071201072917:adjustDefStart
def adjustDefStart (self,unused_s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    return i
#@-node:ekr.20071201072917:adjustDefStart
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,unused_s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,junk = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.appendStringToBody(parent,s[start:])

    # Do any language-specific post-processing.
    self.endGen(s)
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    start = i

    # Skip the opening delim.
    if g.match(s,i,self.blockCommentDelim1):
        delim2 = self.blockCommentDelim2
        i += len(self.blockCommentDelim1)
    elif g.match(s,i,self.blockCommentDelim1_2):
        i += len(self.blockCommentDelim1_2)
        delim2 = self.blockCommentDelim2_2
    else:
        assert False

    # Find the closing delim.
    k = s.find(delim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(delim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@-node:ekr.20070707080042:skipDecls
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
#@+node:ekr.20070711134534:getSigId
def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    return ids and ids[-1]
#@-node:ekr.20070711134534:getSigId
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1) or
        g.match(s,i,self.blockCommentDelim1_2)
    )
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65:<< class baseScannerClass >>
#@+node:ekr.20090501095634.41:class rstScanner
class rstScanner (baseScannerClass):

    @others
#@+node:ekr.20090501095634.42: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='rest')

    # Scanner overrides
    self.atAutoWarnsAboutLeadingWhitespace = True
    self.blockDelim1 = self.blockDelim2 = None
    self.classTags = []
    self.escapeSectionRefs = False
    self.functionSpelling = 'section'
    self.functionTags = []
    self.hasClasses = False
    self.isRst = True
    self.lineCommentDelim = '..'
    self.outerBlockDelim1 = None
    self.sigFailTokens = []
    self.strict = False # Mismatches in leading whitespace are irrelevant.

    # Ivars unique to rst scanning & code generation.
    self.lastParent = None # The previous parent.
    self.lastSectionLevel = 0 # The section level of previous section.
    self.sectionLevel = 0 # The section level of the just-parsed section.
    self.underlineCh = '' # The underlining character of the last-parsed section.
    self.underlines = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~" # valid rst underlines.
    self.underlines1 = [] # Underlining characters for underlines.
    self.underlines2 = [] # Underlining characters for over/underlines.
#@-node:ekr.20090501095634.42: __init__
#@+node:ekr.20090512080015.5798:adjustParent
def adjustParent (self,parent,headline):

    '''Return the proper parent of the new node.'''

    trace = False and not g.unitTesting

    level,lastLevel = self.sectionLevel,self.lastSectionLevel
    lastParent = self.lastParent

    if trace: g.trace('**entry level: %s lastLevel: %s lastParent: %s' % (
        level,lastLevel,lastParent and lastParent.h or '<none>'))

    if self.lastParent:

        if level <= lastLevel:
            parent = lastParent.parent()
            while level < lastLevel:
                level += 1
                parent = parent.parent()
        else: # level > lastLevel.
            level -= 1
            parent = lastParent
            while level > lastLevel:
                level -= 1
                h2 = '@rst-no-head %s' % headline
                body = ''
                parent = self.createFunctionNode(h2,body,parent)

    else:
        assert self.root
        self.lastParent = self.root

    if not parent: parent = self.root

    if trace: g.trace('level %s lastLevel %s %s returns %s' % (
        level,lastLevel,headline,parent.h))

    #self.lastSectionLevel = self.sectionLevel
    self.lastParent = parent.copy()
    return parent.copy()
#@-node:ekr.20090512080015.5798:adjustParent
#@+node:ekr.20091229090857.11694:computeBody (rst)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    # Never indent any text; discard the entire signature.
    body1 = s[start:sigStart]
    body2 = s[self.sigEnd+1:codeEnd]
    body2 = g.removeLeadingBlankLines(body2) # 2009/12/28
    body = body1 + body2

    # Don't warn about missing tail newlines: they will be added.
    if trace: g.trace('body: %s' % repr(body))
    return body
#@-node:ekr.20091229090857.11694:computeBody (rst)
#@+node:ekr.20090512080015.5797:computeSectionLevel
def computeSectionLevel (self,ch,kind):

    '''Return the section level of the underlining character ch.'''

    # Can't use g.choose here.
    if kind == 'over':
        assert ch in self.underlines2
        level = 0
    else:
        level = 1 + self.underlines1.index(ch)

    if False:
        g.trace('level: %s kind: %s ch: %s under2: %s under1: %s' % (
            level,kind,ch,self.underlines2,self.underlines1))

    return level
#@-node:ekr.20090512080015.5797:computeSectionLevel
#@+node:ekr.20090512153903.5810:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '@rst-no-head %s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090512153903.5810:createDeclsNode
#@+node:ekr.20090502071837.2:endGen
def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    trace = False and not g.unitTesting
    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        if trace: g.trace(repr(underlines1),repr(underlines2),g.callers(4))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
#@-node:ekr.20090502071837.2:endGen
#@+node:ekr.20090501095634.46:isUnderLine
def isUnderLine(self,s):

    '''Return True if s consists of only the same rST underline character.'''

    if not s: return False
    ch1 = s[0]

    if not ch1 in self.underlines:
        return False

    for ch in s:
        if ch != ch1:
            return False

    return True
#@-node:ekr.20090501095634.46:isUnderLine
#@+node:ekr.20090501095634.50:startsComment/ID/String
# These do not affect parsing.

def startsComment (self,s,i):
    return False

def startsID (self,s,i):
    return False

def startsString (self,s,i):
    return False
#@-node:ekr.20090501095634.50:startsComment/ID/String
#@+node:ekr.20090501095634.45:startsHelper
def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts an rST section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = True
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i < len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i > progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
#@-node:ekr.20090501095634.45:startsHelper
#@+node:ekr.20090501095634.47:startsSection & helper
def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    verbose = False

    # Under/overlines can not begin with whitespace.
    i1,j,nows,line = self.getLine(s,i)
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j,nows,line2 = self.getLine(s,next_i)
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 >= n2 and n2 > 0 and n3 >= n2 and ch1 == ch3)
        if ok:
            i += n3
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                if trace: g.trace('*** underlines2',self.underlines2,name)
            if trace and verbose:
                g.trace('\nline  %s\nname  %s\nline2 %s' % (
                    repr(line),repr(name),repr(line2))) #,'\n',g.callers(4))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j,nows2,line2 = self.getLine(s,i)
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4,nows4,line4 = self.getLine(s,j3)
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 > 0 and n2 >= n3 and n4 >= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 > 0 and n2 >= n1)
        if ok:
            old_i = i
            i += n2
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                if trace: g.trace('*** underlines1',self.underlines1,name)
            if trace and verbose: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2))) # ,'\n',g.callers(4))
    return kind,name,i,ch
#@+node:ekr.20091229075924.6234:getLine
def getLine (self,s,i):

    i,j = g.getLine(s,i)
    line = s[i:j]
    nows = i == g.skip_ws(s,i)
    line = line.strip()

    return i,j,nows,line
#@-node:ekr.20091229075924.6234:getLine
#@-node:ekr.20090501095634.47:startsSection & helper
#@-node:ekr.20090501095634.41:class rstScanner
#@-node:ekr.20091219132601.6279:Reading
#@+node:ekr.20091219132601.6354:Writing
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False
):

    """Write @file nodes in all or part of the outline"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False ; atOk = True
    force = writeAtFileNodesFlag

    if writeAtFileNodesFlag:
        # The Write @<file> Nodes command.
        # Write all nodes in the selected tree.
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    atOk = True
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
        c.scanAtPathDirectivesCount-scanAtPathDirectivesCount))
    return mustAutoSave,atOk
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
    pathChanged = False
else:
    oldPath = at.getPathUa(p)
    newPath = at.fullPath(p)
    # if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
        # p.h,repr(oldPath),repr(newPath)))
    pathChanged = oldPath and oldPath != newPath
    if pathChanged:
        at.setPathUa(p,newPath) # Remember that we have changed paths.
        g.es_print('path changed for',p.h,color='blue')

if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=force)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p,toString=toString)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,kind='@nosent',nosentinels=True,toString=toString)
        writtenFiles.append(p.v) # No need for autosave
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p,toString=toString,force=force or pathChanged)
        writtenFiles.append(p.v) ; autoSave = True # 2008/7/29
    elif p.isAtThinFileNode():
        at.write(p,kind='@thin',thinFile=True,toString=toString)
        writtenFiles.append(p.v) # No need for autosave.
    elif p.isAtFileNode():
        if g.convert_at_file:
            at.write(p,kind='@file',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
            autoSave = True # Clears root.v.tnodeList, so we must save.
        else:
            at.write(p,kind='@file',thinFile=False,toString=toString)
            writtenFiles.append(p.v)
            autoSave = True # Updates root.v.tnodeList, so we must save.

    if at.errors: atOk = False

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @<file> nodes in the selected tree")
    else:
        g.es("no dirty @<file> nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20041005105605.144:write & helper (atFile)
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    if hasattr(root.v,'tnodeList'):
        has_list,old_list = True,root.v.tnodeList[:]
    else:
        has_list,old_list = False,[]

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)
    # g.trace('eventualFileName',eventualFileName,
        # 'at.targetFileName',at.targetFileName)

    if not scriptWrite and not toString:
        if nosentinels:
            if not self.shouldWriteAtNosentNode(root,exists):
                return
        elif not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            root.v.tnodeList = []
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.
            if has_list:
                if at.errors == 0 and g.convert_at_file:
                    # Clear the tnodeList in the root.
                    # Future writes will write thin-like sentinels.
                    # This will also clear the tnodeList attributes in
                    # <v> elements when the .leo file is written later.
                    root.v.tnodeList = []
                    root.v._p_changed = True
                else:
                    root.v.tnodeList = old_list

    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            root.v.tnodeList = []
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
            if has_list: root.v.tnodeList = old_list
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

#@-node:ekr.20041005105605.146:<< set dirty and orphan bits >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper (atFile)
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # Prompt if writing a new @auto node would overwrite an existing file.
    if (not toString and not hasattr(p.v,'at_auto_read') and
        g.os_path_exists(fileName)
    ):
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            p.v.at_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@nonl
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    if not underlines1: underlines1 = '=+*^~"\'`-:><_'
        # The standard defaults.
    self.atAutoWriteUnderlines = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@+node:ekr.20090502071837.58:write methods (leoRst)
#@+node:ekr.20090502071837.68:getDocPart
def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    << Append whatever follows @doc or @space to result >>
    while n < len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
#@nonl
#@+node:ekr.20090502071837.69:<< Append whatever follows @doc or @space to result >>
if n > 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
#@-node:ekr.20090502071837.69:<< Append whatever follows @doc or @space to result >>
#@-node:ekr.20090502071837.68:getDocPart
#@+node:ekr.20090502071837.72:handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73:formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@nonl
#@-node:ekr.20090502071837.73:formatCodeModeLine
#@+node:ekr.20090502071837.74:rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
#@-node:ekr.20090502071837.74:rstripList
#@+node:ekr.20090502071837.75:finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@nonl
#@-node:ekr.20090502071837.75:finishCodePart
#@-node:ekr.20090502071837.72:handleCodeMode & helper
#@+node:ekr.20090502071837.76:handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
#@nonl
#@-node:ekr.20090502071837.76:handleDocOnlyMode
#@+node:ekr.20090502071837.81:handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
#@-node:ekr.20090502071837.81:handleSpecialDocParts
#@+node:ekr.20090502071837.77:isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
#@nonl
#@-node:ekr.20090502071837.77:isAnyDocPart
#@+node:ekr.20090502071837.79:isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
#@-node:ekr.20090502071837.79:isAnySpecialDocPart
#@+node:ekr.20090502071837.78:isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
#@nonl
#@-node:ekr.20090502071837.78:isSpecialDocPart
#@+node:ekr.20090502071837.80:removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@nonl
#@-node:ekr.20090502071837.80:removeLeoDirectives
#@+node:ekr.20090502071837.82:replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
#@nonl
#@-node:ekr.20090502071837.82:replaceCodeBlockDirectives
#@+node:ekr.20090502071837.70:skip_literal_block
def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n < len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 <= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
#@nonl
#@-node:ekr.20090502071837.70:skip_literal_block
#@+node:ekr.20090502071837.94:write (leoRst)
def write (self,s):

    if self.trialWrite:
        pass
    else:
        s = self.encode(s)

    # g.trace(repr(s),g.callers(2))

    self.outputFile.write(s)
#@-node:ekr.20090502071837.94:write (leoRst)
#@+node:ekr.20090502071837.71:writeBody
def writeBody (self,p):

    # g.trace(p.h,p.b)

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
#@-node:ekr.20090502071837.71:writeBody
#@+node:ekr.20090502071837.83:writeHeadline & helper
def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
#@nonl
#@+node:ekr.20090502071837.84:writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in (
            self.getOption('option_prefix'),
            self.getOption('options_prefix'),
            self.getOption('ignore_headline_prefix'), # Bug fix: 2009-5-13
            self.getOption('ignore_headlines_prefix'),  # Bug fix: 2009-5-13
        ):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
#@-node:ekr.20090502071837.84:writeHeadlineHelper
#@-node:ekr.20090502071837.83:writeHeadline & helper
#@+node:ekr.20090502071837.85:writeNode (rst)
def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
#@-node:ekr.20090502071837.85:writeNode (rst)
#@+node:ekr.20090502071837.86:writePreformat
def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
#@-node:ekr.20090502071837.86:writePreformat
#@+node:ekr.20090502071837.87:writeTree
def writeTree(self,p):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    # g.trace(self.getOption('generate_rst_header_comment'))

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
#@-node:ekr.20090502071837.87:writeTree
#@-node:ekr.20090502071837.58:write methods (leoRst)
#@-node:ekr.20091219132601.6354:Writing
#@+node:ekr.20091227115606.6467:Comparison
#@+node:ekr.20091229075924.6235:removeLeadingBlankLines & test
def removeLeadingBlankLines (s):

    lines = g.splitLines(s)

    result = [] ; remove = True
    for line in lines:
        if remove and not line.strip():
            pass
        else:
            remove = False
            result.append(line)

    return ''.join(result)
#@+node:ekr.20091229075924.6236:@test g.removeLeadingBlankLines
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        ('a\nb', 'a\nb'),
        ('\n  \nb\n', 'b\n'),
        (' \t \n\n\n c', ' c'),
    ):
        result = g.removeLeadingBlankLines(s)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20091229075924.6236:@test g.removeLeadingBlankLines
#@-node:ekr.20091229075924.6235:removeLeadingBlankLines & test
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):

    '''Split s into lines, preserving the number of lines and
    the endings of all lines, including the last line.'''

    # g.stat()

    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):

    return ''.join(aList)

joinlines = joinLines
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20070730093735:compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = False and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090513073632.5735:compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@-node:ekr.20090513073632.5735:compareRstUnderlines
#@-node:ekr.20070730093735:compareHelper & helpers
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i < n: line = repr(lines[i])
            else: line = '<eof>'
            aList.append('%4d %s' % (i,line))
    g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20091227115606.6467:Comparison
#@+node:ekr.20091228080620.6498:Warn about dangerous writes
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@nonl
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    if not underlines1: underlines1 = '=+*^~"\'`-:><_'
        # The standard defaults.
    self.atAutoWriteUnderlines = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@-node:ekr.20091228080620.6498:Warn about dangerous writes
#@+node:ekr.20091229090857.11684:Major changes
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090502071837.84:writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in (
            self.getOption('option_prefix'),
            self.getOption('options_prefix'),
            self.getOption('ignore_headline_prefix'), # Bug fix: 2009-5-13
            self.getOption('ignore_headlines_prefix'),  # Bug fix: 2009-5-13
        ):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
#@-node:ekr.20090502071837.84:writeHeadlineHelper
#@+node:ekr.20090501095634.47:startsSection & helper
def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    verbose = False

    # Under/overlines can not begin with whitespace.
    i1,j,nows,line = self.getLine(s,i)
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j,nows,line2 = self.getLine(s,next_i)
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 >= n2 and n2 > 0 and n3 >= n2 and ch1 == ch3)
        if ok:
            i += n3
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                if trace: g.trace('*** underlines2',self.underlines2,name)
            if trace and verbose:
                g.trace('\nline  %s\nname  %s\nline2 %s' % (
                    repr(line),repr(name),repr(line2))) #,'\n',g.callers(4))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j,nows2,line2 = self.getLine(s,i)
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4,nows4,line4 = self.getLine(s,j3)
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 > 0 and n2 >= n3 and n4 >= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 > 0 and n2 >= n1)
        if ok:
            old_i = i
            i += n2
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                if trace: g.trace('*** underlines1',self.underlines1,name)
            if trace and verbose: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2))) # ,'\n',g.callers(4))
    return kind,name,i,ch
#@+node:ekr.20091229075924.6234:getLine
def getLine (self,s,i):

    i,j = g.getLine(s,i)
    line = s[i:j]
    nows = i == g.skip_ws(s,i)
    line = line.strip()

    return i,j,nows,line
#@-node:ekr.20091229075924.6234:getLine
#@-node:ekr.20090501095634.47:startsSection & helper
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p.h,fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_read = True # Create the attribute

    # Disable caching for test.leo.
    if c.shortFileName() != 'test.leo':
        if cachefile is not None and cachefile in c.db:        
            # g.es('uncache:',p.h)
            aList = c.db[cachefile]
            p.v.createOutlineFromCacheList(c,aList)
            return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    if not underlines1: underlines1 = '=+*^~"\'`-:><_'
        # The standard defaults.
    self.atAutoWriteUnderlines = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@-node:ekr.20091229090857.11684:Major changes
#@+node:ekr.20091229090857.11691:Underlining
#@+node:ekr.20090502071837.2:endGen
def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    trace = False and not g.unitTesting
    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        if trace: g.trace(repr(underlines1),repr(underlines2),g.callers(4))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
#@-node:ekr.20090502071837.2:endGen
#@+node:ekr.20090501095634.45:startsHelper
def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts an rST section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = True
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i < len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i > progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
#@-node:ekr.20090501095634.45:startsHelper
#@+node:ekr.20090501095634.47:startsSection & helper
def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    verbose = False

    # Under/overlines can not begin with whitespace.
    i1,j,nows,line = self.getLine(s,i)
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j,nows,line2 = self.getLine(s,next_i)
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 >= n2 and n2 > 0 and n3 >= n2 and ch1 == ch3)
        if ok:
            i += n3
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                if trace: g.trace('*** underlines2',self.underlines2,name)
            if trace and verbose:
                g.trace('\nline  %s\nname  %s\nline2 %s' % (
                    repr(line),repr(name),repr(line2))) #,'\n',g.callers(4))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j,nows2,line2 = self.getLine(s,i)
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4,nows4,line4 = self.getLine(s,j3)
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 > 0 and n2 >= n3 and n4 >= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 > 0 and n2 >= n1)
        if ok:
            old_i = i
            i += n2
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                if trace: g.trace('*** underlines1',self.underlines1,name)
            if trace and verbose: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2))) # ,'\n',g.callers(4))
    return kind,name,i,ch
#@+node:ekr.20091229075924.6234:getLine
def getLine (self,s,i):

    i,j = g.getLine(s,i)
    line = s[i:j]
    nows = i == g.skip_ws(s,i)
    line = line.strip()

    return i,j,nows,line
#@-node:ekr.20091229075924.6234:getLine
#@-node:ekr.20090501095634.47:startsSection & helper
#@+node:ekr.20090502071837.93:underline (leoRst)
def underline (self,s,p):

    '''Return the underlining string to be used at the given level for string s.
    This includes the headline, and possibly a leading overlining line.
    '''

    trace = False and not g.unitTesting

    if trace: g.trace(self.atAutoWrite,repr(self.underlines2),p.h)

    if self.atAutoWrite:
        # We *might* generate overlines for top-level sections.
        u = self.atAutoWriteUnderlines
        level = p.level()-self.topLevel

        # This is tricky. The index n depends on several factors.
        if self.underlines2:
            level -= 1 # There *is* a double-underlined section.
            n = level
        else:
            n = level-1
        if 0 <= n < len(u): ch = u[n]
        elif u:
            ch = u[-1]
        else:
            g.trace('can not happen: no u')
            ch = '#'

        # 2010/01/10: write longer underlines for non-ascii characters.
        # n = max(4,len(s))
        n = max(4,len(g.toEncodedString(s,encoding='utf-8',reportErrors=False)))
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        if level == 0 and self.underlines2:
            return '%s\n%s\n%s\n\n' % (ch*n,p.h,ch*n)
        else:
            return '%s\n%s\n\n' % (p.h,ch*n)
    else:
        # The user is responsible for top-level overlining.
        u = self.getOption('underline_characters') #  '''#=+*^~"'`-:><_'''
        level = max(0,p.level()-self.topLevel)
        level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
        ch = u [level]
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        # 2010/01/10: write longer underlines for non-ascii characters.
        # n = max(4,len(s))
        n = max(4,len(g.toEncodedString(s,encoding='utf-8',reportErrors=False)))
        return '%s\n%s\n\n' % (p.h.strip(),ch*n)
#@-node:ekr.20090502071837.93:underline (leoRst)
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    if not underlines1: underlines1 = '=+*^~"\'`-:><_'
        # The standard defaults.
    self.atAutoWriteUnderlines = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20090512153903.5806:computeBody (baseScannerClass)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

    return body
#@-node:ekr.20090512153903.5806:computeBody (baseScannerClass)
#@+node:ekr.20091229090857.11694:computeBody (rst)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    # Never indent any text; discard the entire signature.
    body1 = s[start:sigStart]
    body2 = s[self.sigEnd+1:codeEnd]
    body2 = g.removeLeadingBlankLines(body2) # 2009/12/28
    body = body1 + body2

    # Don't warn about missing tail newlines: they will be added.
    if trace: g.trace('body: %s' % repr(body))
    return body
#@-node:ekr.20091229090857.11694:computeBody (rst)
#@-node:ekr.20091229090857.11691:Underlining
#@-node:ekr.20091221094815.6386:Fixed at-auto-rst problems
#@+node:ekr.20091229090857.11695:Ignore blank rst lines in replaceTargetFileIfDifferent
#@+node:ekr.20091229090857.11698:removeBlankLines & test
def removeBlankLines (s):

    lines = g.splitLines(s)
    lines = [z for z in lines if z.strip()]
    return ''.join(lines)
#@+node:ekr.20091229090857.11699:@test g.removeBlankLines
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        ('a\nb', 'a\nb'),
        ('\n  \n\nb\n', 'b\n'),
        (' \t \n\n  \n c\n\t\n', ' c\n'),
    ):
        result = g.removeBlankLines(s)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20091229090857.11699:@test g.removeBlankLines
#@-node:ekr.20091229090857.11698:removeBlankLines & test
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # Prompt if writing a new @auto node would overwrite an existing file.
    if (not toString and not hasattr(p.v,'at_auto_read') and
        g.os_path_exists(fileName)
    ):
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            p.v.at_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent (atFile)
def replaceTargetFileIfDifferent (self,root,ignoreBlankLines=False):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    trace = False and not g.unitTesting
    c = self.c

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if trace: g.trace(self.outputFileName,self.targetFileName)

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(
            self.outputFileName,
            self.targetFileName,
            ignoreLineEndings=not self.explicitLineEnding,
            ignoreBlankLines=ignoreBlankLines):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            g.es('unchanged:',self.shortFileName)
            if not ok:
                # self.remove gives the error.
                if root: root.setDirty() # New in 4.4.8.
            self.fileChangedFlag = False
            return False
        else:
            self.checkPythonCode(root)
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:',self.shortFileName)
            else:
                # self.rename gives the error.
                g.es('unchanged:',self.shortFileName)
                if root: root.setDirty() # New in 4.4.8.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:',self.targetFileName)
        else:
            # self.rename gives the error.
            if root: root.setDirty() # New in 4.4.8.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent (atFile)
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings,ignoreBlankLines=False):

    """Compare two text files ignoring line endings."""

    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        s1,s2 = f1.read(), f2.read()
        f1.close() ; f2.close()
        equal = s1 == s2
        if ignoreBlankLines and not equal:
            s1 = g.removeBlankLines(s1)
            s2 = g.removeBlankLines(s2)
            equal = s1 == s2
        return equal
    except IOError:
        return False # Should never happen
#@-node:ekr.20041005105605.197:compareFiles
#@-node:ekr.20091229090857.11695:Ignore blank rst lines in replaceTargetFileIfDifferent
#@+node:ekr.20091230141112.6265:Fixed cheatsheet.txt problem
#@+node:ekr.20070703122141.65:<< class baseScannerClass >>
class baseScannerClass (scanUtility):

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.escapeSectionRefs = True
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20070730093735:compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = False and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468:adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@-node:ekr.20091227115606.6468:adjustRstLines
#@+node:ekr.20090513073632.5735:compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@-node:ekr.20090513073632.5735:compareRstUnderlines
#@-node:ekr.20070730093735:compareHelper & helpers
#@+node:ekr.20071110144948:checkLeadingWhitespace
def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
#@-node:ekr.20071110144948:checkLeadingWhitespace
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i < n: line = repr(lines[i])
            else: line = '<eof>'
            aList.append('%4d %s' % (i,line))
    g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20090512080015.5800:adjustParent
def adjustParent (self,parent,headline):

    '''Return the effective parent.

    This is overridden by the rstScanner class.'''

    return parent
#@-node:ekr.20090512080015.5800:adjustParent
#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.isRst and not self.atAuto:
        return

    if self.treeType == '@file':
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s,encoding)
#@-node:ekr.20090122201952.6:appendStringToBody & setBodyString (baseScannerClass)
#@+node:ekr.20090512153903.5806:computeBody (baseScannerClass)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

    return body
#@-node:ekr.20090512153903.5806:computeBody (baseScannerClass)
#@+node:ekr.20090513073632.5737:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '%s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090513073632.5737:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.h,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20090502071837.1:endGen
def endGen (self,s):

    '''Do any language-specific post-processing.'''
    pass
#@-node:ekr.20090502071837.1:endGen
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class,
    and a child of c for each def in the class.'''

    trace = False and not g.unitTesting
    if trace:
        # g.trace('tab_width',self.tab_width)
        g.trace('sig',s[i:sigEnd])

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    if trace: g.trace('undentVal',undentVal,'bodyIndent',bodyIndent)

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070703122141.106:getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@-node:ekr.20070703122141.106:getClassNodeRef
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    trace = False and not g.unitTesting

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None
    if trace: g.trace('bodyIndent',bodyIndent)

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction (baseScannerClass)
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and not g.unitTesting
    verbose = False

    # if trace: g.trace(start,sigStart,self.sigEnd,codeEnd)

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body = self.computeBody(s,start,sigStart,codeEnd)

    if trace:
        g.trace('parent',parent.h)
        if verbose: g.trace('**body...\n',body)

    parent = self.adjustParent(parent,headline)
    self.lastParent = self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction (baseScannerClass)
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20090122201952.5:setBodyString
#@-node:ekr.20090122201952.5:setBodyString
#@+node:ekr.20070703122141.88:undentBody
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    if self.isRst:
        return s # Never unindent rst code.

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result
#@-node:ekr.20070703122141.88:undentBody
#@+node:ekr.20081216090156.1:undentBy
def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    trace = False and not g.app.unitTesting

    if self.isRst:
        return s # Never unindent rst code.

    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws < undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

#@-node:ekr.20081216090156.1:undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error, oops, report and warning
def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print('',s,color='red')
    else:
        g.es_print('error:',s,color='red')

def oops (self):
    g.pr('baseScannerClass oops: %s must be overridden in subclass' % g.callers())

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning:',s,color='red')
#@-node:ekr.20070703122141.78:error, oops, report and warning
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20071201072917:adjustDefStart
def adjustDefStart (self,unused_s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    return i
#@-node:ekr.20071201072917:adjustDefStart
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,unused_s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,junk = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.appendStringToBody(parent,s[start:])

    # Do any language-specific post-processing.
    self.endGen(s)
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    start = i

    # Skip the opening delim.
    if g.match(s,i,self.blockCommentDelim1):
        delim2 = self.blockCommentDelim2
        i += len(self.blockCommentDelim1)
    elif g.match(s,i,self.blockCommentDelim1_2):
        i += len(self.blockCommentDelim1_2)
        delim2 = self.blockCommentDelim2_2
    else:
        assert False

    # Find the closing delim.
    k = s.find(delim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(delim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@-node:ekr.20070707080042:skipDecls
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
#@+node:ekr.20070711134534:getSigId
def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    return ids and ids[-1]
#@-node:ekr.20070711134534:getSigId
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1) or
        g.match(s,i,self.blockCommentDelim1_2)
    )
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    if self.escapeSectionRefs: # 2009/12/27
        s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65:<< class baseScannerClass >>
#@+node:ekr.20090501095634.41:class rstScanner
class rstScanner (baseScannerClass):

    @others
#@+node:ekr.20090501095634.42: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='rest')

    # Scanner overrides
    self.atAutoWarnsAboutLeadingWhitespace = True
    self.blockDelim1 = self.blockDelim2 = None
    self.classTags = []
    self.escapeSectionRefs = False
    self.functionSpelling = 'section'
    self.functionTags = []
    self.hasClasses = False
    self.isRst = True
    self.lineCommentDelim = '..'
    self.outerBlockDelim1 = None
    self.sigFailTokens = []
    self.strict = False # Mismatches in leading whitespace are irrelevant.

    # Ivars unique to rst scanning & code generation.
    self.lastParent = None # The previous parent.
    self.lastSectionLevel = 0 # The section level of previous section.
    self.sectionLevel = 0 # The section level of the just-parsed section.
    self.underlineCh = '' # The underlining character of the last-parsed section.
    self.underlines = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~" # valid rst underlines.
    self.underlines1 = [] # Underlining characters for underlines.
    self.underlines2 = [] # Underlining characters for over/underlines.
#@-node:ekr.20090501095634.42: __init__
#@+node:ekr.20090512080015.5798:adjustParent
def adjustParent (self,parent,headline):

    '''Return the proper parent of the new node.'''

    trace = False and not g.unitTesting

    level,lastLevel = self.sectionLevel,self.lastSectionLevel
    lastParent = self.lastParent

    if trace: g.trace('**entry level: %s lastLevel: %s lastParent: %s' % (
        level,lastLevel,lastParent and lastParent.h or '<none>'))

    if self.lastParent:

        if level <= lastLevel:
            parent = lastParent.parent()
            while level < lastLevel:
                level += 1
                parent = parent.parent()
        else: # level > lastLevel.
            level -= 1
            parent = lastParent
            while level > lastLevel:
                level -= 1
                h2 = '@rst-no-head %s' % headline
                body = ''
                parent = self.createFunctionNode(h2,body,parent)

    else:
        assert self.root
        self.lastParent = self.root

    if not parent: parent = self.root

    if trace: g.trace('level %s lastLevel %s %s returns %s' % (
        level,lastLevel,headline,parent.h))

    #self.lastSectionLevel = self.sectionLevel
    self.lastParent = parent.copy()
    return parent.copy()
#@-node:ekr.20090512080015.5798:adjustParent
#@+node:ekr.20091229090857.11694:computeBody (rst)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    # Never indent any text; discard the entire signature.
    body1 = s[start:sigStart]
    body2 = s[self.sigEnd+1:codeEnd]
    body2 = g.removeLeadingBlankLines(body2) # 2009/12/28
    body = body1 + body2

    # Don't warn about missing tail newlines: they will be added.
    if trace: g.trace('body: %s' % repr(body))
    return body
#@-node:ekr.20091229090857.11694:computeBody (rst)
#@+node:ekr.20090512080015.5797:computeSectionLevel
def computeSectionLevel (self,ch,kind):

    '''Return the section level of the underlining character ch.'''

    # Can't use g.choose here.
    if kind == 'over':
        assert ch in self.underlines2
        level = 0
    else:
        level = 1 + self.underlines1.index(ch)

    if False:
        g.trace('level: %s kind: %s ch: %s under2: %s under1: %s' % (
            level,kind,ch,self.underlines2,self.underlines1))

    return level
#@-node:ekr.20090512080015.5797:computeSectionLevel
#@+node:ekr.20090512153903.5810:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '@rst-no-head %s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20090512153903.5810:createDeclsNode
#@+node:ekr.20090502071837.2:endGen
def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    trace = False and not g.unitTesting
    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        if trace: g.trace(repr(underlines1),repr(underlines2),g.callers(4))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
#@-node:ekr.20090502071837.2:endGen
#@+node:ekr.20090501095634.46:isUnderLine
def isUnderLine(self,s):

    '''Return True if s consists of only the same rST underline character.'''

    if not s: return False
    ch1 = s[0]

    if not ch1 in self.underlines:
        return False

    for ch in s:
        if ch != ch1:
            return False

    return True
#@-node:ekr.20090501095634.46:isUnderLine
#@+node:ekr.20090501095634.50:startsComment/ID/String
# These do not affect parsing.

def startsComment (self,s,i):
    return False

def startsID (self,s,i):
    return False

def startsString (self,s,i):
    return False
#@-node:ekr.20090501095634.50:startsComment/ID/String
#@+node:ekr.20090501095634.45:startsHelper
def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts an rST section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = True
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i < len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i > progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
#@-node:ekr.20090501095634.45:startsHelper
#@+node:ekr.20090501095634.47:startsSection & helper
def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    verbose = False

    # Under/overlines can not begin with whitespace.
    i1,j,nows,line = self.getLine(s,i)
    ch,kind = '','plain' # defaults.

    if nows and self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j,nows,line2 = self.getLine(s,next_i)
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (nows and self.isUnderLine(line2) and
            n1 >= n2 and n2 > 0 and n3 >= n2 and ch1 == ch3)
        if ok:
            i += n3
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                if trace: g.trace('*** underlines2',self.underlines2,name)
            if trace and verbose:
                g.trace('\nline  %s\nname  %s\nline2 %s' % (
                    repr(line),repr(name),repr(line2))) #,'\n',g.callers(4))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j,nows2,line2 = self.getLine(s,i)
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4,nows4,line4 = self.getLine(s,j3)
        n3,n4 = len(name2),len(line4)
        overline = (
            nows2 and self.isUnderLine(line2) and
            nows4 and self.isUnderLine(line4) and
            n3 > 0 and n2 >= n3 and n4 >= n3)
        ok = (not overline and nows2 and self.isUnderLine(line2) and
            n1 > 0 and n2 >= n1)
        if ok:
            old_i = i
            i += n2
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                if trace: g.trace('*** underlines1',self.underlines1,name)
            if trace and verbose: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2))) # ,'\n',g.callers(4))
    return kind,name,i,ch
#@+node:ekr.20091229075924.6234:getLine
def getLine (self,s,i):

    i,j = g.getLine(s,i)
    line = s[i:j]
    nows = i == g.skip_ws(s,i)
    line = line.strip()

    return i,j,nows,line
#@-node:ekr.20091229075924.6234:getLine
#@-node:ekr.20090501095634.47:startsSection & helper
#@-node:ekr.20090501095634.41:class rstScanner
#@-node:ekr.20091230141112.6265:Fixed cheatsheet.txt problem
#@-node:ekr.20091221094815.6383: Urgent (voted up) bugs
#@+node:ekr.20091006063434.24624:Fixed bug: at-nosent nodes were not being dirty when headline changes
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
#@nonl
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
#@+node:ekr.20040803072955.91:onHeadChanged (leoTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and not g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace:
        g.trace('*** leoTree',g.callers(5))
        g.trace(p and p.h,'w',repr(w),'s',repr(s))
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged (leoTree)
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20091006063434.24624:Fixed bug: at-nosent nodes were not being dirty when headline changes
#@+node:ekr.20091230062012.6236:Allow hyphens in xml tags
@nocolor-node

Fixes bug 497332: importing xml via @data import_xml_tags does not allow dashes in tag.

For characters valid in names see:
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
#@nonl
#@+node:ekr.20071214072145.1:class xmlScanner
class xmlScanner (baseScannerClass):

    @others
#@+node:ekr.20071214072451: __init__ (xmlScanner)
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='xml')
        # sets self.c

    # Set the parser delims.
    self.blockCommentDelim1 = '<!--'
    self.blockCommentDelim2 = '-->'
    self.blockDelim1 = None 
    self.blockDelim2 = None
    self.classTags = [] # Inited by import_xml_tags setting.
    self.extraIdChars = None
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = False
    self.sigHeadExtraTokens = []
    self.sigFailTokens = []

    # Overrides more attributes.
    self.hasClasses = True
    self.hasFunctions = False
    self.strict = False
    self.trace = False

    self.addTags()
#@nonl
#@-node:ekr.20071214072451: __init__ (xmlScanner)
#@+node:ekr.20071214131818:addTags
def addTags (self):

    '''Add items to self.class/functionTags and from settings.'''

    trace = False and not g.unitTesting
    c = self.c

    for ivar,setting in (
        ('classTags','import_xml_tags',),
        # ('functionTags','import_xml_function_tags'),
    ):
        aList = getattr(self,ivar)
        aList2 = c.config.getData(setting) or []
        aList.extend(aList2)
        if trace: g.trace(ivar,aList)
#@-node:ekr.20071214131818:addTags
#@+node:ekr.20091230062012.6238:skipId (override base class) & helper
@  For characters valid in names see:
   www.w3.org/TR/2008/REC-xml-20081126/#NT-Name
@c

def skipId (self,s,i):

    # Fix bug 497332: @data import_xml_tags does not allow dashes in tag.
    chars = '.-:' # Allow : anywhere.
    n = len(s)
    while i < n and (self.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@nonl
#@+node:ekr.20091230062012.6239:isWordChar
@ From www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

NameStartChar	::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6]     | [#xD8-#xF6]     | [#xF8-#x2FF]    |
    [#x370-#x37D]   | [#x37F-#x1FFF]  | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar	::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]
@c

def isWordChar(self,ch):

    # At present, same as g.isWordChar.
    # This is not correct.
    return ch and (ch.isalnum() or ch == '_')
#@-node:ekr.20091230062012.6239:isWordChar
#@-node:ekr.20091230062012.6238:skipId (override base class) & helper
#@+node:ekr.20071214072924.4:startsHelper & helpers
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace ; verbose = False
    self.codeEnd = self.sigEnd = self.sigId = None

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    if not g.match(s,i,'<'): return False
    self.sigStart = i
    i += 1
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if theId not in tags:
        if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
        return False

    if trace and verbose: g.trace(theId)
    classId = '' 
    sigId = theId

    # Complete the opening tag.
    i, ok = self.skipToEndOfTag(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if 0:
        if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
            if trace and verbose: g.trace('extending sigEnd')
            sigEnd = g.skip_line(s,sigEnd)

    i,ok = self.skipToMatchingTag(s,i,theId)
    if not ok:
        if trace: g.trace('no matching tag',theId)
        return False

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@+node:ekr.20071214072924.3:skipToEndOfTag
def skipToEndOfTag(self,s,i):

    '''Skip to the end of an open tag.'''

    while i < len(s):
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'/>'):
            return i,False # Starts a self-contained tag.
        elif g.match(s,i,'>'):
            i += 1
            if g.match(s,i,'\n'): i += 1
            return i,True
        else:
            i += 1
        assert progress < i

    return i,False
#@-node:ekr.20071214072924.3:skipToEndOfTag
#@+node:ekr.20071214075117:skipToMatchingTag
def skipToMatchingTag (self,s,i,tag):

    while i < len(s):
        progress = i
        if i == '"':
            i = self.skipString(s,i)
        elif g.match(s,i,'</'):
            i += 2 ; j = i
            i = self.skipId(s,j)
            tag2 = s[j:i]
            if tag2.lower() == tag.lower():
                i,ok = self.skipToEndOfTag(s,i)
                return i,ok
        else:
            i += 1
        assert progress < i

    return i,False
#@-node:ekr.20071214075117:skipToMatchingTag
#@-node:ekr.20071214072924.4:startsHelper & helpers
#@-node:ekr.20071214072145.1:class xmlScanner
#@-node:ekr.20091230062012.6236:Allow hyphens in xml tags
#@+node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('<'+'<'+'*'+'>'+'>'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
#@+node:ekr.20090214075058.10:compute_directives_re
def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
#@-node:ekr.20090214075058.10:compute_directives_re
#@-node:ekr.20090214075058.9:g.get_directives_dict (must be fast)
#@+node:ekr.20031218072017.1385:g.findReference
# Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20091016055503.6059:Color sections references in @root trees
#@+node:ekr.20091230094319.6239:Fixed Alt-u bug and refactored k.masterKeyHandler
#@+node:ekr.20091230141112.6264:Report
@nocolor-node

Bug 404993: alt+U (universal argument) "freezes" leo state

Press alt+U displays "Universal argument:" in minibuffer, and there is no
obvious way to get out of this state. It seems ctrl+G gets you out of it, but
that's not really obvious. ESC should do it.
#@-node:ekr.20091230141112.6264:Report
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and not (stroke.startswith('Alt+Ctrl') and not self.enable_alt_ctrl_bindings) and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            if trace: g.trace(w)
            i = w.logCtrl.getInsertPoint()
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            w.logCtrl.insert(i,stroke)
            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@nonl
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        done,b = k.doPlainKey(event,stroke,w)
        if b: k.masterCommand(event,b.func,b.stroke,b.commandName)
        if done: return 'break'

    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20091230094319.6244:doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return True,'break'
#@-node:ekr.20091230094319.6244:doMode
#@+node:ekr.20091230094319.6242:doPlainKey
def doPlainKey (self,event,stroke,w):

    '''Handle a plain key.  Return done,b.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # Important: only keys bound somewhere have a stroke.
    # All unbound plain keys will be handled by handleUnboundKeys.
    if k.unboundKeyAction in ('insert','overwrite'):
        for key in (k.unboundKeyAction,'body','log','text','all'):
            # Ignore bindings for all plain keys in insert/overwrite mode
            # *except* auto-complete.
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    if trace: g.trace('%s: auto-complete key in %s mode' % (
                        stroke,k.unboundKeyAction))
                    return True,b

        if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
        return True,g.bunch(func=None,stroke=stroke,commandName=None)

    # Ignore all command-state keys if we are not in a text widget.
    elif k.unboundKeyAction == 'command':
        if g.app.gui.isTextWidget(w):
            return False,None
        else:
            c.onCanvasKey(event)
            return True,None
    else:
        return False,None
#@-node:ekr.20091230094319.6242:doPlainKey
#@+node:ekr.20091230094319.6240:getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    k = self ; w_name = k.c.widget_name(w)
    keyStatesTuple = ('command','insert','overwrite')

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace:
                g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
#@-node:ekr.20091230094319.6240:getPaneBinding
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.200:universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>

    k = self ; gui = g.app.gui
    state = k.getState('u-arg')

    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        keysym = gui.eventKeysym(event)
        # g.trace(state,keysym)
        if keysym == 'Escape':
            k.keyboardQuit(event)
        elif keysym == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif keysym.isdigit() or keysym == '-':
            k.updateLabel(event)
        elif keysym in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n,stroke=keysym)
            k.keyboardQuit(event)
            # k.clearState()
            # k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
#@+node:ekr.20061031131434.201:<< about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@-node:ekr.20061031131434.201:<< about repeat counts >>
#@+node:ekr.20061031131434.202:executeNTimes
def executeNTimes (self,event,n,stroke):

    trace = False and not g.unitTesting
    k = self

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        b = k.getPaneBinding(stroke,event.widget)
        if b:
            if trace: g.trace('repeat',n,'method',b.func.__name__,
                'stroke',stroke,'widget',event.widget)
            for z in range(n):
                # event = g.Bunch(
                    # c = self.c,
                    # widget = event.widget,
                    # keysym = event.keysym,
                    # stroke = event.stroke,
                    # char = event.char,
                # )
                k.masterCommand(event,b.func,'<%s>' % stroke)
        else:
            # This does nothing for Qt gui.
            w = event.widget
            for z in range(n):
                g.app.gui.event_generate(w,'<Key>',keysym=event.keysym)
#@-node:ekr.20061031131434.202:executeNTimes
#@+node:ekr.20061031131434.203:doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c
    ch = g.app.gui.eventChar(event)

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@-node:ekr.20061031131434.203:doControlU
#@-node:ekr.20061031131434.200:universalDispatcher & helpers
#@-node:ekr.20091230094319.6239:Fixed Alt-u bug and refactored k.masterKeyHandler
#@+node:ekr.20100107051445.6193:Fixed at-shadow error
#@+node:ekr.20100107051445.6194:Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/81f7bb5060ed8b01

I simplified the tree of xsimple.c (the shadow file) to be:

//@+leo-ver=4-thin
//@+node:Gil.20100104180550.2581:@shadow simple.c
hello

//@+others
//@+node:Gil.20100104180550.2582:world
world
//@nonl
//@-node:Gil.20100104180550.2582:world
//@-others

!
//@nonl
//@-node:Gil.20100104180550.2581:@shadow simple.c
//@-leo

The public is trivial (and indeed it is not a valid c file, just an
example).

Now if one exits Leo, adds a single space in every line in the public
file, and re-opens Leo, the error is:

updated private H:\temp\.leo_shadow\xsimple.c from public H:\temp
\simple.c
reading: @shadow simple.c
----- read error. line: 9, file: simple.c
unexpected @nonl directive in code part

Gil
#@nonl
#@-node:ekr.20100107051445.6194:Report
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):

    """Scan a 4.x derived file non-recursively."""

    trace = False and not g.unitTesting
    at = self
    << init ivars for scanText4 >>
    if trace: g.trace(fileName)
    try:
        while at.errors == 0 and not at.done:
            s = at.readLine(theFile)
            self.lineNumber += 1
            if len(s) == 0: break
            kind = at.sentinelKind4(s)
            if kind == at.noSentinel:
                i = 0
            else:
                i = at.skipSentinelStart4(s,0)
            func = at.dispatch_dict[kind]
            if trace: g.trace('%15s %16s %s' % (
                at.sentinelName(kind),func.__name__,repr(s)))
            func(s,i)
    except AssertionError:
        junk, message, junk = sys.exc_info()
        at.error('unexpected assertion failure in',fileName,'\n',message)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.lineNumber = 0
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.v = p.v
at.tStack = []
# New code: always identify root @thin node with self.root:
at.lastThinNode = None
at.thinNodeStack = []
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert at.endSentinelStack,'empty sentinel stack'

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)
#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+all"),'missing @+all'
    else:
        assert g.match(s,j,"+all"),'missing +all'

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")

    at.endSentinelStack.append(at.endAll)
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert g.match(s,i,"+at"),'missing +at'
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)

def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert g.match(s,i,"+doc"),'missing +doc'
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)

def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):

    """Read an unexpected @+leo sentinel."""

    at = self
    assert g.match(s,i,"+leo"),'missing +leo sentinel'
    at.readError("Ignoring unexpected @+leo sentinel")
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):

    """Read an @+middle sentinel."""

    at = self

    at.readStartNode(s,i,middle=True)
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    trace = False and not g.unitTesting
    at = self
    if middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        assert g.match(s,i,"+node:"),'missing +node'
        i += 6

    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.v)

    if trace: g.trace(at.root)
    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        if at.thinNodeStack:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
        else:
            v = at.root.v
            at.thinNodeStack.append(v)
        at.lastThinNode = v
        at.v = v
    else:
        at.v = at.findChild4(headline)

    if trace: g.trace('scanning',at.v)

    at.endSentinelStack.append(at.endNode)
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()

        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = h[i:].strip()
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = h[8:].strip()
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")

    at.endSentinelStack.append(at.endOthers)
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,unused_s,unused_i):

    """Read an @-all sentinel."""

    at = self
    at.popSentinelStack(at.endAll)
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,unused_s,unused_i):

    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,unused_s,unused_i):

    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,unused_s,unused_i):

    """Read an @-leo sentinel."""

    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):

    """Read an @-middle sentinel."""

    at = self

    at.readEndNode(s,i,middle=True)
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.v._bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.v != at.root.v:
            << indicate that the node has been changed >>
        at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()
    # g.trace('visit',at.v)

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.v._bodyString = s # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # g.pr("***",at.v,at.root.v)
            g.es("warning: updating changed text in",at.root.h,color="blue")
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.v.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self
    at.popSentinelStack(at.endOthers)
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
# Ooops: shadow files are cleared if there is a read error!!
#@nonl
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,unused_i):

    """Ignore an 3.x sentinel."""

    g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):

    """Read an @afterref sentinel."""

    at = self
    assert g.match(s,i,"afterref"),'missing afterref'

    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):

    at = self ; tag = "clone"

    assert g.match(s,i,tag),'missing clone sentinel'

    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))

    # Get the clone count.
    junk,val = g.skip_long(s,i)

    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):

    """Read an @comment sentinel."""

    assert g.match(s,i,"comment"),'missing comment sentinel'

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):

    """Read an @delims sentinel."""

    at = self
    assert g.match(s,i-1,"@delims"),'missing @delims'

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)

    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1

    if j < i:
        at.startSentinelComment = s[j:i]
        # g.pr("delim1:", at.startSentinelComment)

        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # g.pr("delim2:",end)
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel' # The first '@' has already been eaten.

    # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nl"),'missing nl sentinel'

    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nonl"),'missing nonl sentinel'

    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[:-1]]
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @<< sentinel."""

    at = self
    j = g.skip_ws(s,i)
    assert g.match(s,j,"<<"),'missing @<< sentinel'

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):

    """Read an @verbatim sentinel."""

    at = self
    assert g.match(s,i,"verbatim"),'missing verbatim sentinel'

    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    # Do **not** insert the verbatim line itself!
        # at.out.append("@verbatim\n")
    at.out.append(s[i:])
#@+node:ekr.20090620101138.6072:@test verbatim sentinel
if g.unitTesting:
    c,p = g.getTestVars()

    # Here is something that should generate a verbtim sentinel::

#@verbatim
    #@+leo-encoding=iso-8859-1.

    # The length of this node should remain constant.

    assert len(p.b) == 235,len(p.b)
#@nonl
#@-node:ekr.20090620101138.6072:@test verbatim sentinel
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert at.endSentinelStack,'empty sentinel stack'
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@-node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20080708094444.80:class shadowController
class shadowController:

    '''A class to manage @shadow files'''

    @others
#@+node:ekr.20080708094444.79: x.ctor
def __init__ (self,c,trace=False,trace_writers=False):

    self.c = c

    # Configuration...
    self.shadow_subdir = c.config.getString('shadow_subdir') or '.leo_shadow'
    self.shadow_prefix = c.config.getString('shadow_prefix') or ''

    # Munch shadow_subdir
    self.shadow_subdir = g.os_path_normpath(self.shadow_subdir)

    # Debugging...
    self.trace = trace
    self.trace_writers = trace_writers  # True: enable traces in all sourcewriters.

    # Error handling...
    self.errors = 0
    self.last_error  = '' # The last error message, regardless of whether it was actually shown.

    # Support for goto-line.
    self.line_mapping = []
#@-node:ekr.20080708094444.79: x.ctor
#@+node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080711063656.7:x.baseDirName
def baseDirName (self):

    x = self ; c = x.c ; filename = c.fileName()

    if filename:
        return g.os_path_dirname(c.os_path_finalize(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None
#@nonl
#@-node:ekr.20080711063656.7:x.baseDirName
#@+node:ekr.20080711063656.4:x.dirName and pathName
def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; c = x.c ; theDir = x.baseDirName()

    return theDir and c.os_path_finalize_join(theDir,filename)
#@nonl
#@-node:ekr.20080711063656.4:x.dirName and pathName
#@+node:ekr.20080712080505.3:x.isSignificantPublicFile
def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) > 10
#@-node:ekr.20080712080505.3:x.isSignificantPublicFile
#@+node:ekr.20080710082231.19:x.makeShadowDirectory
def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        # Force the creation of the directories.
        g.makeAllNonExistentDirectories(path,c=None,force=True)

    return g.os_path_exists(path) and g.os_path_isdir(path)
#@-node:ekr.20080710082231.19:x.makeShadowDirectory
#@+node:ekr.20080711063656.2:x.rename
def rename (self,src,dst,mode=None,silent=False):

    x = self ; c = x.c

    ok = g.utils_rename (c,src,dst,mode=mode,verbose=not silent)
    if not ok:
        x.error('can not rename %s to %s' % (src,dst),silent=silent)

    return ok
#@-node:ekr.20080711063656.2:x.rename
#@+node:ekr.20080713091247.1:x.replaceFileWithString & test
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    trace = False and not g.unitTesting
    x = self
    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = open(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            x.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not g.unitTesting: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            x.error('not written: %s directory not found' % fn)
        return False

    # Replace the file.
    try:
        f = open(fn,'wb')
        f.write(g.toEncodedString(s,encoding='utf-8'))
        if trace: g.trace('fn',fn,
            '\nlines...\n%s' %(g.listToString(g.splitLines(s))),
            '\ncallers',g.callers(4))
        f.close()
        if not g.unitTesting:
            # g.trace('created:',fn,g.callers())
            if exists:  g.es('wrote:',fn)
            else:       g.es('created:',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@+node:ekr.20090530055015.6862:@test x.replaceFileWithString
if g.unitTesting:

    c,p = g.getTestVars()
    x = c.shadowController

    fn = 'does/not/exist'
    assert not g.os_path_exists(fn)
    assert not x.replaceFileWithString (fn,'abc')
#@-node:ekr.20090530055015.6862:@test x.replaceFileWithString
#@-node:ekr.20080713091247.1:x.replaceFileWithString & test
#@+node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; c = x.c

    baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)

    return baseDir and c.os_path_finalize_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))
#@-node:ekr.20080711063656.6:x.shadowDirName and shadowPathName
#@+node:ekr.20080711063656.3:x.unlink
def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
#@-node:ekr.20080711063656.3:x.unlink
#@-node:ekr.20080711063656.1:x.File utils
#@+node:ekr.20080708192807.1:x.Propagation
#@+node:ekr.20080708094444.35:x.check_the_final_output
def check_the_final_output(self, new_private_lines, new_public_lines, sentinel_lines, marker):
    """
    Check that we produced a valid output.

    Input:
        new_targetlines:   the lines with sentinels which produce changed_lines_without_sentinels.
        sentinels:         new_targetlines should include all the lines from sentinels.

    checks:
        1. new_targetlines without sentinels must equal changed_lines_without_sentinels.
        2. the sentinel lines of new_targetlines must match 'sentinels'
    """
    new_public_lines2, new_sentinel_lines2 = self.separate_sentinels (new_private_lines, marker)

    ok = True
    if new_public_lines2 != new_public_lines:
        last_line2 = new_public_lines2[-1]
        last_line  = new_public_lines[-1]
        if (
            new_public_lines2[:-1] == new_public_lines[:-1] and
            last_line2 == last_line + '\n'
        ):
            ok = True
        else:
            ok = False
            self.show_error(
                lines1 = new_public_lines2,
                lines2 = new_public_lines,
                message = "Error in updating public file!",
                lines1_message = "new public lines (derived from new private lines)",
                lines2_message = "new public lines")
        # g.trace(g.callers())

    if new_sentinel_lines2 != sentinel_lines:
        ok = False
        self.show_error(
            lines1 = sentinel_lines,
            lines2 = new_sentinel_lines2,
            message = "Sentinals not preserved!",
            lines1_message = "old sentinels",
            lines2_message = "new sentinels")

    # if ok: g.trace("success!")
#@-node:ekr.20080708094444.35:x.check_the_final_output
#@+node:ekr.20080708094444.37:x.copy_sentinels
def copy_sentinels(self,reader,writer,marker,limit):

    '''Copy sentinels from reader to writer while reader.index() < limit.'''

    x = self
    start = reader.index()
    while reader.index() < limit:
        line = reader.get()
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                # We are *deleting* non-sentinel lines, so we must delete @verbatim sentinels!
                # We must **extend** the limit to get the next line.
                if reader.index() < limit + 1:
                    # Skip the next line, whatever it is.
                    # Important: this **deletes** the @verbatim sentinel,
                    # so this is a exception to the rule that sentinels are preserved.
                    line = reader.get()
                else:
                    x.verbatim_error()
            else:
                # g.trace('put line',repr(line))
                writer.put(line,tag='copy sent %s:%s' % (start,limit))
#@-node:ekr.20080708094444.37:x.copy_sentinels
#@+node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
       New at 2010/01/07: Replacements preserve sentinel locations.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    trace = False and not g.unitTesting
    verbose = True
    x = self ; 
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    delim1,delim2 = marker.getDelims()
    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,
        new_private_lines_wtr,
        marker,
        limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = self.sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = self.sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = self.sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = self.sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace('tag',tag,'old_i',old_i,'limit',limit)

if tag == 'equal':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (
            tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag == 'insert':
    if limit < old_private_lines_rdr.size():
        self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index() # Only used for tag.
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag == 'replace':
    # 2010/01/07: This case is new: it was the same as the 'insert' case.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        old_line = old_private_lines_rdr.get()
        if marker.isSentinel(old_line):
            # Important: this should work for @verbatim sentinels
            # because the next line will also be replaced.
            new_private_lines_wtr.put(old_line,tag='%s %s:%s' % (
                'replace: copy sentinel',start,new_j))
        else:
            new_line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(new_line,tag='%s %s:%s' % (
                'replace: new line',start,new_j))

elif tag=='delete':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # Leave new_public_lines_rdr unchanged.

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
#@+node:ekr.20080708094444.36:x.propagate_changes
def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    trace = False and not g.unitTesting
    x = self ; at = self.c.atFileCommands
    at.errors = 0

    old_public_lines  = open(old_public_file).readlines()
    old_private_lines = open(old_private_file).readlines()
    marker = x.markerFromFileLines(old_private_lines,old_private_file)

    if trace:
        g.trace(
            'marker',marker,
            '\npublic_file',old_public_file,
            '\npublic lines...\n%s' %(
                g.listToString(old_public_lines,toRepr=True)),
            '\nprivate_file',old_private_file,
            '\nprivate lines...\n%s\n' %(
                g.listToString(old_private_lines,toRepr=True)))

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,old_private_lines,marker)

    # Important bug fix: Never create the private file here!
    fn = old_private_file
    copy = os.path.exists(fn) and new_private_lines != old_private_lines

    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        ok = x.replaceFileWithString(fn,s)
        # g.trace('ok',ok,'writing private file',fn)

    return copy
#@-node:ekr.20080708094444.36:x.propagate_changes
#@+node:ekr.20080708094444.34:x.strip_sentinels_with_map
def strip_sentinels_with_map (self, lines, marker):

    '''Strip sentinels from lines, a list of lines with sentinels.

    Return (results,mapping)

    'lines':     A list of lines containing sentinels.
    'results':   The list of non-sentinel lines.
    'mapping':   A list mapping each line in results to the original list.
                results[i] comes from line mapping[i] of the original lines.'''

    x = self
    mapping = [] ; results = [] ; i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                i += 1
                if i < n:
                    # Not a sentinel, whatever it looks like.
                    line = lines[i]
                    # g.trace('not a sentinel',repr(line))
                    results.append(line)
                    mapping.append(i)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
            mapping.append(i)
        i += 1

    mapping.append(len(lines)) # To terminate loops.
    return results, mapping 
#@-node:ekr.20080708094444.34:x.strip_sentinels_with_map
#@+node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    x = self ; trace = False

    if trace and not g.app.unitTesting:
        g.trace('significant',x.isSignificantPublicFile(fn),fn)

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    # else:
        # Don't write *anything*.
        # if 0: # This causes considerable problems.
            # # Create the public file from the private shadow file.
            # x.copy_file_removing_sentinels(shadow_fn,fn)
            # x.message("created public %s from private %s " % (fn, shadow_fn))
#@-node:bwmulder.20041231170726:x.updatePublicAndPrivateFiles
#@-node:ekr.20080708192807.1:x.Propagation
#@+node:ekr.20080708094444.89:x.Utils...
#@+node:ekr.20080708094444.85:x.error & message & verbatim_error
def error (self,s,silent=False):

    x = self

    if not silent:
        g.es_print(s,color='red')

    # For unit testing.
    x.last_error = s
    x.errors += 1

def message (self,s):

    g.es_print(s,color='orange')

def verbatim_error(self):

    x = self

    x.error('file syntax error: nothing follows verbatim sentinel')
    g.trace(g.callers())
#@-node:ekr.20080708094444.85:x.error & message & verbatim_error
#@+node:ekr.20090529125512.6122:x.markerFromFileLines & helper & test
def markerFromFileLines (self,lines,fn):  # fn used only for traces.

    '''Return the sentinel delimiter comment to be used for filename.'''

    trace = False and not g.unitTesting
    x = self ; at = x.c.atFileCommands

    s = x.findLeoLine(lines)
    ok,junk,start,end,junk = at.parseLeoSentinel(s)
    if end:
        delims = '',start,end
    else:
        delims = start,'',''

    if trace: g.trace('delim1 %s delim2 %s delim3 %s fn %s' % (
        delims[0],delims[1],delims[2], fn))

    marker = x.markerClass(delims)
    return marker
#@+node:ekr.20090529125512.6125:x.findLeoLine & test
def findLeoLine (self,lines):

    '''Return the @+leo line, or ''.'''

    for line in lines:
        i = line.find('@+leo')
        if i != -1:
            return line
    else:
        return ''
#@+node:ekr.20090529125512.6126:@test x.findAtLeoLine
if g.unitTesting:

    c,p = g.getTestVars()
    x = c.shadowController
    table = (
        ('c',('//@+leo','a'),                   '//@+leo'),
        ('c',('//@first','//@+leo','b'),        '//@+leo'),
        ('c',('/*@+leo*/','a'),                 '/*@+leo*/'),
        ('c',('/*@first*/','/*@+leo*/','b'),    '/*@+leo*/'),
        ('python',('#@+leo','a'),               '#@+leo'),
        ('python',('#@first','#@+leo','b'),     '#@+leo'),
        ('error',('',),''),
        ('html',('<!--@+leo-->','a'),                '<!--@+leo-->'),
        ('html',('<!--@first-->','<!--@+leo-->','b'),'<!--@+leo-->'),
    )
    for language,lines,expected in table:
        result = x.findLeoLine(lines)
        assert expected==result, 'language %s expected %s got %s lines %s' % (
            language,expected,result,'\n'.join(lines))
#@nonl
#@-node:ekr.20090529125512.6126:@test x.findAtLeoLine
#@-node:ekr.20090529125512.6125:x.findLeoLine & test
#@+node:ekr.20090529125512.6128:@test x.markerFromFileLines
if g.unitTesting:

    c,p = g.getTestVars()
    x = c.shadowController
    # Add -ver=4 so at.parseLeoSentinel does not complain.
    table = (
        ('c',('//@+leo-ver=4','a'),                   '//',''),
        ('c',('//@first','//@+leo-ver=4','b'),        '//',''),
        ('c',('/*@+leo-ver=4*/','a'),                 '/*','*/'),
        ('c',('/*@first*/','/*@+leo-ver=4*/','b'),    '/*','*/'),
        ('python',('#@+leo-ver=4','a'),               '#',''),
        ('python',('#@first','#@+leo-ver=4','b'),     '#',''),
        ('error',('',),             '#--unknown-language--',''),
        ('html',('<!--@+leo-ver=4-->','a'),                '<!--','-->'),
        ('html',('<!--@first-->','<!--@+leo-ver=4-->','b'),'<!--','-->'),
    )

    for language,lines,delim1,delim2 in table:
        s = x.findLeoLine(lines)
        marker = x.markerFromFileLines(lines,'test-file-name')
        result1,result2 = marker.getDelims()
        assert delim1==result1, 'language %s expected1 %s got %s lines %s' % (
            language,delim1,result1,'\n'.join(lines))
        assert delim2==result2, 'language %s expected2 %s got %s lines %s' % (
            language,delim1,result1,'\n'.join(lines))
#@nonl
#@-node:ekr.20090529125512.6128:@test x.markerFromFileLines
#@-node:ekr.20090529125512.6122:x.markerFromFileLines & helper & test
#@+node:ekr.20080708094444.9:x.markerFromFileName
def markerFromFileName (self,filename):

    '''Return the sentinel delimiter comment to be used for filename.'''

    x = self
    if not filename: return None
    root,ext = g.os_path_splitext(filename)
    if ext=='.tmp':
        root, ext = os.path.splitext(root)

    delims = g.comment_delims_from_extension(filename)
    marker = self.markerClass(delims)
    return marker
#@+node:ekr.20090529061522.6613:@test x.markerFromFileName
if g.unitTesting:

    c,p = g.getTestVars()

    x = c.shadowController

    table = (
        ('ini',';','',),
        ('c','//',''),
        ('h','//',''),
        ('py','#',''),
        ('xyzzy','#--unknown-language--',''),
    )

    for ext,delim1,delim2 in table:
        filename = 'x.%s' % ext
        marker = x.markerFromFileName(filename)
        result1,result2 = marker.getDelims()
        assert delim1==result1, 'ext=%s, got %s, expected %s' % (
            ext,delim1,result1)
        assert delim2==result2, 'ext=%s, got %s, expected %s' % (
            ext,delim2,result2)
#@nonl
#@-node:ekr.20090529061522.6613:@test x.markerFromFileName
#@-node:ekr.20080708094444.9:x.markerFromFileName
#@+node:ekr.20080708094444.30:x.push_filter_mapping
def push_filter_mapping (self,lines, marker):
    """
    Given the lines of a file, filter out all
    Leo sentinels, and return a mapping:

      stripped file -> original file

    Filtering should be the same as
    separate_sentinels
    """

    x = self ; mapping = [None]

    i = 0 ; n = len(lines)
    while i < n:
        line = lines[i]
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                i += 1
                if i < n:
                    mapping.append(i+1)
                else:
                    x.verbatim_error()
        else:
            mapping.append(i+1)
        i += 1

    return mapping 
#@-node:ekr.20080708094444.30:x.push_filter_mapping
#@+node:ekr.20080708094444.29:x.separate_sentinels
def separate_sentinels (self, lines, marker):

    '''
    Separates regular lines from sentinel lines.

    Returns (regular_lines, sentinel_lines)
    '''

    x = self ; regular_lines = [] ; sentinel_lines = []

    i = 0 ; n = len(lines)
    while i < len(lines):
        line = lines[i]
        if marker.isSentinel(line):
            sentinel_lines.append(line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    regular_lines.append(line)
                else:
                    x.verbatim_error()
        else:
            regular_lines.append(line)
        i += 1

    return regular_lines, sentinel_lines 
#@-node:ekr.20080708094444.29:x.separate_sentinels
#@+node:ekr.20080708094444.33:x.show_error
def show_error (self, lines1, lines2, message, lines1_message, lines2_message):

    x = self
    banner1 = '=' * 30
    banner2 = '-' * 30
    g.es_print('%s\n%s\n%s\n%s\n%s' % (
        banner1,message,banner1,lines1_message,banner2))

    x.show_error_lines(lines1,'shadow_errors.tmp1')

    g.es_print('\n%s\n%s\n%s' % (
        banner1,lines2_message,banner1))

    x.show_error_lines(lines2,'shadow_errors.tmp2')

    g.es_print('\n@shadow did not pick up the external changes correctly')

    # g.es_print('Please check shadow.tmp1 and shadow.tmp2 for differences')
#@+node:ekr.20080822065427.4:show_error_lines
def show_error_lines (self,lines,fileName):

    for line in lines:
        g.es_print(line)

    if False: # Only for major debugging.
        try:
            f1 = open(fileName, "w")
            for line in lines:
                f1.write(g.toEncodedString(line,encoding='utf-8'))
            f1.close()
        except IOError:
            g.es_exception()
            g.es_print('can not open',fileName)
#@-node:ekr.20080822065427.4:show_error_lines
#@-node:ekr.20080708094444.33:x.show_error
#@-node:ekr.20080708094444.89:x.Utils...
#@+node:ekr.20080709062932.2:atShadowTestCase
class atShadowTestCase (unittest.TestCase):

    '''Support @shadow-test nodes.

    These nodes should have two descendant nodes: 'before' and 'after'.

    '''

    @others

#@+node:ekr.20080709062932.6:__init__
def __init__ (self,c,p,shadowController,lax,trace=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.lax = lax
    self.p = p.copy()
    self.shadowController=shadowController

    # Hard value for now.
    delims = '#','',''
    self.marker = shadowController.markerClass(delims)

    # For teardown...
    self.ok = True

    # Debugging
    self.trace = trace
#@-node:ekr.20080709062932.6:__init__
#@+node:ekr.20080709062932.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20080709062932.7: fail
#@+node:ekr.20080709062932.8:setUp & helpers
def setUp (self):

    c = self.c ; p = self.p ; x = self.shadowController

    old = self.findNode (c,p,'old')
    new = self.findNode (c,p,'new')

    self.old_private_lines = self.makePrivateLines(old)
    self.new_private_lines = self.makePrivateLines(new)

    self.old_public_lines = self.makePublicLines(self.old_private_lines)
    self.new_public_lines = self.makePublicLines(self.new_private_lines)

    # We must change node:new to node:old
    self.expected_private_lines = self.mungePrivateLines(self.new_private_lines,'node:new','node:old')

#@+node:ekr.20080709062932.19:findNode
def findNode(self,c,p,headline):
    p = g.findNodeInTree(c,p,headline)
    if not p:
        g.es_print('can not find',headline)
        assert False
    return p
#@nonl
#@-node:ekr.20080709062932.19:findNode
#@+node:ekr.20080709062932.20:createSentinelNode
def createSentinelNode (self,root,p):

    '''Write p's tree to a string, as if to a file.'''

    h = p.h
    p2 = root.insertAsLastChild()
    p2.setHeadString(h + '-sentinels')
    return p2

#@-node:ekr.20080709062932.20:createSentinelNode
#@+node:ekr.20080709062932.21:makePrivateLines
def makePrivateLines (self,p):

    c = self.c ; at = c.atFileCommands

    at.write (p,
        nosentinels = False,
        thinFile = False,  # Debatable.
        scriptWrite = True,
        toString = True)

    s = at.stringOutput
    return g.splitLines(s)
#@-node:ekr.20080709062932.21:makePrivateLines
#@+node:ekr.20080709062932.22:makePublicLines
def makePublicLines (self,lines):

    x = self.shadowController

    lines,mapping = x.strip_sentinels_with_map(lines,self.marker)

    return lines
#@-node:ekr.20080709062932.22:makePublicLines
#@+node:ekr.20080709062932.23:mungePrivateLines
def mungePrivateLines (self,lines,find,replace):

    x = self.shadowController ; marker = self.marker

    i = 0 ; n = len(lines) ; results = []
    while i < n:
        line = lines[i]
        if marker.isSentinel(line):
            new_line = line.replace(find,replace)
            results.append(new_line)
            if marker.isVerbatimSentinel(line):
                i += 1
                if i < len(lines):
                    line = lines[i]
                    results.append(line)
                else:
                    x.verbatim_error()
        else:
            results.append(line)
        i += 1

    return results
#@-node:ekr.20080709062932.23:mungePrivateLines
#@-node:ekr.20080709062932.8:setUp & helpers
#@+node:ekr.20080709062932.9:tearDown
def tearDown (self):

    pass

    # No change is made to the outline.
    # self.c.redraw()
#@-node:ekr.20080709062932.9:tearDown
#@+node:ekr.20080709062932.10:runTest (atShadowTestCase)
def runTest (self,define_g = True):

    x = self.shadowController

    results = x.propagate_changed_lines(
        self.new_public_lines,
        self.old_private_lines,
        marker = self.marker,
        p = self.p.copy())

    if not self.lax and results != self.expected_private_lines:

        g.pr('%s atShadowTestCase.runTest:failure' % ('*' * 40))
        for aList,tag in ((results,'results'),(self.expected_private_lines,'expected_private_lines')):
            g.pr('%s...' % tag)
            for i, line in enumerate(aList):
                g.pr('%3s %s' % (i,repr(line)))
            g.pr('-' * 40)

        assert results == self.expected_private_lines

    assert self.ok
    return self.ok
#@nonl
#@-node:ekr.20080709062932.10:runTest (atShadowTestCase)
#@+node:ekr.20080709062932.11:shortDescription
def shortDescription (self):

    return self.p and self.p.h or '@test-shadow: no self.p'
#@-node:ekr.20080709062932.11:shortDescription
#@-node:ekr.20080709062932.2:atShadowTestCase
#@+node:ekr.20090529061522.5727:class marker & tests
class markerClass:

    '''A class representing comment delims in @shadow files.'''

    @others

#@+node:ekr.20090529061522.6257:markerClass.ctor & repr
def __init__(self,delims):

    delim1,delim2,delim3 = delims
    self.delim1 = delim1 # Single-line comment delim.
    self.delim2 = delim2 # Block comment starting delim.
    self.delim3 = delim3 # Block comment ending delim.
    if not delim1 and not delim2:
        self.delim1 = g.app.language_delims_dict.get('unknown_language')

def __repr__ (self):

    if self.delim1:
        delims = self.delim1
    else:
        delims = '%s %s' % (self.delim2,self.delim2)

    return '<markerClass: delims: %s>' % repr(delims)
#@-node:ekr.20090529061522.6257:markerClass.ctor & repr
#@+node:ekr.20090529061522.6258:getDelims
def getDelims(self):

    if self.delim1:
        return self.delim1,''
    else:
        return self.delim2,self.delim3
#@+node:ekr.20090529061522.6235:@test class markerClass.getDelims
if g.unitTesting:
    c,p = g.getTestVars()
    x = c.shadowController
    table = (
        ('python','#',''),
        ('c','//',''),
        ('html','<!--','-->'),
        ('xxxx','#--unknown-language--',''),
    )
    for language,delim1,delim2 in table:
        delims = g.set_delims_from_language(language)
        marker = x.markerClass(delims)
        result = marker.getDelims()
        expected = delim1,delim2
        assert result==expected,'language %s expected %s got %s' % (
            language,expected,result)
#@nonl
#@-node:ekr.20090529061522.6235:@test class markerClass.getDelims
#@-node:ekr.20090529061522.6258:getDelims
#@+node:ekr.20090529061522.6259:isSentinel & test
def isSentinel(self,s,suffix=''):
    '''Return True is line s contains a valid sentinel comment.'''

    s = s.strip()
    if self.delim1 and s.startswith(self.delim1):
        return s.startswith(self.delim1+'@'+suffix)
    elif self.delim2:
        return s.startswith(self.delim2+'@'+suffix) and s.endswith(self.delim3)
    else:
        return False
#@+node:ekr.20090529061522.5728:@test class markerClass.isSentinel
if g.unitTesting:
    c,p = g.getTestVars()
    x = c.shadowController
    table = (
        ('python','abc',False),
        ('python','#abc',False),
        ('python','#@abc',True),
        ('python','@abc#',False),
        ('c','abc',False),
        ('c','//@',True),
        ('c','// @abc',False),
        ('c','/*@ abc */',True),
        ('c','/*@ abc',False),
        ('html','#@abc',False),
        ('html','<!--abc-->',False),
        ('html','<!--@ abc -->',True),
        ('html','<!--@ abc ->',False),
        ('xxxx','#--unknown-language--@',True)
    )
    for language,s,expected in table:
        delims = g.set_delims_from_language(language)
        marker = x.markerClass(delims)
        result = marker.isSentinel(s)
        assert result==expected,'language %s s: %s expected %s got %s' % (
            language,s,expected,result)
#@nonl
#@-node:ekr.20090529061522.5728:@test class markerClass.isSentinel
#@-node:ekr.20090529061522.6259:isSentinel & test
#@+node:ekr.20090529061522.6260:isVerbatimSentinel & test
def isVerbatimSentinel(self,s):

    return self.isSentinel(s,suffix='verbatim')
#@nonl
#@+node:ekr.20090529061522.6215:@test class markerClass.isVerbatimSentinel
if g.unitTesting:
    c,p = g.getTestVars()
    x = c.shadowController
    table = (
        ('python','abc',False),
        ('python','#abc',False),
        ('python','#verbatim',False),
        ('python','#@verbatim',True),
        ('c','abc',False),
        ('c','//@',False),
        ('c','//@verbatim',True),
        ('html','#@abc',False),
        ('html','<!--abc-->',False),
        ('html','<!--@verbatim -->',True),
        ('xxxx','#--unknown-language--@verbatim',True)
    )
    for language,s,expected in table:
        delims = g.set_delims_from_language(language)
        marker = x.markerClass(delims)
        result = marker.isVerbatimSentinel(s)
        assert result==expected,'language %s s: %s expected %s got %s' % (
            language,s,expected,result)
#@nonl
#@-node:ekr.20090529061522.6215:@test class markerClass.isVerbatimSentinel
#@-node:ekr.20090529061522.6260:isVerbatimSentinel & test
#@-node:ekr.20090529061522.5727:class marker & tests
#@+node:ekr.20080708094444.12:class sourcereader
class sourcereader:
    """
    A class to read lines sequentially.

    The class keeps an internal index, so that each
    call to get returns the next line.

    Index returns the internal index, and sync
    advances the index to the the desired line.

    The index is the *next* line to be returned.

    The line numbering starts from 0.
    """
    @others
#@+node:ekr.20080708094444.13:__init__
def __init__ (self,shadowController,lines):

    self.lines = lines 
    self.length = len(self.lines)
    self.i = 0
    self.shadowController=shadowController
#@nonl
#@-node:ekr.20080708094444.13:__init__
#@+node:ekr.20080708094444.14:index
def index (self):
    return self.i
#@-node:ekr.20080708094444.14:index
#@+node:ekr.20080708094444.15:get
def get (self):

    trace = False and not g.unitTesting

    result = self.lines[self.i]
    self.i+=1

    if trace: g.trace(repr(result))
    return result 
#@-node:ekr.20080708094444.15:get
#@+node:ekr.20080708094444.16:sync
def sync (self,i):
    self.i = i 
#@-node:ekr.20080708094444.16:sync
#@+node:ekr.20080708094444.17:size
def size (self):
    return self.length 
#@-node:ekr.20080708094444.17:size
#@+node:ekr.20080708094444.18:atEnd
def atEnd (self):
    return self.index>=self.length 
#@-node:ekr.20080708094444.18:atEnd
#@+node:ekr.20080708094444.19:clone
def clone(self):
    sr = self.shadowController.sourcereader(shadowController,self.lines)
    sr.i = self.i
    return sr
#@nonl
#@-node:ekr.20080708094444.19:clone
#@+node:ekr.20080708094444.20:dump
def dump(self, title):

    g.pr(title)
    # g.pr('self.i',self.i)
    for i, line in enumerate(self.lines):
        marker = g.choose(i==self.i,'**','  ')
        g.pr("%s %3s:%s" % (marker, i, repr(line)),)
#@nonl
#@-node:ekr.20080708094444.20:dump
#@-node:ekr.20080708094444.12:class sourcereader
#@+node:ekr.20080708094444.21:class sourcewriter
class sourcewriter:
    """
    Convenience class to capture output to a file.

    Similar to class sourcereader.
    """
	@others
#@+node:ekr.20080708094444.22:__init__
def __init__ (self,shadowController):

    self.i = 0
    self.lines =[]
    self.shadowController=shadowController
    self.trace = False or self.shadowController.trace_writers
#@-node:ekr.20080708094444.22:__init__
#@+node:ekr.20080708094444.23:put
def put(self, line, tag=''):

    trace = (False or self.trace) and not g.unitTesting

    # An important hack.  Make sure *all* lines end with a newline.
    # This will cause a mismatch later in check_the_final_output,
    # and a special case has been inserted to forgive this newline.
    if not line.endswith('\n'):
        if trace: g.trace('adding newline',repr(line))
        line = line + '\n'

    self.lines.append(line)
    self.i+=1

    if trace: g.trace('%30s %s' % (tag,repr(line)))
#@-node:ekr.20080708094444.23:put
#@+node:ekr.20080708094444.24:index
def index (self):

    return self.i 
#@-node:ekr.20080708094444.24:index
#@+node:ekr.20080708094444.25:getlines
def getlines (self):

    return self.lines 
#@-node:ekr.20080708094444.25:getlines
#@+node:ekr.20080708094444.26:dump
def dump(self, title):

    '''Dump lines for debugging.'''

    g.pr(title)
    for i, line in enumerate(self.lines):
        marker = '  '
        g.es("%s %3s:%s" % (marker, i, line),newline=False)
#@-node:ekr.20080708094444.26:dump
#@-node:ekr.20080708094444.21:class sourcewriter
#@-node:ekr.20080708094444.80:class shadowController
#@+node:ekr.20080708094444.23:put
def put(self, line, tag=''):

    trace = (False or self.trace) and not g.unitTesting

    # An important hack.  Make sure *all* lines end with a newline.
    # This will cause a mismatch later in check_the_final_output,
    # and a special case has been inserted to forgive this newline.
    if not line.endswith('\n'):
        if trace: g.trace('adding newline',repr(line))
        line = line + '\n'

    self.lines.append(line)
    self.i+=1

    if trace: g.trace('%30s %s' % (tag,repr(line)))
#@-node:ekr.20080708094444.23:put
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root.h,fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    if at.errors == 0: # 2010/01/07
        self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20080708094444.36:x.propagate_changes
def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    trace = False and not g.unitTesting
    x = self ; at = self.c.atFileCommands
    at.errors = 0

    old_public_lines  = open(old_public_file).readlines()
    old_private_lines = open(old_private_file).readlines()
    marker = x.markerFromFileLines(old_private_lines,old_private_file)

    if trace:
        g.trace(
            'marker',marker,
            '\npublic_file',old_public_file,
            '\npublic lines...\n%s' %(
                g.listToString(old_public_lines,toRepr=True)),
            '\nprivate_file',old_private_file,
            '\nprivate lines...\n%s\n' %(
                g.listToString(old_private_lines,toRepr=True)))

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,old_private_lines,marker)

    # Important bug fix: Never create the private file here!
    fn = old_private_file
    copy = os.path.exists(fn) and new_private_lines != old_private_lines

    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        ok = x.replaceFileWithString(fn,s)
        # g.trace('ok',ok,'writing private file',fn)

    return copy
#@-node:ekr.20080708094444.36:x.propagate_changes
#@+node:ekr.20080708094444.37:x.copy_sentinels
def copy_sentinels(self,reader,writer,marker,limit):

    '''Copy sentinels from reader to writer while reader.index() < limit.'''

    x = self
    start = reader.index()
    while reader.index() < limit:
        line = reader.get()
        if marker.isSentinel(line):
            if marker.isVerbatimSentinel(line):
                # We are *deleting* non-sentinel lines, so we must delete @verbatim sentinels!
                # We must **extend** the limit to get the next line.
                if reader.index() < limit + 1:
                    # Skip the next line, whatever it is.
                    # Important: this **deletes** the @verbatim sentinel,
                    # so this is a exception to the rule that sentinels are preserved.
                    line = reader.get()
                else:
                    x.verbatim_error()
            else:
                # g.trace('put line',repr(line))
                writer.put(line,tag='copy sent %s:%s' % (start,limit))
#@-node:ekr.20080708094444.37:x.copy_sentinels
#@+node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
       New at 2010/01/07: Replacements preserve sentinel locations.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    trace = False and not g.unitTesting
    verbose = True
    x = self ; 
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    delim1,delim2 = marker.getDelims()
    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,
        new_private_lines_wtr,
        marker,
        limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = self.sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = self.sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = self.sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = self.sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace('tag',tag,'old_i',old_i,'limit',limit)

if tag == 'equal':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (
            tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag == 'insert':
    if limit < old_private_lines_rdr.size():
        self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index() # Only used for tag.
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag == 'replace':
    # 2010/01/07: This case is new: it was the same as the 'insert' case.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        old_line = old_private_lines_rdr.get()
        if marker.isSentinel(old_line):
            # Important: this should work for @verbatim sentinels
            # because the next line will also be replaced.
            new_private_lines_wtr.put(old_line,tag='%s %s:%s' % (
                'replace: copy sentinel',start,new_j))
        else:
            new_line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(new_line,tag='%s %s:%s' % (
                'replace: new line',start,new_j))

elif tag=='delete':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # Leave new_public_lines_rdr unchanged.

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines (the main loop)
#@-node:ekr.20100107051445.6193:Fixed at-shadow error
#@+node:ekr.20100101094915.8720:Fixed bug 408886: qttabs gui doesn't mark commanders dirty properly
@nocolor-node

EKR: This applies to --gui=qttabs

Leo's window title should start with a '*' when any node is marked dirty.

Ville: I've fixed the more serious problem of not being prompted when closing
tabs on trunk. The other problem, not having * in titles (these should be in tab
titles too btw) is not fixed yet.

Checking log for rev 2615:

The present code marks the tabs as expected, but there something weird is going
on that prevents the window's title from changing when gui==qttabs. To work
around this, the present code always shows the tab name.
#@nonl
#@+node:ekr.20091007103358.6061:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('-f', '--file',   dest="fileName")
    parser.add_option('--gui',          dest="gui",help = 'gui to use (qt/tk/qttabs)')
    #parser.add_option('--help',         action="store_true",dest="help_option")
    parser.add_option('--ipython',      action="store_true",dest="use_ipython")
    parser.add_option('--no-cache',     action="store_true",dest='no_cache')
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")
    parser.add_option('--version',      action="store_true",dest="version")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --no-cache
    if options.no_cache:
        g.trace('disabling caching')
        g.enableDB = False

    # -f or --file
    fileName = options.fileName

    # --gui
    gui = options.gui
    g.app.qt_use_tabs = False
    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = 'qt'
            g.app.qt_use_tabs = True

        if gui not in ('tk','qt','wx'):
            g.trace('unknown gui: %s' % gui)
            gui = None

    # --ipython
    g.app.useIpython = options.use_ipython

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                if trace: print("scan_options: script: %s" % script_name)
                f = open(script_name,'r')
                script = f.read()
            except IOError:
                print("can not open script file: %s" % script_name)
                script = None
        finally:
            if f: f.close()
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # Compute the return values.
    windowFlag = script and script_path_w
    if trace:
        print('scanOptions: fileName',fileName)
        print('scanOptions: argv',sys.argv)
    return fileName,gui,script,versionFlag,windowFlag
#@-node:ekr.20091007103358.6061:scanOptions
#@+node:ekr.20031218072017.2989:c.setChanged
def setChanged (self,changedFlag):

    trace = False and not g.unitTesting
    c = self
    if not c.frame: return
    c.changed = changedFlag
    if c.loading: return # don't update while loading.

    if trace: g.trace('Commands',changedFlag) # ,c.frame,g.callers(4))

    # Clear all dirty bits _before_ setting the caption.
    # Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        # g.trace("clearing all dirty bits")
        for p in c.all_unique_positions():
            if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
                p.clearDirty()

    if g.app.qt_use_tabs and hasattr(c.frame,'top'):
        c.frame.top.master.setChanged(c,changedFlag)

    s = c.frame.getTitle()
    if len(s) > 2:
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@-node:ekr.20031218072017.2989:c.setChanged
#@-node:ekr.20100101094915.8720:Fixed bug 408886: qttabs gui doesn't mark commanders dirty properly
#@+node:ekr.20100101172153.6252:Fixed bug 476653: @nowrap isn't working for qt / @edit nodes
# The fix was in qtGui.py
#@-node:ekr.20100101172153.6252:Fixed bug 476653: @nowrap isn't working for qt / @edit nodes
#@+node:ekr.20100101094915.6248:Fixed bug 480422: string-rectangle kills syntax highlighting
#@+node:ekr.20050920084036.232:stringRectangle
def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

#@-node:ekr.20050920084036.232:stringRectangle
#@-node:ekr.20100101094915.6248:Fixed bug 480422: string-rectangle kills syntax highlighting
#@+node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20050211120242.2:g.removeExtraLws & test
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
#@+node:ekr.20090517020744.5881:@test g.removeExtraLws
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20090517020744.5881:@test g.removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & test
#@+node:ekr.20051014175117:g.adjustTripleString
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    trace = True and not g.unitTesting
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20090901175503.6098:@test g.adjustTripleString
if g.unitTesting:

    c,p = g.getTestVars()

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


#@-node:ekr.20090901175503.6098:@test g.adjustTripleString
#@-node:ekr.20051014175117:g.adjustTripleString
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@-node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20100102171721.6271:Fixed bug in writeNodeToString
# Leo now adds a leading period if needed.
#@nonl
#@+node:ekr.20090502071837.67:writeNodeToString (New in 4.4.1)
def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
#@nonl
#@-node:ekr.20090502071837.67:writeNodeToString (New in 4.4.1)
#@+node:ekr.20090502071837.63:processTree
def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.topLevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                    if not self.ext.startswith('.'):
                        self.ext = '.'+self.ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                # g.trace('ext',self.ext,self.outputFileName)
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst nodes in selected tree',color='blue')
    return None,None
#@-node:ekr.20090502071837.63:processTree
#@+node:ekr.20090502071837.64:writeSpecialTree
def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = output is not None
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('<title></title>')
            if idxTitle > -1:
                m = re.search('<h1>([^<]*)</h1>', output)
                if not m:
                    m = re.search('<h1><[^>]+>([^<]*)</a></h1>', output)
                if m:
                    output = output.replace(
                        '<title></title>',
                        '<title>%s</title>' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
#@-node:ekr.20090502071837.64:writeSpecialTree
#@-node:ekr.20100102171721.6271:Fixed bug in writeNodeToString
#@+node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        # Note: @asis always writes all nodes,
        # so there can be no orphan or ignored nodes.
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            # openFileForWriting calls root.setDirty() if there are errors.
            return
        for p in root.self_and_subtree():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    except Exception:
        at.writeException(root) # Sets dirty and orphan bits.

silentWrite = asisWrite # Compatibility with old scripts.
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.h

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.b

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v._bodyString)

    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20091007105735.6462:Fixed bug: @nosent should warn about orphan nodes
#@+node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@-node:ekr.20091103082258.6084:Fixed bug: Sometimes 'redefining shortcut' message is backwards
#@+node:ekr.20091003171114.6465:Fixed contractOrGoRight
@nocolor-node

The culprit was the sparse_goto_parent option.
It never worked properly, and it caused the expansion
state of nodes as seen by Leo to get out-of-synch
with the expansion state as seen by the qt tree code.

To exercise the bug, do the following in test.leo:

- Expand the "prototypes" node.
- Expand any child node.
- Move beyond the now-expanded child node.
- Hit Alt-Left.  This will select the prototype node.
  The expanded child node will be marked by Leo as being contracted,
  but it *wont* be contracted actually, which confuses moveToVisNext.
#@nonl
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    # g.trace(p.h)
    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    # g.trace(p.parent())

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    trace = False and not g.unitTesting
    c = self ; p = c.p
    redraw = False ; fullRedraw = False
    if p.hasChildren() and p.isExpanded():
        if trace: g.trace('contract',p.h)
        c.contractNode()
        redraw = True # New in one-node world.
    elif p.hasParent() and p.parent().isVisible(c):
        redraw = False
        p.contract() # Make sure we know this node is contracted.
        # This "feature" is dubious.
        # To work properly, it requires a full redraw.
        if False: # self.sparse_goto_parent:
            for child in p.self_and_siblings():
                if child != p and child.isExpanded():
                    child.contract()
                    redraw = True ; fullRedraw = True
        if trace: g.trace('goto parent',p.h)
        c.goToParent()

    if redraw:
        if fullRedraw or p.isCloned():
            if trace: g.trace('full redraw',p.h)
            c.redraw()
        else:
            c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    trace = False and not g.unitTesting
    c = self ; p = c.p

    # New code.
    if p.hasChildren():
        if p.isExpanded():
            p.moveToFirstChild()
            if trace: g.trace('select',p.h)
            c.selectPosition(p)
        else:
            if trace: g.trace('expand',p.h)
            c.expandNode() # Calls redraw_after_expand.
    elif p.hasNext():
        c.goToNextSibling()
    else:
        while p.hasParent():
            p.moveToParent()
            if p.hasNext():
                p.moveToNext()
                break
        c.selectPosition(p)
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.p

    p.contract()

    if p.isCloned():
        c.redraw() # A full redraw is necessary to handle clones.
    else:
        c.redraw_after_contract(p=p,setFocus=True)
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    trace = False and not g.unitTesting
    c = self ; p = c.p

    p.expand()

    if p.isCloned():
        if trace: g.trace('***redraw')
        c.redraw() # Bug fix: 2009/10/03.
    else:
        c.redraw_after_expand(p,setFocus=True)

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    trace = False and not g.unitTesting
    verbose = True
    p = self ; limit,limitIsVisible = c.visLimit()
    if trace and verbose:
        g.trace(p,'limit',limit,'limitIsVisible',limitIsVisible)
    if trace: g.trace('***entry','parent',p.parent(),'p',p,g.callers(5))
    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))

        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent() # Same as p.moveToThreadBack()
        # if back and (not back.hasChildren() or not back.isExpanded()):
            # p.moveToBack()
        # else:
            # p.moveToThreadBack()
        if trace: g.trace(p.parent(),p)
        if p:
            if trace and verbose: g.trace('**p',p)
            done,val = self.checkVisBackLimit(limit,limitIsVisible,p)
            if done:
                if trace and verbose: g.trace('done',p)
                return val
            if p.isVisible(c):
                if trace and verbose: g.trace('isVisible',p)
                return p
    else:
        # assert not p.
        return p
#@+node:ekr.20090715145956.6166:checkVisBackLimit
def checkVisBackLimit (self,limit,limitIsVisible,p):

    '''Return done, return-val'''

    trace = True and not g.unitTesting
    c = p.v.context

    if limit:
        if limit == p:
            if trace: g.trace('at limit',p)
            if limitIsVisible and p.isVisible(c):
                return True,p
            else:
                return True,None
            #return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree',limit,p)
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6166:checkVisBackLimit
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    trace = False and not g.unitTesting
    verbose = False
    p = self ; limit,limitIsVisible = c.visLimit()
    while p:
        if trace: g.trace('1',p.h)
        # if trace: g.trace('hasChildren %s, isExpanded %s %s' % (
            # p.hasChildren(),p.isExpanded(),p.h))
        # Short-circuit if possible.
        if p.hasNext() and p.hasChildren() and p.isExpanded():
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if trace: g.trace('2',p.h)
        if p:
            done,val = self.checkVisNextLimit(limit,p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        return p
#@+node:ekr.20090715145956.6167:checkVisNextLimit
def checkVisNextLimit (self,limit,p):

    '''Return done, return-val'''

    trace = False and not g.unitTesting

    if limit:
        # Unlike moveToVisBack, being at the limit does not terminate.
        if limit == p:
            return False, None
        elif limit.isAncestorOf(p):
            return False,None
        else:
            if trace: g.trace('outside limit tree')
            return True,None
    else:
        return False,None
#@-node:ekr.20090715145956.6167:checkVisNextLimit
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@-node:ekr.20091003171114.6465:Fixed contractOrGoRight
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20091109103928.6372:Notes
@nocolor

This bug happens only on Linux.
#@nonl
#@-node:ekr.20091109103928.6372:Notes
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090930103947.6085:Fixed elisp bug
> Here is the fix:
> 'startsFunction' in 'elispScanner' should use
>    j = self.skipId(s,i)
> instead of
>    j = g.skip_id(s,i)
> skip_id doesn't take extraIdChars ('-' in elisp case) into
> consideration. 
#@nonl
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@-node:ekr.20090930103947.6085:Fixed elisp bug
#@+node:ekr.20091228143718.6222:Fixed new at-auto-import bug
@nocolor-node

- There was a blunder in isSafeWrite: it must return *True* for trial writes.

- Protected against index errors in reportMismatch and simplified the code.
#@nonl
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@nonl
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    if not underlines1: underlines1 = '=+*^~"\'`-:><_'
        # The standard defaults.
    self.atAutoWriteUnderlines = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@+node:ekr.20090702084917.6033:@test initAtAutoWrite
if g.unitTesting:

    c,p = g.getTestVars()

    rst = c.rstCommands
    rst.initAtAutoWrite(p,fileName='<test file>',outputFile=None)

    # Ensure we are actually testing the default logic.
    d = p.v.u.get('rst-import',{})
    underlines = d.get('underline_characters')
    assert underlines is None,underlines
    assert d == {},d
    # Now test the logic.
    assert rst.underlines2 == '#',rst.underlines2
    assert rst.underlines1 == '=+*^~"\'`-:><_',rst.underlines1
    assert rst.atAutoWriteUnderlines == '#=+*^~"\'`-:><_',\
        rst.atAutoWriteUnderlines
#@-node:ekr.20090702084917.6033:@test initAtAutoWrite
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i < n: line = repr(lines[i])
            else: line = '<eof>'
            aList.append('%4d %s' % (i,line))
    g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20090517020744.5785:@test reportMismatch
if g.unitTesting:

    import leo.core.leoImport as leoImport
    c,p = g.getTestVars()

    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    scanner.root = p
    s1 = ["abc",]
    s2 = ["xyz",]

    scanner.reportMismatch(s1,s2,1)

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?
#@-node:ekr.20090517020744.5785:@test reportMismatch
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20091228143718.6222:Fixed new at-auto-import bug
#@+node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
# The parsing in writeToDocutils had to be rewritten.
#@nonl
#@+node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    trace = True and not g.unitTesting
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
#@+node:ekr.20090502071837.66:handleMissingStyleSheetArgs
def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 < cm < eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm+1:].strip()
        else: # key = val
            key = s[:eq].strip()
            s = s[eq+1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[:rb+1]
                s = s[rb+1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm+1:].strip()

        # g.trace('key',repr(key),'val',repr(val),'s',repr(s))
        if not key: break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)

    return d
#@nonl
#@-node:ekr.20090502071837.66:handleMissingStyleSheetArgs
#@-node:ekr.20090502071837.65:writeToDocutils (sets argv) & helper
#@-node:ekr.20091201125021.6067:Fixed publish-argv-for-missing-stylesheets
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@+node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20041113113140:loadOnePlugin & test
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20090522161156.5886:@test class StubConfig
if g.unitTesting:

    c,p = g.getTestVars()

    class StubConfig(g.nullObject):
        pass

    x = StubConfig()
    assert not x.getBool(c,'mySetting')
    assert not x.enabledPluginsFileName
#@-node:ekr.20090522161156.5886:@test class StubConfig
#@-node:ekr.20041113113140:loadOnePlugin & test
#@-node:ekr.20090907140408.6123:Fixed startup reversion when .leoID.txt does not exist
#@+node:ekr.20091228133644.6221:Handle Insert key properly
# This is now bound in the EKR bindings to insert-node.

g.es(c.k.ignore_unbound_non_ascii_keys)
#@nonl
#@+node:ekr.20061031131434.182:isPlainKey
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
#@-node:ekr.20061031131434.182:isPlainKey
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@+node:ekr.20070123143428:k.defineTkNames
def defineTkNames (self):

    k = self

    # These names are used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        'BackSpace','Begin','Break',
        'Caps_Lock','Clear',
        'Delete','Down',
        'End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'Home',
        'Left','Linefeed',
        'Next','Num_Lock',
        'Prior',
        'Return','Right',
        'Tab',
        'Up',
        # 'space',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace',
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s


@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.
Note: the Tk documentation states that not all of these may be available on all platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
#@-node:ekr.20070123143428:k.defineTkNames
#@-node:ekr.20091228133644.6221:Handle Insert key properly
#@+node:ekr.20090822060128.6035:Improved the install docs
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476

From Matt Wilkie

I've installed Leo several times on windows, yet this morning still
took me a few minutes to find the section you reference above because
there are at least two other document sections with phrases similar to
"installing leo". Anyway, this is my simplified recipe for a virgin
install:

-------------------------
Installing Leo On Windows
-------------------------
//skip any step not needed//

1. Install Python - There are many sources, but from
http://www.python.org/download/releases/ is good

2. Install PyQt - acquire and run Binary Package from
http://www.riverbankcomputing.co.uk/software/pyqt/download which
matches installed Python version (so for python 2.5 scan for the
"Py2.5" in filename)

3. Install Leo
   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
   - Unpack python *site-packages* folder, e.g.
C:\Python25\Lib\site-packages\leo-4-6-2-final

   - [optional] Generate/update a junction link from unpacked
leo-4-6-2-final to ...\site-packages\leo

      cd C:\Python25\Lib\site-packages\
      junction leo leo-4-6-2-final

   - Create windows shortcut (edit paths as necessary):

      Target   =  C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt
      Start in =  D:\code

   - Associate .leo filetype batch file:

      ftype LeoFile=C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
      assoc .leo=LeoFile

   - [optional] Put this leo.bat in %PATH%:

      @C:\Python25\python.exe -i
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt %*

-------------------------

Further reading / Sources used:

   Junction links -
http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
   FTYPE - http://ss64.com/nt/ftype.html
   ASSOC - http://ss64.com/nt/assoc.html


=====================
Ville's comments

On Thu, Aug 20, 2009 at 10:49 PM, Matt Wilkie<map...@gmail.com> wrote:
> 3. Install Leo
>   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
>   - Unpack python *site-packages* folder, e.g.
> C:\Python25\Lib\site-packages\leo-4-6-2-final

I don't think you need to use site-packages. Just extract it anywhere
you want (e.g. c:/opt/leo). But I could be wrong.

>   - Associate .leo filetype batch file:
>n
>      ftype LeoFile=C:\Python25\pythonw.exe
> "C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
>      assoc .leo=LeoFile

--gui=qt us not needed anymore. 
#@nonl
#@-node:ekr.20090822060128.6035:Improved the install docs
#@+node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
@language python

ab
#@nonl
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('no text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.p
    d = c.scanAllDirectives(p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('no text selected',color='blue')
        return

    if d1:
        # Remove the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in range(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es('',"'%s'" % (d2),"not found",color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es('',"'%s'" % (d3),"not found",color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        done,b = k.doPlainKey(event,stroke,w)
        if b: k.masterCommand(event,b.func,b.stroke,b.commandName)
        if done: return 'break'

    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20091230094319.6244:doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return True,'break'
#@-node:ekr.20091230094319.6244:doMode
#@+node:ekr.20091230094319.6242:doPlainKey
def doPlainKey (self,event,stroke,w):

    '''Handle a plain key.  Return done,b.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # Important: only keys bound somewhere have a stroke.
    # All unbound plain keys will be handled by handleUnboundKeys.
    if k.unboundKeyAction in ('insert','overwrite'):
        for key in (k.unboundKeyAction,'body','log','text','all'):
            # Ignore bindings for all plain keys in insert/overwrite mode
            # *except* auto-complete.
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    if trace: g.trace('%s: auto-complete key in %s mode' % (
                        stroke,k.unboundKeyAction))
                    return True,b

        if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
        return True,g.bunch(func=None,stroke=stroke,commandName=None)

    # Ignore all command-state keys if we are not in a text widget.
    elif k.unboundKeyAction == 'command':
        if g.app.gui.isTextWidget(w):
            return False,None
        else:
            c.onCanvasKey(event)
            return True,None
    else:
        return False,None
#@-node:ekr.20091230094319.6242:doPlainKey
#@+node:ekr.20091230094319.6240:getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    k = self ; w_name = k.c.widget_name(w)
    keyStatesTuple = ('command','insert','overwrite')

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace:
                g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
#@-node:ekr.20091230094319.6240:getPaneBinding
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: g.trace(pane,shortcut,commandName)
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,
            g.choose(pane=='button',z,commandName),
            g.choose(pane=='button',commandName,z),
            pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return

    trace = False
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        # Bug fix: 2009/09/30: use canonical stroke.
        accelerator = k.shortcutFromSetting(accel,addKey=False) or ''
        stroke = k.shortcutFromSetting(accel,addKey=True) or ''
        if accelerator:
            accelerator = g.stripBrackets(k.prettyPrintKey(accelerator))
        if trace: # and commandName == 'add-comments':
            g.trace(bunch.val,repr(stroke),repr(accelerator),commandName)
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            # if trace: g.trace('stroke',stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@-node:ekr.20090930151626.6086:Made add-comments and delete-comments commands work with shortcuts
#@+node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root.h,fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    if at.errors == 0: # 2010/01/07
        self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p.h,fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_read = True # Create the attribute

    # Disable caching for test.leo.
    if c.shortFileName() != 'test.leo':
        if cachefile is not None and cachefile in c.db:        
            # g.es('uncache:',p.h)
            aList = c.db[cachefile]
            p.v.createOutlineFromCacheList(c,aList)
            return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty()

    if trace: g.trace("position",dirtyVnodeList,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.isDirty():
        p.v.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20031218072017.3390:v.clearDirty
def clearDirty (self):
    v = self
    v.statusBits &= ~ v.dirtyBit

#@-node:ekr.20031218072017.3390:v.clearDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    newNodes = [v]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    if trace: g.trace(nodes)
    return nodes
#@nonl
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print (v.isDirty(),v.isAnyAtFileNode(),v)

    dirtyVnodeList = [v for v in nodes
        if not v.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.setDirty() # Do not call v.setDirty here!

    if trace: g.trace("vnode",dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty
#@+node:ekr.20080429053831.12:v.setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20080429053831.12:v.setDirty
#@-node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self,c,aList):
    """ Create outline structure from recursive aList
    built by p.makeCacheList.

    Clones will be automatically created by gnx,
    but *not* for the top-level node.
    """

    parent_v = self

    #import pprint ; pprint.pprint(tree)
    parent_v = self
    h,b,gnx,children = aList
    if h is not None:
        v = parent_v
        v._headString = h    
        v._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = parent_v.fastAddLastChild(c,gnx)
        if isClone:
            if child_v.b != b: # or child_v.h
                # Bug fix: the last seen clone rules.
                child_v.h = h
                child_v.b = b
                # Bug fix: mark @<file> nodes dirty.
                child_v.setAllAncestorAtFileNodesDirty()
                child_v.setMarked()
                g.es("changed:",child_v.h,color="blue")
        else:
            child_v.createOutlineFromCacheList(c,z)
#@+node:ekr.20090829064400.6042:v.fastAddLastChild
# Similar to createThinChild4
def fastAddLastChild(self,c,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    parent_v = self
    indices = g.app.nodeIndices
    gnxDict = c.fileCommands.gnxDict

    if gnxString is None: v = None
    else:                 v = gnxDict.get(gnxString)
    is_clone = v is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'v',repr(v))

    if not is_clone:
        v = vnode(context=c)
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            v.fileIndex = gnx
        gnxDict[gnxString] = v

    child_v = v
    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())
    child_v.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
#@-node:ekr.20090829064400.6042:v.fastAddLastChild
#@-node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
#@-node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20100101150822.8719:parse_leo_file now always calls cleanSaxInputString
# Form-feed characters were causing problems with Python 3k.
#@nonl
#@+node:ekr.20100103110349.6274:Error message
reading: /home/edreamleo/leo.repo/trunk/leo/test/test.leo
error parsing /home/edreamleo/leo.repo/trunk/leo/test/test.leo
Traceback (most recent call last):
  File "/usr/lib/python3.1/xml/sax/expatreader.py", line 207, in feed
    self._parser.Parse(data, isFinal)
xml.parsers.expat.ExpatError: not well-formed (invalid token): line 4736, column 0

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/trunk/leo/core/leoFileCommands.py", line 1463, in parse_leo_file
    parser.parse(theFile) # expat does not support parseString
  File "/usr/lib/python3.1/xml/sax/expatreader.py", line 107, in parse
    xmlreader.IncrementalParser.parse(self, source)
  File "/usr/lib/python3.1/xml/sax/xmlreader.py", line 123, in parse
    self.feed(buffer)
  File "/usr/lib/python3.1/xml/sax/expatreader.py", line 211, in feed
    self._err_handler.fatalError(exc)
  File "/usr/lib/python3.1/xml/sax/handler.py", line 38, in fatalError
    raise exception
xml.sax._exceptions.SAXParseException: /home/edreamleo/leo.repo/trunk/leo/test/test.leo:4736:0: not well-formed (invalid token)
#@nonl
#@-node:ekr.20100103110349.6274:Error message
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@-node:ekr.20100101150822.8719:parse_leo_file now always calls cleanSaxInputString
#@+node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217190731.6075:Recover from bad chars in .leo files
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20100107064059.6199:Set read bit when writing @auto/@shadow files
@nocolor-node

Leo warns about "externally changed" file after writing the file for the first time.

The solution was to change the at_auto_read ivar to the at_read ivar.
#@nonl
#@-node:ekr.20100107064059.6199:Set read bit when writing @auto/@shadow files
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20100109094541.6218:Use w.leoMoveCursorHeler if it exists
@nocolor-node

This should fix the following two bugs:

- 421957 When body_pane_wraps is set to true, Previous-Line and Next-Line do not
work as expected.

- 489917 Cursor placement defect 
#@nonl
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j < i and s[j].isspace():
        j += 1

    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20090530181848.6035:movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20090530181848.6035:movePageHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20100109094541.6227:moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@-node:ekr.20100109094541.6227:moveToBufferHelper
#@+node:ekr.20100109094541.6228:moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6228:moveToCharacterHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20100109094541.6231:moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6231:moveWithinLineHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.p

    i,row,col = w.toPythonIndexRowCol(spot)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v

    # g.trace('moveSpot',i)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20081123102100.1:backToHome
def backToHome (self,event):

    '''Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins == 0 or not(s): return

    # Toggle back and forth between start of line and first-non-blank character.
    i,j = g.getLine(s,ins)
    i1 = i
    while i < j and s[i] in (' \t'):
        i += 1
    if i == ins:
        i = i1

    self.moveToHelper(event,i,extend=False)
#@-node:ekr.20081123102100.1:backToHome
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20051218141237:between lines
def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:between lines
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'left',extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    self.moveToCharacterHelper(event,'left',extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'right',extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    self.moveToCharacterHelper(event,'right',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('extend mode',g.choose(val,'on','off'),color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event,direction='forward'):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if direction == 'forward':
        while i < n and not g.isWordChar(s[i]):
            i += 1
    else:
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1

    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1
    i1 = i

    # Move to the end of the word.
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20090530181848.6034:pages
def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
#@-node:ekr.20090530181848.6034:pages
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20100109094541.6232:within lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
#@-node:ekr.20100109094541.6232:within lines
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20100109094541.6230:not changed
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@-node:ekr.20051218122116:moveToHelper
#@-node:ekr.20100109094541.6230:not changed
#@+node:ekr.20100109094541.6229:changed
#@+node:ekr.20051218141237:between lines
def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:between lines
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'left',extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    self.moveToCharacterHelper(event,'left',extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'right',extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    self.moveToCharacterHelper(event,'right',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20090530181848.6035:movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20090530181848.6035:movePageHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20090530181848.6034:pages
def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
#@-node:ekr.20090530181848.6034:pages
#@+node:ekr.20100109094541.6232:within lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
#@-node:ekr.20100109094541.6232:within lines
#@-node:ekr.20100109094541.6229:changed
#@+node:ekr.20100109094541.6234:new
#@+node:ekr.20100109094541.6228:moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6228:moveToCharacterHelper
#@+node:ekr.20100109094541.6231:moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6231:moveWithinLineHelper
#@+node:ekr.20100109094541.6227:moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@-node:ekr.20100109094541.6227:moveToBufferHelper
#@-node:ekr.20100109094541.6234:new
#@-node:ekr.20100109094541.6218:Use w.leoMoveCursorHeler if it exists
#@+node:ekr.20090714085914.5992:Fixed bug 452303 @auto-rst can be dangerous
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b84659e608ba44d5

The data is lost because @auto-rst mostly ignores the top-level node.

This was fixed 2009/12/29.  See bug 452303 @auto-rst can be dangerous:
https://bugs.launchpad.net/leo-editor/+bug/452303
#@nonl
#@-node:ekr.20090714085914.5992:Fixed bug 452303 @auto-rst can be dangerous
#@+node:ekr.20100110064516.11600:Finished cursor work
@nocolor-node

- Added support for 'exchange-point-and-mark' to leoMoveCursorHelper (both Tk and Qt).

- the core moveToHelper usually works properly when extend==False. Leo's core
  needs to call leoMoveCursorHelper only when it can *not* properly compute the
  selection range.
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j < i and s[j].isspace():
        j += 1

    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20090530181848.6035:movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20090530181848.6035:movePageHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20100109094541.6227:moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@-node:ekr.20100109094541.6227:moveToBufferHelper
#@+node:ekr.20100109094541.6228:moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6228:moveToCharacterHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=direction,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toGuiIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20100109094541.6231:moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@-node:ekr.20100109094541.6231:moveWithinLineHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.p

    i,row,col = w.toPythonIndexRowCol(spot)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v

    # g.trace('moveSpot',i)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20081123102100.1:backToHome
def backToHome (self,event):

    '''Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins == 0 or not(s): return

    # Toggle back and forth between start of line and first-non-blank character.
    i,j = g.getLine(s,ins)
    i1 = i
    while i < j and s[i] in (' \t'):
        i += 1
    if i == ins:
        i = i1

    self.moveToHelper(event,i,extend=False)
#@-node:ekr.20081123102100.1:backToHome
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20051218141237:between lines
def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:between lines
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'left',extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    self.moveToCharacterHelper(event,'left',extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'right',extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    self.moveToCharacterHelper(event,'right',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('extend mode',g.choose(val,'on','off'),color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return

        ins = w.getInsertPoint()
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event,direction='forward'):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if direction == 'forward':
        while i < n and not g.isWordChar(s[i]):
            i += 1
    else:
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1

    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1
    i1 = i

    # Move to the end of the word.
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20090530181848.6034:pages
def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
#@-node:ekr.20090530181848.6034:pages
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20100109094541.6232:within lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
#@-node:ekr.20100109094541.6232:within lines
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@-node:ekr.20100110064516.11600:Finished cursor work
#@+node:ekr.20090907080624.6077:Fixed underlining problem in rst
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/cdf78cbca5c526be

@auto-rst will product underline marks just as long as the section title.

When I use Japanese in the section title, it will product many warnings claiming
the the underlines is not long enough, because the underline for one Japanese
char need two marks.

=====

Perhaps we should use the length of the *encoded* string, rather than the unicode string.
#@nonl
#@+node:ekr.20090502071837.93:underline (leoRst)
def underline (self,s,p):

    '''Return the underlining string to be used at the given level for string s.
    This includes the headline, and possibly a leading overlining line.
    '''

    trace = False and not g.unitTesting

    if trace: g.trace(self.atAutoWrite,repr(self.underlines2),p.h)

    if self.atAutoWrite:
        # We *might* generate overlines for top-level sections.
        u = self.atAutoWriteUnderlines
        level = p.level()-self.topLevel

        # This is tricky. The index n depends on several factors.
        if self.underlines2:
            level -= 1 # There *is* a double-underlined section.
            n = level
        else:
            n = level-1
        if 0 <= n < len(u): ch = u[n]
        elif u:
            ch = u[-1]
        else:
            g.trace('can not happen: no u')
            ch = '#'

        # 2010/01/10: write longer underlines for non-ascii characters.
        # n = max(4,len(s))
        n = max(4,len(g.toEncodedString(s,encoding='utf-8',reportErrors=False)))
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        if level == 0 and self.underlines2:
            return '%s\n%s\n%s\n\n' % (ch*n,p.h,ch*n)
        else:
            return '%s\n%s\n\n' % (p.h,ch*n)
    else:
        # The user is responsible for top-level overlining.
        u = self.getOption('underline_characters') #  '''#=+*^~"'`-:><_'''
        level = max(0,p.level()-self.topLevel)
        level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
        ch = u [level]
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        # 2010/01/10: write longer underlines for non-ascii characters.
        # n = max(4,len(s))
        n = max(4,len(g.toEncodedString(s,encoding='utf-8',reportErrors=False)))
        return '%s\n%s\n\n' % (p.h.strip(),ch*n)
#@-node:ekr.20090502071837.93:underline (leoRst)
#@-node:ekr.20090907080624.6077:Fixed underlining problem in rst
#@+node:ekr.20100106170105.8657:Fixed qt key problems
@nocolor-node

Shift-PageUp/Down are not working.
#@nonl
#@+node:ekr.20061031131434.3:<< about key dicts >>
@nocolor
@

ivars:

c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
#@-node:ekr.20061031131434.3:<< about key dicts >>
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:bobjack.20080509080123.2:c.universalCallback
def universalCallback(self, function):

    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """
    def minibufferCallback(event, function=function):

        # Avoid a pylint complaint.
        if hasattr(self,'theContextMenuController'):
            cm = getattr(self,'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None

        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}

        keywords['mb_event'] = event     

        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
    return minibufferCallback

#fix bobjacks spelling error
universallCallback = universalCallback
#@-node:bobjack.20080509080123.2:c.universalCallback
#@+node:ekr.20100108071826.6194:Design notes about key handling
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/d11b4333e0583b7b

Part 1: letting Qt help

At present, the Qt gui code knows only whether a keystroke is bound
somewhere. However, a relatively minor refactoring of (the helpers of)
k.masterKeyHandler should allow the Qt event filter to determine
whether a binding actually exists for the keystroke *in the current
pane*.

This information would allow eventFilter to pass all "actually"
unbound keys on to the gui.  In particular, this would allow Leo to
bind arrow keys in the outline pane, while *unbinding* arrow keys in
the body pane.  This would be the easy way to fix several nasty cursor
bugs.

As I write this, I see that this scheme requires the Qt gui to support
the event_generate function at least for Qt Key events.  This is
necessary to implement the next-line, prev-line and similar commands.
In other words, if Leo isn't going to do these commands itself, there
must be a way to pass on a request for these commands to Qt events.

So the first step is to make g.app.gui.event_generate work at least
for keystrokes representing arrow keys.  Note that most of Leo knows
only the *Tk* names for these keystrokes, so the Qt gui will likely
have to translate the Tk to the Qt name.  This should be doable, given
the variety of translation tables that exist.

Part 2: A clean divide between key binding and key handling.

A few days ago I realized that there is a (mostly) clean separation
between two parts of the key-handling code:

1. The *binding* translates the Tk-named bindings into various tables
used by k.masterKeyHandler and its helpers. This part is horrendous,
but it probably will never have to change.

2. The *lookup* part associates bindings with commands. This is what
k.masterKeyHandler really does.

This Aha means that we don't have to worry much, if at all, about the
complications in the binding part.  Although k.masterKeyHandler is
complex, the recent and contemplated refactorings are localized, and
they are not, in fact, all that difficult in concept.  This is
important, because future enhancements for vim will be to the lookup
part, not the binding part.

Part 3: Simplifying repeat counts

I recently spent some time on the universal-arg code.  This is
inspired by Emacs, but it seems preposterously complex to me.
Instead, it seems more natural to allow (some) commands to be prefixed
by a repeat count, as in vim:

5 next-line or
5 j or
5 <down-arrow>

This is conceptually much cleaner than the universal arg code.
Moreover, the obvious place to handle numeric prefixes is in
k.getArg.  This method could set a global repeat count and call
commands repeatedly if necessary.  It probably would be wise to have a
table of commands for which a repeat count makes sense, but that's a
nit.
#@-node:ekr.20100108071826.6194:Design notes about key handling
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        done,b = k.doPlainKey(event,stroke,w)
        if b: k.masterCommand(event,b.func,b.stroke,b.commandName)
        if done: return 'break'

    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20091230094319.6244:doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return True,'break'
#@-node:ekr.20091230094319.6244:doMode
#@+node:ekr.20091230094319.6242:doPlainKey
def doPlainKey (self,event,stroke,w):

    '''Handle a plain key.  Return done,b.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    # Important: only keys bound somewhere have a stroke.
    # All unbound plain keys will be handled by handleUnboundKeys.
    if k.unboundKeyAction in ('insert','overwrite'):
        for key in (k.unboundKeyAction,'body','log','text','all'):
            # Ignore bindings for all plain keys in insert/overwrite mode
            # *except* auto-complete.
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    if trace: g.trace('%s: auto-complete key in %s mode' % (
                        stroke,k.unboundKeyAction))
                    return True,b

        if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
        return True,g.bunch(func=None,stroke=stroke,commandName=None)

    # Ignore all command-state keys if we are not in a text widget.
    elif k.unboundKeyAction == 'command':
        if g.app.gui.isTextWidget(w):
            return False,None
        else:
            c.onCanvasKey(event)
            return True,None
    else:
        return False,None
#@-node:ekr.20091230094319.6242:doPlainKey
#@+node:ekr.20091230094319.6240:getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    k = self ; w_name = k.c.widget_name(w)
    keyStatesTuple = ('command','insert','overwrite')

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace:
                g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
#@-node:ekr.20091230094319.6240:getPaneBinding
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.103:k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    # if stroke.lower()=='ctrl+v':
        # g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),'w',repr(w),'\n',g.callers())

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@-node:ekr.20061031131434.103:k.makeMasterGuiBinding
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = False
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20090213065933.14:doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@-node:ekr.20090213065933.14:doPlainTab
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@-node:ekr.20100106170105.8657:Fixed qt key problems
#@+node:ekr.20100111094359.6205:Fixed bug: 381895 qtGui Split ratio is not saved in .leo file
@nocolor-node

http://bugs.launchpad.net/leo-editor/+bug/381895

What I did:

- Added splitter-moved event handlers to qt gui.
- putGlobals now writes both splitter ratios.
- startGlobals now reads both splitter ratios.
#@+node:ekr.20100111142347.6219:Changes
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.db and c.mFileName

    if use_db:
        key = c.atFileCommands._contentHashFile(c.mFileName,'globals')
        if trace: g.trace(len(list(c.db.keys())),c.mFileName,key)
        << put all data to c.db >>

    # Always put postions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20100112095623.6267:<< put all data to c.db >>
c.db['body_outline_ratio_%s' % key] = str(c.frame.ratio)
c.db['body_secondary_ratio_%s' % key] = str(c.frame.secondary_ratio)

if trace: g.trace('ratios: %1.2f %1.2f' % (
    c.frame.ratio,c.frame.secondary_ratio))

width,height,left,top = c.frame.get_window_info()

c.db['window_position_%s' % key] = (
    str(top),str(left),str(height),str(width))

if trace: g.trace('top',top,'left',left,'height',height,'width',width)
#@-node:ekr.20100112095623.6267:<< put all data to c.db >>
#@+node:ekr.20031218072017.3038:<< put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratios >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if self.inClipboard:
        return

    c.frame.ratio,c.frame.secondary_ratio = 0.5,0.5 # Set defaults.

    if trace: g.trace(len(list(c.db.keys())),c.mFileName)

    if g.enableDB and c.db and c.mFileName:
        key = c.atFileCommands._contentHashFile(c.mFileName,'globals')
        c.frame.ratio = float(c.db.get(
            'body_outline_ratio_%s' % (key),'0.5'))
        c.frame.secondary_ratio = float(c.db.get(
            'body_secondary_ratio_%s' % (key),'0.5'))
        if trace: g.trace('key',key,
            '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
    else:
        try:
            for bunch in self.attrsToList(attrs):
                name = bunch.name ; val = bunch.val
                if name == 'body_outline_ratio':
                    c.frame.ratio = float(val) # 2010/01/11
                elif name == 'body_secondary_ratio':
                    c.frame.secondary_ratio = float(val) # 2010/01/11
            if trace: g.trace('** no c.db:','%1.2f %1.2f' % (
                c.frame.ratio,c.frame.secondary_ratio))
        except Exception:
            pass
#@-node:ekr.20060919110638.37:startGlobals
#@-node:ekr.20100111142347.6219:Changes
#@-node:ekr.20100111094359.6205:Fixed bug: 381895 qtGui Split ratio is not saved in .leo file
#@+node:ekr.20100110064516.6228:Applied patches to fix bug: 451377 Make Leo frienly to mac apps
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/451377

The following is from Marc-Antoine Parent:

QQQ
I tried my hand at bundling Leo into a double-clickable application. I saw that
someone else tried their hands at a py2app executable in the TkInter days; I
thought I'd do it with the PyQt exectutable. It is still not a smooth process;
PyQt wrapping is not fully functional yet. But I have achieved a functional
executable on my machine; I thought I would share the process with you, and
hopefully I'll be able to automate more as time goes on. I also had to make a
few modifications to the leo source, which I suggest you incorporate.

First the diffs:

Beyond the earlier suggestion about "open" directories, [EKR: see post-script]
leo has to find data files in a py2app executable. Py2App creates a zip file
with the .pyc files, so computeLoadDir() finds that the __file__ does not
correspond to a directory, uses the cwd(), and that ends up a bit lower than we
would want.

I append leo/plugins in the code below instead of leo/core because the latter
does not exist in the data dirs. The other adjustment is more subtle, and has to
do with finding PyQt interface elements. My modified code works both in py2app
and through a normal launchLeo.py. I found confirmation that this is also
relevant in py2exe here:

http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg15893.html

=== modified file 'leo/core/leoGlobals.py'
--- leo/core/leoGlobals.py 2009-09-08 20:30:50 +0000
+++ leo/core/leoGlobals.py 2009-09-18 15:07:50 +0000
@@ -281,7 +281,11 @@
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
- g.pr("Exception getting load directory")
+ if loadDir.endswith("Contents/Resources"):
+ loadDir += "/leo/plugins"
+ print loadDir
+ else:
+ g.pr("Exception getting load directory")
        loadDir = g.os_path_finalize(loadDir,encoding=encoding)
        # g.es("load dir:",loadDir,color="blue")
        return loadDir
@@ -4233,6 +4237,14 @@
 def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
+ elif sys.platform == 'darwin':
+ try:
+ import subprocess
+ subprocess.call(['open', fname])
+ except OSError:
+ pass # There may be a spurious Interrupted system call
+ except ImportError:
+ os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open ' + fname)
#@verbatim
 #@-node:ekr.20090829140232.6036:os_startfile

=== modified file 'leo/plugins/ScrolledMessage.ui'
--- leo/plugins/ScrolledMessage.ui 2008-12-07 11:35:49 +0000
+++ leo/plugins/ScrolledMessage.ui 2009-09-19 12:34:00 +0000
@@ -266,7 +266,7 @@
  <customwidget>
   <class>QWebView</class>
   <extends>QWidget</extends>
- <header>QtWebKit/QWebView</header>
+ <header>PyQt4.QtWebKit</header>
  </customwidget>
 </customwidgets>
 <resources/>

Those modifications done, I have created a py2app-specific setup file. It should
be possible to combine this with the main setup file, but I have not yet
attempted to do so. Note that I had to special-case the plugin directory; I
decided to exclude TkInter to reduce executable size, but that invalidates some
legacy functionality (notably the python window.) Finally, there are adjustments
to the resulting executable, as py2app does not yet handle Qt plugins properly,
and a few similar issues. Talking to the py2app people to that effect; right now
I included a shell script that does the necessary adjustments "by hand". Again,
this is a first effort, I do not suggest inclusion of this (except the diffs) in
the source until I clean it up seriously. Ah, and I converted the Win icons to
mac icons. This was done mechanically, somebody with a better drawing hand
should make them look mac-like. QQQ

P.S. Again, from Marc-Antoine:

QQQ
Saw this in trunk docs:

      If you rclick on @thin / whatever item, you should see "open
      /home/ville/foo" (or equivalent) menu entry. It open up the file manager on
      that folder (using xdg-open on linux, os.startfile on windows). I have no
      idea what to do with mac, now it runs xdg-open and probably fails.

the current accepted way to do this involves the "open" CLI command.

Discussion here:
http://www.mail-archive.com/pythonmac-sig@python.org/msg06709.html

Now, I checked, and the subprocess threw an error. Not sure why.

Traceback (most recent call last):
 File "/Users/maparent/OpenSource/leo-editor/leo/plugins/contextmenu.py", line 118, in openfolder_rclick_cb
  g.os_startfile(path)
 File "/Users/maparent/OpenSource/leo-editor/leo/core/leoGlobals.py", line 4238, in os_startfile
  subprocess.call(['open', fname])
 File "/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/subprocess.py", line 444, in call
  return Popen(*popenargs, **kwargs).wait()
 File "/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/subprocess.py", line 1123, in wait
  pid, sts = os.waitpid(self.pid, 0)
OSError: [Errno 4] Interrupted system call

So here is what worked for me:

  elif sys.platform == 'darwin':
       try:
          import subprocess
          subprocess.call(['open', fname])
      except OSError:
          pass # There may be a spurious "Interrupted system call"
       except ImportError:
               os.system("open '%s'" % (fname,))
QQQ
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leo.core.leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        << resolve symlinks >>
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_finalize(path,encoding=encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            # From Marc-Antoine Parent.
            if loadDir.endswith("Contents/Resources"):
                loadDir += "/leo/plugins"
            else:
                g.pr("Exception getting load directory")
        loadDir = g.os_path_finalize(loadDir,encoding=encoding)
        # g.es("load dir:",loadDir,color="blue")
        return loadDir
    except:
        g.pr("Exception getting load directory")
        raise
#@+node:ville.20090703102253.6160:<< resolve symlinks >>
if path.endswith('pyc'):
    srcfile = path[:-1]
    if os.path.islink(srcfile):
        path = os.path.realpath(srcfile)    
#@-node:ville.20090703102253.6160:<< resolve symlinks >>
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20090829140232.6036:os_startfile
def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open ' + fname)
#@nonl
#@-node:ekr.20090829140232.6036:os_startfile
#@-node:ekr.20100110064516.6228:Applied patches to fix bug: 451377 Make Leo frienly to mac apps
#@+node:ekr.20100111094359.6207:Fixed bug: 394445 Chapters selection button: in qt, missing, in Tk, only one option
The Tk part of this bug can not be fixed.
#@nonl
#@-node:ekr.20100111094359.6207:Fixed bug: 394445 Chapters selection button: in qt, missing, in Tk, only one option
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20091219151045.6361:Simplified g.create_temp_file
# We can do this now that we require Python 2.5+
#@nonl
#@+node:ekr.20031218072017.3117:g.create_temp_file & test
def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''

    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
    except Exception:
        g.es('unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
#@+node:ekr.20090517020744.5873:@test g.create_temp_file
if g.unitTesting:

    c,p = g.getTestVars()

    theFile,fn = g.create_temp_file()
    assert theFile
    assert g.isString(fn)
#@-node:ekr.20090517020744.5873:@test g.create_temp_file
#@-node:ekr.20031218072017.3117:g.create_temp_file & test
#@-node:ekr.20091219151045.6361:Simplified g.create_temp_file
#@+node:ekr.20091001141621.6042:iters -> generators & code cleanup
@nocolor-node
@

What I did:

- Removed t from leoGui.leo.
- Removed t from scripts.leo.
- Renamed xTnodeY to xVnodeY in a few places.
- Removed putDescendantTnodeUas: it was redundant.
- Revised scripting chapter.

Will not do:

- Remove t from leoPlugins.leo.
  This could cause problems that I am not willing to solve.
- v.tnodeList will not change in this branch.
  This must be done in a separate branch as part of the deprecation of @file.



#@+node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6067:c.Old iterators
if not g.new_generators:

    @others
#@nonl
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
def allNodes_iter (self,copy=False):

    r = self.rootPosition()
    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p
    return r.iter_class(r, cp)

all_positions_iter = allNodes_iter
#@nonl
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
def all_tnodes_iter (self):

    return self.rootPosition().tnodes_iter()
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
def all_unique_tnodes_iter (self):

    return self.rootPosition().unique_tnodes_iter()
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
def all_vnodes_iter (self):
    return self.rootPosition().vnodes_iter()
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
def all_unique_vnodes_iter (self):

    return self.rootPosition().unique_vnodes_iter()
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@+node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
def all_positions_with_unique_tnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p)
#@-node:sps.20080317144948.3:c.all_positions_with_unique_tnodes_iter
#@+node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
def all_positions_with_unique_vnodes_iter (self):

    r = self.rootPosition()
    return r.unique_iter_class(r, lambda p: p, lambda u: u.v)
#@-node:sps.20080327174748.4:c.all_positions_with_unique_vnodes_iter
#@-node:ekr.20091001141621.6067:c.Old iterators
#@+node:ekr.20091002072933.6096:p.Old iterators
if not g.new_generators:

    @others
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:sps.20080331123552.3:p.iter
class iter_class:

    """Returns a list of mappings of positions in a subtree,
    possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    return self.iter_class(self, lambda p: p.v.t)

def vnodes_iter (self):

    return self.iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
def __init__(self,p,mapping):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None
    self.mapping = mapping

def __iter__(self):

    return self
#@-node:sps.20080331123552.1:__init__ & __iter__ (p.iter)
#@+node:sps.20080331123552.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@nonl
#@-node:sps.20080331123552.2:next
#@-node:sps.20080331123552.3:p.iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration

__next__ = next
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:sps.20080331123552.12:p.subtree_unique_iter
class subtree_unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_with_unique_tnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v.t,
        includeSelf=False)

def subtree_with_unique_vnodes_iter (self,copy=False):

    if copy:
        cp = lambda p: p.copy()
    else:
        cp = lambda p: p

    return self.subtree_unique_iter_class(self,
        cp,
        lambda p: p.v,
        includeSelf=False)
#@+node:sps.20080331123552.9:__init__ & __iter__
def __init__(self,p,mapping,unique,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.mapping = mapping
    self.unique = unique
    self.d = {}

def __iter__(self):

    return self
#@-node:sps.20080331123552.9:__init__ & __iter__
#@+node:sps.20080331123552.10:next
# moveToThreadNextUnique raises StopIteration
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    return self.mapping(self.p)

__next__ = next
#@nonl
#@-node:sps.20080331123552.10:next
#@+node:sps.20080331123552.11:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            if p == self.after:
                raise StopIteration
            while p and self.d.get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()
                if p == self.after:
                    raise StopIteration

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self.d.get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if p == self.after:
                    raise StopIteration
                if not self.d.get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self.d.get(u(p)):
            p.moveToParent()
            # if p.equal(self.after):
            if p == self.after:
                raise StopIteration
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if p == self.after:
                        raise StopIteration
                    if not self.d.get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self.d.get(u(p)):
                    p.moveToParent()
                    if p == self.after:
                        raise StopIteration
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.11:moveToThreadNextUnique
#@-node:sps.20080331123552.12:p.subtree_unique_iter
#@+node:sps.20080331123552.8:p.unique_iter
class unique_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v.t)

def unique_vnodes_iter (self):

    return self.unique_iter_class(self, lambda p: p.v)
#@+node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
def __init__(self,p,mapping,unique=lambda p: p.v.t):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None
    self.mapping = mapping
    self.unique=unique

def __iter__(self):

    return self
#@-node:sps.20080331123552.4:__init__ & __iter__ (p.unique_tnodes_iter)
#@+node:sps.20080331123552.5:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.moveToThreadNextUnique()

    if self.p:
        return self.mapping(self.p)

    raise StopIteration

__next__ = next
#@-node:sps.20080331123552.5:next
#@+node:sps.20080331123552.7:moveToThreadNextUnique
def moveToThreadNextUnique (self):

    """Move a position to threadNext position."""

    p = self.p
    u = self.unique

    self_d_get = self.d.get
    if p:
        # We've been visited
        self.d[u(p)]=True

        # First, try to find an unmarked child
        if p.v.t.children:
            p.moveToFirstChild()
            while p and self_d_get(u(p)):
                if p.hasNext():
                    p.moveToNext()
                else:
                    p.moveToParent()

        # If we didn't find an unmarked child,
        # try to find an unmarked sibling
        if p and self_d_get(u(p)):
            while p.hasNext():
                p.moveToNext()
                if not self_d_get(u(p)):
                    break

        # If we didn't find an unmarked sibling,
        # find a parent with an unmarked sibling
        if p and self_d_get(u(p)):
            p.moveToParent()
            while p:
                while p.hasNext():
                    p.moveToNext()
                    if not self_d_get(u(p)):
                        break
                # if we run out of siblings, go to parent
                if self_d_get(u(p)):
                    p.moveToParent()
                else:
                    break # found
            # At this point, either (not p.d[p.v.t]) and found
            # or (not p) and we're finished

    return p 
#@-node:sps.20080331123552.7:moveToThreadNextUnique
#@-node:sps.20080331123552.8:p.unique_iter
#@-node:ekr.20091002072933.6096:p.Old iterators
#@+node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
def newVnode(self,index):

    c = self.c

    v = leoNodes.vnode(context=c)

    if index in self.tnodesDict:
        g.es("bad tnode index:",str(index),"using empty text.")
        return v
    else:
        # Create the tnode.
        # Use the _original_ index as the key in tnodesDict.
        self.tnodesDict[index] = v

        if not g.isString(index):
            g.es("newVnode: unexpected index type:",type(index),index,color="red")

        # Convert any pre-4.1 index to a gnx.
        junk,theTime,junk = gnx = g.app.nodeIndices.scanGnx(index,0)
        if theTime != None:
            v.fileIndex = gnx

        return v
#@-node:ekr.20031218072017.2009:newVnode (fileCommands) (not used)
#@-node:ekr.20091003023754.6105:Not used
#@+node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
def all_nodes(self):
    c = self
    for p in c.all_positions():
        yield p.v
    raise StopIteration

def all_unique_nodes(self):
    c = self
    for p in c.all_unique_positions():
        yield p.v
    raise StopIteration

# Compatibility with old code.
all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
#@-node:ekr.20091001141621.6043:c.all_nodes & all_unique_nodes
#@+node:ekr.20091001141621.6062:c.all_unique_positions
def all_unique_positions(self):
    c = self
    p = c.rootPosition() # Make one copy.
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
#@nonl
#@-node:ekr.20091001141621.6062:c.all_unique_positions
#@+node:ekr.20091001141621.6044:c.all_positions
def all_positions (self):
    c = self
    p = c.rootPosition() # Make one copy.
    while p:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
all_positions_iter = all_positions
allNodes_iter = all_positions
#@-node:ekr.20091001141621.6044:c.all_positions
#@-node:ekr.20091001141621.6061:c.generators
#@+node:ekr.20091001141621.6060:p.generators
#@+node:ekr.20091001141621.6055:p.children
def children(self):

    '''Return all children of p.'''

    p = self
    p = p.firstChild()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
children_iter = children
#@-node:ekr.20091001141621.6055:p.children
#@+node:ekr.20091002083910.6102:p.following_siblings
def following_siblings(self):
    '''
    Return all siblings that follow p, not including p.
    '''

    p = self
    p = p.copy() # Always include the original node.
    p = p.next()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
following_siblings_iter = following_siblings
#@-node:ekr.20091002083910.6102:p.following_siblings
#@+node:ekr.20091002083910.6104:p.nodes
def nodes (self):

    p = self
    p = p.copy()
    while p:
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.
tnodes_iter = nodes
vnodes_iter = nodes
#@-node:ekr.20091002083910.6104:p.nodes
#@+node:ekr.20091001141621.6058:p.parents
def parents(self):

    '''Return all parents of p.'''

    p = self
    p = p.parent()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
parents_iter = parents
#@-node:ekr.20091001141621.6058:p.parents
#@+node:ekr.20091002083910.6099:p.self_and_parents
def self_and_parents(self):

    '''Return p and all parents of p.'''

    p = self
    p = p.copy()
    while p:
        yield p
        p.moveToParent()
    raise StopIteration

# Compatibility with old code.
self_and_parents_iter = self_and_parents
#@-node:ekr.20091002083910.6099:p.self_and_parents
#@+node:ekr.20091001141621.6057:p.self_and_siblings
def self_and_siblings(self):
    '''Return all siblings of p including p.
    '''

    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p
        p.moveToNext()
    raise StopIteration

# Compatibility with old code.
self_and_siblings_iter = self_and_siblings
#@nonl
#@-node:ekr.20091001141621.6057:p.self_and_siblings
#@+node:ekr.20091001141621.6066:p.self_and_subtree
def self_and_subtree(self):

    '''Return p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
self_and_subtree_iter = self_and_subtree
#@-node:ekr.20091001141621.6066:p.self_and_subtree
#@+node:ekr.20091001141621.6056:p.subtree
def subtree(self):

    '''Return all descendants of p, not including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p
        p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_iter = subtree
#@-node:ekr.20091001141621.6056:p.subtree
#@+node:ekr.20091002083910.6105:p.unique_nodes
def unique_nodes (self):

    p = self
    p = p.copy()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.v
            p.moveToThreadNext()

# Compatibility with old code.
unique_tnodes_iter = unique_nodes
unique_vnodes_iter = unique_nodes
#@-node:ekr.20091002083910.6105:p.unique_nodes
#@+node:ekr.20091002083910.6103:p.unique_subtree
def unique_subtree (self):
    '''Return unique positions in p's entire subtree, including p.'''

    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    seen = set()
    while p and p != after:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p
            p.moveToThreadNext()
    raise StopIteration

# Compatibility with old code.
subtree_with_unique_tnodes_iter = unique_subtree
subtree_with_unique_vnodes_iter = unique_subtree
#@-node:ekr.20091002083910.6103:p.unique_subtree
#@-node:ekr.20091001141621.6060:p.generators
#@+node:tbrown.20080119085249.1:setIconList & helpers
def setIconList(self, p, l):
    """Set list of icons for position p to l"""

    trace = False and not g.unitTesting

    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return

    if trace: g.trace(l)

    self._setIconListHelper(p, l, p.v)

#@+node:ekr.20090701125429.6012:_setIconListHelper
def _setIconListHelper(self, p, subl, uaLoc):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node"""

    trace = False and not g.unitTesting

    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
#@-node:ekr.20090701125429.6012:_setIconListHelper
#@-node:tbrown.20080119085249.1:setIconList & helpers
#@+node:ekr.20080805071954.1:putDescendentTnodeUas
def putDescendentTnodeUas (self,p):

    ### In the one-node world, there are no such things as independent tnodes.
    g.trace('*** ERROR: should not be called')
    return

    trace = False
    if trace: g.trace(p.h)

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = [] ; aList = []
    for p2 in p.self_and_subtree():
        v = p2.v
        if hasattr(v,"unknownAttributes"):
            if v not in tnodes :
                # g.trace(p2.h,v)
                tnodes.append(v)
                aList.append((p2.copy(),v),)

    # Create a list of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create s, an enclosing dict to hold all the inner dicts.
    d = {}
    nodeIndices = g.app.nodeIndices
    for v,d2 in aList:
        # Could be eliminated.
        # New in Leo 4.4.8.  Assign v.fileIndex here as needed.
        if not v.fileIndex:
            v.fileIndex = g.app.nodeIndices.getNewIndex()
        gnx = nodeIndices.toString(v.fileIndex)
        d[gnx]=d2

    if trace: g.trace(g.dictToString(d))

    # Pickle and hexlify d.
    return d and self.pickle(
        torv=p.v,val=d,tag="descendentTnodeUnknownAttributes") or ''
#@-node:ekr.20080805071954.1:putDescendentTnodeUas
#@-node:ekr.20091001141621.6042:iters -> generators & code cleanup
#@+node:ekr.20091211111443.6264:Batch operations on nodes
#@+node:ekr.20091211111443.6265:c.doBatchOperations & helpers
def doBatchOperations (self,aList):
    # Validate aList and create the parents dict
    ok, d = self.checkBatchOperationsList()
    if not ok:
        return g.es('do-batch-operations: invalid list argument',
            color='red')

    for v in list(d.keys()):
        aList2 = d.get(v,[])
        if aList2:
            aList.sort()
            for n,op in aList2:
                if op == 'insert':
                    g.trace('insert:',v.h,n)
                else:
                    g.trace('delete:',v.h,n)
#@+node:ekr.20091211111443.6266:checkBatchOperationsList
def checkBatchOperationsList(self,aList):
    ok = True ; d = {}
    for z in aList:
        try:
            op,p,n = z
            ok= (op in ('insert','delete') and
                isinstance(p,leoNodes.position) and
                type(n) == type(9))
            if ok:
                aList2 = d.get(p.v,[])
                data = n,op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok,d
#@nonl
#@-node:ekr.20091211111443.6266:checkBatchOperationsList
#@-node:ekr.20091211111443.6265:c.doBatchOperations & helpers
#@+node:ekr.20091210082012.6231:Comparing positions
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.h,p2 and p2.v and p2.h))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
def __ge__ (self,other):

    return self.__eq__(other) or self.__gt__(other)

def __le__ (self,other):

    return self.__eq__(other) or self.__lt__(other)

def __lt__ (self,other):

    return not self.__eq__(other) and not self.__gt__(other)
#@-node:ekr.20091210082012.6230:p.__ge__ & __le__& __lt__
#@+node:ekr.20091210082012.6233:p.__gt__
def __gt__ (self,other):

    '''Return True if self appears after other in outline order.'''

    stack1,stack2 = self.stack,other.stack
    n1,n2 = len(stack1),len(stack2) ; n = min(n1,n2)
    # Compare the common part of the stacks.
    for item1,item2 in zip(stack1,stack2):
        v1,x1 = item1 ; v2,x2 = item2
        if x1 > x2: return True
        elif x1 < x2: return False
    # Finish the comparison.
    if n1 == n2:
        x1,x2 = self._childIndex,other._childIndex
        return x1 > x2
    elif n1 < n2:
        x1 = self._childIndex; v2,x2 = other.stack[n]
        return x1 > x2
    else:
        return True
#@nonl
#@-node:ekr.20091210082012.6233:p.__gt__
#@+node:ekr.20091210082012.6232:@test p rich comparison methods
if g.unitTesting:

    c,p = g.getTestVars()

    last = None

    for p in c.all_positions():
        if last:
            assert p > last,'%s <= %s' % (p.h,last.h)
        last = p.copy()
#@nonl
#@-node:ekr.20091210082012.6232:@test p rich comparison methods
#@+node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace: g.trace('entry',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2.v == p3.v: # A match with the to-be-moved node?
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
#@nonl
#@+node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
if g.unitTesting:

    c,p = g.getTestVars()

    table = (
        '1',
        '1-1','1-1-1','1-1-2',
        '1-2','1-2-1','1-2-2',
        '2',
        '2-1','2-1-1','2-1-2',
        '2-2','2-2-1','2-2-2',
        '3',
        '3-1','3-1-1','3-1-2',
        '3-2','3-2-1','3-2-2',
    )

    for suffix in table:
        h = 'node %s' % suffix
        p2 = g.findNodeInTree(c,p,h)
        assert p2,h

    table2 = (
        ('2-1-2','2-1-1','2-1-1'),
        ('3','2','2'),
    )  

    for h1,h2,h3 in table2:
        p1 = g.findNodeInTree(c,p,'node %s' % h1)
        p2 = g.findNodeInTree(c,p,'node %s' % h2)
        p3 = g.findNodeInTree(c,p,'node %s' % h3)
        p1._adjustPositionBeforeUnlink(p2)
        result = p1
        assert result.stack == p3.stack,'expected %s got %s' % (
            p3.h,result and result.h or '<none>')

    # Data.
    @others
#@+node:ekr.20090713125326.6117:node 1
# Node 1
#@nonl
#@+node:ekr.20090713125326.6118:node 1-1
# node 1-1
#@nonl
#@+node:ekr.20090713125326.6119:node 1-1-1
# node 1-1-1
#@nonl
#@-node:ekr.20090713125326.6119:node 1-1-1
#@+node:ekr.20090713125326.6135:node 1-1-2
# node 1-1-2
#@nonl
#@-node:ekr.20090713125326.6135:node 1-1-2
#@-node:ekr.20090713125326.6118:node 1-1
#@+node:ekr.20090713125326.6133:node 1-2
# node 1-2
#@nonl
#@+node:ekr.20090713125326.6134:node 1-2-1
# node 1-2-1
#@nonl
#@-node:ekr.20090713125326.6134:node 1-2-1
#@+node:ekr.20090713125326.6136:node 1-2-2
# node 1-2-2
#@nonl
#@-node:ekr.20090713125326.6136:node 1-2-2
#@-node:ekr.20090713125326.6133:node 1-2
#@-node:ekr.20090713125326.6117:node 1
#@+node:ekr.20090713125326.6124:node 2
# node 2
#@nonl
#@+node:ekr.20090713125326.6125:node 2-1
# node 2-1
#@nonl
#@+node:ekr.20090713125326.6126:node 2-1-1
# node 2-1-1
#@nonl
#@-node:ekr.20090713125326.6126:node 2-1-1
#@+node:ekr.20090713125326.6137:node 2-1-2
# node 2-1-2
#@-node:ekr.20090713125326.6137:node 2-1-2
#@-node:ekr.20090713125326.6125:node 2-1
#@+node:ekr.20090713125326.6142:node 2-2
# node 2-2
#@nonl
#@+node:ekr.20090713125326.6143:node 2-2-1
# node 2-2-1
#@nonl
#@-node:ekr.20090713125326.6143:node 2-2-1
#@+node:ekr.20090713125326.6144:node 2-2-2
# node 2-2-2
#@-node:ekr.20090713125326.6144:node 2-2-2
#@-node:ekr.20090713125326.6142:node 2-2
#@-node:ekr.20090713125326.6124:node 2
#@+node:ekr.20090713125326.6130:node 3
# node 3
#@nonl
#@+node:ekr.20090713125326.6131:node 3-1
# node 3-1
#@+node:ekr.20090713125326.6132:node 3-1-1
# node 3-1-1
#@nonl
#@-node:ekr.20090713125326.6132:node 3-1-1
#@+node:ekr.20090713125326.6138:node 3-1-2
# node 3-1-2
#@-node:ekr.20090713125326.6138:node 3-1-2
#@-node:ekr.20090713125326.6131:node 3-1
#@+node:ekr.20090713125326.6148:node 3-2
# node 3-2
#@+node:ekr.20090713125326.6149:node 3-2-1
# node 3-2-1
#@nonl
#@-node:ekr.20090713125326.6149:node 3-2-1
#@+node:ekr.20090713125326.6150:node 3-2-2
# node 3-2-2
#@-node:ekr.20090713125326.6150:node 3-2-2
#@-node:ekr.20090713125326.6148:node 3-2
#@-node:ekr.20090713125326.6130:node 3
#@-node:ekr.20090713125326.6116:@test p.adjustPositionBeforeUnlink
#@-node:ekr.20080427062528.4:p._adjustPositionBeforeUnlink
#@-node:ekr.20091210082012.6231:Comparing positions
#@-node:ekr.20091211111443.6264:Batch operations on nodes
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@+node:ekr.20090822054806.6002:Merged clean-sys-path branch
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

I noted that leo adds all of its directories to sys.path. This is
considered "bad form" and can cause nasty surprises. I believe this is
an artifact of the old "leo-as-package" work; now that leo-as-package
stuff works well, I don't think this is needed anymore.

It's not a lot of work to fix either - it's just a matter of removing
the call to adjustSysPath in runLeo.py, and fixing some plugins. (yes,
I tried it). e.g. quicksearch.py needed this trivial change:

+++ leo/plugins/quicksearch.py  2009-08-15 20:22:20 +0000

-import qt_quicksearch
+from leo.plugins import qt_quicksearch 

What I did:

- disabled adjustSysPath.
- g.importModule now imports from 'extensions' and 'external' directories as needed.
- Modified two plugins to import from leo.plugins.
- Added __init__.py to 'extensions' folder.
#@nonl
#@-node:ekr.20090822054806.6002:Merged clean-sys-path branch
#@+node:ekr.20091007104807.6469:Added support for --version and --help
Actually, --help was supported already.
#@nonl
#@-node:ekr.20091007104807.6469:Added support for --version and --help
#@+node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
@nocolor-node

Leo will now automatically write @file nodes as if they were @thin nodes
(thin-like sentinels). Leo will read @file correctly regardless of whether the
corresponding external file has file-like (legacy) or thin-like (recommended)
sentinels. Once thin-like sentinels are written, Leo deletes the problematic
tnodeList attribute in the .leo file.

**Important**: The conversion to thin-like sentinels happens *only* if Leo
actually writes the @file node, and that happens only if the @file node or one
of its descendants changes. As usual with @file nodes, writing any @file node
forces Leo to write the .leo file. This is necessary so that the tnodeList
attribute in the .leo file remains up- to-date. Thus, the conversion process
should be as safe as using @file nodes ever was, which is to say, *usually* safe
but subject to problems in a cooperative environment.

In short, I recommend that you use Shift-Ctrl-W (write-at-files-nodes)
to force the conversion of all your legacy @file nodes.  Please back
up your .leo file and all your external files first.
#@nonl
#@-node:ekr.20091005145253.6057:Convert @file nodes so they use file-like sentinels
#@+node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@-node:ekr.20091007105735.6463:Made show-fonts work with qt gui
#@+node:ekr.20091103082258.6085:Removed 'end of script' message
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                exec(script,d)
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        f = open(path,'w')
        f.write(script)
        f.close()
    except Exception:
        g.es("Failed to write script to %s" % path)
        g.es("Check your configuration of script_file_path, currently %s" % c.config.getString('script_file_path'))
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@-node:ekr.20091103082258.6085:Removed 'end of script' message
#@+node:ekr.20090705062946.6037:Update the panel as soon as the user completes the find string
@nocolor-node

The change was to searchWithPresentOptions.
#@nonl
#@+node:ekr.20060123125256:class minibufferFind (the findHandler)
class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    # g.trace('replaceStringShortcut',s)
    self.replaceStringShortcut = s
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20090126063121.1:editWidget (minibufferFind)
def editWidget (self,event):

    '''An override of baseEditCommands.editWidget

    that does *not* set focus when using anything other than the tk gui.

    This prevents this class from caching an edit widget
    that is about to be deallocated.'''

    c = self.c ; w = event and event.widget
    bodyCtrl = self.c.frame.body and self.c.frame.body.bodyCtrl

    # g.trace('isText',g.app.gui.isTextWidget(w),'w',w,g.app.gui.widget_name(w))

    if g.app.gui.guiName() == 'tkinter':

        # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
        if w and g.app.gui.isTextWidget(w):
            self.w = w
        else:
            self.w = bodyCtrl
        if self.w:
            c.widgetWantsFocusNow(self.w)
    else:
        # Do not cache a pointer to a headline!
        # It will die when the minibuffer is selected.
        self.w = bodyCtrl

    return self.w
#@-node:ekr.20090126063121.1:editWidget (minibufferFind)
#@+node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
# This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
#@-node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):

    # g.trace('pattern',g.callers(4))

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    # g.trace(pattern,g.callers(4))

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20070105123800:changeAll (minibufferFind)
def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        # Bug fix: 2009-5-31.
        # None denotes that we use the present value of the option.
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)
#@nonl
#@-node:ekr.20070105123800:changeAll (minibufferFind)
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder

    f.p = self.c.p
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper (minibufferFind)
def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    # Bug fix: 2007-12-14: remove call to self.finder.findNextCommand.
    # This was the cause of replaces not starting in the right place!

    if changeAll:
        self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060205105950.1:generalChangeHelper (minibufferFind)
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.p
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind (the findHandler)
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@-node:ekr.20090705062946.6037:Update the panel as soon as the user completes the find string
#@+node:ekr.20100111115044.14051:Allow repeat-complex commands for *all* commands
#@+node:ekr.20061031131434.122:repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit(event)
#@-node:ekr.20061031131434.122:repeatComplexCommand & helper
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and not (stroke.startswith('Alt+Ctrl') and not self.enable_alt_ctrl_bindings) and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            if trace: g.trace(w)
            i = w.logCtrl.getInsertPoint()
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            w.logCtrl.insert(i,stroke)
            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@nonl
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@-node:ekr.20100111115044.14051:Allow repeat-complex commands for *all* commands
#@+node:ekr.20100112051224.6219:Merge open_with branch with the trunk
# I made several minor changes from the diff.
#@nonl
#@+node:ekr.20100112051224.6220:diff
<< set ext based on the present language >>

=== modified file 'leo/core/leoCommands.py'
2	--- leo/core/leoCommands.py 2009-10-08 00:25:54 +0000
3	+++ leo/core/leoCommands.py 2009-10-29 23:05:26 +0000
4	@@ -725,10 +725,21 @@
5	#@ << set ext based on the present language >>
6	#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
7	if not ext:
8	- theDict = c.scanAllDirectives()
9	- language = theDict.get("language")
10	- ext = g.app.language_extension_dict.get(language)
11	- # g.pr(language,ext)
12	+ # if node is part of @<file> tree, get ext from file name
13	+ for cursor in p.self_and_parents():
14	+ if cursor.isAnyAtFileNode():
15	+ h = cursor.h
16	+ f = h.split(None, 1)[1]
17	+ ext = os.path.splitext(f)[1]
18	+ break
19	+
20	+ # otherwise use ext from @language directive
21	+ if not ext:
22	+ theDict = c.scanAllDirectives()
23	+ language = theDict.get("language")
24	+ ext = g.app.language_extension_dict.get(language)
25	+ # g.pr(language,ext)
26	+
27	if ext == None:
28	ext = "txt"
#@nonl
#@-node:ekr.20100112051224.6220:diff
#@+node:ekr.20031218072017.2823:openWith and helpers
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=500)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    # if node is part of @<file> tree, get ext from file name
    for p2 in p.self_and_parents():
        if p2.isAnyAtFileNode():
            fn = p2.h.split(None,1)[1]
            ext = g.os_path_splitext(fn)[1]
            g.trace(ext)
            break

if not ext:
    theDict = c.scanAllDirectives()
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # g.trace(language,ext)

if not ext:
    ext = ".txt"

if ext[0] != ".":
    ext = "."+ext

# g.trace("ext",ext)
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.b
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening:",g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec(arg+path,{},{})
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        os.spawnl(os.P_NOWAIT,arg,filename,path)
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        os.spawnv(os.P_NOWAIT,arg[0],vtuple)
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        use_shell = True
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
            use_shell = False
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            try:
                subprocess.Popen(vtuple, shell=use_shell)
            except OSError:
                g.es_print("vtuple",repr(vtuple))
                g.es_exception()
        else:
            g.trace('Can not import subprocess.  Skipping: "%s"' % command)
    elif callable(openType):
        # Invoke openWith like this:
        # c.openWith(data=[f,None,None])
        # f will be called with one arg, the filename
        openType(shortPath)

    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing:",command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    theFile = None # pylint complains if this is inited to ''.
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  ",g.shortFileName(path),color="red")
        else:
            g.es("creating:  ",g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.b
        theDict = c.scanAllDirectives(p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v == p2.v:
        # g.pr("removing previous entry in g.app.openWithFiles for",p.h)
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    name = "%s_LeoTemp_%s%s" % (
        g.sanitize_filename(p.headString()),
        str(id(p.v)),ext)

    name = g.toUnicode(name,g.app.tkEncoding)

    td = g.os_path_finalize(tempfile.gettempdir())

    path = g.os_path_join(td,name)

    return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and helpers
#@-node:ekr.20100112051224.6219:Merge open_with branch with the trunk
#@+node:ekr.20100112095623.6266:Write <globals> data to c.db
#@+node:ville.20090606150238.6351:_contentHashFile (atFile)
def _contentHashFile(self,s,content):

    '''Compute the has of s (usually a headline) and content.'''

    # We add s (usually the headline) to the hash,
    # to distinguish @auto foo.py from @thin foo.py

    c = self.c
    m = hashlib.md5()
    if g.isPython3:
        m.update(g.toEncodedString(s,encoding='utf-8'))
        m.update(g.toEncodedString(content,encoding='utf-8'))
    else:
        m.update(s)
        m.update(content)
    return "fcache/" + m.hexdigest()




#@-node:ville.20090606150238.6351:_contentHashFile (atFile)
#@+node:ekr.20100112095623.6268:Writing...
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.db and c.mFileName

    if use_db:
        key = c.atFileCommands._contentHashFile(c.mFileName,'globals')
        if trace: g.trace(len(list(c.db.keys())),c.mFileName,key)
        << put all data to c.db >>

    # Always put postions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20100112095623.6267:<< put all data to c.db >>
c.db['body_outline_ratio_%s' % key] = str(c.frame.ratio)
c.db['body_secondary_ratio_%s' % key] = str(c.frame.secondary_ratio)

if trace: g.trace('ratios: %1.2f %1.2f' % (
    c.frame.ratio,c.frame.secondary_ratio))

width,height,left,top = c.frame.get_window_info()

c.db['window_position_%s' % key] = (
    str(top),str(left),str(height),str(width))

if trace: g.trace('top',top,'left',left,'height',height,'width',width)
#@-node:ekr.20100112095623.6267:<< put all data to c.db >>
#@+node:ekr.20031218072017.3038:<< put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratios >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@-node:ekr.20100112095623.6268:Writing...
#@+node:ekr.20100112095623.6269:Reading
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if self.inClipboard:
        return

    c.frame.ratio,c.frame.secondary_ratio = 0.5,0.5 # Set defaults.

    if trace: g.trace(len(list(c.db.keys())),c.mFileName)

    if g.enableDB and c.db and c.mFileName:
        key = c.atFileCommands._contentHashFile(c.mFileName,'globals')
        c.frame.ratio = float(c.db.get(
            'body_outline_ratio_%s' % (key),'0.5'))
        c.frame.secondary_ratio = float(c.db.get(
            'body_secondary_ratio_%s' % (key),'0.5'))
        if trace: g.trace('key',key,
            '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
    else:
        try:
            for bunch in self.attrsToList(attrs):
                name = bunch.name ; val = bunch.val
                if name == 'body_outline_ratio':
                    c.frame.ratio = float(val) # 2010/01/11
                elif name == 'body_secondary_ratio':
                    c.frame.secondary_ratio = float(val) # 2010/01/11
            if trace: g.trace('** no c.db:','%1.2f %1.2f' % (
                c.frame.ratio,c.frame.secondary_ratio))
        except Exception:
            pass
#@-node:ekr.20060919110638.37:startGlobals
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(len(list(c.db.keys())),c.mFileName,self.fileName)

    d = {}

    if g.enableDB and c.db and c.mFileName:
        key = c.atFileCommands._contentHashFile(c.mFileName,'globals')
        data = c.db.get('window_position_%s' % (key))
        if data:
            top,left,height,width = data
            top,left,height,width = int(top),int(left),int(height),int(width)
            d = {'top':top,'left':left,'height':height,'width':width}

    if not d and c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}

    if not d:
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    # if trace: g.trace(d)
    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@-node:ekr.20100112095623.6269:Reading
#@-node:ekr.20100112095623.6266:Write <globals> data to c.db
#@-node:ekr.20090817080059.5996:Features
#@+node:ekr.20091203060018.6100:leo-3k
@nocolor-node

To do:

- Run all tests in this file (Alt-6).

- Fix plugins that fail with Python3k.

#@+node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091203165343.6144:2to3 args
Available transformations for the -f/--fix option:
apply
basestring
buffer
callable
dict
except
exec
execfile
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
paren
### print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
#@-node:ekr.20091203165343.6144:2to3 args
#@-node:ekr.20091203060018.6067:2to3 output
#@+node:ekr.20091206084842.6197:Details, surprises
@nocolor-node

- add list for .keys(), .values(), .items()
- changes to library & exceptions.

*** Happy surprises ***

Python 3k does significantly better in catching type errors involving arithmetic types.
#@nonl
#@-node:ekr.20091206084842.6197:Details, surprises
#@+node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091206150342.6202:print statement in unit tests
ERROR: @test unindent in triple string does not end function

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 32
    print 'h',h
            ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6202:print statement in unit tests
#@+node:ekr.20091206150342.6193:u' in unit tests
======================================================================
ERROR: @test selfInsertCommand-1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 12
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉΩBぅ乼cz):\n'
                                          ^
SyntaxError: invalid syntax

ERROR: @test open non-existent non-ascii directory
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 6
    file = u'Ỗ'

ERROR: @test atFile.printError
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 9
    s = u'La Pe\xf1a'
                    ^
SyntaxError: invalid syntax

ERROR: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 13
    s = u'炰'
           ^
SyntaxError: invalid syntax

ERROR: @test g.reportBadChars
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 8
    (u'aĂbĂ', 'ascii'),
             ^
SyntaxError: invalid syntax
#@-node:ekr.20091206150342.6193:u' in unit tests
#@+node:ekr.20091206150342.6207:string.strip does not exist
#@-node:ekr.20091206150342.6207:string.strip does not exist
#@+node:ekr.20091206150342.6192:sortLines: string.lower does not exist
======================================================================
ERROR: @test reverse-sort-lines-ignoring-case

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4650, in reverseSortLinesIgnoringCase
    return self.sortLines(event,ignoreCase=True,reverse=True)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4676, in sortLines
    if ignoreCase:  aList.sort(key=string.lower)
AttributeError: 'module' object has no attribute 'lower'
#@-node:ekr.20091206150342.6192:sortLines: string.lower does not exist
#@+node:ekr.20091206150342.6191:centerRegion
ERROR: @test center-region

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 2125, in centerRegion
    w.insert(i,' '*n)
TypeError: can't multiply sequence by non-int of type 'float'
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = int((self.fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion
#@-node:ekr.20091206150342.6191:centerRegion
#@+node:ekr.20091206150342.6195:setInsertPoint
ERROR: @test moveUpOrDownHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 7, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1105, in setInsertPoint
    i = max(0,min(i,len(s)))
TypeError: unorderable types: int() < str()
#@nonl
#@-node:ekr.20091206150342.6195:setInsertPoint
#@+node:ekr.20091206150342.6201:skipBlock (elisp)
ERROR: @test elisp functions

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1506, in elispUnitTest
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1557, in scannerUnitTest
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 862, in createOutline
    func(s,p,atAuto=atAuto)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1610, in scanElispText
    scanner.run(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3096, in run
    self.scan(s,parent)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2554, in scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2786, in skipDecls
    elif self.startsFunction(s,i):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 3254, in startsFunction
    end = self.skipBlock(s,i)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 2654, in skipBlock
    if indent < startIndent and line.strip():
TypeError: unorderable types: int() < NoneType()
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@-node:ekr.20091206150342.6201:skipBlock (elisp)
#@+node:ekr.20091206150342.6194:sortColumns
ERROR: @test sort-columns

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 4, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1669, in runEditCommandTest
    c.k.simulateCommand(commandName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 3079, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoKeys.py", line 2543, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 390, in doCommand
    val = command(event)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoEditCommands.py", line 4709, in sortColumns
    zlist.sort()
AttributeError: 'zip' object has no attribute 'sort'

#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in range(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = list(zip(columns,aList))
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@-node:ekr.20091206150342.6194:sortColumns
#@+node:ekr.20091206150342.6196:setSelectionRangeHelper
ERROR: @test paste from menu into headline sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 382, in setSelectionRange
    return self.setSelectionRangeHelper(i,j,insert)
  File "/home/edreamleo/leo.repo/leo-3k/leo/plugins/qtGui.py", line 1594, in setSelectionRangeHelper
    insert = max(0,min(insert,n))
TypeError: unorderable types: int() < str()
#@-node:ekr.20091206150342.6196:setSelectionRangeHelper
#@+node:ekr.20091206150342.6199:flattenHeadline
ERROR: ImportExportTestCase: flattenOutline /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/flattenOutline.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1545, in flattenOutline
    c.importCommands.flattenOutline(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 409, in flattenOutline
    theFile.write(head + nl)
TypeError: can't concat bytes to str
#@+node:ekr.20031218072017.1147:flattenOutline
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = g.toEncodedString(head + nl,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1147:flattenOutline
#@-node:ekr.20091206150342.6199:flattenHeadline
#@+node:ekr.20091206150342.6198:exportHeadlines
ERROR: ImportExportTestCase: exportHeadlines /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/output/exportHeadlines.txt
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1523, in exportHeadlines
    c.importCommands.exportHeadlines(fileName)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 384, in exportHeadlines
    theFile.write(head + nl)
TypeError: can't concat bytes to str

#@+node:ekr.20031218072017.1462:exportHeadlines
def exportHeadlines (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.p
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    try:
        theFile = open(fileName,mode)
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = g.toEncodedString(head + nl,self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@-node:ekr.20031218072017.1462:exportHeadlines
#@-node:ekr.20091206150342.6198:exportHeadlines
#@+node:ekr.20091206150342.6200:scanWebFile
ERROR: ImportExportTestCase: importCWEBFiles /home/edreamleo/leo.repo/leo-3k/leo/test/unittest/input/cweave.w
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1229, in runTest
    self.importExport()
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 1219, in importExport
    command(event=None)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoCommands.py", line 1626, in importCWEBFiles
    c.importCommands.importWebCommand(names,"cweb")
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1212, in importWebCommand
    p = self.createOutlineFromWeb(fileName,current)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1195, in createOutlineFromWeb
    self.scanWebFile(path,p)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoImport.py", line 1332, in scanWebFile
    if k > -1: self.cstEnter(s[j:k])
TypeError: unorderable types: NoneType() > int()
#@nonl
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    j = s.find('\n',i)
    if j == -1: j = len(s)
    k = s.find(pattern,i,j)
    return k
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except Exception:
        g.es("can not import",fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)

j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)

while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@-node:ekr.20091206150342.6200:scanWebFile
#@+node:ekr.20091206150342.6189:outputStringWithLineEndings
Traceback (most recent call last):

  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 3175, in asisWrite
    at.outputStringWithLineEndings(s)
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoAtFile.py", line 4324, in outputStringWithLineEndings
    self.os(s.replace('\n',self.output_newline))
TypeError: expected an object with the buffer interface
#@nonl
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):
    at = self
    # Calling self.onl() runs afoul of queued newlines.

    if 1: # g.u(s) == s when isPython3.
        if g.isPython3:
            s = g.ue(s,at.encoding)
        s = s.replace('\n',at.output_newline)
        self.os(s)
    else:
        if g.isPython3:
            s = g.ue(s,at.encoding)
            s = s.replace(g.u('\n'),g.u(at.output_newline))
        else:
            s = s.replace('\n',at.output_newline)
        self.os(s)
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@-node:ekr.20091206150342.6189:outputStringWithLineEndings
#@+node:ekr.20091206150342.6190:parse_leo_file
 File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoFileCommands.py", line 1445, in parse_leo_file
    theFile = StringIO(s)

TypeError: initial_value must be str or None, not bytes
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091206150342.6190:parse_leo_file
#@+node:ekr.20091206224118.6260:unicode failures
FAIL: @test failure to convert unicode characters to ascii
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 11, in <module>
AssertionError: toUnicodeWithErrorCode returns True for 炰 with ascii encoding

======================================================================
FAIL: @test of round-tripping toUnicode & toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: Round-trip one fails for a

======================================================================
FAIL: @test failure with ascii encodings
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 10, in <module>
AssertionError: toUnicodeWithErrorCode returns True for 炰 with ascii encoding

======================================================================
FAIL: @test round trip toUnicode toEncodedString
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 27, in <module>
AssertionError: Round-trip one failed for a
#@+node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
# The syntax of these functions must be valid on Python2K and Python3K.

def isBytes(s):
    '''Return True if s is Python3k bytes type.'''
    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isChar(s):
    '''Return True if s is a Python2K character type.'''
    if g.isPython3:
        return False
    else:
        return type(s) == types.StringType

def isString(s):
    '''Return True if s is any string, but not bytes.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes

def isUnicode(s):
    '''Return True if s is a unicode string.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) == types.UnicodeType
#@-node:ekr.20080816125725.2:g.isBytes, isChar, isString & isUnicode
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
def toEncodedStringWithErrorCode (s,encoding,reportErrors=False):

    ok = True

    if g.isUnicode(s):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors: g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
            ok = False
    return s, ok
#@-node:ekr.20080919065433.2:toEncodedStringWithErrorCode (for unit testing)
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
#@nonl
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20091206161352.6232:g.u & g.ue
if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
#@-node:ekr.20091206161352.6232:g.u & g.ue
#@+node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
def toUnicodeWithErrorCode (s,encoding,reportErrors=False):

    ok = True
    if g.isPython3: f = str
    else: f = unicode
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s,encoding,'strict')
        except (UnicodeError,ValueError):
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = f(s,encoding,'replace')
            ok = False
    return s,ok
#@-node:ekr.20080919065433.1:toUnicodeWithErrorCode (for unit testing)
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@-node:ekr.20091206224118.6260:unicode failures
#@+node:ekr.20091207194815.6264:t1.next
ERROR: @test find_h / find_b / select_h / select_b

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 23, in <module>
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoNodes.py", line 2842, in select_b
    first = t1.next()
AttributeError: 'itertools.tee' object has no attribute 'next'
#@+node:ville.20090311195550.1:select_b
def select_b(self, regex, flags = re.IGNORECASE ):
    """ Find all the nodes in poslist where body matches regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

        pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')
    """
    pat = re.compile(regex, flags)
    res = poslist()
    for p in self:
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
            # if does not raise StopIteration...
            pc = p.copy()
            pc.matchiter = t2
            res.append(pc)

        except StopIteration:
            pass

    return res
#@-node:ville.20090311195550.1:select_b
#@+node:ville.20090311200059.1:c.find_b
def find_b(self, regex, flags = re.IGNORECASE | re.MULTILINE):
    """ Return list (a poslist) of all nodes whose body matches the regex

    You can chain find_h / find_b with select_h / select_b like this
    to refine an outline search::

    pl = c.find_h('@thin.*py').select_h('class.*').select_b('import (.*)')    
    """

    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.poslist()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1,t2 = itertools.tee(m,2)
        try:
            if g.isPython3:
                first = t1.__next__()
            else:
                first = t1.next()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
#@-node:ville.20090311200059.1:c.find_b
#@-node:ekr.20091207194815.6264:t1.next
#@+node:ekr.20091207194815.6265:putDescendentVnodeUas
FAIL: @test putDescendentVnodeUas

----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/edreamleo/leo.repo/leo-3k/leo/core/leoTest.py", line 192, in runTest
    exec(script,d)
  File "<string>", line 19, in <module>
AssertionError: expected: ' descendentVnodeUnknownAttributes="7d7100285503302e3071017d7102550f756e69745f746573745f6368696c6471035504616263647104735505302e302e3071057d71065514756e69745f746573745f6772616e646368696c64710755047778797a710873752e"', got: ' descendentVnodeUnknownAttributes="b\'7d7100285803000000302e3071017d7102580f000000756e69745f746573745f6368696c6471035804000000616263647104735805000000302e302e3071057d71065814000000756e69745f746573745f6772616e646368696c64710758040000007778797a710873752e\'"'
#@-node:ekr.20091207194815.6265:putDescendentVnodeUas
#@+node:ekr.20041001161108:doPlugins
ignoringMessageGiven = False

def doPlugins(tag,keywords):

    global ignoringMessageGiven

    if g.app.killed:
        return

    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20091206161352.6230:Fixed unit tests
#@+node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20031218072017.1997:scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
#@-node:ekr.20031218072017.1997:scanGnx
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:ekr.20091209095640.6218:Output tnodes in proper order
#@+node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20091217191310.6304:Remove bad chars from .leo files
#@+node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = g.u('') # Must always be a string.
self.navTime = None

pth, bname = os.path.split(self.mFileName)
if pth and bname and g.enableDB:
    fn = self.mFileName.lower()
    fn = g.toEncodedString(fn,'utf-8') # Required for Python 3.x.
    dbdirname = '%s/db/%s_%s' % (
        g.app.homeLeoDir,bname,hashlib.md5(fn).hexdigest())
    # Use compressed pickles (handy for @thin caches)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname,protocol='picklez')
else:
    self.db = {}
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
import leo.core.leoGlobals as g
from leo.external.path import path as Path
import glob
import os
import stat
import sys
import time
import warnings

isPython3 = sys.version_info >= (3,0,0)

try:
    import marshal
except ImportError:
    marshal = None

if isPython3:
    import pickle
else:
    import cPickle as pickle

try:
    import simplejson
except ImportError:
    simplejson = None

try:
    import zlib
except ImportError:
    zlib = None
#@-node:ekr.20091204132346.6078:<< imports >> (pickleshare.py)
#@+node:ekr.20041005105605.21:read (atFile) & helper
def read(self,root,
    importFileName=None,thinFile=False,
    fromString=None,atShadow=False,
    force=False
):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName and isAtFile >>
    if isAtFile:
        # The @file node has file-like sentinels iff a tnodeList exists.
        thinFile = not (hasattr(root.v,'tnodeList') and root.v.tnodeList)
    doCache = g.enableDB and (thinFile or atShadow) and not force
    at.initReadIvars(root,fileName,
        importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root.h,fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    # (We do delete all children for @file nodes with thin-like sentinels.)
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    if at.errors == 0: # 2010/01/07
        self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName and isAtFile >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False

isAtFile = (
    not thinFile and
    not importFileName and
    not atShadow and
    not fromString and
    root.h.startswith('@file'))
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName and isAtFile >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree():
    if p.v.isVisited():
        pass
        # g.trace('visited',p.v,p.h)
    else:
        g.trace('**** not visited',p.v,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for v in c.all_unique_nodes():

    if hasattr(v,"tempBodyString"):
        delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile) & helper
#@+node:ekr.20091204132346.6080:class PickleShareDB
_sentinel = object()

class PickleShareDB:
    """ The main 'connection' object for PickleShare database """
    @others
#@+node:ekr.20091204132346.6081: __init__
def __init__(self,root, protocol = 'pickle'):
    """ Initialize a PickleShare object that will manage the specied directory

    root: The directory that contains the data. Created if it doesn't exist.

    protocol: one of 

        * 'pickle' (universal, default) 
        * 'picklez' (compressed pickle)         
        * 'marshal' (fast, limited type support)
        * 'json' : brief, human-readable, very limited type support

    Protol 'json' requires installation of simplejson module
    """
    self.root = Path(root).expanduser().abspath()
    if not self.root.isdir():
        self.root.makedirs()
    # cache has { 'key' : (obj, orig_mod_time) }
    self.cache = {}

    if protocol == 'pickle':
        self.loader = pickle.load
        self.dumper = pickle.dump
    elif protocol == 'marshal':
        if marshal:
            self.loader = marshal.load
            self.dumper = marshal.dump
    elif protocol == 'json':
        if simplejson:
            self.loader = simplejson.load
            self.dumper = simplejson.dump
    elif protocol == 'picklez':
        if zlib:
            def loadz(fileobj):
                val = pickle.loads(zlib.decompress(fileobj.read()))
                return val

            def dumpz(val, fileobj):
                compressed = zlib.compress(pickle.dumps(val, pickle.HIGHEST_PROTOCOL))
                fileobj.write(compressed)

            self.loader = loadz
            self.dumper = dumpz
#@-node:ekr.20091204132346.6081: __init__
#@+node:ekr.20091216103214.6305:__contains__
def __contains__(self, key):

    return self.has_key(key)
#@-node:ekr.20091216103214.6305:__contains__
#@+node:ekr.20091204132346.6088:__delitem__
def __delitem__(self,key):

    """ del db["key"] """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    self.cache.pop(fil,None)
    try:
        fil.remove()
    except OSError:
        # notfound and permission denied are ok - we
        # lost, the other process wins the conflict
        pass
#@-node:ekr.20091204132346.6088:__delitem__
#@+node:ekr.20091204132346.6082:__getitem__
def __getitem__(self,key):

    """ db['key'] reading """

    fil = self.root / key
    # g.trace('(PickleShareDB)',key) #,g.shortFileName(fil))
    try:
        mtime = (fil.stat()[stat.ST_MTIME])
    except OSError:
        raise KeyError(key)

    if fil in self.cache and mtime == self.cache[fil][1]:
        return self.cache[fil][0]
    try:
        # The cached item has expired, need to read
        obj = self.loader(fil.open("rb"))
    except:
        raise KeyError(key)

    self.cache[fil] = (obj,mtime)
    return obj
#@-node:ekr.20091204132346.6082:__getitem__
#@+node:ekr.20091216103214.6303:__iter__
def __iter__(self):

    for k in list(self.keys()):
        yield k
#@-node:ekr.20091216103214.6303:__iter__
#@+node:ekr.20091204132346.6094:__repr__
def __repr__(self):

    return "PickleShareDB('%s')" % self.root



#@-node:ekr.20091204132346.6094:__repr__
#@+node:ekr.20091204132346.6083:__setitem__
def __setitem__(self,key,value):

    """ db['key'] = 5 """

    fil = self.root / key
    parent = fil.parent
    if parent and not parent.isdir():
        parent.makedirs()
    pickled = self.dumper(value,fil.open('wb'))
    # g.trace('(PickleShareDB)',key) # ,g.shortFileName(fil))
    try:
        self.cache[fil] = (value,fil.mtime)
    except OSError as e:
        if e.errno != 2:
            raise

#@-node:ekr.20091204132346.6083:__setitem__
#@+node:ekr.20091204132346.6089:_normalized
def _normalized(self, p):
    """ Make a key suitable for user's eyes """
    return str(self.root.relpathto(p)).replace('\\','/')

#@-node:ekr.20091204132346.6089:_normalized
#@+node:ekr.20091224075120.6536:get
def get(self, key, default=None):
    try:
        return self[key]
    except KeyError:
        return default
#@nonl
#@-node:ekr.20091224075120.6536:get
#@+node:ekr.20091204132346.6093:getlink
def getlink(self,folder):
    """ Get a convenient link for accessing items  """
    return PickleShareLink(self, folder)

#@-node:ekr.20091204132346.6093:getlink
#@+node:ekr.20091216103214.6304:has_key
def has_key(self, key):

    try:
        value = self[key]
    except KeyError:
        return False

    return True
#@-node:ekr.20091216103214.6304:has_key
#@+node:ekr.20091204132346.6087:hcompress
def hcompress(self, hashroot):
    """ Compress category 'hashroot', so hset is fast again

    hget will fail if fast_only is True for compressed items (that were
    hset before hcompress).

    """
    hfiles = self.keys(hashroot + "/*")
    all = {}
    for f in hfiles:
        # print("using",f)
        all.update(self[f])
        self.uncache(f)

    self[hashroot + '/xx'] = all
    for f in hfiles:
        p = self.root / f
        if p.basename() == 'xx':
            continue
        p.remove()



#@-node:ekr.20091204132346.6087:hcompress
#@+node:ekr.20091204132346.6086:hdict
def hdict(self, hashroot):
    """ Get all data contained in hashed category 'hashroot' as dict """
    hfiles = self.keys(hashroot + "/*")
    hfiles.sort()
    last = len(hfiles) and hfiles[-1] or ''
    if last.endswith('xx'):
        # print("using xx")
        hfiles = [last] + hfiles[:-1]

    all = {}

    for f in hfiles:
        # print("using",f)
        try:
            all.update(self[f])
        except KeyError:
            print("Corrupt",f,"deleted - hset is not threadsafe!")
            del self[f]

        self.uncache(f)

    return all
#@-node:ekr.20091204132346.6086:hdict
#@+node:ekr.20091204132346.6085:hget
def hget(self, hashroot, key, default = _sentinel, fast_only = True):
    """ hashed get """
    hroot = self.root / hashroot
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, _sentinel )
    g.trace("got dict",d,"from",g.shortFileName(hfile))
    if d is _sentinel:
        if fast_only:
            if default is _sentinel:
                raise KeyError(key)
            return default
        # slow mode ok, works even after hcompress()
        d = self.hdict(hashroot)

    return d.get(key, default)
#@nonl
#@-node:ekr.20091204132346.6085:hget
#@+node:ekr.20091204132346.6084:hset
def hset(self, hashroot, key, value):
    """ hashed set """
    hroot = self.root / hashroot
    if not hroot.isdir():
        hroot.makedirs()
    hfile = hroot / gethashfile(key)
    d = self.get(hfile, {})
    d.update( {key : value})
    self[hfile] = d                



#@-node:ekr.20091204132346.6084:hset
#@+node:ekr.20091216103214.6306:iteritems & iterkeys
def iteritems(self):
    for k in self:
        yield (k, self[k])

def iterkeys(self):
    return self.__iter__()
#@-node:ekr.20091216103214.6306:iteritems & iterkeys
#@+node:ekr.20091204132346.6090:keys
def keys(self, globpat = None):
    """ All keys in DB, or all keys matching a glob"""

    if globpat is None:
        files = self.root.walkfiles()
    else:
        files = [Path(p) for p in glob.glob(self.root/globpat)]

    return [self._normalized(p) for p in files if p.isfile()]

#@-node:ekr.20091204132346.6090:keys
#@+node:ekr.20091204132346.6091:uncache
def uncache(self,*items):
    """ Removes all, or specified items from cache

    Use this after reading a large amount of large objects
    to free up memory, when you won't be needing the objects
    for a while.

    """
    if not items:
        self.cache = {}
    for it in items:
        self.cache.pop(it,None)

#@-node:ekr.20091204132346.6091:uncache
#@+node:ekr.20091204132346.6092:waitget
def waitget(self,key, maxwaittime = 60 ):
    """ Wait (poll) for a key to get a value

    Will wait for `maxwaittime` seconds before raising a KeyError.
    The call exits normally if the `key` field in db gets a value
    within the timeout period.

    Use this for synchronizing different processes or for ensuring
    that an unfortunately timed "db['key'] = newvalue" operation 
    in another process (which causes all 'get' operation to cause a 
    KeyError for the duration of pickling) won't screw up your program 
    logic. 
    """

    wtimes = [0.2] * 3 + [0.5] * 2 + [1]
    tries = 0
    waited = 0
    while 1:
        try:
            val = self[key]
            return val
        except KeyError:
            pass

        if waited > maxwaittime:
            raise KeyError(key)

        time.sleep(wtimes[tries])
        waited+=wtimes[tries]
        if tries < len(wtimes) -1:
            tries+=1
#@-node:ekr.20091204132346.6092:waitget
#@-node:ekr.20091204132346.6080:class PickleShareDB
#@-node:ekr.20091209114435.6223:Fixed caching
#@+node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20051104075904.99:createUnitTestsFromDoctests
def createUnitTestsFromDoctests (modules,verbose=True):

    created = False # True if suite is non-empty.

    suite = unittest.makeSuite(unittest.TestCase)

    for module in list(modules):
        # New in Python 4.2: n may be zero.
        try:
            test = doctest.DocTestSuite(module)
            n = test.countTestCases()
            if n > 0:
                suite.addTest(test)
                created = True
                if verbose:
                    g.pr("found %2d doctests for %s" % (n,module.__name__))
        except ValueError:
            g.pr('no doctests in %s' % module.__name__)
            pass # No tests found.

    return g.choose(created,suite,None)
#@-node:ekr.20051104075904.99:createUnitTestsFromDoctests
#@+node:ekr.20051104075904.102:importAllModulesInPath
def importAllModulesInPath (path,exclude=[]):

    path = g.os_path_finalize(path)

    if not g.os_path_exists(path):
        g.es("path does not exist:",path)
        return []

    path2 = g.os_path_join(path,"leo*.py")
    files = glob.glob(path2)
    files2 = []
    for theFile in files:
        for z in exclude:
            if theFile.endswith(z):
                break
        else:
            files2.append(theFile)
    modules = []

    for theFile in files2:
        module = safeImportModule(theFile)
        if module:
            modules.append(module)

    # g.trace(modules)
    return modules
#@nonl
#@-node:ekr.20051104075904.102:importAllModulesInPath
#@+node:ekr.20051104075904.103:safeImportModule & test
@ Warning: do NOT use g.importFromPath here!

g.importFromPath uses imp.load_module, and that is equivalent to reload!
reloading Leo files while running will crash Leo.
@c

def safeImportModule (fileName):

    fileName = g.os_path_finalize(fileName)
    head,tail = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(tail)
    oldUnitTesting = g.unitTesting

    if ext == ".py":
        try:
            # g.trace(moduleName)
            g.unitTesting = False # Disable @test nodes!
            g.app.unitTesting = False
            try:
                # for base in ('leo.core','leo.plugins','leo.external',):
                    # fullName = '%s.%s' % (base,moduleName)
                    # m = __import__(fullName) # 'leo.core.%s' % moduleName)
                    # if m is not None:
                        # return sys.modules.get(fullName)
                fullName = 'leo.core.%s' % (moduleName)
                __import__(fullName)
                return sys.modules.get(fullName)
            finally:
                g.unitTesting = oldUnitTesting
                g.app.unitTesting = oldUnitTesting
        except Exception:
            # g.trace('can not import',moduleName,fileName)
            # leoScriptModule.py, for example, can throw other exceptions.
            return None
    else:
        g.pr("Not a .py file:",fileName)
        return None
#@+node:ekr.20090703155133.6418:@test safeImportModule
if g.unitTesting:

    d = g.app.unitTestDict
    c,p = g.getTestVars()
    assert d.get('getTestVars') is True
    d['getTestVars'] = False

    # Do lots of imports.
    import leo.core.leoTest as leoTest
    path = g.os_path_join(g.app.loadDir,"..","core")
    modules = leoTest.importAllModulesInPath(path)

    # Assert that g.getTestVars has not been called.
    val = d.get('getTestVars')
    assert val is False, val

#@-node:ekr.20090703155133.6418:@test safeImportModule
#@-node:ekr.20051104075904.103:safeImportModule & test
#@-node:ekr.20091218143600.6302:Fixed doctest problems on Linux
#@+node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20060221083356:g.prettyPrintType
def prettyPrintType (obj):

    if g.isPython3:
        if type(obj) in (types.MethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif g.isString(obj):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
    else:
        if type(obj) in (
            types.MethodType,types.UnboundMethodType,types.BuiltinMethodType):
            return 'method'
        elif type(obj) in (types.BuiltinFunctionType,types.FunctionType):
            return 'function'
        elif type(obj) == types.ModuleType:
            return 'module'
        elif type(obj) == types.InstanceType:
            return 'object'
        elif type(obj) in (types.UnicodeType,types.StringType):
            return 'string'
        else:
            theType = str(type(obj))
            if theType.startswith("<type '"): theType = theType[7:]
            if theType.endswith("'>"): theType = theType[:-2]
            return theType
#@-node:ekr.20060221083356:g.prettyPrintType
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    if g.isPython3:
        for z in gc.get_objects():
            try:
                name = z.__class__.__name__
            except ReferenceError:
                pass
            self.allClassesDict [name] = z
    else:
        for z in gc.get_objects():
            t = type(z)
            if t == types.ClassType:
                name = z.__name__
            elif t == types.InstanceType:
                name = z.__class__.__name__
            elif repr(t).startswith('<class'): # A wretched kludge.
                name = z.__class__.__name__
            elif t == types.TypeType:
                name = z.__name__
            else:
                name = None
            if name:
                # if name == 'position': g.trace(t,z)
                self.allClassesDict [name] = z

    # g.printList(list(self.allClassesDict.keys()),tag='Classes',sort=True)
    # g.trace(len(list(self.allClassesDict.keys())))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@-node:ekr.20091218173731.6717:Fixed completer crash
#@+node:ekr.20091218182246.6722:Added entries for haxe language
#@+node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--', # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    "rst"           : "rst",
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@-node:ekr.20031218072017.368:<< define global data structures >> (leoApp.py)
#@-node:ekr.20091218182246.6722:Added entries for haxe language
#@+node:ekr.20091220131901.6364:Unicode bug
#@+node:ekr.20091206161352.6232:g.u & g.ue
if isPython3: # g.not defined yet.
    def u(s):
        return s
    def ue(s,encoding):
        return str(s,encoding)
else:
    def u(s):
        return unicode(s)
    def ue(s,encoding):
        return unicode(s,encoding)
#@-node:ekr.20091206161352.6232:g.u & g.ue
#@+node:ekr.20070412082527:g.openLeoOrZipFile & tests
# This is used in several places besides g.openWithFileName.

def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            if not theFile: return None,False
            # Read the file into an StringIO file.
            aList = theFile.namelist()
            name = aList and len(aList) == 1 and aList[0]
            if not name: return None,False
            s = theFile.read(name)
            if g.isPython3:
                theStringFile = StringIO(g.ue(s,'utf-8'))
            else:
                theStringFile =  StringIO(s)
            return theStringFile,True
        else:
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@+node:ekr.20090526083112.5838:@test g.openLeoOrZipFile
if g.unitTesting:

    import zipfile

    # Create a zip file for testing.
    s = 'this is a test file'
    testDir = g.os_path_join(g.app.loadDir,'..','test')
    assert g.os_path_exists(testDir)
    path = g.os_path_finalize_join(testDir,'testzip.zip')
    theFile = zipfile.ZipFile(path,'w')
    theFile.writestr('leo-zip-file',s)
    theFile.close()

    # Open the file, and use read (with no args) to get the contents.
    theFile,ok = g.openLeoOrZipFile(path)
    assert ok,'not ok'
    s2 = theFile.read()
    assert s == s2,'s:  %s\ns2: %s' % (repr(s),repr(s2))
#@-node:ekr.20090526083112.5838:@test g.openLeoOrZipFile
#@-node:ekr.20070412082527:g.openLeoOrZipFile & tests
#@+node:ekr.20091220131901.6365:leoAtFile
#@+node:ekr.20090525144314.6526:cleanSaxInputString & test
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20090525144314.6527:@test cleanSaxInputString
if g.unitTesting:

    c,p = g.getTestVars()

    s = 'test%cthis' % 27

    assert c.fileCommands.cleanSaxInputString(s) == 'test this'
#@-node:ekr.20090525144314.6527:@test cleanSaxInputString
#@-node:ekr.20090525144314.6526:cleanSaxInputString & test
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):
    at = self
    # Calling self.onl() runs afoul of queued newlines.

    if 1: # g.u(s) == s when isPython3.
        if g.isPython3:
            s = g.ue(s,at.encoding)
        s = s.replace('\n',at.output_newline)
        self.os(s)
    else:
        if g.isPython3:
            s = g.ue(s,at.encoding)
            s = s.replace(g.u('\n'),g.u(at.output_newline))
        else:
            s = s.replace('\n',at.output_newline)
        self.os(s)
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20080712150045.1:replaceFileWithString (atFile)
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    at = self ; testing = g.app.unitTesting

    # g.trace('fn',fn,'s','\n',s)
    # g.trace(g.callers())

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = open(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            at.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            g.es('not written: %s directory not found' % fn,color='red')
        return False

    # Replace
    try:
        f = open(fn,'wb')
        if g.isPython3:
            s = g.toEncodedString(s,encoding=self.encoding)
        f.write(s)
        f.close()
        if not testing:
            if exists:
                g.es('wrote:    ',fn)
            else:
                # g.trace('created:',fn,g.callers())
                g.es('created:',fn)
        return True
    except IOError:
        at.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@+node:ekr.20090530055015.6873:@test at.replaceFileWithString
if g.unitTesting:

    c,p = g.getTestVars()
    at = c.atFileCommands

    fn = 'does/not/exist'
    assert not g.os_path_exists(fn)
    assert not at.replaceFileWithString (fn,'abc')
#@-node:ekr.20090530055015.6873:@test at.replaceFileWithString
#@-node:ekr.20080712150045.1:replaceFileWithString (atFile)
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    trace = False
    at = self ; tag = self.underindentEscapeString
    f = at.outputFile

    if s and f:
        try:
            if trace: g.trace(repr(s))
            if s.startswith(tag):
                junk,s = self.parseUnderindentTag(s)
            # Bug fix: this must be done last.
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            f.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20091220131901.6365:leoAtFile
#@+node:ekr.20091220131901.6366:leoFileCommands
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@+node:ekr.20080805085257.2:pickle
def pickle (self,torv,val,tag):

    '''Pickle val and return the hexlified result.'''

    trace = False and g.unitTesting
    try:
        s = pickle.dumps(val,protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.ue(s2,'utf-8')
        if trace: g.trace('\n',
            type(val),val,'\n',type(s),repr(s),'\n',
            type(s2),s2,'\n',type(s3),s3)
        field = ' %s="%s"' % (tag,s3)
        return field

    except pickle.PicklingError:
        if tag: # The caller will print the error if tag is None.
            g.es_print("ignoring non-pickleable value",val,"in",torv,color="blue")
        return ''

    except Exception:
        g.es("fc.pickle: unexpected exception in",torv,color='red')
        g.es_exception()
        return ''
#@-node:ekr.20080805085257.2:pickle
#@-node:ekr.20091220131901.6366:leoFileCommands
#@-node:ekr.20091220131901.6364:Unicode bug
#@-node:ekr.20091203060018.6100:leo-3k
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20091220103056.6363:pylint
@nocolor-node

pylint is a python script in /usr/bin

python is in /usr/lib/

pylint sources are **not** in /usr/lib/pymodules/python2.6
(these are just links !!)

Shared sources are in usr/share/pyshared/pylint

$ echo $PATH
/usr/local/sbin: (empty)
/usr/local/bin: (4 items, no leo)
/usr/sbin: (256 items, no leo)
/usr/bin: (1876 items, no leo)
/sbin: (162 items, no leo)
/bin: (118 items, no leo)
/usr/games (28 items, no leo)

_psyco.so is in /usr/local/lib/python2.6
#@nonl
#@+node:ekr.20050405141130:<< imports >> (leoFileCommands)
import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

import leo.core.leoNodes as leoNodes

import binascii

if g.isPython3:
    import io # Python 3.x
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    import cStringIO # Python 2.x
    StringIO = cStringIO.StringIO

import os
import pickle
import string
import sys
import types
import zipfile

try:
    # IronPython has problems with this.
    import xml.sax
    import xml.sax.saxutils
except Exception:
    pass

# The following is sometimes used.
# import time
#@-node:ekr.20050405141130:<< imports >> (leoFileCommands)
#@+node:ekr.20091220130303.6365:Linux messages
@nocolor-node

************* Module leo.core.leoApp
E0611:346:LeoApp.createDefaultGui: No name 'QtGui' in module 'PyQt4'
E1101:757:LeoApp.computeSignon: Module 'sys' has no 'getwindowsversion' member
************* Module leo.core.leoAtFile
E0211:4045:atFile.syntaxErrorTest: Method has no argument
************* Module leo.core.leoCommands
E1101:1079:baseCommands.openWith: Module 'os' has no 'startfile' member
************* Module leo.core.leoFileCommands
E1101:1066:baseFileCommands.cleanSaxInputString: Class 'str' has no 'maketrans' member
************* Module leo.core.leoGlobals
E1101:4249:os_startfile: Module 'os' has no 'startfile' member
E1101:5473:getpreferredencoding: Module '_locale' has no '_getdefaultlocale' member
#@-node:ekr.20091220130303.6365:Linux messages
#@-node:ekr.20091220103056.6363:pylint
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
