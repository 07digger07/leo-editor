#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20080917153158.11:4.6
#@+node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@-node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@+node:ekr.20080917153158.12:Bugs
#@+node:ekr.20081003084608.4:Not bugs
@ This contains investigations which revealed no bug at present.
#@nonl
#@+node:ekr.20080918164844.7:Investigated settings strangeness re @string debugger_path
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d38704eb27eb9340

I find that
@settings
  @string debugger_path = /usr/bin/winpdb

sets the config string successfully if in
home/.leo/myLeoSettings.leo
not if in
cwd/myLeoSettings.leo

============

This works as expected, provided that by 'cwd' you mean the directory from which the .leo file was loaded.

#@-node:ekr.20080918164844.7:Investigated settings strangeness re @string debugger_path
#@+node:ekr.20080918164844.9:Don't put relative paths on the recent file list
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/5c6653927911de0d#

Code-->Core classes-->@thin runLeo.py -->utils-->createFrame (leo.py)

        c.updateRecentFiles(relativeFileName or fileName)

I don't think relative filenames should be passed to
c.updateRecentFiles()?  They get stuff in the recent file list but
don't work there.

Also appears to happen here:

Code-->Core classes-->@thin leoCommands.py-->class commands-->Command
handlers...-->File Menu-->Recent Files submenu &
allies-->clearRecentFiles

c.updateRecentFiles(c.relativeFileName())

and here

Code-->Core classes-->@thin leoGlobals.py-->Files &
Directories...-->g.openWithFileName

c.updateRecentFiles(relativeFileName or fileName)

The only way I've seen a relative path get into the list is from
command line invocation, so I'm not sure if all these routes are
active, but I think it should be avoided.

Cheers -Terry 


======

c.updateRecentFiles calls g.os_path_finalize/join so only abs paths can be put on the list.

@color
#@nonl
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    c = self

    if g.app.unitTesting: return

    def munge(name):
        return c.os_path_finalize(name or '').lower()
    def munge2(name):
        return c.os_path_finalize_join(g.app.loadDir,name or '')

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20080918164844.9:Don't put relative paths on the recent file list
#@-node:ekr.20081003084608.4:Not bugs
#@+node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@-node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@+node:ekr.20080917153158.14:Fix config crasher
@nocolor

Latest revision from trunk.

To reproduce:

- open a new outline.
- create a @settings node.
- create two children of the @settings node with the following
headlines "@string xxx = aaa" and "@button xxx".
- save the outline and close it.
- reopen the outline.

I'm getting the following traceback:

Traceback (most recent call last):
 File "/home/shadow/leo/leo-current/leo/core/leoGlobals.py", line
2818, in doHook
   return f(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 97,
in doPlugins
   return doHandlersForTag(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 76,
in doHandlersForTag
   val = callTagHandler(bunch,tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 55,
in callTagHandler
   result = handler(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 197, in onCreate
   sc.createAllButtons()
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 261, in createAllButtons
   self.handleAtButtonNode(p)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 533, in handleAtButtonNode
   b =
self.createAtButtonHelper(p,h,statusLine,shortcut,verbose=False)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 681, in createAtButtonHelper
   pane='button',verbose=verbose)
 File "/home/shadow/leo/leo-current/leo/core/leoKeys.py", line 3161,
in registerCommand
   junk,bunchList = c.config.getShortcut(commandName)
 File "/home/shadow/leo/leo-current/leo/core/leoCommands.py", line
7271, in getShortcut
   return g.app.config.getShortcut(self.c,shortcutName)
 File "/home/shadow/leo/leo-current/leo/core/leoConfig.py", line
1682, in getShortcut
   if bunch.val and bunch.val.lower() != 'none']
AttributeError: 'unicode' object has no attribute 'val'

@color
#@nonl
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20080917153158.14:Fix config crasher
#@+node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2

@nocolor

I recently discovered leo and decided to give it a try. I'm using the
rst3 plugin for generating latex docs. In general it works like a
charm, but I'm having some problems with the text encoding. The most
annoying one follows. If in my rst tree I've nodes with the character

ŀ (U+0140)

(or other character from the catalan alphabet) in the body text, I get
conversion errors in the log pane when the Write-Restructured-Text
command is executed. For instance, a node with the following body text

Nuŀla

causes the following error in the log pane:

1 errors converting Nu?la.

 to iso-8859-1

If I process the generated .tex file via pdflatex the character is
displayed as a ? symbol in the pdf.

The rst-options are:

@ @rst-options
default_path=latex
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--output-
encoding=utf-8,--stylesheet=/home/vmas/.leo/custom_style.sty
@c

If, instead of using leo, I put the problematic text content in a
plain rst file and process it via rst2latex I get no conversion
errors. The command line is:

rst2latex --language=ca --output-encoding=utf-8 --stylesheet=/home/
vmas/.leo/custom_style.sty prova.txt prova.tex 
#@nonl
#@-node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
#@+node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@-node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080827175609.39:c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.currentPosition()

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }
#@nonl
#@-node:ekr.20080827175609.39:c.scanAllDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080710082231.10:c.gotoLineNumber and helpers
def goToLineNumber (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self
    delim = None ; gnx = None ; vnodeName = None
    if n < 0: return

    fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p,scriptData)

    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; n2 = root.bodyString().count('\n') ; found = False
    elif isRaw:
        p,n2,found = c.goto_countLines(root,n)
    else:
        vnodeName,gnx,n2,delim = c.goto_findVnode(root,lines,n,ignoreSentinels)
        if delim:
            p,found = c.goto_findPosition(
                root,lines,vnodeName,gnx,n,delim)
        else:
            p,found = root,False
    if 0:
        << trace gotoLineNumber results >>
    c.goto_showResults(found,p or root,n,n2,lines)
#@+node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
g.trace(
    '\n  found',found,'n2',n2,'gnx',gnx,'delim',repr(delim),
    '\n  vnodeName',vnodeName,
    '\n  p        ',p and p.headString(),
    '\n  root     ',root and root.headString())
#@-node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
#@+node:ekr.20080708094444.65:goto_applyLineNumberMapping
def goto_applyLineNumberMapping(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) > n:
        return x.line_mapping[n]
    else:
        return n
#@-node:ekr.20080708094444.65:goto_applyLineNumberMapping
#@+node:ekr.20080904071003.12:goto_countLines
def goto_countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,n2,found) where p is the found node,
    n2 is the actural line found, and found is True if the line was found.'''

    p = lastv = root
    prev = 0 ; found = False
    isNosent = root.isAtNoSentFileNode()
    isAuto = root.isAtAutoNode()

    for p in p.self_and_subtree_iter():
        lastv = p.copy()
        s = p.bodyString()
        if isNosent or isAuto:
            s = ''.join([z for z in g.splitLines(s) if not z.startswith('@')])
        n_lines = s.count('\n')
        if len(s) > 0 and s[-1] != '\n': n_lines += 1
        # g.trace(n,prev,n_lines,p.headString())
        if prev + n_lines >= n:
            found = True ; break
        prev += n_lines

    p = lastv
    n2 = max(1,n-prev)

    return p,n2,found
#@-node:ekr.20080904071003.12:goto_countLines
#@+node:ekr.20080904071003.4:goto_findPosition & helpers
def goto_findPosition(self,root,lines,vnodeName,gnx,n,delim):

    c = self

    # if scriptFind:
        # p,found = c.scanForVnodeName(root,vnodeName

    if gnx:
        p,found = c.goto_findGnx(root,gnx,vnodeName)
    else:
        p,found = c.goto_scanTnodeList(root,delim,lines,n,vnodeName)

    # if not found:
        # g.es("not found:",vnodeName,color="red")

    return p,found
#@+node:ekr.20080904071003.18:goto_findGnx
def goto_findGnx (self,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    gnx = g.app.nodeIndices.scanGnx(gnx,0)

    for p in root.self_and_subtree_iter():
        if p.matchHeadline(vnodeName):
            if p.v.t.fileIndex == gnx:
                return p.copy(),True

    return None,False
#@-node:ekr.20080904071003.18:goto_findGnx
#@+node:ekr.20080904071003.19:goto_scanTnodeList
def goto_scanTnodeList (self,root,delim,lines,n,vnodeName):

    # This is about the best that can be done without replicating the entire atFile write logic.
    found = False
    ok = hasattr(root.v.t,"tnodeList")

    if ok:
        # Use getattr to keep pylint happy.
        tnodeList = getattr(root.v.t,'tnodeList')
        << set tnodeIndex to the number of +node sentinels before line n >>
        tnodeIndex = max(0,tnodeIndex)
        << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
    else:
        g.es_print("no child index for",root.headString(),color="red")

    if not ok:
        # Fall back to the old logic.
        << set p to the first node whose headline matches vnodeName >>

    return p,found
#@+node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>

tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20080904071003.19:goto_scanTnodeList
#@-node:ekr.20080904071003.4:goto_findPosition & helpers
#@+node:ekr.20031218072017.2877:goto_findVnode
def goto_findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self ; at = c.atFileCommands
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es('no sentinels in:',root.headString())
        return None,None,None,None

    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.headString(),gnx,1,delim

    s = lines[nodeSentinelLine]

    << set gnx and vnodeName from s >>
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

# Set delim from the @+leo line.
delim = None
if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
    # New in Leo 4.5.1: only support 4.x files.
    if valid and newDerivedFile:
        delim = start + '@'
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
@
Scan backwards from the requested line, looking for an @-body line. When found,
we get the vnode's name from that line and set p to the indicated vnode. This
will fail if vnode names have been changed, and that can't be helped.

We compute the offset of the requested line **within the found node**.
@c

offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1 # Start with the requested line.
while line >= 0:
    progress = line
    s = lines[line]
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        ### offset += 1 # Assume the line is real.  A dubious assumption.
        line -= 1
    assert line < progress
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    old_line = line
    line = c.goto_skipToMatchingNodeSentinel(lines,line,delim)
    assert line < old_line
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"+node"):
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    # if not ignoreSentinels:
        # offset += 1 # Count these as a "real" lines.
    line -= 1
else:
    line -= 1
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
i = 0 ; gnx = None ; vnodeName = None

if thinFile:
    # gnx is lies between the first and second ':':
    i = s.find(':',i)
    if i > 0:
        i += 1
        j = s.find(':',i)
        if j > 0:   gnx = s[i:j]
        else:       i = len(s) # Force an error.
    else:
        i = len(s) # Force an error.

# vnode name is everything following the first or second':'
i = s.find(':',i)
if i > -1:
    vnodeName = s[i+1:].strip()
else:
    vnodeName = None
    g.es_print("bad @+node sentinel",color='red')
#@-node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
#@-node:ekr.20031218072017.2877:goto_findVnode
#@+node:ekr.20080904071003.28:goto_setup & helpers
def goto_setup (self,n,p=None,scriptData=None):

    '''Return (fileName,isRaw,lines,n,p,root) where:

    fileName is the name of the nearest @file node, or None.
    isRaw is True if there are no sentinels in the file.
    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    root is the nearest @file node, or c.currentPosition.'''

    c = self

    if scriptData:
        assert p is None
        lines = scriptData.get('lines')
        p = scriptData.get('p')
        root,fileName = c.goto_findRoot(p)
    else:
        # p is for unit testing only!
        if not p: p = c.currentPosition()
        root,fileName = c.goto_findRoot(p)
        if root and fileName:
            c.shadowController.line_mapping = [] # Set by goto_open.
            lines = c.goto_getFileLines(root,fileName)
            n = c.goto_applyLineNumberMapping(n)
        else:
            lines = c.goto_getScriptLines(p)

    isRaw = not root or (
        root.isAtAsisFileNode() or root.isAtNoSentFileNode() or root.isAtAutoNode())

    ignoreSentinels = root and root.isAtNoSentFileNode()

    if scriptData:
        if not root: root = p.copy()
    else:
        if not root: root = c.currentPosition()

    return fileName,ignoreSentinels,isRaw,lines,n,root
#@+node:ekr.20080904071003.25:goto_findRoot
def goto_findRoot (self,p):

    '''Find the closest ancestor @file node, of any type, except @all nodes.

    return root, fileName.'''

    c = self ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents_iter():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions_iter():
        # if p.v.t == p1.v.t: g.trace('p1',p1,'p',p)
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents_iter():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20080904071003.25:goto_findRoot
#@+node:ekr.20080904071003.26:goto_getFileLines
def goto_getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self

    if root.isAtNoSentFileNode():
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        at.write(root,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = c.goto_open(fileName)

    return lines
#@-node:ekr.20080904071003.26:goto_getFileLines
#@+node:ekr.20080904071003.27:goto_getScriptLines
def goto_getScriptLines (self,p):

    c = self

    if not g.unitTesting:
        g.es("no ancestor @file node: using script line numbers", color="blue")

    lines = g.getScript (c,p,useSelectedText=False)
    lines = g.splitLines(lines)

    return lines
#@-node:ekr.20080904071003.27:goto_getScriptLines
#@+node:ekr.20080708094444.63:goto_open
def goto_open (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -> real file number.
    """

    c = self ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20080708094444.63:goto_open
#@-node:ekr.20080904071003.28:goto_setup & helpers
#@+node:ekr.20080904071003.14:goto_showResults
def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    c.redraw()

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace(p.headString(),g.callers())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20080904071003.14:goto_showResults
#@+node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
def goto_skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
#@-node:ekr.20080710082231.10:c.gotoLineNumber and helpers
#@-node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080923143214.1:Removed pychecker stuff
# It's time.
#@nonl
#@-node:ekr.20080923143214.1:Removed pychecker stuff
#@+node:ekr.20080921154026.3:Fixed new rst3 crash
# Calls g.makeAllNonExistentDirectories instead of os.mkdir.
#@nonl
#@+node:ekr.20080923163444.2:Report
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

I receive the following traceback, when I try to create an HTML-
File from a @rst-Node.

<Traceback>

Leo Log Window...
Leo 4.5.1 final, build  1.244 , September 14, 2008
python 2.5.2, Tk 8.4.12, Pmw 1.3
Windows 5, 1, 2600, 2, Service Pack 3

Can not load c:\aspell\bin\aspell-15.dll
leoID=vr20080824 (in C:\Dokumente und Einstellungen\VR\.leo)
load dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
global config dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\.leo
\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene Dateien
\Tools\Leo\Leo-20080921.leo
rewriting empty .leo file: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\Leo-20080921.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\Tools\Leo
\Leo-20080921.leo
saved: Leo-20080921.leo
SilverCity not present so no syntax highlighting
exception executing command
Traceback (most recent call last):
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 309, in doCommand
    val = command(event)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 482, in minibufferCallback
    retval = function(keywords)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 675, in rst3PluginCallback
    self.processTopTree(c.currentPosition())
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1152, in processTopTree

self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1184, in processTree
    ok =
self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1222, in writeSpecialTree
    os.mkdir(dir)
WindowsError: [Error 3] Das System kann den angegebenen Pfad nicht
finden: u'C:\\Python25\\Lib\\site-packages\\Leo-4-5-1-2-final\\2008\
\09'

</Traceback>

The related outline can be reduced to:

Worklog-->2008-->09-->@rst WLE-2008-09-21.html

The content of the right-most node is:

@ @rst-options
default_path=./2008/09
@c
======================
Worklog for 2008-09-21
======================

Kind regards,

Viktor 
#@nonl
#@-node:ekr.20080923163444.2:Report
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@-node:ekr.20080921154026.3:Fixed new rst3 crash
#@+node:ekr.20080924032842.2:Fixed two c syntax-coloring bugs
@
There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

Happily, no changes were required in the modes/c.py or modes/c.xml.
#@nonl
#@+node:ekr.20080709161540.1:Bug 1
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

Coloring of macro definitions is not extended after '\'.

More than that - refer again to the screenshot and look at the
comments and #defines at the bottom. The comments after the multi-line
macro are either not coloured or are coloured incorrectly. At the top,
the '#define ADDPRIM_CO' macro is only partially coloured. The macros
below the multi-line macro are incorrectly comment-coloured.

@color
#@nonl
#@+node:ekr.20080729064227.4:@url http://www.freenet.org.nz/misc/leo-c-screenshot.jpg
#@-node:ekr.20080729064227.4:@url http://www.freenet.org.nz/misc/leo-c-screenshot.jpg
#@-node:ekr.20080709161540.1:Bug 1
#@+node:ekr.20080924032842.1:Bug 2
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

I've noticed a strange behaviour of the "@language cplusplus" mode
using doxygen style comments.
I wrote this code doxygen java-like commenting style:

/**
 * first comment
 */

/**
 * second comment
 */

now I've the string "first comment" highlited as code and the string
"second comment" highlithed as comment.
Qt-style doxygen comments have the same behaviour and if I don't use
doxygen comments it's all ok.
I'm using leo 4.5.1 final on Windows XP.
It's a bug or I haven't understood something?

@color
#@nonl
#@-node:ekr.20080924032842.1:Bug 2
#@+node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i >= len(s): return len(s)
    if i <= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
#@-node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
#@-node:ekr.20080924032842.2:Fixed two c syntax-coloring bugs
#@+node:ekr.20081001062423.3:Restored deleted unit tests for p.textOffset
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/6f744c2a5819e3

I was browsing the source code and I've incidentally found that the
tests for p.textOffset() are not in the trunk. Perhaps they were lost
during a merge.

Relevant pointers:

------------------------------------------------------------
revno: 903
committer: Edward K. Ream <edream...@gmail.com>
branch nick: trunk
timestamp: Mon 2008-08-25 11:14:15 -0500
message:
  commit after merge
    ------------------------------------------------------------
    revno: 899.1.3
    committer: zpcspm zpc...@gmail.com
    branch nick: leo-fcol
    timestamp: Mon 2008-08-25 17:53:37 +0300
    message:
      commit after merge

The following command shows that the tests disappeared here.

$ bzr diff leo/test/unitTest.leo -r 899.1.3..903 
#@nonl
#@-node:ekr.20081001062423.3:Restored deleted unit tests for p.textOffset
#@+node:ekr.20080930072519.10:Fixed bug that prevented Leo from opening files on the XP desktop
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@-node:ekr.20080930072519.10:Fixed bug that prevented Leo from opening files on the XP desktop
#@+node:ekr.20081001062423.2:Fixed nested @path problem
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30

I'm finding

@path project
 \
   @shadow one.py
   @shadow two.py
   @path subdir
     \
       @shadow three.py

I'm finding three.py is considered project/three.py instead of
project/subdir/three.py 

===========

The problem was that leoAtFile/leoImport.scanDefaultDirectory did not support
nested @path directives.

I refactored them so all the common work is done in g.setDefaultDirectory.

@color
#@nonl
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20080211085914:scanDefaultDirectory (leoImport)
def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory, error = g.setDefaultDirectory(c,p,importing=False)

    if error: self.error(error)
#@-node:ekr.20080211085914:scanDefaultDirectory (leoImport)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory,error = g.setDefaultDirectory(c,p,importing)

    if error: at.error(error)
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20081001062423.9:g.setDefaultDirectory
# This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefault directory

def setDefaultDirectory(c,p,importing=False):

    '''Set default_directory by scanning @path directives.
    Return (default_directory,error_message).'''

    default_directory = '' ; error = ''
    if not p: return default_directory,error

    << Set path from @file node >>

    if not default_directory:
        # Scan for @path directives.
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        if path:
            << handle @path >>

    if not default_directory:
        << Set current directory >>

    if not default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    # g.trace('returns',default_directory)
    return default_directory, error
#@+node:ekr.20081001062423.10:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        default_directory = theDir
    else:
        default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not default_directory:
            error = "Directory \"%s\" does not exist" % theDir
#@-node:ekr.20081001062423.10:<< Set path from @file node >>
#@+node:ekr.20081001062423.11:<< handle @path >>
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        if g.os_path_exists(path):
            default_directory = path
        else:
            default_directory = g.makeAllNonExistentDirectories(path,c=c)
            if not default_directory:
                error = "invalid @path: %s" % path
            else:
                error = "ignoring bad @path: %s" % path
else:
    error = "ignoring empty @path"
#@-node:ekr.20081001062423.11:<< handle @path >>
#@+node:ekr.20081001062423.12:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not default_directory)

if c.frame:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    default_directory = theDir ; break
                else:
                    default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20081001062423.12:<< Set current directory >>
#@-node:ekr.20081001062423.9:g.setDefaultDirectory
#@-node:ekr.20081001062423.2:Fixed nested @path problem
#@+node:ekr.20080313032655.1:Fixed one failed unit test on Linux
@

This happened at line 36 of leo/test/unittest/perfectImport/formatter.py

It was caused by non-Linux line-endings.

I also fixed a bug that caused the unit test not to fail.
#@nonl
#@+node:ekr.20070703122141.104:checkTrialWrite
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite
#@+node:ekr.20070730093735:compareHelper
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@nonl
#@-node:ekr.20070730093735:compareHelper
#@+node:ekr.20070911110507:reportMismatch
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.headString(),bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in range(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in range(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@-node:ekr.20070911110507:reportMismatch
#@+node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20051104075904.78:makeImportExportSuite
def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite
#@-node:ekr.20051104075904.78:makeImportExportSuite
#@+node:ekr.20051104075904.79:class importExportTestCase
class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.80:__init__
def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.currentPosition()
#@-node:ekr.20051104075904.80:__init__
#@+node:ekr.20051104075904.81: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.81: fail
#@+node:ekr.20051104075904.82:importExport
def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.headString()
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
#@-node:ekr.20051104075904.82:importExport
#@+node:ekr.20051104075904.83:runTest
def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
#@-node:ekr.20051104075904.83:runTest
#@+node:ekr.20051104075904.84:setUp
def setUp(self):

    c = self.c ; temp_p = self.temp_p ; d = self.dialog

    temp_p.setBodyString('',g.app.tkEncoding)

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import test: " + self.p.headString())
    c.selectVnode(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
#@-node:ekr.20051104075904.84:setUp
#@+node:ekr.20051104075904.85:shortDescription
def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.headString(),self.fileName)
    except Exception:
        return "ImportExportTestCase"
#@-node:ekr.20051104075904.85:shortDescription
#@+node:ekr.20051104075904.86:tearDown
def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("",g.app.tkEncoding)
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
#@-node:ekr.20051104075904.86:tearDown
#@-node:ekr.20051104075904.79:class importExportTestCase
#@-node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        << Create a parent for two files having a common prefix >>
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw()

    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@-node:ekr.20080313032655.1:Fixed one failed unit test on Linux
#@+node:ekr.20080330085343.3:Save/restore tnodeList in atFile.write
The code should save/restore, just as in the clean_file function (from scripts.leo)
#@nonl
#@+node:ekr.20041005105605.144:write & helper
# This is the entry point to the write code.  root should be an @file vnode.

def write (self,root,
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
    write_strips_blank_lines = None,
):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    if hasattr(root.v.t,'tnodeList'):# 2008/10/3
        has_list,old_list = True,root.v.t.tnodeList[:]
    else:
        has_list,old_list = False,[]

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString,
        write_strips_blank_lines = write_strips_blank_lines)

    if nosentinels and not scriptWrite and not toString:
        fileName = c.os_path_finalize_join(at.default_directory,at.targetFileName)
        exists = g.os_path_exists(fileName)
        if not self.shouldWriteAtNosentNode(root,exists):
            return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    self.remove(at.outputFileName) # Delete the temp file.
    g.es("not written:",at.outputFileName)
else:
    at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don ' t want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper
#@+node:ekr.20080330085343.1:clean_file
def clean_file(p):

    at = c.atFileCommands

    if hasattr(p.v.t,'tnodeList'):
        has_list = True
        old_list =  p.v.t.tnodeList[:]
    else:
        has_list = False

    at.write(
        root=p,nosentinels=True,
        thinFile=False,
        scriptWrite=True,
        toString=True,
        write_strips_blank_lines=False)

    if has_list:
        p.v.t.tnodeList = old_list

    fileName = g.os_path_normpath(g.os_path_join(
        at.default_directory,
        'clean',
        g.os_path_basename(p.anyAtFileNodeName())))

    # g.trace(p.headString(),len(at.stringOutput),fileName)

    # Adapted from at.openFileForWritingHelper
    path = g.os_path_dirname(fileName)
    if not g.os_path_exists(path):
        g.es('clean directory does not exist',path)
        return

    try:
        f = file(fileName,'w')
        f.write(at.stringOutput)
        f.close()
        g.es_print('wrote',fileName)
    except IOError:
        g.es_print('can not write',fileName,color='red')
        g.es_exception()
#@-node:ekr.20080330085343.1:clean_file
#@-node:ekr.20080330085343.3:Save/restore tnodeList in atFile.write
#@+node:ekr.20081003155540.1:Fixed (?) bug in plugins dispatcher
@nocolor-node

callTagHandler now checks c.exists when possible.
#@nonl
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):

    handler = bunch.fn ; moduleName = bunch.moduleName

    # if tag != 'idle': g.pr('callTagHandler',tag,keywords.get('c'))

    # Make sure the new commander exists.
    if True: ### tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    g.pr('skipping tag %s: c does not exists or does not have a frame.' % tag)
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@-node:ekr.20050102094729:callTagHandler
#@-node:ekr.20081003155540.1:Fixed (?) bug in plugins dispatcher
#@+node:ekr.20081121081651.1:Paste outline problem
# The problem was missing calls to initAfterLoad in c.new.
#@nonl
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.frame.initCompleteHint()

    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:c.new
#@-node:ekr.20081121081651.1:Paste outline problem
#@-node:ekr.20080917153158.12:Bugs
#@+node:ekr.20080922124033.2:Documentation
#@+node:ekr.20080921154026.9:Added getInput example to Leo's docs
http://webpages.charter.net/edreamleo/scripting.html#getting-interactive-input-from-scripts
#@nonl
#@-node:ekr.20080921154026.9:Added getInput example to Leo's docs
#@+node:ekr.20080924164654.1:Drive Leo's autocompleter from a list
@nocolor

How can I hook my own completer into this?

What I need is that leo will call my own hook function when the user tries to
autocomplete, and my own function will tell leo what completions are suggested
(and thus what leo should show for the user).

@color
#@nonl
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
    g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
    g.es(s,color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace('(autocompleter)',self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion (autocompleter)
def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion (autocompleter)
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.34:finish
def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning (not used)
if 0: # Not used at present.
    @others
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('','.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        for key in sorted(self.watchwords):
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        for key in sorted(self.calltips):
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning (not used)
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) ### Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):

    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@-node:ekr.20080924164654.1:Drive Leo's autocompleter from a list
#@+node:ekr.20080406075855.3:Added warning about running test unitTest.leo when it is opened from another .leo file
@nocolor

I was playing around with this and I discovered that if I open
unitTest.leo from the File->Open menu pick of another leo outline and
then I run a unit test, then all the nodes from unitTest.leo appear in
the original document.  If I execute a save on the original document
(now with the unitTest.leo nodes), then the leo file gets overwritten
with the contents unitTest.leo.

=====

Added a warning in unitTest.leo:

Do not run tests from this file after opening unitTest.leo from another .leo
file. The unit tests in this file open and close many .leo files and many
strange things can happen if you have opened this file from another file.
#@nonl
#@-node:ekr.20080406075855.3:Added warning about running test unitTest.leo when it is opened from another .leo file
#@-node:ekr.20080922124033.2:Documentation
#@+node:ekr.20080918201437.1:Leo3k work
- Use sorted(dict) everywhere.

- Removed many calls to d.keys()
#@nonl
#@+node:ekr.20080919085541.4:Fixed hangs in Leo3k
# They were due to __cmp__ not being called.
# Replaced p.__cmp__ with p.__eq__ and p.__ne__.
#@nonl
#@+node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.headString())
            # if p.headString() == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.headString(),color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@-node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20080919121250.4:runLeo
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.4:runLeo
#@+node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@-node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    at = self

    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
#@+node:ekr.20050404151753: ctor
def __init__(self,encoding='utf-8',fromString=None):

    # g.trace('g.fileLikeObject:__init__','fromString',fromString)

    # New in 4.2.1: allow the file to be inited from string s.

    self.encoding = encoding

    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):

    self.list = []
#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):

    pass

    # The StringIo version free's the memory buffer.
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):

    pass
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue & read
def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
#@-node:ekr.20050404151753.4:get & getvalue & read
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):

    if s:
        if g.isBytes(s):
            s = g.toUnicode(s,self.encoding)

        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080816125725.2:g.isBytes & g.isString
def isBytes (s):

    '''Return True if s is Python3k bytes type.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: always returns False.'''

    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isString (s):

    '''Return True if s is a string.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: s may be either a unicode string or a regular string.'''

    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes
#@-node:ekr.20080816125725.2:g.isBytes & g.isString
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if isPython3:
        if g.isString(s):
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")

    else:
        if type(s) == types.UnicodeType:
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
#@nonl
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20031218072017.2317:g.trace
# Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception: name = ''
    if name == "?":
        name = "<unknown>"

    # Pad the caller name.
    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = []
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg,'utf-8')
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)
    try:
        g.pr('%s: %s' % (name,s),newline=newline)
    except Exception:
        s = g.toEncodedString(s,'ascii')
        g.pr('%s: %s' % (name,s),newline=newline)

#@-node:ekr.20031218072017.2317:g.trace
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.

    try: # We can't use any print keyword args in Python 2.x!
        # print(s) # Not quite right.
        if d.get('newline'):
            sys.stdout.write(s+'\n')
        else:
            sys.stdout.write(s)
    except Exception:
        print('unexpected Exception in g.pr')
        g.es_exception()
        g.trace(g.callers())
#@-node:ekr.20080710101653.1:g.pr
#@-node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080920052058.1:Unbounded loops
@
The problem was that __cmp__ was not being called.
It has now been replaced by the __eq__ and __ne__ operators.
#@nonl
#@+node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.headString(),p2 and p2.v and p2.headString()))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                g.pr("unknown position attribute:",attr)
                import traceback ; traceback.print_stack()
            raise AttributeError(attr)
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040117173448:p.__nonzero__ & __bool__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

if g.isPython3:

    def __bool__ ( self):

        """Return True if a position is valid."""

        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())

        return self.v is not None

else:

    def __nonzero__ ( self):

        """Return True if a position is valid."""

        # if g.app.trace: "__nonzero__",self.v

        # g.trace(repr(self))

        return self.v is not None
#@-node:ekr.20040117173448:p.__nonzero__ & __bool__
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d childIndex: %d lvl: %d [%d] %s>" % (
            id(p),p._childIndex,p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20061006092649:p.archivedPosition
def archivedPosition (self,root_p=None):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self

    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents_iter()]
    else:
        aList = []
        for z in p.self_and_parents_iter():
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
        # g.trace(aList)

    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061006092649:p.archivedPosition
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    g.pr('-'*10,label,p)
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20080416161551.191:p.key
def key (self):

    p = self

    vList = [z[0] for z in p.stack]

    return '%s:%s.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(z)) for z in vList])
    )
#@-node:ekr.20080416161551.191:p.key
#@-node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@-node:ekr.20080920052058.1:Unbounded loops
#@-node:ekr.20080919085541.4:Fixed hangs in Leo3k
#@-node:ekr.20080918201437.1:Leo3k work
#@+node:ekr.20080917153158.15:New features
#@+node:ekr.20080124083629.1:Improved @path handling
@nocolor





@color
#@nonl
#@+node:ekr.20080917154206.1:Done
What I did:

- Changed g.scanDirectives(c,p) to c.scanAllDirectives(p) in core.

- A deprecated g.scanDirectives just calls c.scanAllDirectives.
#@nonl
#@+node:ekr.20050121081635:Cumulative @path directives
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2936513
By: ktenney

In the @view plugin is a method, currentPath() which examines the current headline
and body, and the headlines and bodies of it's parents, looking for @path and
@view directives. It builds a path from them and checks for validity.

if a top level node contains;
@path /home/ktenney

and a descendant of that node contains;
@path projects/myproject

Then a node further down the tree which contains;
@view readme.txt

will display /home/ktenney/projects/myproject/readme.txt

I like this principle of cumulative paths, and would like other plugins to work
the same way ... @image, @url etc.

This brings me to my question, would it make sense for Leo to offer a 'Plugin'
class to inherit from? It seems that there are some operations that are being
re-written in many plugins.


============

QQQQQQ
nested @paths don't do what I expected: 

For a leo file in directory foo: 

@path src 
....@path tmpl

should refer to foo/src and foo/src/tmpl

using @path src/tmpl works fine though.
QQQQQQQ
#@nonl
#@-node:ekr.20050121081635:Cumulative @path directives
#@-node:ekr.20080917154206.1:Done
#@+node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
# This is the elegant, clear way to support os.path.expanduser.
#@nonl
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@-node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
#@+node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@-node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@+node:ekr.20080921154026.7:Added support for {{exp}}
#@+node:ekr.20080922170408.1:Made {{exp}} work in @path
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20080922124033.6:os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.currentPosition()
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@-node:ekr.20080922124033.6:os_path_expandExpression
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20080729142651.2:os_path_getsize
def os_path_getsize (path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getsize(path)
#@-node:ekr.20080729142651.2:os_path_getsize
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20080605064555.2:os_path_realpath
def os_path_realpath(path,encoding=None):


    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20080605064555.2:os_path_realpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory,error = g.setDefaultDirectory(c,p,importing)

    if error: at.error(error)
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
#@-node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20071109165315:g.computeRelativePath
def computeRelativePath (path):

    if len(path) > 2 and (
        (path[0]=='<' and path[-1] == '>') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
#@-node:ekr.20071109165315:g.computeRelativePath
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@-node:ekr.20080922170408.1:Made {{exp}} work in @path
#@-node:ekr.20080921154026.7:Added support for {{exp}}
#@+node:ekr.20080917154206.3:Finished at-path branch items
@nocolor

- Replaced g.scanDirectives with c.scanAllDirectives in scripts.leo, unitTest.leo and plugins.
- Removed obsolete helper methods.
- Rewrote tangle.scanAllDirectives.
- Rewrote scanForTabWidth.
- Replaced scanColorDirectives with new version.
- Replaced at.scanAllDirectives with new version.

@color
#@nonl
#@+node:ekr.20080901124540.1:c.Directive scanning
# These are all new in Leo 4.5.1.
#@nonl
#@+node:ekr.20080827175609.39:c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.currentPosition()

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }
#@nonl
#@-node:ekr.20080827175609.39:c.scanAllDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20080828103146.12:c.scanAtRootDirectives
# Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
#@-node:ekr.20080828103146.12:c.scanAtRootDirectives
#@+node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
#@-node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
#@+node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    filename = p.isAnyAtFileNode()
    return filename and g.os_path_finalize_join(path,filename) or None
#@-node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
#@-node:ekr.20080901124540.1:c.Directive scanning
#@+node:ekr.20031218072017.1380:g.Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20071109165315:g.computeRelativePath
def computeRelativePath (path):

    if len(path) > 2 and (
        (path[0]=='<' and path[-1] == '>') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
#@-node:ekr.20071109165315:g.computeRelativePath
#@+node:ekr.20031218072017.1385:g.findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@+node:ekr.20031218072017.1260:g.get_directives_dict
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(p,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    global globalDirectiveList

    if root: root_node = root[0]
    d = {'_p':p.copy()}

    # The headline has higher precedence because it is more visible.
    for kind,s in (
        ('body',p.v.t._headString),
        ('head',p.v.t._bodyString),
    ):
        i = 0 ; n = len(s)
        while i < n:
            if s[i] == '@' and i+1 < n:
                << set d for @ directives >>
            elif kind == 'body' and root and g.match(s,i,"<<"):
                << set d["root"] for noweb * chunks >>
            i = g.skip_line(s,i)
    return d
#@+node:ekr.20031218072017.1261:<< set d for @ directives >>
j = g.skip_id(s,i+1,chars='-')
word = s[i+1:j]

if word in globalDirectiveList:
    if d.get(word):
        # Ignore second value.
        pass
        # g.es("warning: conflicting values for",word,color="blue")
    else:
        k = g.skip_line(s,j)
        d[word] = s[j:k].strip()
#@nonl
#@-node:ekr.20031218072017.1261:<< set d for @ directives >>
#@+node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)

if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            d["root"]=0 # value not immportant
        else:
            g.es('',g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:g.get_directives_dict
#@+node:ekr.20080827175609.1:g.get_directives_dict_list
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to the start of each directive"""

    result = [] ; p1 = p1.copy()

    for p in p1.self_and_parents_iter():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    return result
#@-node:ekr.20080827175609.1:g.get_directives_dict_list
#@+node:ekr.20031218072017.1386:g.getOutputNewline
def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))
    return s
#@-node:ekr.20031218072017.1386:g.getOutputNewline
#@+node:ekr.20080827175609.52:g.scanAtCommentAndLanguageDirectives
def scanAtCommentAndAtLanguageDirectives(aList):

    '''Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.'''

    lang = None

    for d in aList:

        comment = d.get('comment')
        language = d.get('language')

        # Important: assume @comment follows @language.
        if language:
            # if g.unitTesting: g.trace('language',language)
            lang,delim1,delim2,delim3 = g.set_language(language,0)

        if comment:
            # if g.unitTesting: g.trace('comment',comment)
            delim1,delim2,delim3 = g.set_delims_from_string(comment)

        if comment or language:
            delims = delim1,delim2,delim3
            return {'language':lang,'comment':comment,'delims':delims}

    return None
#@-node:ekr.20080827175609.52:g.scanAtCommentAndLanguageDirectives
#@+node:ekr.20080827175609.32:g.scanAtEncodingDirectives
def scanAtEncodingDirectives(aList):

    '''Scan aList for @encoding directives.'''

    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            # g.trace(encoding)
            return encoding
        elif encoding and not g.app.unitTesting:
            g.es("invalid @encoding:",encoding,color="red")

    return None
#@-node:ekr.20080827175609.32:g.scanAtEncodingDirectives
#@+node:ekr.20080827175609.53:g.scanAtHeaderDirectives
def scanAtHeaderDirectives(aList):

    '''scan aList for @header and @noheader directives.'''

    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.es_print("conflicting @header and @noheader directives",color='red')
#@nonl
#@-node:ekr.20080827175609.53:g.scanAtHeaderDirectives
#@+node:ekr.20080827175609.33:g.scanAtLineendingDirectives
def scanAtLineendingDirectives(aList):

    '''Scan aList for @lineending directives.'''

    for d in aList:

        e = d.get('lineending')
        if e in ("cr","crlf","lf","nl","platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.es("invalid @lineending directive:",e,color="red")

    return None
#@-node:ekr.20080827175609.33:g.scanAtLineendingDirectives
#@+node:ekr.20080827175609.34:g.scanAtPagewidthDirectives
def scanAtPagewidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @pagewidth directives.'''

    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s,0)
            if val != None and val > 0:
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @pagewidth",s,color="red")

    return None
#@-node:ekr.20080827175609.34:g.scanAtPagewidthDirectives
#@+node:ekr.20031218072017.3154:g.scanAtRootOptions
def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        << scan another @root option >>

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    return i,mode
#@+node:ekr.20031218072017.3155:<< scan another @root option >>
i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i < len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err > -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s,i)
    g.es("unknown option:",z_opt,"in",z_line)
#@-node:ekr.20031218072017.3155:<< scan another @root option >>
#@-node:ekr.20031218072017.3154:g.scanAtRootOptions
#@+node:ekr.20080827175609.37:g.scanAtTabwidthDirectives
def scanAtTabwidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @tabwidth directives.'''

    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk,val = g.skip_long(s,0)

            if val not in (None,0):
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @tabwidth",s,color="red")

    return None
#@-node:ekr.20080827175609.37:g.scanAtTabwidthDirectives
#@+node:ekr.20080831084419.4:g.scanAtWrapDirectives
def scanAtWrapDirectives(aList,issue_error_flag=False):

    '''Scan aList for @wrap and @nowrap directives.'''

    for d in aList:
        if d.get('wrap') is not None:
            return True
        elif d.get('nowrap') is not None:
            return False

    return None
#@nonl
#@-node:ekr.20080831084419.4:g.scanAtWrapDirectives
#@+node:ekr.20070302160802:g.scanColorDirectives
def scanColorDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None: return # c may be None for testing.

    language = c.target_language and c.target_language.lower() or 'python'

    p = p.copy()
    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        z = d.get('language')
        if z is not None:
            language,junk,junk,junk = g.set_language(z,0)
            return language

    return language
#@-node:ekr.20070302160802:g.scanColorDirectives
#@+node:ekr.20080901195858.4:g.scanDirectives  (for compatibility only)
def scanDirectives(c,p=None):

    return c.scanAllDirectives(p)
#@nonl
#@-node:ekr.20080901195858.4:g.scanDirectives  (for compatibility only)
#@+node:ekr.20040715155607:g.scanForAtIgnore
def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True

    return False
#@-node:ekr.20040715155607:g.scanForAtIgnore
#@+node:ekr.20040712084911.1:g.scanForAtLanguage
def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
#@-node:ekr.20040712084911.1:g.scanForAtLanguage
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20081001062423.9:g.setDefaultDirectory
# This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefault directory

def setDefaultDirectory(c,p,importing=False):

    '''Set default_directory by scanning @path directives.
    Return (default_directory,error_message).'''

    default_directory = '' ; error = ''
    if not p: return default_directory,error

    << Set path from @file node >>

    if not default_directory:
        # Scan for @path directives.
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        if path:
            << handle @path >>

    if not default_directory:
        << Set current directory >>

    if not default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    # g.trace('returns',default_directory)
    return default_directory, error
#@+node:ekr.20081001062423.10:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        default_directory = theDir
    else:
        default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not default_directory:
            error = "Directory \"%s\" does not exist" % theDir
#@-node:ekr.20081001062423.10:<< Set path from @file node >>
#@+node:ekr.20081001062423.11:<< handle @path >>
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        if g.os_path_exists(path):
            default_directory = path
        else:
            default_directory = g.makeAllNonExistentDirectories(path,c=c)
            if not default_directory:
                error = "invalid @path: %s" % path
            else:
                error = "ignoring bad @path: %s" % path
else:
    error = "ignoring empty @path"
#@-node:ekr.20081001062423.11:<< handle @path >>
#@+node:ekr.20081001062423.12:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not default_directory)

if c.frame:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    default_directory = theDir ; break
                else:
                    default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20081001062423.12:<< Set current directory >>
#@-node:ekr.20081001062423.9:g.setDefaultDirectory
#@+node:ekr.20031218072017.1382:g.set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    # g.trace(g.callers())

    val = g.app.language_delims_dict.get(language)
    # if language.startswith('huh'): g.pdb()

    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:g.set_delims_from_language
#@+node:ekr.20031218072017.1383:g.set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in range(0,3):
        if delims[i]:
            delims[i] = delims[i].replace("__",'\n').replace('_',' ')

    return delims[0], delims[1], delims[2]
#@-node:ekr.20031218072017.1383:g.set_delims_from_string
#@+node:ekr.20031218072017.1384:g.set_language
def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring:",g.get_line(s,i))

    return None, None, None, None,
#@-node:ekr.20031218072017.1384:g.set_language
#@-node:ekr.20031218072017.1380:g.Directive utils...
#@+node:ekr.20080923070954.12:Rewrote
#@+node:ekr.20080828103146.8:scanColorDirectives
def scanColorDirectives(self,p):

    '''Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.'''

    c = self.c
    if not c: return # May be None for testing.

    table = (
        ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
        ('root',        c.scanAtRootDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,func in table:
        val = func(aList)
        if val: d[key]=val

    # Post process.
    lang_dict       = d.get('lang-dict')
    self.rootMode   = d.get('root') or None

    if lang_dict:
        self.language       = lang_dict.get('language')
        self.comment_string = lang_dict.get('comment')
    else:
        self.language       = c.target_language and c.target_language.lower()
        self.comment_string = None

    # g.trace('self.language',self.language)
    return self.language # For use by external routines.
#@-node:ekr.20080828103146.8:scanColorDirectives
#@+node:ekr.20080923070954.4:atFile.scanAllDirectives
def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    at = self ; c = self.c

    << set ivars >>

    lang_dict = {'language':at.language,'delims':delims,}

    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    delims          = lang_dict.get('delims')
    lineending      = d.get('lineending')
    if lineending:
        at.explicitLineEnding = True
        at.output_newline = lineending
    else:
        at.output_newline = g.getOutputNewline(c=c) # Init from config settings.

    at.encoding             = d.get('encoding')
    at.language             = lang_dict.get('language')
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>

    # For unit testing.
    return {
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
#@+node:ekr.20080923070954.14:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@-node:ekr.20080923070954.14:<< Set ivars >>
#@+node:ekr.20080923070954.13:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims ### g.set_delims_from_language(at.language)

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@-node:ekr.20080923070954.13:<< Set comment strings from delims >>
#@-node:ekr.20080923070954.4:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1375:frame.scanForTabWidth
def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    aList = g.get_directives_dict_list(p)
    w = g.scanAtTabwidthDirectives(aList)
    c.frame.setTabWidth(w or c.tab_width)
#@-node:ekr.20031218072017.1375:frame.scanForTabWidth
#@+node:ekr.20080923124254.16:tangle.scanAllDirectives
def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>

    # delims = (self.single_comment_string,self.start_comment_string,self.end_comment_string)
    lang_dict = {'language':self.language,'delims':None,} # Delims not used

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.page_width           = d.get('pagewidth')
    self.default_directory    = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.default_directory,
        "tabwidth"  : self.tab_width,
    }

#@+node:ekr.20080923124254.17:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
#@-node:ekr.20080923124254.17:<< Collect @first attributes >>
#@-node:ekr.20080923124254.16:tangle.scanAllDirectives
#@-node:ekr.20080923070954.12:Rewrote
#@-node:ekr.20080917154206.3:Finished at-path branch items
#@-node:ekr.20080124083629.1:Improved @path handling
#@+node:ekr.20080917154206.4:Merge leo-30 branch
@nocolor 

This make's Leo's syntax compatible with Python 3.0.
#@nonl
#@-node:ekr.20080917154206.4:Merge leo-30 branch
#@+node:ekr.20080919085541.2:Open a default .leo file if no other is specified
# Added support for @string default_leo_file = ~/.leo/workbook.leo
#@nonl
#@+node:ekr.20080921060401.7: Request
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Now it's easier than ever to add *quick* notes with leo. ILeo knows of
"special" leo file ~/.ipython/ipython_notebook.leo, which is opened
automatically when you do:

lleo

("launch leo" without specifying a .leo file to open. The old
behaviour was to open untitled file, saving of which iIs pain).

lno This is my note

("leo note")

This opens ipython_notebook.leo if leo is not running already, and
adds a headline with "This is my note" under headline "Scratch". Of
course the focus still remains in the ipython window, so you can
proceed adding more notes with %lno without losing your concentration
or touching your mouse. If you run  %lno with a note string that
already exists, the existing note is focused instead.

To enable all this goodness, you just need to add

_ip.load('ipy_leo')

to your ipy_user_conf.py.

You also need to install leo with "setup.py develop".

I guess this is leo's equivalent of Chandler's "Quick entry bar",
described here:

http://www.youtube.com/watch?v=JJBxajDwmLI 

@color
#@nonl
#@-node:ekr.20080921060401.7: Request
#@+node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.9:doEarlyInits
def doEarlyInits(verbose):

    import leo.core.leoGlobals as g
    import leo.core.leoNodes as leoNodes
    import leo.core.leoConfig as leoConfig

    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.

    # There is a circular dependency between leoCommands and leoEditCommands.
    import leo.core.leoCommands as leoCommands

    # New in Leo 4.5 b3: make sure we call the new leoPlugins.init top-level function.
    # This prevents a crash when run is called repeatedly from IPython's lleo extension.
    import leo.core.leoPlugins as leoPlugins
    leoPlugins.init()

    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921060401.9:doEarlyInits
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@-node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@-node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@-node:ekr.20080919085541.2:Open a default .leo file if no other is specified
#@+node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

I'm wondering, would it make sense for leo to do "something" when launched
directly against a .py file, i.e.

"leo test.py".

Of course that's a perfectly sensible thing to do, considering that leo is,
among other things, a python editor ;-)

Perhaps it might create create a (unsaved) leo document  where the .py file
is present as @shadow node, or something.

@color
#@nonl
#@+node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@-node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@+node:ekr.20080921154026.4:Not changed
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    # if not g.app.initing:
        # g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame

    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir: c.openDirectory = theDir

    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)

    if ok:
        frame.resizePanesToRatio(ratio,frame.secondary_ratio)

    return ok
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20080921154026.4:Not changed
#@+node:ekr.20080921154026.5:Changed
#@+node:ekr.20080211085914:scanDefaultDirectory (leoImport)
def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory, error = g.setDefaultDirectory(c,p,importing=False)

    if error: self.error(error)
#@-node:ekr.20080211085914:scanDefaultDirectory (leoImport)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if 1: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None,None
        p = c.currentPosition()
        if p:
            p.setHeadString(fileName)
            p.setBodyString(s)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.currentPosition()
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.currentPosition()
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.currentPosition()
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw_now() # Only needed by menu commands.
    return c,frame
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@-node:ekr.20080921154026.5:Changed
#@+node:ekr.20080921154026.6:tests
leo c:\leo.repo\trunk\leo\modes\python.py

# --silent optional below
leo --script c:\leo.repo\trunk\leo\test\unittest\batchTest.py
#@nonl
#@-node:ekr.20080921154026.6:tests
#@-node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
#@+node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e

The suggestion: paste fonts into myLeoSettings.leo.

Can they be a better default?
#@nonl
#@+node:ekr.20080921154026.11:Fonts
@nocolor
@

Valid values:

weight: bold, normal, None
slant: roman, italic, None

Use the show-fonts command to pick fonts, then copy the values shown
by the show-fonts command to the values here.

@c

import sys ; print sys.platform
#@+node:ekr.20080921154026.12:@font body text font
body_text_font_family = fixed
body_text_font_size = 11
body_text_font_slant = None
body_text_font_weight = None
#@-node:ekr.20080921154026.12:@font body text font
#@+node:ekr.20080921154026.13:@font button font
button_text_font_family = fixed
button_text_font_size = 8
button_text_font_slant = roman
button_text_font_weight = normal
#@-node:ekr.20080921154026.13:@font button font
#@+node:ekr.20080921154026.14:@font log font
# The font for the log pane. Default is
default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
#
# Default size is 12 for Linux, 9 otherwise.

log_text_font_family = Courier
log_text_font_size = 9
log_text_font_slant = roman
log_text_font_weight = normal
#@-node:ekr.20080921154026.14:@font log font
#@+node:ekr.20080921154026.15:@font menu text font
menu_text_font_family = None
menu_text_font_size = None
menu_text_font_slant = None
menu_text_font_weight = None
#@nonl
#@-node:ekr.20080921154026.15:@font menu text font
#@+node:ekr.20080921154026.16:@font outline font
headline_text_font_family = fixed
headline_text_font_size = 11
headline_text_font_slant = roman
headline_text_font_weight = normal
#@-node:ekr.20080921154026.16:@font outline font
#@-node:ekr.20080921154026.11:Fonts
#@-node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
#@+node:ekr.20080922124033.3:Enter tree pane after clone-find-all
# It's surprisingly annoying not to be able to move the tree just created.
#@nonl
#@-node:ekr.20080922124033.3:Enter tree pane after clone-find-all
#@+node:ekr.20080918164844.10:Added autoCompleter.getExternalCompletions
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

> As I said, all I need would be is for leo to call callback/hook with
> signature like
> def complete(line-up-to-cursor, current_node) => list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color
#@nonl
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
    g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
    g.es(s,color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace('(autocompleter)',self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion (autocompleter)
def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion (autocompleter)
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.34:finish
def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning (not used)
if 0: # Not used at present.
    @others
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('','.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        for key in sorted(self.watchwords):
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        for key in sorted(self.calltips):
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning (not used)
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) ### Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):

    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@-node:ekr.20080918164844.10:Added autoCompleter.getExternalCompletions
#@+node:ekr.20081003123804.1:Added @nocolor-node directive
# Useful: we don't need a closing @color to enable coloring in descendants.
#@nonl
#@+node:ekr.20031218072017.2805:useSyntaxColoring
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    self.killFlag = False

    # New in Leo 4.6: @nocolor-node disables one node only.
    theDict = g.get_directives_dict(p)
    if 'nocolor-node' in theDict:
        return False

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        no_color = 'nocolor' in theDict
        color = 'color' in theDict
        kill_color = 'killcolor' in theDict
        # A killcolor anywhere disables coloring.
        if kill_color:
            self.killFlag = True
            return False
        # A color anywhere in the target enables coloring.
        elif color and p == first:
            return True
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            return False
        elif color and not no_color:
            return True

    return True
#@-node:ekr.20031218072017.2805:useSyntaxColoring
#@+node:EKR.20040610094819:<< define global data structures >>
# Visible externally so plugins may add to the list of directives.

globalDirectiveList = [
    # New in Leo 4.6:
    'markup', # Make this an official directive,
              # even if the color_markup directive is not enabled.
    'nocolor-node',
    # New in Leo 4.4.4: these used to be in leoKeywords.
    'all','c','code','delims','doc','end_raw',
    'first','last','others','raw','root-code','root-doc',
    # Old.
    "color", "comment", "encoding", "header", "ignore", "killcolor",
    "language", "lineending", "nocolor", "noheader", "nowrap",
    "pagewidth", "path", "quiet", "root", "silent",
    "tabwidth", "terse", "unit", "verbose", "wrap",
]
#@-node:EKR.20040610094819:<< define global data structures >>
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@nonl
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.1260:g.get_directives_dict
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(p,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    global globalDirectiveList

    if root: root_node = root[0]
    d = {'_p':p.copy()}

    # The headline has higher precedence because it is more visible.
    for kind,s in (
        ('body',p.v.t._headString),
        ('head',p.v.t._bodyString),
    ):
        i = 0 ; n = len(s)
        while i < n:
            if s[i] == '@' and i+1 < n:
                << set d for @ directives >>
            elif kind == 'body' and root and g.match(s,i,"<<"):
                << set d["root"] for noweb * chunks >>
            i = g.skip_line(s,i)
    return d
#@+node:ekr.20031218072017.1261:<< set d for @ directives >>
j = g.skip_id(s,i+1,chars='-')
word = s[i+1:j]

if word in globalDirectiveList:
    if d.get(word):
        # Ignore second value.
        pass
        # g.es("warning: conflicting values for",word,color="blue")
    else:
        k = g.skip_line(s,j)
        d[word] = s[j:k].strip()
#@nonl
#@-node:ekr.20031218072017.1261:<< set d for @ directives >>
#@+node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)

if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            d["root"]=0 # value not immportant
        else:
            g.es('',g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:g.get_directives_dict
#@+node:ekr.20080827175609.1:g.get_directives_dict_list
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to the start of each directive"""

    result = [] ; p1 = p1.copy()

    for p in p1.self_and_parents_iter():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    return result
#@-node:ekr.20080827175609.1:g.get_directives_dict_list
#@+node:ekr.20081003155540.2:Failed unit test
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20080828103146.12:c.scanAtRootDirectives
# Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
#@-node:ekr.20080828103146.12:c.scanAtRootDirectives
#@-node:ekr.20081003155540.2:Failed unit test
#@-node:ekr.20081003123804.1:Added @nocolor-node directive
#@+node:ekr.20081006100835.2:Added c.getNodePath and c.getNodeFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
#@nonl
#@+node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    filename = p.isAnyAtFileNode()
    return filename and g.os_path_finalize_join(path,filename) or None
#@-node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
#@-node:ekr.20081006100835.2:Added c.getNodePath and c.getNodeFileName
#@+node:ekr.20081022080424.1:Added support for meta keys
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1

Patches made to leoKeys.py
#@nonl
#@-node:ekr.20081022080424.1:Added support for meta keys
#@-node:ekr.20080917153158.15:New features
#@+node:ekr.20080930072519.8:New options
#@+node:ekr.20080910054558.2:Added -c option to specify config files
@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
#@nonl
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080910054558.2:Added -c option to specify config files
#@+node:ekr.20080917153158.16:Added c.config.getSettingSource
@nocolor

c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo

theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

@color
#@nonl
#@-node:ekr.20080917153158.16:Added c.config.getSettingSource
#@+node:ekr.20080930072519.1:Added support for @int icon_bar_widgets_per_row setting
#@+node:ekr.20061119120006:Icon area convenience methods
def addIconButton (self,*args,**keys):
    if self.iconBar: return self.iconBar.add(*args,**keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self,w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar (self):
    if self.iconBar: self.iconBar.clear()

def createIconBar (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar (self):
    if self.iconBar: self.iconBar.hide()

def showIconBar (self):
    if self.iconBar: self.iconBar.show()
#@-node:ekr.20061119120006:Icon area convenience methods
#@+node:ekr.20041223102225:class tkIconBarClass
class tkIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20041223102225.1: ctor
def __init__ (self,c,parentFrame):

    self.c = c

    self.buttons = {}

    # Create a parent frame that will never be unpacked.
    # This allows us to pack and unpack the container frame without it moving.
    self.iconFrameParentFrame = Tk.Frame(parentFrame)
    self.iconFrameParentFrame.pack(fill="x",pady=0)

    # Create a container frame to hold individual row frames.
    # We hide all icons by doing pack_forget on this one frame.
    self.iconFrameContainerFrame = Tk.Frame(self.iconFrameParentFrame)
        # Packed in self.show()

    self.addRow()
    self.font = None
    self.parentFrame = parentFrame
    self.visible = False
    self.widgets_per_row = c.config.getInt('icon_bar_widgets_per_row') or 10
    self.show() # pack the container frame.
#@-node:ekr.20041223102225.1: ctor
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080930072519.2:addRow
def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
#@-node:ekr.20080930072519.2:addRow
#@+node:ekr.20080930072519.5:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n >= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
#@-node:ekr.20080930072519.5:addRowIfNeeded
#@+node:ekr.20080930072519.6:addWidget
def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


#@-node:ekr.20080930072519.6:addWidget
#@+node:ekr.20031218072017.3956:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    f = self.iconFrameContainerFrame

    for slave in f.pack_slaves():
        slave.pack_forget()
    f.pack_forget()

    self.addRow(height='0m')

    self.visible = False

    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clear
#@+node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
def deleteButton (self,w):

    w.pack_forget()
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
#@+node:ekr.20041223114821:getFrame & getNewFrame
def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

#@-node:ekr.20041223114821:getFrame & getNewFrame
#@+node:ekr.20041223102225.2:pack (show)
def pack (self):

    """Show the icon bar by repacking it"""

    if not self.visible:
        self.visible = True
        self.iconFrameContainerFrame.pack(fill='x',pady=2)

show = pack
#@-node:ekr.20041223102225.2:pack (show)
#@+node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
def setCommandForButton(self,b,command):

    b.configure(command=command)
#@-node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
#@+node:ekr.20031218072017.3955:unpack (hide)
def unpack (self):

    """Hide the icon bar by unpacking it."""

    if self.visible:
        self.visible = False
        w = self.iconFrameContainerFrame
        w.pack_forget()

hide = unpack
#@-node:ekr.20031218072017.3955:unpack (hide)
#@-node:ekr.20041223102225:class tkIconBarClass
#@+node:ekr.20080930072519.7:New/changed code
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080930072519.6:addWidget
def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


#@-node:ekr.20080930072519.6:addWidget
#@+node:ekr.20080930072519.5:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n >= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
#@-node:ekr.20080930072519.5:addRowIfNeeded
#@+node:ekr.20080930072519.2:addRow
def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
#@-node:ekr.20080930072519.2:addRow
#@+node:ekr.20041223114821:getFrame & getNewFrame
def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

#@-node:ekr.20041223114821:getFrame & getNewFrame
#@+node:ekr.20070317073819.2:tt.createControl
def createControl (self):

    tt = self ; c = tt.c

    # Create the main container, possibly in a new row.
    tt.frame = c.frame.getNewIconFrame()

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)

    # Actually add tt.frame to the icon row.
    c.frame.addIconWidget(tt.frame)
#@nonl
#@-node:ekr.20070317073819.2:tt.createControl
#@-node:ekr.20080930072519.7:New/changed code
#@-node:ekr.20080930072519.1:Added support for @int icon_bar_widgets_per_row setting
#@+node:ekr.20081119132758.5:Added support for --gui option
#@-node:ekr.20081119132758.5:Added support for --gui option
#@-node:ekr.20080930072519.8:New options
#@+node:ekr.20081001140516.16:Plugins
#@+node:ekr.20081001140516.1:Improved nav_buttons plugin and corresponding nodeHistory class
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20070615131604:class nodeHistory
class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
#@+node:ekr.20070615131604.1: ctor (nodeHistory)
def __init__ (self,c):

    self.c = c
    self.beadList = []
        # list of (position,chapter) tuples for
        # nav_buttons and nodenavigator plugins.
    self.beadPointer = -1
    self.trace = False
#@nonl
#@-node:ekr.20070615131604.1: ctor (nodeHistory)
#@+node:ekr.20070615131604.3:canGoToNext/Prev
def canGoToNextVisited (self):

    if self.trace:
        g.trace(
            self.beadPointer + 1 < len(self.beadList),
            self.beadPointer,len(self.beadList))

    return self.beadPointer + 1 < len(self.beadList)

def canGoToPrevVisited (self):

    if self.trace:
        g.trace(self.beadPointer > 0,
            self.beadPointer,len(self.beadList))

    return self.beadPointer > 0
#@-node:ekr.20070615131604.3:canGoToNext/Prev
#@+node:ekr.20070615132939:clear
def clear (self):

    self.beadList = []
    self.beadPointer = -1
#@-node:ekr.20070615132939:clear
#@+node:ekr.20070615134813:goNext/Prev
def goNext (self):

    '''Return the next visited node, or None.'''
    if self.beadPointer + 1 < len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None

def goPrev (self):

    '''Return the previous visited node, or None.'''
    if self.beadPointer > 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None
#@-node:ekr.20070615134813:goNext/Prev
#@+node:ekr.20070615132939.1:remove
def remove (self,p):

    '''Remove an item from the nav_buttons list.'''

    c = self.c
    target = self.beadPointer > -1 and self.beadList[self.beadPointer]

    self.beadList = [z for z in self.beadList
                        if z[0] != p and c.positionExists(z[0])]

    try:
        self.beadPointer = self.beadList.index(target)
    except ValueError:
        self.beadPointer = max(0,self.beadPointer-1)

    if self.trace:
        g.trace('bead list',p.headString())
        g.pr([z[0].headString() for z in self.beadList])
#@-node:ekr.20070615132939.1:remove
#@+node:ekr.20070615140032:selectChapter
def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController

    if cc and chapter and chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
#@-node:ekr.20070615140032:selectChapter
#@+node:ekr.20070615131604.2:update
def update (self,p):

    c = self.c

    self.beadList = [z for z in self.beadList
                        if c.positionExists(z[0])]

    positions = [z[0] for z in self.beadList]

    try:
        self.beadPointer = positions.index(p)
    except ValueError:
        cc = c.chapterController
        theChapter = cc and cc.getSelectedChapter()
        data = (p.copy(),theChapter)
        self.beadList.append(data)
        self.beadPointer = len(self.beadList)-1

    if self.trace:
        g.trace('bead list',p.headString())
        g.pr([z[0].headString() for z in self.beadList])

#@-node:ekr.20070615131604.2:update
#@+node:ekr.20070615140655:visitedPositions
def visitedPositions (self):

    return [p.copy() for p,chapter in self.beadList]
#@-node:ekr.20070615140655:visitedPositions
#@-node:ekr.20070615131604:class nodeHistory
#@-node:ekr.20081001140516.1:Improved nav_buttons plugin and corresponding nodeHistory class
#@+node:ekr.20081005065934.11:Created qtGui plugin
#@-node:ekr.20081005065934.11:Created qtGui plugin
#@+node:ekr.20081121104952.2:Created leoGuiPluginsRef.leo
This contains all gui plugins.
#@nonl
#@-node:ekr.20081121104952.2:Created leoGuiPluginsRef.leo
#@-node:ekr.20081001140516.16:Plugins
#@-node:ekr.20080917153158.11:4.6
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
