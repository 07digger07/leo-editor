#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @thin leoProjects.txt
#@+all
#@+node:ekr.20100709113505.6257: ** Leo 4.7.1 projects
#@+node:ekr.20100709113505.6258: *3* Auto-convert thin-like external files
@
The fix involves disabling caching when a file has file-like sentinels,
regardless of whether the root node is spelled @file or @thin.

In addition, Leo's read code now issues a red warning message in the
console when converting files.
#@+node:ekr.20100709113505.6259: *4* Testing
#@+node:ekr.20100709113505.6260: *5* at-File test code (leoTest.py)
def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in (
        "@auto","@edit","@file","@thin","@nosent",
        "@asis",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@auto":
        at.writeOneAtAutoNode(child1,toString=True,force=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput)
        assert(result == expected)
    except AssertionError:
        << dump result and expected >>
        raise
#@+node:ekr.20100709113505.6261: *6* << dump result and expected >>
print('\n','-' * 20)
print("result...")
for line in g.splitLines(result):
    print("%3d" % len(line),repr(line))
print('-' * 20)
print("expected...")
for line in g.splitLines(expected):
    print("%3d" % len(line),repr(line))
print('-' * 20)
#@+node:ekr.20100709113505.6291: ** Leo 4.8 a1
#@+node:ekr.20100709113505.6292: *3* Bugs
#@+node:ekr.20100709113505.6293: *4* Fixed save scrolling bug
@nocolor-node

- Open a node with long (multipage) body text
- Move cursor towards the end of the node
- Save (ctrl+s)
- Observe how window is scrolled, cursor is moved
#@+node:ekr.20100709113505.6321: *4* Fixed recent save-to bug
#@+node:ekr.20100709113505.6322: *4* Fixed at-auto-rst crash
#@+node:ekr.20100709113505.6324: *5* Original traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2644, in writeOneAtAutoNode
    ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 683, in writeAtAutoFile
    self.writeNode(p) # side effect: advances p
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1509, in writeNode
    self.writeHeadline(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1438, in writeHeadline
    self.writeHeadlineHelper(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1477, in writeHeadlineHelper
    self.write(self.underline(h,p)) # Used by @auto-rst.
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1364, in write
    self.outputFile.write(s)
TypeError: must be bytes or buffer, not str
#@+node:ekr.20100709113505.6325: *5* Second traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2652, in writeOneAtAutoNode
    at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4547, in replaceTargetFileIfDifferent
    ignoreBlankLines=ignoreBlankLines):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4040, in compareFiles
    s1 = g.removeBlankLines(s1)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 5992, in removeBlankLines
    return ''.join(lines)
TypeError: sequence item 0: expected str instance, bytes found
saved: test.leo
#@+node:ekr.20100709113505.6335: *4* Investigated at-auto-rst bug
@nocolor-node
https://bugs.launchpad.net/leo-editor/+bug/532085

auto-rst isn't switching to a new title underline char. going from level 2 to 3
in the outline.

Changing to regular @rst and using the rst3 command to export works.

Tree:

Foo
    Bar
        This
        That
    Etc

Output:

Foo
===

Bar
+++

This
++++ <- still using '+' one level down

--------------------------------------------------


Another test and this seems as bad or worse,

A-+
    |
   C-+
       |
      D

is using '=' to underline all three levels.
#@+node:ekr.20100709113505.6341: *4* Don't put &nbsp; in redirected log
@nocolor-node
@

https://bugs.launchpad.net/leo-editor/+bug/549319

Leo 4.7.1 final, build 3005, February 26, 2010
Python 2.6.2, qt version 4.5.2
Windows 5, 1, 2600, 2, Service Pack 3

When redirecting the output to the Log pane using g.redirectStderr() and
g.redirectStdout(), the output displays non-breaking space characters (&nbsp;)
everywhere there is supposed to be a space.

For example, if I run print 'Hello World' I get Hello&nbsp;World in the Log
pane. This is really hard to read when you have 50 or 100 lines of numbers from
the output of a program.
#@+node:ekr.20100709113505.6357: *4* Fixed tangle bug
#@+node:ekr.20100709113505.6360: *4* Fixed crash in log pane
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 366, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 284, in autoComplete
    k.masterCommand(event,func=None,stroke=None,commandName=None)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2606, in masterCommand
    val = k.handleDefaultChar(event,stroke)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2664, in handleDefaultChar
    if stroke.lower() == 'return': stroke = '\n'
AttributeError: 'NoneType' object has no attribute 'lower'
#@+node:ekr.20100709113505.6363: *4* Patch for 64-bit aspell
#@+node:ekr.20100709113505.6367: *4* Fixed at-auto-rst bug
#@+node:ekr.20100709113505.6370: *4* Fixed erroneous error message in at-auto-rst read logic
#@+node:ekr.20100709113505.6375: *4* Fixed crasher in openFileForReading
#@+node:ekr.20100707124440.5869: *4* Fixed Java import problem
@nocolor-node

On Windows, using Leo trunk from a few days ago, I get "error: class
class does not end in a newline; one will be added [nl]" on what seems
to be every imported java chunk.

This issue seems to be line-ending related and I duplicated it with a
simple test.  When I run the following code from within a Leo node, I
get the same error as when I tried to import the file.
#@+node:ekr.20100707124440.5871: *5* test
# Java code from org.apache.commons.lang.immutable
s = '''
public class MutableBoolean implements Mutable, Serializable, Comparable {

   /**
    * Required for serialization support.
    *
    * @see java.io.Serializable
    */
   private static final long serialVersionUID = -4830728138360036487L;

}

'''
# If the string has DOS line endings then I see warnings like:
# 'class class does not end in a newline; one will be added [nl]'
# Without the DOS line endings (i.e. comment out this line), no warning seen

if 1: # Dos line endings creates the error.
    s = s.replace("\n", "\r\n")

# Import the code to a child of the current one
p.insertAsLastChild()
p.moveToLastChild()
c.importCommands.scanJavaText (s,p,atAuto=True)
c.redraw()
#@+node:ekr.20100707124440.5872: *6* newHeadline
@language java
@tabwidth -4
@others


@ignore
#@+node:ekr.20100707124440.5873: *7* class Mutable

public class MutableBoolean implements Mutable, Serializable, Comparable {

   /**
    * Required for serialization support.
    *
    * @see java.io.Serializable
    */
   private static final long serialVersionUID = -4830728138360036487L;

}
#@+node:ekr.20100728074713.5839: *4* Fixed gloto-global-line
#@+node:ekr.20100729045510.5825: *4* Fixed hard crash in delete_aspell_config
#@+node:ekr.20100731134533.5797: *4* Fixed rst3 bug with docutils on py3k
#@+node:ekr.20100801112314.11721: *4* Made sure that all @auto nodes end with a newline
@nocolor-node

The fix was to the "if not trailingNewlineFlag:" code at the end of at.putBody.
#@+node:ekr.20100121050224.6140: *4* Fixed vampire nodes and created p.deletePositionsInList
# Also, created a "Resurrected Nodes" node to handle such nodes cleanly and safely.
#@+node:ekr.20100802121531.5802: *5* Post re vampire nodes
@language rest

Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle
consequence of how Leo writes outlines and reads derived files.  This
is a big bug in Leo, not cvs.  The effect of the bug is that nodes can
appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the
following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such
files.  Maybe all @thin derived files should be -kb files, but Leo's
users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is
concerned.  Other .txt files, like leoScripts.txt, should also be
binary files.  As we shall see, the fact that leoProjects.txt is now a
-kb file means that we can not possibly blame the cvs merge algorithm
for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I
added a node called 'changed in the main line'.  In sandbox 2 I added
a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the
following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/
leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.
1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not**
been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge
surprise: the outline contains **both** the node 'changed in main-
line' and the node 'changed2'!

How did this happen?  Well, obviously the 'changed in main-line' node
came from the cvs update.  I expected that.  The 'changed2' line must
have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had
happened.  The 'changed2' is a descendant of a cloned node called '4.4
projects'.

- One clone of '4.4 projects' node is a descendant of the @thin
leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but
outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was
reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node
**already existed in the outline** before Leo read leoProjects.txt,
and the present atFile read logic only **adds** nodes, it never
deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read
logic.  The 'changed2' node became a 'vampire' node that couldn't be
killed.

The problem is far from benign.  Because of clones, the vampire node
became an orphan node in **another** file, namely leoKeys.py.  I tried
two or three times to remove the vampire/orphan node before realizing
what had happened.

The fix (there is *always* a fix) will require some care.  The present
atFile.read logic is robust because it *doesn't* delete nodes.  It is
essential that the read logic remain robust.  I suspect the solutions
will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes
initially, because it doesn't know whether there will be read errors
later.  If there are read errors absolutely nothing must change.  This
ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not
actually read from the derived file.  I think (but haven't proven)
that all descendents of vampire nodes are also vampire nodes.  If that
is so the post-pass will simply delete vampire nodes without worrying
about whether they have descendents.

Warning: the new scheme will mean that cvs update can destroy
information that previously existed in the outline.  I believe this is
correct: we assume that derived files are the 'truly meaningful'
files.  Hey, if we are wrong we can always get the old info from
cvs :-)
QQQ

At present, atFile.read contains code to warn of "resurrected" nodes,
and I did indeed get such a warning when the recent problem arose.

After a quick look at atFile.read, I strongly suspect that the problem
remains today pretty much exactly as it was in 2003.  The only
difference is that the caching code (the call to
root.v.createOutlineFromCacheList(c,aList)) doesn't do the check:
\<\< advise user to delete all unvisited nodes \>\>
that is done later in read(). That probably should be fixed.

Finding a better solution to vampire nodes has been on the list since
2003.  It's not easy because it involves the dreaded "multiple delete"
problem.

Hmm.  The present read code *does* delete the tree before reading thin
external files.  So it appears that vampire nodes could only be
expected in external files derived from @file nodes.  It may be that
part of the problem is that somehow Leo thinks that it is reading an
@file node?? That's pretty weird, but messages about resurrected nodes
and missing tnode lists did happen.  It's quite a puzzle.

Edward
#@+node:ekr.20071105164407: *5* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *6* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *6* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20100802121531.5804: *5* p.deletePositionsInList
def deletePositionsInList (self,aList,callback=None):

    '''Traverse the tree starting from self until all nodes in aList have been
    found.

    This method calls the callback for any position in aList found in the range,
    excluding any node whose ancestor has already been passed to the callback.

    The callback takes one explicit argument, p. As usual, the callback can bind
    values using keyword arguments. The callback may delete p or move p out of
    the range. The callback **must not** move p within range of the traversal.
    If no callback is given, this method deletes all found nodes.
    '''

    if callback is None:
        def callback(p):
            p.doDelete(newNode=None)

    p = self.copy()
    while p and aList:
        # g.trace(repr(p))
        if p in aList:
            aList.remove(p)
            for z in aList:
                if p.isAncestorOf(z):
                    aList.remove(z)
            next = p.nodeAfterTree()
            callback(p.copy())
            p = next
        else:
            p.moveToThreadNext()
#@+node:ekr.20100827095120.5871: *4* fixed bug 618474: show_leo_directives
@language python
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/618474

in core/leoRst the method removeLeoDirectives seems not to remove the leo directives.
which results in @leo directives inside generated rst code.

The problematic code line is the statement "g.match_word(s, 0,key)" in the following block:

                for key in self.leoDirectivesList:
                    if g.match_word(s, 0,key):
                        #g.trace('removing %s' % s)
                        break

As far as I understand the function match_word, it returns 1 if s contains key at index 0,
The self.leoDirectivesList contains all directive like color, language, ... (without @) but
s is a complete body line that looks like:
@language rest

That means language starts at index 1 not at 0.
changing the line to
  g.match_word(s, 1,key)

let it work correctly in my installation (4.7.1)
#@+node:ekr.20090502071837.80: *5* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20100827095120.5869: *4* fixed bug 618482: code-mode line feeds
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/618482

in leoRst.py:

the method "handleCodeMode" does not preserve line linefeeds of the original code. While this is only annoying for code
parts it is fatal for doc parts, because rst directives does not work anymore.

The problem is in the line "elif not z.rstrip(): pass" of the following code block at the end of the method
        for z in result:
            if z == '': result2.append('\n\n')
            elif not z.rstrip(): pass
            elif z.endswith('\n\n'): result2.append(z) # Leave alone.
            else: result2.append('%s\n' % z.rstrip())

Commenting this line out, preserves the linefeeds in the doc part but doubles them in the code part.

The method "rstripList" is responsible for the doubling linefeeds:
   The lines arguments is a list of lines with (!) trainling linefeeds (\n),

   The statement s = '\n'.join(theList).rstrip() doubles therefore the linefeeds
    replacing the line with s = ''.join(theList).rstrip() works.
#@+node:ekr.20090502071837.72: *5* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73: *6* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@+node:ekr.20090502071837.74: *6* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
#@+node:ekr.20090502071837.75: *6* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@+node:ekr.20100826110728.5843: *4* Fixed weave (and many similar) commands
#@+node:ekr.20100831090251.5839: *4* Take more care with inititing gui
#@+node:ekr.20100831090251.5838: *5* app.createXGui
#@+node:ekr.20100831090251.5840: *6* app.createCursesGui
def createCursesGui (self,fileName='',verbose=False):

    app = self

    app.pluginsController.loadOnePlugin('leo.plugins.cursesGui',verbose=verbose)
#@+node:ekr.20090619065122.8593: *6* app.createDefaultGui
def createDefaultGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to create the default gui class."""

    app = self ; argName = app.guiArgName

    # This method can be called twice if we had to get .leoID.txt.
    if app.gui: return

    if argName == 'qt':
        app.createQtGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Qt gui: trying Tk gui')
            app.createTkGui(fileName,verbose=verbose)  
    elif argName == 'tk':
        app.createTkGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Tk gui: trying Qt gui')
            app.createQtGui(fileName,verbose=verbose)
    elif argName == 'null':
        app.createNullGui()
    elif argName == 'curses':
        app.createCursesGui()

    if not app.gui:
        print('Leo requires either Tk or Qt to be installed.')
#@+node:ekr.20090202191501.5: *6* app.createNullGui
def createNullGui (self):

    # Don't import this at the top level:
    # it might interfere with Leo's startup logic.

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.gui = leoGui.nullGui("nullGui")
#@+node:ekr.20031218072017.1938: *6* app.createNullGuiWithScript
def createNullGuiWithScript (self,script=None):

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.batchMode = True
        app.gui = leoGui.nullGui("nullGui")
        app.gui.setScript(script)
#@+node:ekr.20090202191501.1: *6* app.createQtGui
def createQtGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the Qt gui class."""

    app = self

    try:
        # Take care to try the same imports as in qtGui.py.
        import PyQt4.QtCore
        import PyQt4.QtGui            
        import leo.plugins.qtGui as qtGui
    except ImportError:
        qtGui = None

    if qtGui:
        qtGui.init()
        if app.gui and fileName and verbose:
            print('qtGui created in %s' % fileName)
#@+node:ekr.20031218072017.2610: *6* app.createTkGui
def createTkGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to 
    create the default Tk gui class."""

    app = self

    try:
        import tkinter as Tk
    except ImportError:
        try:
            import Tkinter as Tk
        except ImportError:
            Tk = None

    Pmw = g.importExtension('Pmw',pluginName='startup',verbose=False)

    if Tk and Pmw:
        app.pluginsController.loadOnePlugin('leo.plugins.tkGui',verbose=verbose)
        if app.gui and fileName and verbose:
            print('tkGui created in %s' % fileName)
#@+node:ekr.20090126063121.3: *6* app.createWxGui
def createWxGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the wx gui class."""

    app = self

    app.pluginsController.loadOnePlugin ('leo.plugins.wxGui',verbose=verbose)

    if fileName and verbose:

        print('wxGui created in %s' % fileName)
#@+node:ekr.20100831090251.5841: *4* Shorter warnings about incompatible gui type
#@+node:ekr.20031218072017.2278: *5* g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):

    trace = False and not g.unitTesting
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path)
    module = sys.modules.get(moduleName)
    if module:
        if trace: g.trace('already loaded',moduleName,module)
        return module

    try:
        theFile = None
        import imp
        try:
            data = imp.find_module(moduleName,[path]) # This can open the file.
            theFile,pathname,description = data
            module = imp.load_module(moduleName,theFile,pathname,description)
        except ImportError:
            if trace: # or verbose:
                g.es_print("exception in g.importFromPath",color='blue')
                g.es_exception()
        except UiTypeException:
            if not g.unitTesting and not g.app.batchMode:
                g.es_print('Plugin %s does not support %s gui' % (
                    name,g.app.gui.guiName()))          
        except Exception:
            g.es_print("unexpected exception in g.importFromPath(%s)" %
                (name),color='blue')
            g.es_exception()
    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()

    if module:
        if trace: g.trace('loaded',moduleName)
    else:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@+node:ekr.20041113113140: *5* loadOnePlugin
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.startswith('@'):
        if trace: g.trace('ignoring Leo directive')
        return False # Allow Leo directives in @enabled-plugins nodes.

    if moduleOrFileName.endswith('.py'):
        moduleName = 'leo.plugins.' + moduleOrFileName [:-3]
    elif moduleOrFileName.startswith('leo.plugins.'):
        moduleName = moduleOrFileName
    else:
        moduleName = 'leo.plugins.' + moduleOrFileName

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    moduleName = g.toUnicode(moduleName)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)

    try:
        toplevel = __import__(moduleName)
        # need to look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]

    except g.UiTypeException:
        if not g.unitTesting and not g.app.batchMode:
            g.es_print('Plugin %s does not support %s gui' % (
                moduleName,g.app.gui.guiName()))
        result = None

    except ImportError:
        if trace or tag == 'open0': # Just give the warning once.
            g.es_print('plugin does not exist:',moduleName,color='red')
        result = None

    except Exception as e:
        g.es_print('exception importing plugin ' + moduleName,color='red')
        g.es_exception()
        result = None

    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20100907092144.6079: *4* Improved @enabled-plugins: ignore lines starting with '@'
Also give calmer messages for non-existent plugins.
#@+node:ekr.20101009135202.5932: *4* Preserve expansion bits!!
#@+node:ekr.20070325104904: *5* cc.finishCreate
def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    # g.trace('(chapterController)',g.callers(4))

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if 0: # Now done in cc.createChapterNode.
        if not cc.chaptersNode and not cc.findChaptersNode():
            cc.createChaptersNode()

    if cc.findChaptersNode():
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.all_unique_positions():
        h = p.h
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    # Always select the main chapter.
    # It can be alarming to open a small chapter in a large .leo file.
    cc.selectChapterByName('main',collapse=False)
        # 2010/10/09: an important bug fix!
#@+node:ekr.20031218072017.3395: *5* v.contract & expand & initExpandedBit
def contract(self):

    # if self.context.p.v == self: g.trace(self,g.callers(4))
    # if self.isExpanded(): g.trace(self,g.callers())

    self.statusBits &= ~ self.expandedBit

def expand(self):

    # g.trace(self,g.callers(4))

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    # g.trace(self._headString)

    self.statusBits |= self.expandedBit
#@+node:ekr.20090306060344.2: *5* selectChapterHelper
def selectChapterByNameHelper (self,chapter,collapse=True):

    cc = self ; c = cc.c

    if chapter != cc.selectedChapter:
        if cc.selectedChapter:
            cc.selectedChapter.unselect()
        chapter.select()
        c.setCurrentPosition(chapter.p)
        cc.selectedChapter = chapter

        # New in Leo 4.6 b2: clean up, but not initially.
        if collapse and chapter.name == 'main':
            for p in c.all_unique_positions():
                # 2010/01/26: compare vnodes, not positions.
                if p.v != c.p.v:
                    p.contract()

        # New in Leo 4.6 b2: *do* call c.redraw.
        c.redraw()
#@+node:ekr.20101019185106.5934: *4* Fixed bug in runUnitTestLeoFile
Replace ';' by os.pathsep.
#@+node:ekr.20101021101942.6009: *4* Fixed unicode bug in files
@nocolor-node

I created a file time.leo. When it's in the dir d:/Dmitry it's being
opened fine. But when I put it into the dir with russian characters:
D:/Личное/Время leo prints squares at the window header and doesn't
open the file correctly. This problem existed in one of the revisions,
then it was fixed in the last official release. Now it emerged again
in my Leo 4.8 devel, build 3005

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 3307, in pr
    sys.stdout.write(s2)
  File "c:\python31\lib\encodings\cp437.py", line 19, in encode
    return codecs.charmap_encode(input,self.errors,encoding_map)[0]

UnicodeEncodeError: 'charmap' codec can't encode character '\xc2' in position 31: character maps to <undefined>
path changed for @thin Unicode-Â-folder/unicode-Â-test2.txt
created: C:\Users\edreamleo\Unicode-Â-folder\unicode-Â-test2.txt
#@+node:ekr.20041005105605.149: *5* at.writeAllHelper
def writeAllHelper (self,p,
    force,toString,writeAtFileNodesFlag,writtenFiles
):

    trace = True and not g.unitTesting
    at = self ; c = at.c

    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        pathChanged = False
    else:
        oldPath = at.getPathUa(p).lower()
        newPath = at.fullPath(p).lower()
        pathChanged = oldPath and oldPath != newPath
        # 2010/01/27: suppress this message during save-as and save-to commands.
        if pathChanged and not c.ignoreChangedPaths:
            at.setPathUa(p,newPath) # Remember that we have changed paths.
            g.es_print('path changed for',p.h,color='blue')
            if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
                p.h,repr(oldPath),repr(newPath)))

    if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v in writtenFiles:

        # Tricky: @ignore not recognised in @asis nodes.
        if p.isAtAsisFileNode():
            at.asisWrite(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtIgnoreNode():
            pass
        elif p.isAtAutoNode():
            at.writeOneAtAutoNode(p,toString=toString,force=force)
            writtenFiles.append(p.v)
        elif p.isAtEditNode():
            at.writeOneAtEditNode(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtNoSentFileNode():
            at.write(p,kind='@nosent',nosentinels=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtShadowFileNode():
            at.writeOneAtShadowNode(p,toString=toString,force=force or pathChanged)
            writtenFiles.append(p.v)
        elif p.isAtThinFileNode():
            at.write(p,kind='@thin',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtFileNode():
            # Write old @file nodes using @thin format.
            at.write(p,kind='@file',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
#@+node:ekr.20080710101653.1: *5* g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if app.logInited:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2)
        except Exception:
            g.es('unexpected exception in g.pr')
            # if not g.pr_warning_given:
                # g.pr_warning_given = True
                # # print('unexpected Exception in g.pr')
                # # print('make sure your sitecustomize.py contains::')
                # # print('    sys.setdefaultencoding("utf-8")')
                # g.es_exception()
                # g.trace(g.callers())
            # s2 = s.encode('ascii',"replace")
            # if g.isPython3:
                # s2 = str(s2,'ascii','replace')
            # sys.stdout.write(s2)
    else:
        app.printWaiting.append(s2)
#@+node:ekr.20101021112112.5947: *5* pr tests
import sys
g.es(sys.stdout.encoding)
# g.es(sys.stdout.errors)
#@+node:ekr.20101021112112.5948: *4* Fixed unicode bug when dragging
@nocolor-node

Bug 659211: drag and drop unicode error
#@+node:ekr.20100709113505.6383: *3* Features
#@+node:ekr.20100517130356.5809: *4* New sentinels
#@+node:ekr.20100709113505.6384: *4* Fixed the @test logic
#@+node:ekr.20100709113505.6386: *5* patch
# Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
#@+node:ekr.20100709113505.6387: *4* Allow changing minibuffer colors
@nocolor-node

Added the following options with the indicated defaults.

\@color minibuffer_background_color = lightblue
\@color minibuffer_warning_color = lightgrey
#@+node:ekr.20100709113505.6405: *4* Added legend for print-settings command
#@+node:ekr.20100709113505.6407: *4* Added support for @string qt-toolbar-location
Valid values are top,bottom,left,right
#@+node:ekr.20100709113505.6408: *4* Added g.app.config.config_iter
This simplifies the print-settings command.
#@+node:ekr.20100709113505.6412: *4* Don't create @chapter node for new file
@nocolor-node

I think @chapters node shouldn't be in a new leo file, but it should
be created when the first chapter is created.

Ditto for the chapter selector toolbar button.
#@+node:ekr.20100728074713.5838: *4* Remember whether @asis/@nosent existed at read time
@nocolor-node
@

Removed all traces of the "significant change" logic. The read code remembers
whether a node existed when Leo loaded the outline.

Leo will warn when writing a node that didn't previously exist. This is a nice
simplification of the code.
#@+node:ekr.20100731091712.5828: *4* Can we put up the LeoID dialog later?
@nocolor-node

It is needed to set g.app.nodeIndices, which is used in the read logic for outlines,
so it *must* be set before we load any Leo file!  Thus, alas, it is not possible.
#@+node:ekr.20100731091712.5829: *4* Be more clever in putting up the Leo id dialog
@nocolor-node

g.app.setLeoID now calls createDefaultGui instead of createTkGui.
#@+node:ekr.20100731114918.5843: *4* Improved install instructions & logic
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/a5a47afa65af9a37

The following changes are on the trunk, and also on Leo's web site:

- In home page, added link to Install page, just above the Beginner's Guide.

- Added more explicit instructions for installing Tk and Qt.

- In step 6 of the Windows install steps, the "assoc .leo=LeoFile"
  is on a line by itself.

- Updated home page to indicate that Leo requires Python and PyQt.
  I also revised and simplified the introduction in other ways.
  Ditto for description of Leo on SourceForge.

- Changed "%1" to "%*" throughout the installation instructions.

- Made batch files given in Installing Leo and Running Leo the same.

- The dialogs that ask for the Leo ID now tells why Leo needs it.

- Just before raising the dialog that asks for the Leo ID, Leo attempts
  to create the Qt Qui first, and then the Tk Gui if Qt does not exist.
  This should make it much less likely that a prompt for the id
  will be sent to the console.


2. The readme.txt file for 4.7.1-final does not mention that Python and PyQt is
   required.

readme.txt does say it has a new Windows installer. This
led me to believe -- erroneously -- that the Windows installer is all
I would need to download and install, since it's typical for most open
source programs I've used to have everything needed for the install
(for example. .NET) in the single Windows download.

2b. And perhaps the readme.txt file as well?

Can the [install] page be updated to make this clearer?

4. When I first went to the Install page, I clicked on the link for
"Installing Leo on Windows", got to the end of the steps and saw the
next section was "Tracking the development version" which I wasn't
interested in doing so I didn't read any further.

Clicking on the installer-created Windows link for Leo on the Start
Menu did nothing. Eventually I found the Windows section under
"Running Leo" and learned it was required to run Leo the first time
from a console window and not by launching it from Windows.
#@+node:ekr.20100801112314.11718: *4* Improved handling of history
@nocolor-node

nav_qt.py just uses these:

    c.goPrevVisitedNode()
    c.goNextVisitedNode()

and these subsequently use leoCommand.py / class nodeHistory.

The fix would have to happen in leoFrame.py / selectHelper() which does this:

    c.nodeHistory.update(p) # Remember this position.

It shouldn't call update() there. Rather, the call should be moved to
wherever body focus code is.

The fix was to leoTree.selectHelper and qtBody.onFocusIn.

#@+node:ekr.20100803231223.5806: *4* Added ini importer
#@+node:ekr.20100803231223.5807: *5* class iniScanner
class iniScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,
            importCommands,atAuto=atAuto,language='ini')

        # Override defaults defined in the base class.
        self.classTags = []
        self.functionTags = []
        self.hasClasses = False
        self.hasFunctions = True
        self.lineCommentDelim = ';'

    def startsString(self,s,i):
        return False

    @others
#@+node:ekr.20100803231223.5810: *6* startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    sigStart = i
    ok,sigId,i = self.isSectionLine(s,i)
    if not sigId or not ok:
        # if trace: g.trace('fail',repr(g.getLine(s,i)))
        return False

    i = sigEnd = g.skip_line(s,i)

    # Skip everything until the next section.
    while i < len(s):
        progress = i
        ok,junk,junk = self.isSectionLine(s,i)
        if ok: break # don't change i.
        i = g.skip_line(s,i)
        assert progress < i

    # Success: set the ivars.
    self.sigStart = sigStart
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = None

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    if trace: g.trace(sigId,'returns\n'+s[self.sigStart:i]+'\nEND')
    return True
#@+node:ekr.20100803231223.5815: *6* isSectionLine
def isSectionLine(self,s,i):

    i = g.skip_ws(s,i)
    if not g.match(s,i,'['):
        return False,None,i
    k = s.find('\n',i+1)
    if k == -1: k = len(s)
    j = s.find(']',i+1)
    if -1 < j < k:
        return True,s[i:j+1],i
    else:
        return False,None,i
#@+node:ekr.20100812082517.5943: *4* Added code-to-rst command
# And deprecated code mode.
#@+node:ekr.20100813041139.5917: *4* Added g.findTestScript
The typical usage::

    g.findTestScript(c,'@common code for tests of x')
#@+node:ekr.20100827114047.5891: *4* Removed mark-clones command
It is useless in the one-node world.
#@+node:ekr.20100830095308.5828: *4* Can we write all top-level tnodes?
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isEdit:   forceWrite = False     # Never write non-ignored @edit trees.
    elif isShadow: forceWrite = False     # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20060919110638.5: *5* fc.createSaxChildren & helpers
def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') > -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
#@+node:ekr.20060919110638.7: *6* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
#@+node:ekr.20060919110638.8: *7* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
#@+node:ekr.20061004053644: *7* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes
    # if trace and d: g.trace(d)

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
#@+node:ekr.20041005105605.72: *5* at.createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees."""

    trace = False and not g.unitTesting
    verbose = False
    at = self ; c = at.c ; indices = g.app.nodeIndices
    parent = last = at.lastThinNode # A vnode.
    lastIndex = last.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last,gnxString,headline))

    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(parent,child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies,headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace:g.trace('found last',last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child',child)
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the vnode only if it does not already exist.
        gnxDict = c.fileCommands.gnxDict
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.trace('can not happen: v.fileIndex: %s gnx: %s' % (
                    v.fileIndex,gnx))
        else:
            v = leoNodes.vnode(context=c)
            v._headString = headline # Allowed use of v._headString.
            v.fileIndex = gnx
            gnxDict[gnxString] = v

        child = v
        child._linkAsNthChild(parent,parent.numberOfChildren())

    if trace: g.trace('new node: %s' % child)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
#@+node:ekr.20070806111212: *5* readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545: *6* readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # 2010/01/15: Remember that we have read this file.
    # http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
    # Important: createOutline usually sets the bit in the wrong node.
    p.v.at_read = True # Create the attribute

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@+node:ekr.20100901080826.5851: *4* Improved abbreviation commands
@nocolor-node

- Space activates abbreviations.
- Multi-line abbreviations handled properly.
- add-global-abbrev command uses entire selected text as the value of the abbreviation.
- Inserted abbreviations are undoable.
- Added support for @data abbreviations and @data global-abbreviations.
- Added support for @bool enable-abbreviations.
#@+node:ekr.20100901080826.5850: *5* aproposAbbreviations
@pagewidth 45

def aproposAbbreviations (self,event=None):

    s = '''\

apropos-abbreviations
=====================

When abbreviation mode is on (abbrev-mode
toggles this mode) Leo will expand
abbreviations as you type. Type the name of
an abbreviation, followed by a space. As soon
as you type the space, Leo will replace the
name by the abbreviations value. You can undo
the replacement as usual.

Note that defining any abbreviation
automatically turns on abbreviation mode.

The add-global-abbreviation command
(<alt-x>add-gl<tab><return>) takes the
selected text as the replacement value of the
abbreviation. The minibuffer prompts you for
the name of the abbreviation.

Settings
========

As usual, the following settings have effect
only in @settings trees:

@bool enable-abbreviations (default: False)

When true, enables substitution of
abbreviations.

@data global-abbreviations
@data abbreviations

In both cases, body text contains lines of
the form::

   name=value

name is the abbreviation name, value is the
substituted text. Whitespace is ignore around
the name, but is significant in the value.
Abbreviation names may contain only
alphabetic characters, but may start with the
'@' sign.

By *convention* @data global-abbreviations
setting should be defined in
myLeoSettings.leo, while @data abbreviations
should be defined in other .leo files.
Regardless of where they are defined,
abbreviations in @data abbreviation nodes
will override settings (with the same name)
in @data global-abbreviations nodes.

Commands
========

apropos-abbreviations

Prints this summary.

dabbrev-completion

Insert the common prefix of all dynamic
abbreviations matching the present word.
Similar C-M-/ in Emacs.

dabbrev-expands

Expand the word in the buffer before point as
a dynamic abbrev, by searching in the buffer
for words starting with that abbreviation
(dabbrev-expand). Similar to M-/ in Emacs

abbrev-mode

Toggles abbreviation mode. Abbreviations are
only active when this mode is on.

add-global-abbrev

Adds an abbreviation for the selected text.
The minibuffer prompts for the abbreviation
name.

inverse-add-global-abbrev

Adds an abbreviation. The selected text is
the abbreviation name. The minibuffer prompts
for the value of the abbreviation.

kill-all-abbrevs

Removes all abbreviations.

list-abbrevs

Lists all active abbreviations.

read-abbrev-file

Read an external file containing
abbreviations.

write-abbrev-file

Writes abbreviations to an external file.

Scripting
=========

Leo scripts may read abbreviations from a file with::

    c.abbrevCommands.readAbbreviationsFromFile(fn)

'''

    if not g.app.unitTesting:
        g.es(g.adjustTripleString(s.rstrip(),
            self.c.tab_width))
#@+node:ekr.20100902090334.5858: *4* DnD creates @thin or @auto nodes if appropriate
#@+node:ekr.20041005105605.120: *5* at.parseLeoSentinel
def parseLeoSentinel (self,s):

    trace = False and not g.unitTesting
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    start = '' ; end = '' ; isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    if trace:
        g.trace('valid',valid,'isThin',isThinDerivedFile)
    return valid,new_df,start,end,isThinDerivedFile
#@+node:ekr.20041005105605.121: *6* << set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    if trace: g.trace('no opening delim')
    valid = False

#@+node:ekr.20041005105605.122: *6* << make sure we have @+leo >>
@
REM hack: leading whitespace is significant before the
@+leo. We do this so that sentinelKind need not skip
whitespace following self.startSentinelComment. This is
correct: we want to be as restrictive as possible about what
is recognized as a sentinel. This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else:
    if trace: g.trace('no @+leo')
    valid = False
#@+node:ekr.20041005105605.123: *6* << read optional version param >>
new_df = g.match(s,i,version_tag)

if trace and not new_df:
    g.trace('not new_df',repr(s[0:100]))

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line,
    #                or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i < len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1
    at.readVersion = s[j:i] # 2010/05/18.
    at.readVersion5 = at.readVersion >= '5'

    if j < i:
        pass
    else:
        if trace: g.trace('no version')
        valid = False
#@+node:ekr.20041005105605.124: *6* << read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@+node:ekr.20041005105605.125: *6* << read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            g.es_print("bad encoding in derived file:",encoding)
    else:
        if trace: g.trace('no encoding')
        valid = False
#@+node:ekr.20041005105605.126: *6* << set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@+node:ekr.20100125073206.8710: *5* g.readFileIntoString (Leo 4.7)
def readFileIntoString (fn,
    encoding='utf-8',
    kind=None,
    mode='rb',
    raw=False,
    silent=False,
):

    '''Return the contents of the file whose full path is fn.

    Return (s,e)
    s is the string, converted to unicode, or None if there was an error.
    e the encoding line for Python files: it is usually None.
    '''

    try:
        e = None
        f = open(fn,mode)
        s = f.read()
        f.close()
        if raw:
            return s,None
        else:
            # Python's encoding comments override everything else.
            if s:
                junk,ext = g.os_path_splitext(fn)
                if ext == '.py':
                    e = g.getPythonEncodingFromString(s)
            s = g.toUnicode(s,encoding=e or encoding)
            return s,e
    except IOError:
        # Translate 'can not open' and kind, but not fn.
        # g.trace(g.callers(5))
        if not silent:
            if kind:
                g.es('can not open','',kind,fn,color='red')
            else:
                g.es('can not open',fn,color='red')
    except Exception:
        g.trace('unexpected exception reading %s' % (fn),color='red')
        g.es_exception()

    import leo.core.leoTest as leoTest
    leoTest.fail()
    return None,None
#@+node:ekr.20080923070954.4: *5* atFile.scanAllDirectives
def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
    createPath=True,
    issuePathWarning=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    trace = False and not g.unitTesting
    at = self ; c = self.c
    g.app.atPathInBodyWarning = None
    << set ivars >>
    lang_dict = {'language':at.language,'delims':delims,}
    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    if issuePathWarning and g.app.atPathInBodyWarning:
        g.es('warning: ignoring @path directive in',
            g.app.atPathInBodyWarning,color='red')

    # Post process.
    lang_dict       = d.get('lang-dict')
    delims          = lang_dict.get('delims')
    lineending      = d.get('lineending')
    if lineending:
        at.explicitLineEnding = True
        at.output_newline = lineending
    else:
        at.output_newline = g.getOutputNewline(c=c) # Init from config settings.

    at.encoding             = d.get('encoding')
    at.language             = lang_dict.get('language')
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>

    # For unit testing.
    d = {
        "all"       : all,
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
    if trace: g.trace(d)
    return d
#@+node:ekr.20080923070954.14: *6* << Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@+node:ekr.20080923070954.13: *6* << Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@+node:ekr.20041005105605.13: *5* initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):

    importing = importFileName is not None

    self.initCommonIvars()

    << init ivars for reading >>

    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.fromString = False
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = False # 2010/01/22: was thinFile
    self.atShadow = atShadow
#@+node:ekr.20041005105605.14: *6* << init ivars for reading >>
self.cloneSibCount = 0
    # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelIndentStack = []
    # Restored indentation for @-others and @-<< sentinels.
    # Used only when readVersion5.
self.endSentinelStack = []
    # Contains entries for +node sentinels only when not readVersion5
self.endSentinelLevelStack = []
    # The saved level, len(at.thinNodeStack), for @-others and @-<< sentinels.
    # Used only when readVersion5.
self.endSentinelNodeStack = []
    # Used only when readVersion5.
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastRefNode = None
    # The previous reference node, for at.readAfterRef.
    # No stack is needed because -<< sentinels restore at.v
    # to the node needed by at.readAfterRef.
self.lastThinNode = None
    # The last thin node at this level.
    # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.readVersion = '' # New in Leo 4.8: "4" or "5" for new-style thin files.
self.readVersion5 = False # synonym for at.readVersion >= '5' and not atShadow.
self.rootSeen = False
self.tnodeList = []
    # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.vStack = [] # Stack of at.v values.
self.thinNodeStack = [] # Entries are vnodes.
self.updateWarningGiven = False
#@+node:ekr.20041005105605.21: *5* at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h)
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        if trace: g.trace('Init error')
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif fromString: # 2010/09/02.
        pass
    else:
        g.trace('No inputFile')
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    if fromString:
        s,loaded,fileKey = fromString,False,None
    else:
        s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # 2010/02/24: Never read an external file
    # with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.deleteUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToVnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike:
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    if at.errors == 0 and not isFileLike and not fromString:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('at.errors',at.errors)
    return at.errors == 0
#@+node:ekr.20041005105605.25: *6* at.deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@+node:ekr.20100122130101.6174: *6* at.deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@+node:ekr.20071105164407: *6* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *7* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *7* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20041005105605.22: *6* at.initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@+node:ekr.20100224050618.11547: *6* at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@+node:ekr.20041005105605.19: *5* at.openFileForReading
def openFileForReading(self,fromString=False):

    '''Open the file given by at.root.
    This will be the private file for @shadow nodes.'''

    trace = False and not g.app.unitTesting
    verbose = False
    at = self ; c = at.c

    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.inputFile = g.fileLikeObject(fromString=fromString)
        fn = None
    else:
        fn = at.fullPath(self.root)
            # Returns full path, including file name.
        at.setPathUa(self.root,fn) # Remember the full path to this node.
        if trace: g.trace(fn)

        if at.atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn     = x.shadowPathName(fn)
            shadow_exists = g.os_path_exists(shadow_fn) and \
                g.os_path_isfile(shadow_fn)
            if not shadow_exists:
                g.trace('can not happen: no private file',
                    shadow_fn,g.callers())
                return at.error(
                    'can not happen: private file does not exist: %s' % (
                        shadow_fn))
            # This method is the gateway to the shadow algorithm.
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            if trace and verbose and at.atShadow:
                g.trace('opening %s file: %s' % (
                    g.choose(at.atShadow,'private','public'),fn))
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
            fn = None

    return fn
#@+node:ekr.20100831144649.5844: *4* write @edit nodes like @nosent nodes
@nocolor-node

at-edit nodes:
at.writeOneAtEditNode(p,toString=toString)

at-nosent nodes 
at.write(p,kind='@nosent',nosentinels=True,toString=toString)

#@+node:ekr.20090225080846.3: *5* at.readOneAtEditNode
def readOneAtEditNode (self,fn,p):

    at = self ; c = at.c ; ic = c.importCommands
    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = c.os_path_finalize_join(at.default_directory,fn)
    junk,ext = g.os_path_splitext(fn)

    # 2010/7/28: Remember that we have seen the @edit node.
    p.v.at_read = True # Create the attribute

    if not g.unitTesting:
        g.es("reading @edit:", g.shortFileName(fn))

    s,e = g.readFileIntoString(fn,kind='@edit')
    if s is None: return
    encoding = g.choose(e is None,'utf-8',e)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html','.htm'):   head = '@language html\n'
    elif ext in ('.txt','.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor\n'

    p.b = g.u(head) + g.toUnicode(s,encoding=encoding,reportErrors='True')

    if not changed: c.setChanged(False)
    g.doHook('after-edit',p=p)
#@+node:ekr.20041005105605.198: *5* directiveKind4 (write logic)
def directiveKind4(self,s,i):

    """Return the kind of at-directive or noDirective."""

    trace = False and not g.unitTesting
    at = self
    n = len(s)

    if trace and s.startswith('@'): g.trace(s.rstrip())

    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective),
        ("@verbatim",at.startVerbatim))

    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # New in Leo 4.4.3: add support for add_directives plugin.
    for name in g.globalDirectiveList:
        if g.match_word(s,i+1,name):
            return at.miscDirective

    return at.noDirective
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isEdit:   forceWrite = False     # Never write non-ignored @edit trees.
    elif isShadow: forceWrite = False     # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20041005105605.157: *5* at.writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self
    s = g.choose(fromString,fromString,root.v.b)
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=%s" % (
        g.choose(at.writeVersion5,5,4)))
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
    if not toString:
        at.warnAboutOrphandAndIgnoredNodes()
#@+node:ekr.20090225080846.5: *5* at.writeOneAtEditNode
def writeOneAtEditNode(self,p,toString,force=False):

    '''Write one @edit node.'''

    at = self ; c = at.c ; root = p.copy()
    c.endEditing()

    fn = p.atEditNodeName()
    if not fn and not toString: return False

    if p.hasChildren():
        g.es('@edit nodes must not have children',color='red')
        g.es('To save your work, convert @edit to @auto or @thin')
        return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = c.os_path_finalize_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)
    if not hasattr(root.v,'at_read') and exists:
        # Prompt if writing a new @edit node would overwrite the existing file.
        ok = self.promptForDangerousWrite(fn,kind='@edit')
        if ok:
            root.v.at_read = True # Create the attribute for all clones.
        else:
            g.es("not written:",fn)
            return False

    at.targetFileName = fn
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True, atEdit=True,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=toString)

    # Compute the file's contents.
    # Unlike the @nosent file logic it does not add a final newline.
    contents = ''.join([s for s in g.splitLines(p.b)
        if at.directiveKind4(s,0) == at.noDirective])

    if toString:
        at.stringOutput = contents
        return True

    ok = at.openFileForWriting(root,fileName=fn,toString=False)
    if ok:
        self.os(contents)
        at.closeWriteFile()
    if ok and at.errors == 0:
        at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
    else:
        g.es("not written:",at.outputFileName)
        root.setDirty()

    return ok
#@+node:ekr.20100903162809.5920: *4* Leo now uses PyEnchant to check spelling
This is much safer than the old Aspell wrapper.
#@+node:ekr.20051025071455: *5* Spell classes
@others
#@+node:ekr.20051025071455.1: *6* class spellCommandsClass
class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
#@+node:ekr.20051025080056: *7* ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
#@+node:ekr.20051025080420: *7* getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
#@+node:ekr.20051025080633: *7* openSpellTab
def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
#@+node:ekr.20051025080420.1: *7* commands...(spellCommandsClass)
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.
# self.handler is a spellTabHandler object (inited by openSpellTab)

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        # A workaround for a pylint warning:
        # self.handler.changeThenFind()
        f = getattr(self.handler,'changeThenFind')
        f()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@+node:ekr.20051025071455.18: *6* class spellTabHandler (leoFind.leoFind)
class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
#@+node:ekr.20051025071455.19: *7* Birth & death
#@+node:ekr.20051025071455.20: *8* spellTabHandler.__init__
def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    if enchant:
        self.spellController = EnchantClass(c)
        # self.controller = self.spellController 
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
        self.loaded = True
    else:
        self.spellController = None
        self.tab = None
        self.loaded = False
#@+node:ekr.20051025071455.36: *7* Commands
#@+node:ekr.20051025071455.37: *8* add (spellTab)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    w = self.currentWord

    if w:
        self.spellController.add(w)
        # self.dictionary[w] = 0
        self.tab.onFindButton()
#@+node:ekr.20051025071455.38: *8* change (spellTab)
def change(self,event=None):
    """Make the selected change to the text"""

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        if hasattr(self.tab,'change_i') and self.tab.change_i is not None:
            start,end = oldSel = self.tab.change_i,self.tab.change_j
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start is not None:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
#@+node:ekr.20051025071455.40: *8* find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45: *9* findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    w = c.frame.body.bodyCtrl
    sc = self.spellController
    alts = None ; word = None
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '<no p>')
            if not p or not word:
                alts = None
                break
            alts = sc.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if c.sparse_spell and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents():
                        p2.contract()
                        redraw = True
                for p2 in p.parents():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.47: *9* findNextWord (spellTab)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'-->',p.h)

    return None,None,None,None
#@+node:ekr.20051025121408: *8* hide
def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    # for message in self.messages:
        # g.es(message,color='blue')

    # self.messages = []
#@+node:ekr.20051025071455.41: *8* ignore
def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    w = self.currentWord

    if w:
        self.spellController.ignore(w)
        self.tab.onFindButton()
#@+node:ekr.20100904095239.5914: *6* class EnchantClass
class EnchantClass:

    """A wrapper class for PyEnchant spell checker"""

    @others
#@+node:ekr.20100904095239.5916: *7*  __init__ (EnchantClass)
def __init__ (self,c):

    """Ctor for the EnchantClass class."""

    self.c = c
    language = c.config.getString('enchant_language')

    # Set the base language
    if language and not enchant.dict_exists(language):
        g.es_print('Invalid language code for Enchant',language_code,color='blue')
        g.es('Using "en_US" instead')
        language = 'en_US'

    # Compute fn, the full path to the local dictionary.
    fn = g.os_path_finalize(
        c.config.getString('enchant_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if fn and g.os_path_exists(fn):
        # Merge the local and global dictionaries.
        try:
            self.d = enchant.DictWithPWL(language,fn)
        except Exception:
            g.es_exception()
            g.es_print('not a valid dictionary file',fn,color='red')
            self.d = enchant.Dict(language) 
    else:
        self.d = enchant.Dict(language) 
#@+node:ekr.20100904095239.5927: *7* add
def add (self,word):

    '''Add a word to the user dictionary.'''

    self.d.add(word)
#@+node:ekr.20100904095239.5928: *7* ignore
def ignore (self,word):

    self.d.add_to_session(word)
#@+node:ekr.20100904095239.5920: *7* processWord
def processWord(self, word):

    """Check the word. Return None if the word is properly spelled.
    Otherwise, return a list of alternatives."""

    d = self.d 

    if not d:
        return None
    elif d.check(word):
        return None
    else:
        return d.suggest(word)
#@+node:ekr.20100909065501.5975: *4* Simplified leoPlugins code
@nocolor-node

There are some tricky issues here:

http://groups.google.com/group/leo-editor/browse_thread/thread/4da36f0d897a25e8

Important: g.loadOnePlugin calls the plugins onCreate method to make up for
events that have already been generated. pc.loadOnePlugin does not.
#@+node:ekr.20100913161311.5857: *4* Added support for slideshow plugin
#@+node:ekr.20031218072017.2817: *5*  doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.p
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.app.commandInterruptFlag = True
        g.es('ignoring command: already executing a command.',color='red')
        return 'break'

    g.app.commandInterruptFlag = False

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: g.pr('c no longer exists',c)
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es_print("exception executing command")
                g.es_exception(c=c)

        if c and c.exists:
            if c.requestCloseWindow:
                g.trace('Closing window after command')
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return "break" # Inhibit all other handlers.
#@+node:ekr.20031218072017.1934: *5* run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    trace = False # and not g.unitTesting
    if trace: print('runLeo.run: sys.argv %s' % sys.argv)

    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    if not isValidPython(): return

    files,options = doPrePluginsInit(fileName,pymacs)
    if options.get('exit'): return

    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed: return

    # Phase 3: after loading plugins. Create one or more frames.
    ok = doPostPluginsInit(args,files,options)
    if ok: g.app.gui.runMainLoop()
        # For scripts, the gui is a nullGui.
        # and the gui.setScript has already been called.
#@+node:ekr.20090519143741.5915: *6* doPrePluginsInit & helpers
def doPrePluginsInit(fileName,pymacs):

    ''' Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    options = scanOptions()

    # Post-process the options.
    fileName2 = options.get('fileName')
    if fileName2: fileName = fileName2

    if pymacs:
        options['script'] = script = None
        options['windowFlag'] = False
    else:
        script = options.get('script')
    verbose = script is None

    # Init the app.
    initApp(verbose)
    files = getFiles(fileName2)
    reportDirectories(verbose)

    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(None,verbose)
    for fn in files:
        g.app.config.readSettingsFiles(fn,verbose)

    if not files and not script:
        # This must be done *after* the standard settings have been read.
        fn = getDefaultFile()
        if fn:
            files = [fn]
            g.app.config.readSettingsFiles(fn,verbose=True)

    g.app.setGlobalDb()
    createGui(pymacs,options)

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    versionFlag = options.get('versionFlag')
    if versionFlag:
        print(g.app.signon)
    if versionFlag or not g.app.gui:
        options['exit'] = True

    return files,options
#@+node:ekr.20100914142850.5892: *7* createGui & helper
def createGui(pymacs,options):

    gui = options.get('gui')
    windowFlag = options.get('windowFlag')
    script = options.get('script')

    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)

#@+node:ekr.20080921060401.4: *7* createSpecialGui
def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
#@+node:ekr.20070306085724: *7* adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
#@+node:ekr.20041124083125: *7* completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName
#@+node:ekr.20101021101942.6010: *7* getDefaultFile
def getDefaultFile ():

    # Get the name of the workbook.
    fn = g.app.config.getString(c=None,setting='default_leo_file')
    fn = g.os_path_finalize(fn)

    if fn and g.os_path_exists(fn):
        return fn
    else:
        return None
#@+node:ekr.20101020125657.5976: *7* getFiles
def getFiles(fileName):

    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if not arg.startswith('-'):
            files.append(arg)

    files = [completeFileName(z) for z in files]
    return files
#@+node:ekr.20080921091311.2: *7* initApp
def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.pluginsController.finishCreate() # 2010/09/09
#@+node:ekr.20041130093254: *7* reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@+node:ekr.20091007103358.6061: *7* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path")
    add('--debug',        action="store_true",dest="debug")
    add('-f', '--file',   dest="fileName")
    add('--gui', dest="gui",help = 'gui to use (qt/tk/qttabs)')
    add('--ipython',      action="store_true",dest="use_ipython")
    add('--no-cache',     action="store_true",dest='no_cache')
    add('--silent',       action="store_true",dest="silent")
    add('--screen-shot',  dest='screenshot_fn')
    add('--script',       dest="script")
    add('--script-window',dest="script_window")
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui
    g.app.qt_use_tabs = False

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
    else:
        gui = g.app.guiArgName = 'qt'

    assert gui == g.app.guiArgName

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
#@+node:ekr.20090519143741.5917: *6* doPostPluginsInit & helpers
def doPostPluginsInit(args,files,options):

    '''Return True if the frame was created properly.'''

    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,fileName = None,None
    for fileName in files:
        c,frame = createFrame(fileName,options)
        if not frame:
            g.trace('createFrame failed',repr(fileName))
            return False

    if not c:
        c,frame = createFrame(None,options)
        if c and frame:
            fileName = c.fileName()
        else:
            g.trace('createFrame failed 2')
            return False

    # Do the final inits.
    c.setLog() # 2010/10/20
    g.app.logInited = True # 2010/10/20
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)

    screenshot_fn = options.get('screenshot_fn')
    if screenshot_fn:
        make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.

    return True
#@+node:ekr.20031218072017.1624: *7* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *8* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *8* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *8* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20080921060401.5: *7* finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@+node:ekr.20080921060401.6: *7* initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@+node:ekr.20100914142850.5894: *7* make_screen_shot
def make_screen_shot(fn):

    '''Create a screenshot of the present Leo outline and save it to path.'''

    # g.trace('runLeo.py',fn)

    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20040411081633: *7* startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@+node:ekr.20031218072017.1936: *6* isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.6'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8: *7* << define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9: *8* __init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@+node:ekr.20080822065427.12: *8* createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,
            underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@+node:ekr.20080822065427.14: *8* createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@+node:ekr.20080822065427.10: *8* okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@+node:ekr.20080822065427.21: *8* onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@+node:ekr.20080822065427.16: *8* run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@+node:ekr.20100929121021.13741: *4* Improved import for elisp
@nocolor-node

Improvements:

- Use @language lisp instead of @language elisp.
- Use short file name when .treeType is None.
- Don't warn about underindented line.
- Add single-line comment if it ends a definition.
#@+node:ekr.20070808115837: *5* Checking
#@+node:ekr.20070703122141.102: *6* check
def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType in (None,'@file'):
        return self.checkTrialWrite()
    else:
        return True
#@+node:ekr.20070703122141.104: *6* checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070730093735: *6* compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468: *7* adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@+node:ekr.20090513073632.5735: *7* compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@+node:ekr.20071110144948: *6* checkLeadingWhitespace
def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
#@+node:ekr.20070911110507: *6* reportMismatch
def reportMismatch (self,lines1,lines2,bad_i):

    kind = g.choose(self.atAuto,'@auto','import command')
    n1,n2 = len(lines1),len(lines2)
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d' % (
            kind,self.root.h,bad_i))

    aList = []
    for i in range(max(0,bad_i-2),min(bad_i+3,max(n1,n2))):
        for lines,n in ((lines1,n1),(lines2,n2)):
            if i < n: line = repr(lines[i])
            else: line = '<eof>'
            aList.append('%4d %s' % (i,line))

    if not g.unitTesting:
        g.es_print('\n'.join(aList),color='blue')

    return False
#@+node:ekr.20070711060113.2: *5* Overrides (elispScanner)
# skipClass/Function/Signature are defined in the base class.
#@+node:ekr.20070711060113.3: *6* startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.startSigIndent = self.getLeadingIndent(s,i)
    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = self.skipId(s,i) # Bug fix: 2009/09/30
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@+node:ekr.20070711063339: *6* startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    # ?\x is the universal character escape.
    return g.match(s,i,'"') or g.match(s,i,'?\\')
#@+node:ekr.20100929121021.13743: *6* skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    # Call the base class
    i = baseScannerClass.skipBlock(self,s,i,delim1,delim2)

    # Skip the closing parens of enclosing constructs.
    # This prevents the "does not end in a newline error.
    while i < len(s) and s[i] == ')':
        i += 1

    return i
#@+node:ekr.20100929121021.13745: *6* skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    if s.startswith('?',i):
        return min(len(s),i + 3)
    else:
        return g.skip_string(s,i,verbose=False)
#@+node:ekr.20100929121021.13742: *5* changed
#@+node:ekr.20070711060113.1: *6*  __init__ (elispScanner)
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='lisp')

    # Set the parser delims.
    self.atAutoWarnsAboutLeadingWhitespace = False # 2010/09/29.
    self.warnAboutUnderindentedLines = False # 2010/09/29.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'
    self.strict=False

#@+node:ekr.20070703122141.66: *6* baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.escapeSectionRefs = True
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
    self.warnAboutUnderindentedLines = True
#@+node:ekr.20070730093735: *6* compareHelper & helpers
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@+node:ekr.20091227115606.6468: *7* adjustRstLines
def adjustRstLines(self,lines):

    '''Ignore newlines.

    This fudge allows the rst code generators to insert needed newlines freely.'''

    return [z for z in lines if z.strip() != '']
#@+node:ekr.20090513073632.5735: *7* compareRstUnderlines
def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 >= 2 and n2 >= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
#@+node:ekr.20090512153903.5806: *6* computeBody (baseScannerClass)
def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    # g.trace(repr(s[sigStart:codeEnd]))

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace: g.trace('body: %s' % repr(body))

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

        # g.trace(repr(s[sigStart:codeEnd]))
        # g.pdb()

    return body
#@+node:ekr.20070703122141.105: *6* createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@root':
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True
    else:
        prefix = ''

    return prefix
#@+node:ekr.20070707085612: *6* createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@root':
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True
    else:
        prefix = ''

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

#@+node:ekr.20031218072017.3210: *6* createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    # New in Leo 4.4.7: honor @path directives.
    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Remember that we have read this file.
        # Fixes bug 488894: unsettling dialog when saving Leo file
        # after creating and populating an @auto node.
        # Important: this often sets the bit in the wrong node:
        # The caller may have to set the bit in the "real" root node.
        p.v.at_read = True # Create the attribute

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
#@+node:ekr.20070703122141.106: *6* getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType in ('@file',None):
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@+node:ekr.20031218072017.3212: *6* importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        << Create a parent for two files having a common prefix >>
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw(current)
#@+node:ekr.20031218072017.3213: *7* << Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last
period is the same. For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@+node:ekr.20041005105605.171: *6* inAtOthers
def inAtOthers(self,p):

    """Returns True if p should be included in the expansion of the at-others directive

    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False

    # Return False if this is a definition node.
    h = p.h ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    if self.sentinels or self.atAuto or self.toString:
        # 2010/09/29: @ignore must not stop expansion here!
        return True 

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@+node:ekr.20070707073859: *6* skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    verbose = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace and verbose:
        g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace and verbose: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                # 2010/09/20
                # Skip a single-line comment if it exists.
                j = g.skip_ws(s,i)
                if (g.match(s,j,self.lineCommentDelim) or
                    g.match(s,j,self.lineCommentDelim2)
                ):
                    i = g.skip_to_end_of_line(s,i)
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block: %s' % self.root.h)
    if 1:
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@+node:ekr.20101008110759.5928: *4* Improved @url nodes
#@+node:ekr.20031218072017.2312: *5* tree.OnIconDoubleClick (@url) & helper
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b:
            url = p.b.strip()
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.b.split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@+node:ekr.20031218072017.2313: *6* << stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            z_url = url[i:]
            g.es("ignoring characters after space in url:",z_url)
            g.es("use %20 instead of spaces")
        url = url[:i]
#@+node:tbrown.20090219095555.61: *5* g.handleUrlInUrlNode
def handleUrlInUrlNode(url):

    # Note 1: the UNL plugin has its own notion of what a good url is.

    # Note 2: tree.OnIconDoubleClick now uses the body text of an @url
    #         node if it exists.

    if g.unitTesting: return
    << check the url; return if bad >>
    << pass the url to the web browser >>
#@+node:tbrown.20090219095555.62: *6* << check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url:",url)
    return
#@+node:tbrown.20090219095555.63: *6* << pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],None)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening",url)
    g.es_exception()
#@+node:ekr.20101009103953.5929: *4* Support @bool write_expansion_bits_in_leo_files
#@+node:ekr.20031218072017.3019: *5* leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a',
        'descendentTnodeUnknownAttributes',
        'descendentVnodeUnknownAttributes', # New in Leo 4.5.
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )

    self.checkOutlineBeforeSave = c.config.getBool(
        'check_outline_before_save',default=False)

    self.initIvars()
#@+node:ekr.20090213065933.6: *5* c.initConfigSettings
def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self
    c.autoindent_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    c.contractVisitedNodes  = c.config.getBool('contractVisitedNodes')
    c.fixed                 = c.config.getBool('fixedWindow',default=False)
    c.fixedWindowPosition   = c.config.getData('fixedWindowPosition')
    c.showMinibuffer        = c.config.getBool('useMinibuffer')
        # This option is a bad idea.
    c.putBitsFlag           = c.config.getBool('put_expansion_bits_in_leo_files',default=True)
    # g.trace('putBitsFlag',c.putBitsFlag,c.fileName())
    c.sparse_move           = c.config.getBool('sparse_move_outline_left')
    c.sparse_find           = c.config.getBool('collapse_nodes_during_finds')
    c.sparce_spell          = c.config.getBool('collapse_nodes_while_spelling')
    c.stayInTree            = c.config.getBool('stayInTreeAfterSelect')
    c.smart_tab             = c.config.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = c.config.getInt('tab_width') or -4

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isEdit:   forceWrite = False     # Never write non-ignored @edit trees.
    elif isShadow: forceWrite = False     # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20101020041809.5962: *4* Allow multiple files on the command line
@nocolor-node

Refactored g.app.config.readSettingsFiles.

Settings now honored in workbook.

* Window size not honored when opened from menu.
#@+node:ekr.20101020183900.5989: *5* disabled startup messages
#@+node:ekr.20070925144337.2: *6* doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if False and not g.app.unitTesting and not g.app.silentMode:
            s = 'using menus from: %s' % c.shortFileName()
            g.es_print(s,color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716: *7* doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.h)
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        # if trace:
            # if p.h==after.h:
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.b
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.h)
            p.moveToThreadNext()
#@+node:ekr.20070926142312: *7* dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@+node:ekr.20050424115658: *6* readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        try:
            if g.isPython3:
                f = open(fileName,encoding='utf-8',mode='r')
            else:
                f = open(fileName,'r')
        except IOError:
            g.trace('can not open',fileName)
            return False
        if 0:
            if not g.unitTesting and not self.silent:
                g.pr(('reading %s' % fileName))
        lines = f.readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line)) for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@+node:ekr.20101020183900.5990: *5* log
#@+node:ekr.20070626132332: *6* g.es & minitest
def es(*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    if not app or app.killed: return
    log = app.log

    # Compute the effective args.
    d = {'color':'black','commas':False,'newline':True,'spaces':True,'tabName':'Log'}
    d = g.doKeywordArgs(keys,d)
    color = d.get('color')
    if color == 'suppress': return # New in 4.3.
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args,d)
    # print('g.es',app.logInited,log and id(log),args)
    # print('g.es',g.callers())

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # New in Leo 4.5 b4: this is no longer needed.
            # This makes the output of unit tests match the output of scripts.
            # s = g.toEncodedString(s,'ascii')
            g.pr(s,newline=newline)
    else:
        if log and app.logInited:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611: *7* mini test of es
@nocolor
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@+node:ekr.20080710101653.1: *6* g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if app.logInited:
        s = s + '\n'

    if g.isPython3:
        if encoding.lower() in ('utf-8','utf-16'):
            s2 = s # There can be no problem.
        else:
            # 2010/10/21: Carefully convert s to the encoding.
            s3 = g.toEncodedString(s,encoding=encoding,reportErrors=False)
            s2 = g.toUnicode(s3,encoding=encoding,reportErrors=False)
    else:
        s2 = g.toEncodedString(s,encoding,reportErrors=False)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2)
        except Exception:
            g.es('unexpected exception in g.pr')
            # if not g.pr_warning_given:
                # g.pr_warning_given = True
                # # print('unexpected Exception in g.pr')
                # # print('make sure your sitecustomize.py contains::')
                # # print('    sys.setdefaultencoding("utf-8")')
                # g.es_exception()
                # g.trace(g.callers())
            # s2 = s.encode('ascii',"replace")
            # if g.isPython3:
                # s2 = str(s2,'ascii','replace')
            # sys.stdout.write(s2)
    else:
        app.printWaiting.append(s2)
#@+node:ekr.20031218072017.2619: *6* app.writeWaitingLog
def writeWaitingLog (self,c):

    app = self
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    # print('***** writeWaitingLog','unitTesting',g.unitTesting,c,g.callers())

    if not c or not c.exists:
        return

    if g.unitTesting:
        app.printWaiting = []
        app.logWaiting = []
        g.app.setLog(None) # Prepare to requeue for other commanders.
        return

    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    c.setLog() # 2010/10/20
    app.logInited = True # Prevent recursive call.
    if not app.signon_printed:
        app.signon_printed = True
        print(app.signon)
        print(app.signon2)
    for s in app.printWaiting:
        print(s)
    app.printWaiting = []
    for s,color in table:
        app.logWaiting.insert(0,(s+'\n',color),)
    for s,color in app.logWaiting:
        g.es('',s,color=color,newline=0)
            # The caller must write the newlines.

    # Essential when opening multiple files...
    app.logWaiting = []
    g.app.setLog(None) 
#@+node:ekr.20031218072017.1847: *6* app.setLog, lockLog, unlocklog
def setLog (self,log):

    """set the frame to which log messages will go"""

    # print("app.setLog:",log,g.callers())
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True

def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False
#@+node:ekr.20060109164136: *6* c.setLog
def setLog (self):

    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass
#@+node:ekr.20031218072017.1934: *5* run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    trace = False # and not g.unitTesting
    if trace: print('runLeo.run: sys.argv %s' % sys.argv)

    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    if not isValidPython(): return

    files,options = doPrePluginsInit(fileName,pymacs)
    if options.get('exit'): return

    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed: return

    # Phase 3: after loading plugins. Create one or more frames.
    ok = doPostPluginsInit(args,files,options)
    if ok: g.app.gui.runMainLoop()
        # For scripts, the gui is a nullGui.
        # and the gui.setScript has already been called.
#@+node:ekr.20090519143741.5915: *6* doPrePluginsInit & helpers
def doPrePluginsInit(fileName,pymacs):

    ''' Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    options = scanOptions()

    # Post-process the options.
    fileName2 = options.get('fileName')
    if fileName2: fileName = fileName2

    if pymacs:
        options['script'] = script = None
        options['windowFlag'] = False
    else:
        script = options.get('script')
    verbose = script is None

    # Init the app.
    initApp(verbose)
    files = getFiles(fileName2)
    reportDirectories(verbose)

    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(None,verbose)
    for fn in files:
        g.app.config.readSettingsFiles(fn,verbose)

    if not files and not script:
        # This must be done *after* the standard settings have been read.
        fn = getDefaultFile()
        if fn:
            files = [fn]
            g.app.config.readSettingsFiles(fn,verbose=True)

    g.app.setGlobalDb()
    createGui(pymacs,options)

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    versionFlag = options.get('versionFlag')
    if versionFlag:
        print(g.app.signon)
    if versionFlag or not g.app.gui:
        options['exit'] = True

    return files,options
#@+node:ekr.20100914142850.5892: *7* createGui & helper
def createGui(pymacs,options):

    gui = options.get('gui')
    windowFlag = options.get('windowFlag')
    script = options.get('script')

    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)

#@+node:ekr.20080921060401.4: *7* createSpecialGui
def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
#@+node:ekr.20070306085724: *7* adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
#@+node:ekr.20041124083125: *7* completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName
#@+node:ekr.20101021101942.6010: *7* getDefaultFile
def getDefaultFile ():

    # Get the name of the workbook.
    fn = g.app.config.getString(c=None,setting='default_leo_file')
    fn = g.os_path_finalize(fn)

    if fn and g.os_path_exists(fn):
        return fn
    else:
        return None
#@+node:ekr.20101020125657.5976: *7* getFiles
def getFiles(fileName):

    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if not arg.startswith('-'):
            files.append(arg)

    files = [completeFileName(z) for z in files]
    return files
#@+node:ekr.20080921091311.2: *7* initApp
def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.pluginsController.finishCreate() # 2010/09/09
#@+node:ekr.20041130093254: *7* reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@+node:ekr.20091007103358.6061: *7* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path")
    add('--debug',        action="store_true",dest="debug")
    add('-f', '--file',   dest="fileName")
    add('--gui', dest="gui",help = 'gui to use (qt/tk/qttabs)')
    add('--ipython',      action="store_true",dest="use_ipython")
    add('--no-cache',     action="store_true",dest='no_cache')
    add('--silent',       action="store_true",dest="silent")
    add('--screen-shot',  dest='screenshot_fn')
    add('--script',       dest="script")
    add('--script-window',dest="script_window")
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui
    g.app.qt_use_tabs = False

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
    else:
        gui = g.app.guiArgName = 'qt'

    assert gui == g.app.guiArgName

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
#@+node:ekr.20090519143741.5917: *6* doPostPluginsInit & helpers
def doPostPluginsInit(args,files,options):

    '''Return True if the frame was created properly.'''

    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,fileName = None,None
    for fileName in files:
        c,frame = createFrame(fileName,options)
        if not frame:
            g.trace('createFrame failed',repr(fileName))
            return False

    if not c:
        c,frame = createFrame(None,options)
        if c and frame:
            fileName = c.fileName()
        else:
            g.trace('createFrame failed 2')
            return False

    # Do the final inits.
    c.setLog() # 2010/10/20
    g.app.logInited = True # 2010/10/20
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)

    screenshot_fn = options.get('screenshot_fn')
    if screenshot_fn:
        make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.

    return True
#@+node:ekr.20031218072017.1624: *7* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *8* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *8* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *8* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20080921060401.5: *7* finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@+node:ekr.20080921060401.6: *7* initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@+node:ekr.20100914142850.5894: *7* make_screen_shot
def make_screen_shot(fn):

    '''Create a screenshot of the present Leo outline and save it to path.'''

    # g.trace('runLeo.py',fn)

    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20040411081633: *7* startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@+node:ekr.20031218072017.1936: *6* isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.6'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8: *7* << define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9: *8* __init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@+node:ekr.20080822065427.12: *8* createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,
            underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@+node:ekr.20080822065427.14: *8* createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@+node:ekr.20080822065427.10: *8* okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@+node:ekr.20080822065427.21: *8* onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@+node:ekr.20080822065427.16: *8* run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@+node:ekr.20101020201751.7361: *5* New windows
#@+node:ekr.20031218072017.2188: *6* app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,
        relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c)
            # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
#@+node:ekr.20031218072017.2189: *7* << compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@+node:ekr.20031218072017.1623: *6* c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    g.doHook("new",old_c=self,c=c,new_c=c)
    g.app.unlockLog()

    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.redraw()
    return c # For unit test.
#@+node:ekr.20031218072017.2821: *6* c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822: *7* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@+node:ekr.20090212054250.9: *7* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@+node:ekr.20031218072017.2081: *6* c.openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082: *7* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and the window
has never been written to or saved, then we will automatically close that window
if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@+node:ekr.20031218072017.1624: *6* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *7* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *7* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *7* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20090520055433.5945: *6* g.openWithFileName & helpers
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)

    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    app.setLog(None) # 2010/10/20
    app.lockLog()# 2010/10/20
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None
    app.unlockLog()# 2010/10/20
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    # Handle the open hooks and open the log for c.
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.app.writeWaitingLog(c)
    c.setLog() # 2010/10/20
    g.createMenu(c,fn)
    g.finishOpen(c)
    return True,c.frame
#@+node:ekr.20090520055433.5951: *7* g.createMenu
def createMenu(c,fileName=None):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
#@+node:ekr.20090520055433.5948: *7* g.findOpenFile
def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if munge(fileName) == munge(c.mFileName):
            frame.bringToFront()
            c.setLog()
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20090520055433.5952: *7* g.finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
#@+node:ekr.20090520055433.5950: *7* g.handleOpenHooks
def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        if theFile:
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    if not c.openDirectory:
        c.openDirectory = c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True
#@+node:ekr.20090520055433.5954: *7* g.mungeFileName
def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
#@+node:ekr.20090520055433.5946: *7* g.openWithFileNameHelper
def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(fileName)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
#@+node:ekr.20090520055433.5949: *8* preRead
def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
#@+node:ekr.20080921154026.1: *7* g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if True: # Just read the file into the node.
        fileName = g.os_path_finalize(fileName)
        s,e = g.readFileIntoString(fileName)
        if s is None: return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.p
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.p
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.p
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Mark the outline dirty.
    return c
#@+node:ekr.20031218072017.2297: *6* open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame

    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir:
        c.openDirectory = c.frame.openDirectory = theDir

    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)

    if ok:
        frame.resizePanesToRatio(ratio,frame.secondary_ratio)

    return ok
#@+node:ekr.20101020134714.5831: *5* settings
#@+node:ekr.20090213065933.6: *6* c.initConfigSettings
def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self
    c.autoindent_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    c.contractVisitedNodes  = c.config.getBool('contractVisitedNodes')
    c.fixed                 = c.config.getBool('fixedWindow',default=False)
    c.fixedWindowPosition   = c.config.getData('fixedWindowPosition')
    c.showMinibuffer        = c.config.getBool('useMinibuffer')
        # This option is a bad idea.
    c.putBitsFlag           = c.config.getBool('put_expansion_bits_in_leo_files',default=True)
    # g.trace('putBitsFlag',c.putBitsFlag,c.fileName())
    c.sparse_move           = c.config.getBool('sparse_move_outline_left')
    c.sparse_find           = c.config.getBool('collapse_nodes_during_finds')
    c.sparce_spell          = c.config.getBool('collapse_nodes_while_spelling')
    c.stayInTree            = c.config.getBool('stayInTreeAfterSelect')
    c.smart_tab             = c.config.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = c.config.getInt('tab_width') or -4

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))
    # g.trace(c.sparse_move)
#@+node:ekr.20041228042224: *6* setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.

    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''

    trace = False and not g.unitTesting
    verbose = False

    if not self.inited: return

    # Ignore temporary commanders created by readSettingsFiles.
    if trace and verbose: g.trace('*' * 10)
    if trace: g.trace(
        'inited',self.inited,
        c and c.shortFileName() or '<no c>',g.callers(2))

    d = self.ivarsDict
    keys = list(d.keys())
    keys.sort()
    for key in keys:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    if trace and verbose: g.trace("%20s %s = %s" % (
                        g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    if trace and verbose: g.trace("%20s %s = %s" % (
                        'g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@+node:ekr.20041120064303: *6* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file or the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose or trace
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    if trace: g.trace(fileName,g.callers())
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            if giveMessage:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.es_print(s,color='blue')
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *7* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *7* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        path = g.os_path_finalize(fileName)
        theDir = g.os_path_dirname(fileName)
        myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
        local_table = (
            (localConfigFile,False),
            (myLocalConfigFile,False),
        )
        table1 = [z for z in global_table if z not in global_table]
        table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    # g.trace(table)
    return table
#@+node:ekr.20041117085625: *7* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *7* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20050424114937.2: *6* writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    seen = []
    for path in (localPath,g.app.globalConfigDir,g.app.homeLeoDir): # homeLeoDir was homeDir.
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName) and not fileName.lower() in seen:
                seen.append(fileName.lower())
                ok = self.writeRecentFilesFileHelper(fileName)
                if not self.recentFileMessageWritten:
                    if ok:
                        g.pr('wrote recent file: %s' % fileName)
                        written = True
                    else:
                        g.pr('failed to recent file: %s' % (fileName),color='red')
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051: *7* writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):

    # g.trace(g.toUnicode(fileName))

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = open(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return False
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        if g.isPython3:
            theFile = open(fileName,encoding='utf-8',mode='w')
        else:
            theFile = open(fileName,mode='w')
        if self.recentFiles:
            s = '\n'.join(self.recentFiles)
        else:
            s = '\n'
        if not g.isPython3:
            s = g.toEncodedString(s,reportErrors=True)
        theFile.write(s)

    except IOError:
        if 1: # The user may have erased a file.  Not an error.
            g.es_print('error writing',fileName,color='red')
            g.es_exception()
            return False

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()
        if g.unitTesting: raise
        return False

    if theFile:
        theFile.close()
        return True
    else:
        return False
#@-all
#@-leo
