#@+leo-ver=4-thin
#@+node:ekr.20100120072650.6089:@thin leoProjects.txt
#@+at
# This part of the tree shows views of the outline related to specific 
# projects or
# tasks. I put such headlines in parentheses, and that is just my convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the
# cloned headlines under the task headline. This greatly increases my focus. 
# Any
# changes made in a task view to clone headlines affect the other clones 
# scattered
# throughout the outline. In particular, all @file nodes containing changed 
# clones
# become marked as dirty, so they will be written when the entire outline is
# saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20100223085638.5635:Leo 4.7.1 projects
#@+node:ekr.20100224050618.11546:Auto-convert thin-like external files
@
The fix involves disabling caching when a file has file-like sentinels,
regardless of whether the root node is spelled @file or @thin.

In addition, Leo's read code now issues a red warning message in the
console when converting files.
#@nonl
#@+node:ekr.20100225102636.5626:Testing
#@+node:ekr.20051104075904.44:at-File test code (leoTest.py)
def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in (
        "@auto","@edit","@file","@thin","@nosent",
        "@asis",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@auto":
        at.writeOneAtAutoNode(child1,toString=True,force=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput)
        assert(result == expected)
    except AssertionError:
        << dump result and expected >>
        raise
#@+node:ekr.20051104075904.45:<< dump result and expected >>
print('\n','-' * 20)
print("result...")
for line in g.splitLines(result):
    print("%3d" % len(line),repr(line))
print('-' * 20)
print("expected...")
for line in g.splitLines(expected):
    print("%3d" % len(line),repr(line))
print('-' * 20)
#@-node:ekr.20051104075904.45:<< dump result and expected >>
#@-node:ekr.20051104075904.44:at-File test code (leoTest.py)
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@-node:ekr.20100225102636.5626:Testing
#@+node:ekr.20100225120559.5631:Reference
#@+node:ekr.20031218072017.1553:fc.getLeoFile & helpers
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    self.warnOnReadOnlyFiles(fileName)
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    recoveryNode = None # Position of recovery node, if present.

    try:
        c.loading = True # disable c.changed
        ok = self.getLeoFileHelper(theFile,fileName,silent)

        # Do this before reading derived files.
        self.resolveTnodeLists()

        if ok and readAtFileNodesFlag:
            # Redraw before reading the @file nodes so the screen isn't blank.
            # This is important for big files like LeoPy.leo.
            c.redraw()
            c.setFileTimeStamp(fileName)
            c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
            recoveryNode = self.handleNodeConflicts()

        # Do this after reading derived files.
        if readAtFileNodesFlag:
            # The descendent nodes won't exist unless we have read the @thin nodes!
            self.restoreDescendentAttributes()

        self.setPositionsFromVnodes()
        c.selectVnode(recoveryNode or c.p) # load body pane
        if c.config.getBool('check_outline_after_read'):
            c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    finally:
        c.loading = False # reenable c.changed

    if c.changed:
        self.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, c.frame.ratio
#@+node:ekr.20090526081836.5841:getLeoFileHelper
def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c = self.c

    try:
        ok = True
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
#@-node:ekr.20090526081836.5841:getLeoFileHelper
#@+node:ekr.20100205060712.8314:handleNodeConflicts
def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        child.setBodyString('%s %s' % (tag,gnx))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
#@-node:ekr.20100205060712.8314:handleNodeConflicts
#@+node:ekr.20100124110832.6212:propegateDirtyNodes
def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
#@-node:ekr.20100124110832.6212:propegateDirtyNodes
#@+node:ekr.20031218072017.1554:warnOnReadOnlyFiles
def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:warnOnReadOnlyFiles
#@-node:ekr.20031218072017.1553:fc.getLeoFile & helpers
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):

    """Return the next vnode in at.root.tnodeLisft.
    This is called only for @file nodes"""

    # tnodeLists are used *only* when reading @file (not @thin) nodes.
    # tnodeLists compensate for not having gnx's in derived files! 

    trace = False and not g.unitTesting
    at = self ; v = at.root.v

    # if not g.unitTesting:
        # if headline.startswith('@file'):
            # g.es_print('Warning: @file logic',headline)

    if trace: g.trace('%s %s %s' % (
        at.tnodeListIndex,
        v.tnodeList[at.tnodeListIndex],headline))

    if not hasattr(v,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v,g.callers())
        return None

    if at.tnodeListIndex >= len(v.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (
            at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",
            at.tnodeListIndex,len(v.tnodeList),v)
        return None

    v = v.tnodeList[at.tnodeListIndex]
    assert(v)
    at.tnodeListIndex += 1

    # Don't check the headline.  It simply causes problems.
    v.setVisited() # Supress warning/deletion of unvisited nodes.
    return v
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.144:write & helper (atFile)
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)
    # g.trace('eventualFileName',eventualFileName,
        # 'at.targetFileName',at.targetFileName)

    if not scriptWrite and not toString:
        if nosentinels:
            if not self.shouldWriteAtNosentNode(root,exists):
                return
        elif not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

#@-node:ekr.20041005105605.146:<< set dirty and orphan bits >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper (atFile)
#@+node:ekr.20041005105605.147:writeAll (atFile) & helper
def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False
):

    """Write @file nodes in all or part of the outline"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    if trace: scanAtPathDirectivesCount = c.scanAtPathDirectivesCount
    writtenFiles = [] # Files that might be written again.
    force = writeAtFileNodesFlag

    if writeAtFileNodesFlag:
        # The Write @<file> Nodes command.
        # Write all nodes in the selected tree.
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    if trace: g.trace('%s calls to c.scanAtPathDirectives()' % (
        c.scanAtPathDirectivesCount-scanAtPathDirectivesCount))

#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @<file> nodes in the selected tree")
    else:
        g.es("no dirty @<file> nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@+node:ekr.20041005105605.149:writeAllHelper (atFile)
def writeAllHelper (self,p,
    force,toString,writeAtFileNodesFlag,writtenFiles
):

    trace = False and not g.unitTesting
    at = self ; c = at.c

    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        pathChanged = False
    else:
        oldPath = at.getPathUa(p).lower()
        newPath = at.fullPath(p).lower()
        pathChanged = oldPath and oldPath != newPath
        # 2010/01/27: suppress this message during save-as and save-to commands.
        if pathChanged and not c.ignoreChangedPaths:
            at.setPathUa(p,newPath) # Remember that we have changed paths.
            g.es_print('path changed for',p.h,color='blue')
            if trace: g.trace('p %s\noldPath %s\nnewPath %s' % (
                p.h,repr(oldPath),repr(newPath)))

    if p.v.isDirty() or pathChanged or writeAtFileNodesFlag or p.v in writtenFiles:

        # Tricky: @ignore not recognised in @asis nodes.
        if p.isAtAsisFileNode():
            at.asisWrite(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtIgnoreNode():
            pass
        elif p.isAtAutoNode():
            at.writeOneAtAutoNode(p,toString=toString,force=force)
            writtenFiles.append(p.v)
        elif p.isAtEditNode():
            at.writeOneAtEditNode(p,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtNoSentFileNode():
            at.write(p,kind='@nosent',nosentinels=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtShadowFileNode():
            at.writeOneAtShadowNode(p,toString=toString,force=force or pathChanged)
            writtenFiles.append(p.v)
        elif p.isAtThinFileNode():
            at.write(p,kind='@thin',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
        elif p.isAtFileNode():
            # Write old @file nodes using @thin format.
            at.write(p,kind='@file',thinFile=True,toString=toString)
            writtenFiles.append(p.v)
#@-node:ekr.20041005105605.149:writeAllHelper (atFile)
#@-node:ekr.20041005105605.147:writeAll (atFile) & helper
#@-node:ekr.20100225120559.5631:Reference
#@+node:ekr.20100225120559.5630:Changed
#@+node:ekr.20031218072017.2833:c.close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:c.close
#@+node:ekr.20031218072017.2821:c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@+node:ekr.20090212054250.9:c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@nonl
#@-node:ekr.20090212054250.9:c.createNodeFromExternalFile
#@-node:ekr.20031218072017.2821:c.open & helper
#@+node:ekr.20100208071151.5905:readFile (cacher)
def readFile (self,fileName,root):

    trace = False and not g.unitTesting
    c = self.c

    if not g.enableDB:
        if trace: g.trace('g.enableDB is False')
        return '',False,None

    s,e = g.readFileIntoString(fileName,raw=True,silent=True)
    if s is None:
        if trace: g.trace('empty file contents',fileName)
        return s,False,None
    assert not g.isUnicode(s)

    # There will be a bug if s is not already an encoded string.
    key = self.fileKey(root.h,s,requireEncodedString=True)
    ok = self.db and key in self.db
    if trace: g.trace('in cache',ok,fileName,key)
    if ok:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        # Recreate the file from the cache.
        aList = self.db[key]
        self.createOutlineFromCacheList(root.v,aList,fileName=fileName)

    return s,ok,key
#@-node:ekr.20100208071151.5905:readFile (cacher)
#@+node:ekr.20100224050618.11547:at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@-node:ekr.20100224050618.11547:at.isFileLike
#@+node:ekr.20041005105605.21:at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # 2010/02/24: Never read an external file
    # with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike:
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    if at.errors == 0 and not isFileLike:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('root.isDirty',root.isDirty())

    return at.errors == 0
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20100122130101.6174:deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@-node:ekr.20100122130101.6174:deleteTnodeList
#@+node:ekr.20041005105605.22:initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@-node:ekr.20041005105605.22:initFileName
#@+node:ekr.20100224050618.11547:at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@-node:ekr.20100224050618.11547:at.isFileLike
#@+node:ekr.20071105164407:warnAboutUnvisitedNodes
def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
#@-node:ekr.20071105164407:warnAboutUnvisitedNodes
#@-node:ekr.20041005105605.21:at.read & helpers
#@-node:ekr.20100225120559.5630:Changed
#@-node:ekr.20100224050618.11546:Auto-convert thin-like external files
#@-node:ekr.20100223085638.5635:Leo 4.7.1 projects
#@+node:ekr.20100303074003.5639:Leo 4.8 devel projects
#@+node:ekr.20100319090849.5760:Bugs
#@+node:ekr.20100303074003.5635:Fix save scrolling bug
@nocolor-node

- Open a node with long (multipage) body text
- Move cursor towards the end of the node
- Save (ctrl+s)
- Observe how window is scrolled, cursor is moved
#@nonl
#@+node:ekr.20100303074003.5637:p.restore/saveCursorAndScroll
def restoreCursorAndScroll (self,w):

    self.v.restoreCursorAndScroll(w)

def saveCursorAndScroll (self,w):

    self.v.saveCursorAndScroll(w)
#@-node:ekr.20100303074003.5637:p.restore/saveCursorAndScroll
#@+node:ekr.20100303074003.5636:v.restoreCursorAndScroll
def restoreCursorAndScroll (self,w):

    v = self

    if v and v.insertSpot != None:
        spot = v.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)

    # Restore the scroll spot after the call to w.see.
    if v and v.scrollBarSpot != None:
        first,last = v.scrollBarSpot
        w.setYScrollPosition(first)
#@-node:ekr.20100303074003.5636:v.restoreCursorAndScroll
#@+node:ekr.20100303074003.5638:v.saveCursorAndScroll(w)
def saveCursorAndScroll(self,w):

    v = self
    if not w: return

    v.scrollBarSpot = w.getYScrollPosition()
    v.insertSpot = w.getInsertPoint()
#@-node:ekr.20100303074003.5638:v.saveCursorAndScroll(w)
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.2821:c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@+node:ekr.20090212054250.9:c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@nonl
#@-node:ekr.20090212054250.9:c.createNodeFromExternalFile
#@-node:ekr.20031218072017.2821:c.open & helper
#@+node:ekr.20031218072017.2823:c.openWith and helpers
def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return 'break'
#@+node:ekr.20031218072017.2824:c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
#@-node:ekr.20031218072017.2824:c.getOpenWithExt
#@+node:ekr.20031218072017.2829:c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '<no command>'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@-node:ekr.20031218072017.2829:c.openTempFileInExternalEditor
#@+node:ekr.20100203050306.5797:c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
#@+node:ekr.20031218072017.2827:c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
#@-node:ekr.20031218072017.2827:c.createOrRecreateTempFileAsNeeded
#@+node:ekr.20100203050306.5937:c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if g.os_path_exists(fn):
            g.es('recreating:  ',g.shortFileName(fn),color='red')
        else:
            g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time: g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
#@-node:ekr.20100203050306.5937:c.createOpenWithTempFile
#@-node:ekr.20100203050306.5797:c.openWithHelper
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

     This is overridden in mod_tempfname plugin
     '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath (may be over-ridden)
#@-node:ekr.20031218072017.2823:c.openWith and helpers
#@+node:ekr.20031218072017.2833:c.close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:c.close
#@+node:ekr.20031218072017.2834:c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
#@nonl
#@-node:ekr.20031218072017.2834:c.save
#@+node:ekr.20031218072017.2835:c.saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        if g.app.qt_use_tabs and hasattr(c.frame,'top'):
            c.frame.top.master.setTabName(c,c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
#@-node:ekr.20031218072017.2835:c.saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:c.saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    # Does not change icons status.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocusNow()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocusNow()
#@nonl
#@-node:ekr.20031218072017.2836:c.saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.doHook("close-frame",c=c)
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20040803072955.128:leoTree.select & helpers
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:selectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if p:
        # 2009/10/10: selecting a foreign position
        # will not be pretty.
        assert p.v.context == c
    else:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if old_p:
            g.trace('old: %s %s new: %s %s' % (
                len(old_p.b),old_p.h,len(p.b),p.h))
        else:
            g.trace('old: <none> new: %s %s' % (len(p.b),p.h))

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    if trace: g.trace('**** after old: %s new %s' % (
        old_p and len(old_p.b),len(p.b)))

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p != p: # 2010/02/11: Don't change the *new* node's insert point!
    old_p.v.scrollBarSpot = yview
    old_p.v.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:selectHelper
#@+node:ekr.20090608081524.6109:setBodyTextAfterSelect
def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = p.v.b # Guaranteed to be unicode.
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # w.setAllText destroys all color tags, so do a full recolor.
        w.setAllText(s,new_p=p)
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        self.frame.body.recolor(p)

    p.restoreCursorAndScroll(w)
#@-node:ekr.20090608081524.6109:setBodyTextAfterSelect
#@-node:ekr.20040803072955.128:leoTree.select & helpers
#@-node:ekr.20100303074003.5635:Fix save scrolling bug
#@+node:ekr.20100319090849.5758:Fixed recent save-to bug
#@-node:ekr.20100319090849.5758:Fixed recent save-to bug
#@+node:ekr.20100329071036.5741:Fixed at-auto-rst crash
#@+node:ekr.20100329071036.5745: Tracebacks
#@+node:ekr.20100329071036.5742:Original traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2644, in writeOneAtAutoNode
    ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 683, in writeAtAutoFile
    self.writeNode(p) # side effect: advances p
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1509, in writeNode
    self.writeHeadline(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1438, in writeHeadline
    self.writeHeadlineHelper(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1477, in writeHeadlineHelper
    self.write(self.underline(h,p)) # Used by @auto-rst.
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1364, in write
    self.outputFile.write(s)
TypeError: must be bytes or buffer, not str
#@nonl
#@-node:ekr.20100329071036.5742:Original traceback
#@+node:ekr.20100329071036.5743:Second traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2652, in writeOneAtAutoNode
    at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4547, in replaceTargetFileIfDifferent
    ignoreBlankLines=ignoreBlankLines):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4040, in compareFiles
    s1 = g.removeBlankLines(s1)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 5992, in removeBlankLines
    return ''.join(lines)
TypeError: sequence item 0: expected str instance, bytes found
saved: test.leo
#@nonl
#@-node:ekr.20100329071036.5743:Second traceback
#@-node:ekr.20100329071036.5745: Tracebacks
#@+node:ekr.20100329071036.5744:g.is_binary_file
def is_binary_file (f):

    if g.isPython3:
        return f and isinstance(f,io.BufferedIOBase)
    else:
        g.internalError('g.is_binary_file called from Python 2.x code')
#@-node:ekr.20100329071036.5744:g.is_binary_file
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName and not toString: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # Prompt if writing a new @auto node would overwrite an existing file.
    if (not toString and not hasattr(p.v,'at_read') and
        g.os_path_exists(fileName)
    ):
        ok = self.promptForDangerousWrite(fileName,kind='@auto')
        if ok:
            p.v.at_read = True # Create the attribute
        else:
            g.es("not written:",fileName)
            return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    isAtAutoRst = root.isAtAutoRstNode()
    if ok:
        if isAtAutoRst:
            ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
            if not ok2: at.errors += 1
        else:
            at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        # g.trace('at.errors',at.errors)
        if at.errors == 0:
            # g.trace('toString',toString,'force',force,'isAtAutoRst',isAtAutoRst)
            at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
                # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers (atFile)
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        ok = at.openFileForWritingHelper(fileName)

        # New in Leo 4.4.8: set dirty bit if there are errors.
        if not ok: at.outputFile = None

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143:openFileForWritingHelper & helper
def openFileForWritingHelper (self,fileName):

    '''Open the file and return True if all went well.'''

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        at.targetFileName = c.os_path_finalize_join(at.default_directory,fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return False
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return False

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not open: read only: " + at.targetFileName)
                return False
        except AttributeError:
            pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        kind,at.outputFile = self.openForWrite(at.outputFileName,'wb')
        if not at.outputFile:
            kind = g.choose(kind=='check',
                'did not overwrite','can not create')
            at.writeError("%s %s" % (kind,at.outputFileName))
            return False
    except Exception:
        at.exception("exception creating:" + at.outputFileName)
        return False

    return True
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@-node:ekr.20041005105605.143:openFileForWritingHelper & helper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20090502071837.90:encode
def encode (self,s):

    # g.trace(self.encoding)

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
#@-node:ekr.20090502071837.90:encode
#@+node:ekr.20090502071837.94:write (leoRst)
def write (self,s,theFile=None):

    if theFile is None:
        theFile = self.outputFile

    if g.isPython3:
        if g.is_binary_file(theFile):
            s = self.encode(s)
    else:
        s = self.encode(s)

    theFile.write(s)
#@-node:ekr.20090502071837.94:write (leoRst)
#@+node:ekr.20041005105605.197:compareFiles
def compareFiles (self,path1,path2,ignoreLineEndings,ignoreBlankLines=False):

    """Compare two text files."""
    at = self

    # We can't use 'U' mode because of encoding issues (Python 2.x only).
    s1,e = g.readFileIntoString(path1,mode='rb',raw=True)
    if s1 is None:
        g.internalError('empty compare file: %s' % path1)
        return False
    s2,e = g.readFileIntoString(path2,mode='rb',raw=True)
    if s2 is None:
        g.internalError('empty compare file: %s' % path2)
        return False
    equal = s1 == s2

    # 2010/03/29: Make sure both strings are unicode.
    # This is requred to handle binary files in Python 3.x.
    s1 = g.toUnicode(s1,encoding=at.encoding)
    s2 = g.toUnicode(s2,encoding=at.encoding)

    if ignoreBlankLines and not equal:
        s1 = g.removeBlankLines(s1)
        s2 = g.removeBlankLines(s2)
        equal = s1 == s2

    if ignoreLineEndings and not equal:
        # Wrong: equivalent to ignoreBlankLines!
            # s1 = s1.replace('\n','').replace('\r','')
            # s2 = s2.replace('\n','').replace('\r','')
        s1 = s1.replace('\r','')
        s2 = s2.replace('\r','')
        equal = s1 == s2
    # g.trace('equal',equal,'ignoreLineEndings',ignoreLineEndings,'encoding',at.encoding)
    return equal
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@-node:ekr.20100329071036.5741:Fixed at-auto-rst crash
#@+node:ekr.20100329071036.5739:Investigated at-auto-rst bug
@nocolor-node
https://bugs.launchpad.net/leo-editor/+bug/532085

auto-rst isn't switching to a new title underline char. going from level 2 to 3
in the outline.

Changing to regular @rst and using the rst3 command to export works.

Tree:

Foo
    Bar
        This
        That
    Etc

Output:

Foo
===

Bar
+++

This
++++ <- still using '+' one level down

--------------------------------------------------


Another test and this seems as bad or worse,

A-+
    |
   C-+
       |
      D

is using '=' to underline all three levels.
#@+node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    # g.trace('trial',trialWrite,fileName,outputFile)

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:><_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20091228080620.6499:isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
#@-node:ekr.20091228080620.6499:isSafeWrite
#@-node:ekr.20090512153903.5803:writeAtAutoFile (rstCommands)
#@+node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.
    c = self.c ; at = c.atFileCommands
    if s1 is None and s2 is None:
        if self.isRst:
            outputFile = StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)

    if self.isRst:
        lines1 = self.adjustRstLines(lines1)
        lines2 = self.adjustRstLines(lines2)

    n1,n2 = len(lines1), len(lines2)
    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite (baseScannerClass)
#@+node:ekr.20090502071837.94:write (leoRst)
def write (self,s,theFile=None):

    if theFile is None:
        theFile = self.outputFile

    if g.isPython3:
        if g.is_binary_file(theFile):
            s = self.encode(s)
    else:
        s = self.encode(s)

    theFile.write(s)
#@-node:ekr.20090502071837.94:write (leoRst)
#@-node:ekr.20100329071036.5739:Investigated at-auto-rst bug
#@+node:ekr.20100329071036.5746:Don't put &nbsp; in redirected log
@nocolor-node
@

https://bugs.launchpad.net/leo-editor/+bug/549319

Leo 4.7.1 final, build 3005, February 26, 2010
Python 2.6.2, qt version 4.5.2
Windows 5, 1, 2600, 2, Service Pack 3

When redirecting the output to the Log pane using g.redirectStderr() and
g.redirectStdout(), the output displays non-breaking space characters (&nbsp;)
everywhere there is supposed to be a space.

For example, if I run print 'Hello World' I get Hello&nbsp;World in the Log
pane. This is really hard to read when you have 50 or 100 lines of numbers from
the output of a program.
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout to Leo's log pane
class redirectClass:

    """A class to redirect stdout and stderr to Leo's log pane."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):

    self.old = None
    self.encoding = 'utf-8' # 2019/03/29 For pdb.
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return
#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        g.pr(s)
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    trace = False

    if self.old:
        if app.log:
            if trace: self.old.write(
                'redirectClass: to log: %s\n' % repr(s))
            app.log.put(s)
        else:
            self.old.write(s +'\n')
    else:
        # Can happen when g.batchMode is True.
        g.pr(s)
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)

def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()

def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leo.core.leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leo.core.leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leo.core.leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leo.core.leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leo.core.leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout to Leo's log pane
#@-node:ekr.20100329071036.5746:Don't put &nbsp; in redirected log
#@+node:ekr.20100412060436.5821:Fixed tangle bug
#@+node:ekr.20031218072017.1241:g.update_file_if_changed
# This is part of the tangle code.

def update_file_if_changed(c,file_name,temp_name):

    """Compares two files.

    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(c,temp_name,file_name,mode)
    else:
        kind = 'creating'
        # 2010/02/04: g.utils_rename no longer calls
        # makeAllNonExistentDirectories
        head, tail = g.os_path_split(file_name)
        ok = True
        if head:
            ok = g.makeAllNonExistentDirectories(head,c=c)
        if ok:
            ok = g.utils_rename(c,temp_name,file_name)

    if ok:
        g.es('','%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es('',file_name," may be read-only or in use")
#@-node:ekr.20031218072017.1241:g.update_file_if_changed
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    trace = False and not g.unitTesting
    testing = False # True: don't actually make the directories.

    if force:
        create = True # Bug fix: g.app.config will not exist during startup.
    elif c:
        create = c.config and c.config.create_nonexistent_directories
    else:
        create = (g.app and g.app.config and
            g.app.config.create_nonexistent_directories)

    if c: theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    ok = g.os_path_isdir(dir1) and g.os_path_exists(dir1)
    if ok:
        return ok
    elif not force and not create:
        if trace:
            g.trace('did not create: force and create are both false')
        return ok

    if trace:
        g.trace('\n',theDir,'\n',g.callers(4))
        # g.trace('c exists: %s force: %s create: %s dir: %s' % (
            # c is not None,force,create,theDir))

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    if trace: g.trace('paths:',paths)
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                if testing:
                    g.trace('***making',path)
                else:
                    os.mkdir(path)
                if verbose and not testing and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@-node:ekr.20100412060436.5821:Fixed tangle bug
#@+node:ekr.20100504092040.18289:Fixed crash in log pane
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 366, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 284, in autoComplete
    k.masterCommand(event,func=None,stroke=None,commandName=None)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2606, in masterCommand
    val = k.handleDefaultChar(event,stroke)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2664, in handleDefaultChar
    if stroke.lower() == 'return': stroke = '\n'
AttributeError: 'NoneType' object has no attribute 'lower'
#@nonl
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return 'break'

    self.language = g.scanForAtLanguage(c,c.p)
    if w and self.language == 'python' and (k.enable_autocompleter or force):
        self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20100504092040.18289:Fixed crash in log pane
#@+node:ekr.20100517094256.5803:Patch for 64-bit aspell
#@+node:ekr.20100517094256.5804:The patch
@nocolor-node

Good day!
I recently updated my aspell library, and leo started to crash. This is due to using c_int instead of c_void_p in ctypes, with 64-bit pointers. Patch below.

Cheers,
Marc-Antoine

=== modified file 'leo/core/leoEditCommands.py'
--- leo/core/leoEditCommands.py 2010-02-23 20:35:31 +0000
+++ leo/core/leoEditCommands.py 2010-04-05 15:38:47 +0000
@@ -8976,7 +8976,7 @@
    def getAspellWithCtypes (self):

        try:
-            c_int, c_char_p = ctypes.c_int, ctypes.c_char_p
+            c_void_p, c_char_p, c_int, c_uint = ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int, ctypes.c_uint

            if sys.platform.startswith('win'):
                path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
@@ -8996,20 +8996,36 @@
#@verbatim
            #@+node:ekr.20061018111933:<< define and configure aspell entry points >>
            # new_aspell_config
            new_aspell_config = aspell.new_aspell_config
-            new_aspell_config.restype = c_int
+            new_aspell_config.restype = c_void_p

            # aspell_config_replace
            aspell_config_replace = aspell.aspell_config_replace
-            aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p]
+            aspell_config_replace.argtypes = [c_void_p, c_char_p, c_char_p]

            # aspell_config_retrieve
            aspell_config_retrieve = aspell.aspell_config_retrieve
            aspell_config_retrieve.restype = c_char_p
-            aspell_config_retrieve.argtypes = [c_int, c_char_p]
+            aspell_config_retrieve.argtypes = [c_void_p, c_char_p]

            # aspell_error_message
            aspell_error_message = aspell.aspell_error_message
+            aspell_error_message.argtypes = [c_void_p]
            aspell_error_message.restype = c_char_p
+
+            # new_aspell_speller
+            new_aspell_speller = aspell.new_aspell_speller
+            new_aspell_speller.argtypes = [c_void_p]
+            new_aspell_speller.restype = c_void_p
+
+            # aspell_error_number
+            aspell_error_number = aspell.aspell_error_number
+            aspell_error_number.argtypes = [c_void_p]
+            aspell_error_number.restype = c_uint
+
+            # to_aspell_speller
+            to_aspell_speller = aspell.to_aspell_speller
+            to_aspell_speller.argtypes = [c_void_p]
+            to_aspell_speller.restype = c_void_p

            sc = new_aspell_config()
            if 0:
@@ -9020,42 +9036,42 @@
                g.pr(aspell_config_replace(sc, "lang",self.local_language_code))
                g.pr(aspell_config_retrieve(sc, "lang"))

-            possible_err = aspell.new_aspell_speller(sc)
-            aspell.delete_aspell_config(c_int(sc))
+            possible_err = new_aspell_speller(sc)
+            aspell.delete_aspell_config(c_void_p(sc))

            # Rudimentary error checking, needs more.
-            if aspell.aspell_error_number(possible_err) != 0:
+            if aspell_error_number(possible_err) != 0:
                self.report(aspell_error_message(possible_err))
                spell_checker = None
            else:
-                spell_checker = aspell.to_aspell_speller(possible_err)
+                spell_checker = to_aspell_speller(possible_err)

            if not spell_checker:
                raise Exception('aspell checker not enabled')

            word_list_size = aspell.aspell_word_list_size
-            word_list_size.restype = c_int
-            word_list_size.argtypes = [c_int,]
+            word_list_size.restype = c_uint
+            word_list_size.argtypes = [c_void_p,]

            # word_list_elements
            word_list_elements = aspell.aspell_word_list_elements
-            word_list_elements.restype = c_int
-            word_list_elements.argtypes = [c_int,]
+            word_list_elements.restype = c_void_p
+            word_list_elements.argtypes = [c_void_p,]

            # string_enumeration_next
            string_enumeration_next = aspell.aspell_string_enumeration_next
            string_enumeration_next.restype = c_char_p
-            string_enumeration_next.argtypes = [c_int,]
+            string_enumeration_next.argtypes = [c_void_p,]

            # check
            check = aspell.aspell_speller_check
            check.restype = c_int
-            check.argtypes = [c_int, c_char_p, c_int]
+            check.argtypes = [c_void_p, c_char_p, c_void_p]

            # suggest
            suggest = aspell.aspell_speller_suggest
-            suggest.restype = c_int
-            suggest.argtypes = [c_int, c_char_p, c_int]
+            suggest.restype = c_void_p
+            suggest.argtypes = [c_void_p, c_char_p, c_int]
#@verbatim
            #@nonl
#@verbatim
            #@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@verbatim
            #@nl
#@-node:ekr.20100517094256.5804:The patch
#@+node:ekr.20061018111331:getAspellWithCtypes
def getAspellWithCtypes (self):

    try:
        c_int, c_char_p = ctypes.c_int, ctypes.c_char_p
        c_void_p, c_uint = ctypes.c_void_p, ctypes.c_uint # 2010/05/11

        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        self.report('Can not load %s' % (path))
        self.aspell = self.check = self.sc = None
        return

    try:
        << define and configure aspell entry points >>
    except Exception:
        self.report('aspell checker not enabled')
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
#@+node:ekr.20061018111933:<< define and configure aspell entry points >>
# new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_void_p # 2010/05/11 was c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_void_p, c_char_p, c_char_p]
    # 2010/05/11: was [c_int, c_char_p, c_char_p]

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_void_p, c_char_p]
    # 2010/05/11: was [c_int, c_char_p]

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p
aspell_error_message.argtypes = [c_void_p] # 2010/05/11: was [c_int]

# new_aspell_speller
new_aspell_speller = aspell.new_aspell_speller
new_aspell_speller.argtypes = [c_void_p]
new_aspell_speller.restype = c_void_p

# aspell_error_number
aspell_error_number = aspell.aspell_error_number
aspell_error_number.argtypes = [c_void_p]
aspell_error_number.restype = c_uint

# to_aspell_speller
to_aspell_speller = aspell.to_aspell_speller
to_aspell_speller.argtypes = [c_void_p]
to_aspell_speller.restype = c_void_p

sc = new_aspell_config()
if 0:
    g.pr(sc )
    g.pr(aspell_config_replace(sc, "prefix", self.aspell_dir)) #1/0
    g.pr('prefix', self.aspell_dir, repr(aspell_config_retrieve(sc, "prefix")))
    g.pr(aspell_config_retrieve(sc, "lang"))
    g.pr(aspell_config_replace(sc, "lang",self.local_language_code))
    g.pr(aspell_config_retrieve(sc, "lang"))

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))
possible_err = new_aspell_speller(sc) # 2010/05/11
aspell.delete_aspell_config(c_void_p(sc)) # 2010/05/11

# Rudimentary error checking, needs more.  
if aspell_error_number(possible_err) != 0: # 2010/05/11
    self.report(aspell_error_message(possible_err))
    spell_checker = None
else: 
    spell_checker = to_aspell_speller(possible_err) # 2010/05/11

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_uint # 2010/05/11: was c_int
word_list_size.argtypes = [c_void_p,] # 2010/05/11: was [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_void_p # 2010/05/11: was c_int
word_list_elements.argtypes = [c_void_p,] # 2010/05/11: was [c_int,]


# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_void_p,] # 2010/05/11: was [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_void_p # 2010/05/11: was c_int
suggest.argtypes = [c_void_p, c_char_p, c_int]
    # 2010/05/11: was [c_int, c_char_p, c_int]
#@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@-node:ekr.20061018111331:getAspellWithCtypes
#@-node:ekr.20100517094256.5803:Patch for 64-bit aspell
#@+node:ekr.20100526084301.5912:Fixed at-auto-rst bug
#@+node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:><_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
#@-node:ekr.20090513073632.5733:initAtAutoWrite (rstCommands)
#@+node:ekr.20090502071837.93:underline (leoRst)
def underline (self,s,p):

    '''Return the underlining string to be used at the given level for string s.
    This includes the headline, and possibly a leading overlining line.
    '''

    trace = False and not g.unitTesting

    if self.atAutoWrite:
        # We *might* generate overlines for top-level sections.
        u = self.atAutoWriteUnderlines
        level = p.level()-self.topLevel

        if trace: g.trace('level: %s under2: %s under1: %s %s' % (
            level,repr(self.underlines2),repr(self.underlines1),p.h))

        # This is tricky. The index n depends on several factors.
        if self.underlines2:
            level -= 1 # There *is* a double-underlined section.
            n = level
        else:
            n = level-1

        if 0 <= n < len(u):
            ch = u[n]
        elif u:
            ch = u[-1]
        else:
            g.trace('can not happen: no u')
            ch = '#'

        # 2010/01/10: write longer underlines for non-ascii characters.
        n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        if level == 0 and self.underlines2:
            return '%s\n%s\n%s\n\n' % (ch*n,p.h,ch*n)
        else:
            return '%s\n%s\n\n' % (p.h,ch*n)
    else:
        # The user is responsible for top-level overlining.
        u = self.getOption('underline_characters') #  '''#=+*^~"'`-:><_'''
        level = max(0,p.level()-self.topLevel)
        level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
        ch = u [level]
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
        return '%s\n%s\n\n' % (p.h.strip(),ch*n)
#@-node:ekr.20090502071837.93:underline (leoRst)
#@-node:ekr.20100526084301.5912:Fixed at-auto-rst bug
#@+node:ekr.20100526084301.5913:Fixed erroneous error message in at-auto-rst read logic
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False):

    """Scan vnodes, looking for @<file> nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    force = partialFlag
    if partialFlag:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()

    scanned_tnodes = set()

    if partialFlag: after = p.nodeAfterTree()    
    else: after = c.nullPosition()

    while p and p != after:
        gnx = p.gnx
        #skip clones
        if gnx in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(gnx)

        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,force=force)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p,force=force)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty() # Expensive, but it can't be helped.
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_nodes():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @<file> nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Remember that we have read this file.
    p.v.at_read = True # Create the attribute

    s,ok,fileKey = c.cacher.readFile(fileName,p)
    if ok: return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        c.cacher.writeFile(p,fileKey)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20100208071151.5905:readFile (cacher)
def readFile (self,fileName,root):

    trace = False and not g.unitTesting
    c = self.c

    if not g.enableDB:
        if trace: g.trace('g.enableDB is False')
        return '',False,None

    s,e = g.readFileIntoString(fileName,raw=True,silent=True)
    if s is None:
        if trace: g.trace('empty file contents',fileName)
        return s,False,None
    assert not g.isUnicode(s)

    # There will be a bug if s is not already an encoded string.
    key = self.fileKey(root.h,s,requireEncodedString=True)
    ok = self.db and key in self.db
    if trace: g.trace('in cache',ok,fileName,key)
    if ok:
        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        # Recreate the file from the cache.
        aList = self.db[key]
        self.createOutlineFromCacheList(root.v,aList,fileName=fileName)

    return s,ok,key
#@-node:ekr.20100208071151.5905:readFile (cacher)
#@+node:ekr.20100208071151.5903:writeFile (cacher)
# Was atFile.writeCachedTree

def writeFile(self,p,fileKey):

    trace = False and not g.unitTesting
    c = self.c

    # Bug fix: 2010/05/26: check g.enableDB before giving internal error.
    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif not fileKey:
        g.trace(g.callers(5))
        g.internalError('empty fileKey')
    elif fileKey in self.db:
        if trace: g.trace('already cached',fileKey)
    else:
        if trace: g.trace('caching ',p.h,fileKey)
        self.db[fileKey] = self.makeCacheList(p)
#@-node:ekr.20100208071151.5903:writeFile (cacher)
#@-node:ekr.20100526084301.5913:Fixed erroneous error message in at-auto-rst read logic
#@+node:ekr.20100614101034.5921:Fixed crasher in openFileForReading
#@+node:ekr.20041005105605.21:at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # 2010/02/24: Never read an external file
    # with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike:
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    if at.errors == 0 and not isFileLike:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('root.isDirty',root.isDirty())

    return at.errors == 0
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20100122130101.6174:deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@-node:ekr.20100122130101.6174:deleteTnodeList
#@+node:ekr.20041005105605.22:initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@-node:ekr.20041005105605.22:initFileName
#@+node:ekr.20100224050618.11547:at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@-node:ekr.20100224050618.11547:at.isFileLike
#@+node:ekr.20071105164407:warnAboutUnvisitedNodes
def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
#@-node:ekr.20071105164407:warnAboutUnvisitedNodes
#@-node:ekr.20041005105605.21:at.read & helpers
#@+node:ekr.20041005105605.19:openFileForReading (atFile) helper
def openFileForReading(self,fromString=False):

    '''Open the file given by at.root.
    This will be the private file for @shadow nodes.'''

    trace = False and not g.app.unitTesting
    verbose = False
    at = self ; c = at.c

    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.inputFile = g.fileLikeObject(fromString=fromString)
        fn = None
    else:
        fn = at.fullPath(self.root)
            # Returns full path, including file name.
        at.setPathUa(self.root,fn) # Remember the full path to this node.
        if trace: g.trace(fn)

        if at.atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn     = x.shadowPathName(fn)
            shadow_exists = g.os_path_exists(shadow_fn) and \
                g.os_path_isfile(shadow_fn)
            if not shadow_exists:
                g.trace('can not happen: no private file',
                    shadow_fn,g.callers())
                return at.error(
                    'can not happen: private file does not exist: %s' % (
                        shadow_fn))
            # This method is the gateway to the shadow algorithm.
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            if trace and verbose and at.atShadow:
                g.trace('opening %s file: %s' % (
                    g.choose(at.atShadow,'private','public'),fn))
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
            fn = None

    return fn
#@-node:ekr.20041005105605.19:openFileForReading (atFile) helper
#@-node:ekr.20100614101034.5921:Fixed crasher in openFileForReading
#@-node:ekr.20100319090849.5760:Bugs
#@+node:ekr.20100319090849.5759:Features
#@+node:ekr.20100307070200.5720:Fixed the @test logic
#@+node:ekr.20090514072254.5746:runUnitTestLeoFile
def runUnitTestLeoFile (gui='qt',path='unitTest.leo',silent=True):

    '''Run all unit tests in path (a .leo file) in a pristine environment.'''

    # New in Leo 4.5: leoDynamicTest.py is in the leo/core folder.
    trace = False
    path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
    leo  = g.os_path_finalize_join(g.app.loadDir,'..','core','leoDynamicTest.py')

    if sys.platform.startswith('win'): 
        if ' ' in leo: leo = '"' + leo + '"'
        if ' ' in path: path = '"' + path + '"'

    guiArg = '--gui=%s' % gui
    pathArg = '--path=%s' % path
    args = [sys.executable,leo,path,guiArg,pathArg]
    if silent: args.append('--silent')
    if trace: g.trace(args)

    # 2010/03/05: set the current directory so that importing leo.core.whatever works.
    leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')

    # os.chdir(leoDir)
    # os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
    env = dict(os.environ)
    env['PYTHONPATH'] = env.get('PYTHONPATH', '') + ';' + leoDir

    if False:
        keys = list(os.environ.keys())
        keys.sort()
        for z in keys:
            print(z,os.environ.get(z))

    if trace: g.trace('*** spawning test process',path)
    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
#@-node:ekr.20090514072254.5746:runUnitTestLeoFile
#@+node:ekr.20100307070200.5721:patch
# Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
#@-node:ekr.20100307070200.5721:patch
#@-node:ekr.20100307070200.5720:Fixed the @test logic
#@+node:ekr.20100313080341.5732:Allow changing minibuffer colors
@nocolor-node

Added the following options with the indicated defaults.

\@color minibuffer_background_color = lightblue
\@color minibuffer_warning_color = lightgrey
#@+node:ekr.20061031131434.76: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.widget = c.frame.miniBufferWidget
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
#@+node:ekr.20061031131434.78:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@-node:ekr.20061031131434.78:<< define externally visible ivars >>
#@+node:ekr.20061031131434.79:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@-node:ekr.20061031131434.79:<< define internal ivars >>
#@-node:ekr.20061031131434.76: ctor (keyHandler)
#@+node:ekr.20061031170011.3:Minibuffer (keyHandler)
# These may be overridden, but this code is now gui-independent.
#@nonl
#@+node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
def minibufferWantsFocus(self):

    c = self.c
    c.widgetWantsFocus(c.miniBufferWidget)


def minibufferWantsFocusNow(self):

    c = self.c
    c.widgetWantsFocusNow(c.miniBufferWidget)
#@-node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
#@+node:ekr.20061031170011.5:getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.widget
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@-node:ekr.20061031170011.5:getLabel
#@+node:ekr.20080408060320.791:k.killLine
def killLine (self,protect=True):

    k = self ; c = self.c
    w = self.widget
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20080408060320.791:k.killLine
#@+node:ekr.20061031170011.6:protectLabel
def protectLabel (self):

    k = self ; w = self.widget
    if not w: return

    k.mb_prefix = w.getAllText()

#@-node:ekr.20061031170011.6:protectLabel
#@+node:ekr.20061031170011.7:resetLabel
def resetLabel (self):

    k = self ; w = self.widget
    k.setLabelGrey('')
    k.mb_prefix = ''

    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        k.setLabelBlue(label='%s State' % (state.capitalize()),protect=True)
#@-node:ekr.20061031170011.7:resetLabel
#@+node:ekr.20061031170011.8:setLabel
def setLabel (self,s,protect=False):

    trace = (False or self.trace_minibuffer) and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if trace: g.trace(repr(s),g.callers(4))

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20061031170011.8:setLabel
#@+node:ekr.20061031170011.9:extendLabel
def extendLabel(self,s,select=False,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('len(s)',len(s))
    if not s: return

    c.widgetWantsFocusNow(w)
    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
#@-node:ekr.20061031170011.9:extendLabel
#@+node:ekr.20080408060320.790:selectAll
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.widget
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


#@-node:ekr.20080408060320.790:selectAll
#@+node:ekr.20061031170011.10:setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.widget
    if not w: return

    w.setBackgroundColor(self.minibuffer_background_color) # 'lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20061031170011.10:setLabelBlue
#@+node:ekr.20061031170011.11:setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return

    w.setBackgroundColor(self.minibuffer_warning_color) # 'lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@-node:ekr.20061031170011.11:setLabelGrey
#@+node:ekr.20080510153327.2:setLabelRed
def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.widget
    if not w: return

    w.setForegroundColor(self.minibuffer_error_color) # 'red')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20080510153327.2:setLabelRed
#@+node:ekr.20061031170011.12:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
#@nonl
#@-node:ekr.20061031170011.12:updateLabel
#@+node:ekr.20061031170011.13:getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.widget
    trace = self.trace_minibuffer and not g.app.unitTesting

    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)

    trace and g.trace(i,j)
    return i,j
#@-node:ekr.20061031170011.13:getEditableTextRange
#@-node:ekr.20061031170011.3:Minibuffer (keyHandler)
#@-node:ekr.20100313080341.5732:Allow changing minibuffer colors
#@+node:ekr.20100313150347.8255:Added legend for print-settings command
#@+node:ekr.20070418073400:g.app.config.printSettings
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
    legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in self.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    g.es('',''.join(result),tabName='Settings')
#@-node:ekr.20070418073400:g.app.config.printSettings
#@-node:ekr.20100313150347.8255:Added legend for print-settings command
#@+node:ekr.20100507153425.5799:Added support for @string qt-toolbar-location
Valid values are top,bottom,left,right
#@nonl
#@-node:ekr.20100507153425.5799:Added support for @string qt-toolbar-location
#@+node:ekr.20100616160343.5929:Added g.app.config.config_iter
This simplifies the print-settings command.
#@nonl
#@+node:ekr.20100616083554.5922:Iterators... (g.app.config)
def config_iter(self,c):

    '''Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    '''

    names = [] # Already-handled settings names.
    result = []

    if c:
        d = self.localOptionsDict.get(c.hash())
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,c,'F'),)

    for d in self.localOptionsList:
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,None,letter),)

    for d in self.dictList:
        for name,val,letter in self.config_iter_helper(d,names):
            result.append((name,val,None,letter),)

    result.sort()
    for z in result:
        yield z

    raise StopIteration
#@+node:ekr.20100616083554.5923:config_iter_helper
def config_iter_helper (self,d,names):

    if not d: return []

    result = []
    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')
    theHash = d.get('_hash').lower()

    if theHash.endswith('myleosettings.leo'):
        letter = 'M'
    elif theHash.endswith('leosettings.leo'):
        letter = ' '
    else:
        letter = 'D' # Default setting.

    for key in d:
        if key not in suppressKeys and key not in names:
            bunch = d.get(key)
            if bunch and bunch.kind not in suppressKind:
                names.append(key)
                result.append((key,bunch.val,letter),)

    return result
#@-node:ekr.20100616083554.5923:config_iter_helper
#@-node:ekr.20100616083554.5922:Iterators... (g.app.config)
#@+node:ekr.20070418073400:g.app.config.printSettings
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
    legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in self.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    g.es('',''.join(result),tabName='Settings')
#@-node:ekr.20070418073400:g.app.config.printSettings
#@-node:ekr.20100616160343.5929:Added g.app.config.config_iter
#@+node:ekr.20100520070413.5879:Don't create @chapter node for new file
@nocolor-node

I think @chapters node shouldn't be in a new leo file, but it should
be created when the first chapter is created.

Ditto for the chapter selector toolbar button.
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,
        relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c)
            # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.p
    c.miniBufferWidget = c.frame.miniBufferWidget
    # print('Commands.finishCreate',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders:
        # A 'real' .leo file.
        import leo.core.leoEditCommands as leoEditCommands
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        self.rstCommands.finishCreate()

        # copy global commands to this controller    

        for name,f in g.app.global_commands_dict.items():
            k.registerCommand(name,shortcut = None, func = f, pane='all',verbose=False)        

        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()
    c.bodyWantsFocusNow()
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):

    c = self

    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print('%30s = %s' % (
            key,g.choose(command,command.__name__,'<None>')))
    print('')
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20090520055433.5952:g.finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
#@-node:ekr.20090520055433.5952:g.finishOpen
#@+node:ekr.20100618065127.5924:Changed
#@+node:ekr.20070325104904:cc.finishCreate
def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    # g.trace('(chapterController)',g.callers(4))

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if 0: # Now done in cc.createChapterNode.
        if not cc.chaptersNode and not cc.findChaptersNode():
            cc.createChaptersNode()

    if cc.findChaptersNode():
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.all_unique_positions():
        h = p.h
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    # Always select the main chapter.
    # It can be alarming to open a small chapter in a large .leo file.
    cc.selectChapterByName('main')
#@-node:ekr.20070325104904:cc.finishCreate
#@+node:ekr.20070325063303.2:cc.createChapterNode
def createChapterNode (self,chapterName,p=None):

    '''Create an @chapter node for the named chapter.
    Use p for the first child, or create a first child if p is None.'''

    cc = self ; c = cc.c
    current = c.p or c.rootPosition()

    # 2010/06/17: Create an @chapters node if necessary.
    # This is no longer done automatically when creating a new window.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()
        if hasattr(c.frame.iconBar,'createChaptersIcon'):
            c.frame.iconBar.createChaptersIcon()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    root = current.insertAsLastChild()
    root.initHeadString('@chapter ' + chapterName)
    root.moveToFirstChildOf(cc.chaptersNode)
    if p:
        # Clone p and move it to the first child of the root.
        clone = p.clone()
        clone.moveToFirstChildOf(root)
    else:
        cc.createChild(root,'%s node 1' % chapterName)
    c.setChanged(True)

    return root
#@-node:ekr.20070325063303.2:cc.createChapterNode
#@-node:ekr.20100618065127.5924:Changed
#@-node:ekr.20100520070413.5879:Don't create @chapter node for new file
#@-node:ekr.20100319090849.5759:Features
#@-node:ekr.20100303074003.5639:Leo 4.8 devel projects
#@+node:ekr.20100517130356.5809:New sentinels
#@+node:ekr.20100624082003.5936:  To do
@nocolor-node

** Make sure that @shadow always write version-4 (old-style) sentinels.
#@-node:ekr.20100624082003.5936:  To do
#@+node:ekr.20100625184546.5977: Searches
#@+node:ekr.20100625092449.5962:Found: at.docOut
# The docOut exists so that the doc part can be munged.
#@nonl
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@+node:ekr.20100624082003.5942:appendToDocPart
def appendToDocPart (self,s):

    trace = False and not g.unitTesting
    at = self

    # Skip the leading stuff
    if len(at.endSentinelComment) == 0:
        # Skip the single comment delim and a blank.
        i = g.skip_ws(s,0)
        if g.match(s,i,at.startSentinelComment):
            i += len(at.startSentinelComment)
            if g.match(s,i," "): i += 1
    else:
        i = at.skipIndent(s,0,at.indent)

    # Append s to docOut.
    line = s[i:-1] # remove newline for rstrip.

    if line == line.rstrip():
        # no trailing whitespace: the newline is real.
        at.docOut.append(line + '\n')
    else:
        # trailing whitespace: the newline is fake.
        at.docOut.append(line)

    if trace: g.trace(repr(line))
#@-node:ekr.20100624082003.5942:appendToDocPart
#@+node:ekr.20100624082003.5938:readStartAt
def readStartAt (self,s,i):

    """Read an @+at sentinel."""

    at = self
    assert g.match(s,i,"+at"),'missing +at'
    i += 3

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
#@-node:ekr.20100624082003.5938:readStartAt
#@+node:ekr.20100624082003.5939:readStartDoc
def readStartDoc (self,s,i):

    """Read an @+doc sentinel."""

    at = self
    assert g.match(s,i,"+doc"),'missing +doc'
    i += 4

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]+'\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
#@-node:ekr.20100624082003.5939:readStartDoc
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.appendToOut(tag + s)
    at.docOut = []
#@-node:ekr.20041005105605.99:readLastDocLine
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nl"),'missing nl sentinel'

    if at.inCode:
        at.appendToOut('\n')
    else:
        at.docOut.append('\n')
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nonl"),'missing nonl sentinel'

    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[:-1]] # Do not use at.appendToOut here!
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@-node:ekr.20041005105605.110:readNonl
#@-node:ekr.20100625092449.5962:Found: at.docOut
#@+node:ekr.20100625140824.5967:Found: endSentinelStack
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.atAllFlag = False # True if @all seen.
self.cloneSibCount = 0
    # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
    # Contains entries for +node sentinels only when not readVersion5
self.endSentinelNodeStack = []
    # Used only when readVersion5.
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None
    # The last thin node at this level.
    # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.readVersion = '' # New in Leo 4.8: "4" or "5" for new-style thin files.
self.readVersion5 = False # synonym for new_read and at.readVersion >= '5'
self.rootSeen = False
self.tnodeList = []
    # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.vStack = [] # Stack of at.v values.
self.thinNodeStack = [] # Entries are vnodes.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.lineNumber = 0
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.endSentinelNodeStack = [None]
at.out = [] ; at.outStack = []
at.v = p.v
at.vStack = []
# New code: always identify root @thin node with self.root:
at.lastThinNode = None
at.thinNodeStack = []
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert at.endSentinelStack,'empty sentinel stack'

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.81:at.readStartAll
def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+all"),'missing @+all'
    else:
        assert g.match(s,j,"+all"),'missing +all'

    # g.trace('root_seen',at.root_seen,at.root.h,repr(s))
    at.atAllFlag = True

    # Make sure that the generated at-all is properly indented.
    at.appendToOut(leadingWs + "@all\n")
    at.endSentinelStack.append(at.endAll)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.81:at.readStartAll
#@+node:ekr.20041005105605.85:at.readStartNode & helpers
def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    at = self
    gnx,headline,i,level,ok = at.parseNodeSentinel(s,i,middle)
    if not ok: return
    at.root_seen = True

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out)
    at.out = []
    at.vStack.append(at.v)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        at.v = at.createNewThinNode(gnx,headline,level)
    else:
        at.v = at.findChild4(headline)

    if not at.readVersion5:
        at.endSentinelStack.append(at.endNode)
#@+node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
def createNewThinNode (self,gnx,headline,level):

    trace = False and not g.unitTesting
    at = self

    if at.thinNodeStack:
        if at.readVersion5:
            oldLevel = len(at.thinNodeStack)
            newLevel = level - 1
            assert newLevel >= 0
            at.closePreviousNode(oldLevel,newLevel)
            v = at.createThinChild4(gnx,headline)
            at.thinNodeStack.append(v)
            if trace: g.trace(
                '** oldLvl: %s, newLvl: %s, v: %s, last: %s, stack: \n%s\n' % (
                oldLevel,newLevel,v.h,at.lastThinNode.h,
                [z.h for z in at.thinNodeStack]))
        else:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
    else:
        v = at.root.v
        at.thinNodeStack.append(v)

    at.lastThinNode = v
    return v
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@-node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
#@+node:ekr.20100625184546.5979:parseNodeSentinel & helpers
def parseNodeSentinel (self,s,i,middle):

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+node"),'bad start node sentinel'
        i += 1
    elif middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        assert g.match(s,i,"+node:"),'missing +node'
        i += 6

    # Get the gnx and the headline.
    if at.thinFile:
        gnx,i,level,ok = at.parseThinNodeSentinel(s,i)
        if not ok: None,None,None,False

    headline = at.getNodeHeadline(s,i)
    return gnx,headline,i,level,True
#@+node:ekr.20100625085138.5955:getNodeHeadline
def getNodeHeadline (self,s,i):

    '''Set headline to the rest of the line.
    Don't strip leading whitespace.'''

    at = self

    if len(at.endSentinelComment) == 0:
        h = s[i:-1].rstrip()
    else:
        k = s.rfind(at.endSentinelComment,i)
        h = s[i:k].rstrip() # works if k == -1

    # Undo the CWEB hack: undouble @ signs if\
    # the opening comment delim ends in '@'.
    if at.startSentinelComment[-1:] == '@':
        h = h.replace('@@','@')

    return h
#@-node:ekr.20100625085138.5955:getNodeHeadline
#@+node:ekr.20100625085138.5953:parseThinNodeSentinel
def parseThinNodeSentinel (self,s,i):

    at = self

    def oops(s):
        at.readError(s)
        return None,None,None,False

    j = s.find(':',i)
    if j == -1:
        return oops('Expecting gnx in @+node sentinel')
    else:
        gnx = s[i:j]

    if at.readVersion5:
        if not g.match(s,j,': '):
            return oops('Expecting space after gnx')
        i = j + 2
        level = 0
        while i < len(s) and s[i] == '*':
            i += 1
            level += 1
        if level == 0:
            return oops('No level stars')
        if not g.match(s,i,' '):
            return oops('No space after level stars')
        i += 1
    else: # not readVersion5.
        i = j + 1 # Skip the gnx.
        level = 0

    return gnx,i,level,True
#@-node:ekr.20100625085138.5953:parseThinNodeSentinel
#@-node:ekr.20100625184546.5979:parseNodeSentinel & helpers
#@-node:ekr.20041005105605.85:at.readStartNode & helpers
#@+node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert at.endSentinelStack,'empty sentinel stack'
    s = "(badEndSentinel) Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        if 1: g.trace('%s\n%s' % (
            [at.sentinelName(z) for z in at.endSentinelStack],
            g.callers(4)))
        at.badEndSentinel(expectedKind)
#@-node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self

    at.popSentinelStack(at.endOthers)

    if at.readVersion5:
        at.v = at.endSentinelNodeStack.pop()
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20100624082003.5938:readStartAt
def readStartAt (self,s,i):

    """Read an @+at sentinel."""

    at = self
    assert g.match(s,i,"+at"),'missing +at'
    i += 3

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
#@-node:ekr.20100624082003.5938:readStartAt
#@+node:ekr.20100624082003.5939:readStartDoc
def readStartDoc (self,s,i):

    """Read an @+doc sentinel."""

    at = self
    assert g.match(s,i,"+doc"),'missing +doc'
    i += 4

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]+'\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
#@-node:ekr.20100624082003.5939:readStartDoc
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self

    j = g.skip_ws(s,i)
    leadingWs = s[i:j]

    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    at.appendToOut(leadingWs + "@others\n")
    at.endSentinelStack.append(at.endOthers)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.89:readStartOthers
#@+node:ekr.20041005105605.114:sentinelKind4 & helper (read logic)
def sentinelKind4(self,s):

    """Return the kind of sentinel at s."""

    trace = False and not g.unitTesting
    at = self

    val = at.sentinelKind4_helper(s)

    if trace: g.trace('%-20s %s' % (
        at.sentinelName(val),s.rstrip()))

    return val
#@+node:ekr.20100518083515.5896:sentinelKind4_helper
def sentinelKind4_helper(self,s):

    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + s[i:].replace('@@','@')

    # New sentinels.
    if g.match(s,i,"@+"):
        if g.match(s,i+2,"others"):
            return at.startOthers
        elif g.match(s,i+2,"<<"):
            return at.startRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"<<"):
                return at.startRef
    elif g.match(s,i,"@-"):
        if g.match(s,i+2,"others"):
            return at.endOthers
        elif g.match(s,i+2,"<<"):
            return at.endRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"<<"):
                return at.endRef
    # Old sentinels.
    elif g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"@-others"):
                return at.endOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and key in at.sentinelDict:
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@-node:ekr.20100518083515.5896:sentinelKind4_helper
#@-node:ekr.20041005105605.114:sentinelKind4 & helper (read logic)
#@+node:ekr.20041005105605.115:skipSentinelStart4
def skipSentinelStart4(self,s,i):

    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)>0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.115:skipSentinelStart4
#@+node:ekr.20041005105605.111:readRef (paired using new sentinels)
@
The sentinel contains an @ followed by a section name in angle brackets.
This code is different from the code for the @@ sentinel: the expansion
of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @<< sentinel."""

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+")
        i += 1 # Skip the new plus sign.
    j = g.skip_ws(s,i)
    assert g.match(s,j,"<<"),'missing @<< sentinel'

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    if new_read and at.readVersion == '5':
        # Put the newline back: there is no longer an @nl sentinel.
        line = line + '\n'

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.appendToOut(line)
    if at.readVersion5:
        at.endSentinelStack.append(at.endRef)
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.111:readRef (paired using new sentinels)
#@-node:ekr.20100625140824.5967:Found: endSentinelStack
#@+node:ekr.20100625161750.5972:Found: tempBodyString
#@+node:ekr.20041005105605.21:at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # 2010/02/24: Never read an external file
    # with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike:
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    if at.errors == 0 and not isFileLike:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('root.isDirty',root.isDirty())

    return at.errors == 0
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20100122130101.6174:deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@-node:ekr.20100122130101.6174:deleteTnodeList
#@+node:ekr.20041005105605.22:initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@-node:ekr.20041005105605.22:initFileName
#@+node:ekr.20100224050618.11547:at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@-node:ekr.20100224050618.11547:at.isFileLike
#@+node:ekr.20071105164407:warnAboutUnvisitedNodes
def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
#@-node:ekr.20071105164407:warnAboutUnvisitedNodes
#@-node:ekr.20041005105605.21:at.read & helpers
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@+node:ekr.20041005105605.95:at.readEndNode
def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle @-node sentinels."""

    trace = False and not g.unitTesting
    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    if at.readVersion5:
        if hasattr(at.v,'tempBodyList'):
            s = ''.join(at.v.tempBodyList)
        else:
            s = ''
    else:
        s = ''.join(at.out)

    s = g.toUnicode(s)
    # g.trace('%20s %s' % (at.v.h,repr(s)))

    if at.importing:
        at.v._bodyString = s # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if at.v == at.root.v:
            old = None # Don't issue warnings for the root.
        elif hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None

        if old:
            << indicate that the node has been changed >>

        # *Always* update the text.
        if at.readVersion5:
            if trace and hasattr(at.v,"tempBodyString") and at.v.tempBodyString:
                g.trace('*** can not happen: tempBodyString',at.v.h,repr(s))
        else:
            at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.vStack.pop()

    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    if not at.readVersion5:
        at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty()
        # Mark the node dirty. Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # 2010/02/05: removed special case for @all.
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx=at.v.gnx,
        fileName = at.root.h,
        b_old=old,
        b_new=s,
        h_old=at.v._headString,
        h_new=at.v._headString,
    ))

    g.es_print("uncached read node changed",at.v.h,color="red")

    at.v.setDirty()
        # Just set the dirty bit. Ancestors will be marked dirty later.
    c.changed = True
        # Important: the dirty bits won't stick unless we set c.changed here.
        # Do *not* call c.setChanged(True) here: that would be too slow.
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:at.readEndNode
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty()
        # Mark the node dirty. Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # 2010/02/05: removed special case for @all.
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx=at.v.gnx,
        fileName = at.root.h,
        b_old=old,
        b_new=s,
        h_old=at.v._headString,
        h_new=at.v._headString,
    ))

    g.es_print("uncached read node changed",at.v.h,color="red")

    at.v.setDirty()
        # Just set the dirty bit. Ancestors will be marked dirty later.
    c.changed = True
        # Important: the dirty bits won't stick unless we set c.changed here.
        # Do *not* call c.setChanged(True) here: that would be too slow.
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):

    c = self.c
    for p in root.self_and_subtree():
        if hasattr(p.v,'tempBodyString'):
            s = p.v.tempBodyString
        else:
            s = ''
        if hasattr(p.v,'tempBodyList'):
            s = s + ''.join(p.v.tempBodyList)
        # try: s = p.v.tempBodyString
        # except Exception: s = ""
        old_body = p.b
        if s != old_body:
            if thinFile:
                p.v.setBodyString(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                c.setBodyString(p,s) # Sets c and p dirty.

            if p.v.isDirty():
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                # 2010/02/05: This warning is given elsewhere.
                # g.es("changed:",p.h,color="blue")
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@-node:ekr.20100625161750.5972:Found: tempBodyString
#@+node:ekr.20100625184546.5976:Found: thinNodeStack
#@+node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
def createNewThinNode (self,gnx,headline,level):

    trace = False and not g.unitTesting
    at = self

    if at.thinNodeStack:
        if at.readVersion5:
            oldLevel = len(at.thinNodeStack)
            newLevel = level - 1
            assert newLevel >= 0
            at.closePreviousNode(oldLevel,newLevel)
            v = at.createThinChild4(gnx,headline)
            at.thinNodeStack.append(v)
            if trace: g.trace(
                '** oldLvl: %s, newLvl: %s, v: %s, last: %s, stack: \n%s\n' % (
                oldLevel,newLevel,v.h,at.lastThinNode.h,
                [z.h for z in at.thinNodeStack]))
        else:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
    else:
        v = at.root.v
        at.thinNodeStack.append(v)

    at.lastThinNode = v
    return v
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@-node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
#@+node:ekr.20041005105605.95:at.readEndNode
def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle @-node sentinels."""

    trace = False and not g.unitTesting
    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    if at.readVersion5:
        if hasattr(at.v,'tempBodyList'):
            s = ''.join(at.v.tempBodyList)
        else:
            s = ''
    else:
        s = ''.join(at.out)

    s = g.toUnicode(s)
    # g.trace('%20s %s' % (at.v.h,repr(s)))

    if at.importing:
        at.v._bodyString = s # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if at.v == at.root.v:
            old = None # Don't issue warnings for the root.
        elif hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None

        if old:
            << indicate that the node has been changed >>

        # *Always* update the text.
        if at.readVersion5:
            if trace and hasattr(at.v,"tempBodyString") and at.v.tempBodyString:
                g.trace('*** can not happen: tempBodyString',at.v.h,repr(s))
        else:
            at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.vStack.pop()

    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    if not at.readVersion5:
        at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty()
        # Mark the node dirty. Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # 2010/02/05: removed special case for @all.
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx=at.v.gnx,
        fileName = at.root.h,
        b_old=old,
        b_new=s,
        h_old=at.v._headString,
        h_new=at.v._headString,
    ))

    g.es_print("uncached read node changed",at.v.h,color="red")

    at.v.setDirty()
        # Just set the dirty bit. Ancestors will be marked dirty later.
    c.changed = True
        # Important: the dirty bits won't stick unless we set c.changed here.
        # Do *not* call c.setChanged(True) here: that would be too slow.
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:at.readEndNode
#@+node:ekr.20100619222623.5918:How to read new sentinels
http://groups.google.com/group/leo-editor/browse_thread/thread/3c3d52f652386d25

How to read new sentinels

The old scheme uses three stacks:

- The **node stack**, at.thinNodeStack, contains the vnode being read at every
nesting level.

- The **indent stack**, at.indentStack, contains the leading whitespace (in
  units of blanks) to be removed from all body lines at a particular level. This
  is *not* the same as the outline level of the node! In particular, it does not
  depend on level stars.

- The **sentinel stack**, at.endSentinelStack, contains an entry for every pair
  of sentinels. For example, when Leo appends an -others item to this stack when
  it reads a +others sentinel.  The old scheme appends -node entries when it reads
  a +node sentinel: the new scheme probably won't.

- The **sentinel-level stack**, at.sentinelLevelStack. Only the new scheme uses
  this stack. This stack contains the outline level in effect when the opening
  sentinel is seen. When the closing sentinel is seen we cut back the node and
  indent stacks to that level.

In general, +node sentinels push, pop and change entries on the node and indent
stacks, while paired sentinels push and pop entries on the sentinel and
sentinel-level stacks. The node and indent stacks always have the same number of
entries, as do the sentinel and sentinel-level stacks (in the new scheme). Thus
we could speak of the **node/indent** stack, containing entries (v,indent), and
the **sentinel/level** stack, containing entries (kind,n).

In more details, we handle sentinels as follows:

Case 1. -others and -<<

This terminates the previous node, if it hasn't already been terminated.

- Pop the sentinel/level stack into kind,n.
- Check that kind is +others or +<<.
- Cut back the node/indent stack to level n. The top of the stack is (v,indent).
  The present node becomes v, and indent becomes the present indentation level.

Case 2. +node.

This terminates the previous node, if it hasn't already been terminated.

Unlike in the old scheme, outline level is indicated by the **level stars** in
the +node sentinel. Let N be the indentation of the new +node, and M be the
previous indentation. In a well-formed file N <= M+1.

Case 2a: N == M + 1.  Create a new node as the first child of the previous current node.

Case 2b: N == M.  Create a new node as the next sibling of the previous current node.

Case 3c: N < M. Cut back the node/indent stack to level N. In a well-formed thin file,
cutting back the stack can not terminate any section reference or @others range. Check this
by ensuring that N is not less than the indent item for all entries in the sentinel/level stack.
#@-node:ekr.20100619222623.5918:How to read new sentinels
#@-node:ekr.20100625184546.5976:Found: thinNodeStack
#@-node:ekr.20100625184546.5977: Searches
#@+node:ekr.20041005105605.7:at.Birth & init
#@+node:ekr.20041005105605.8:atFile.__init__
def __init__(self,c):

    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.

    # User options.
    self.checkPythonCodeOnWrite = c.config.getBool(
        'check-python-code-on-write',default=True)
    self.underindentEscapeString = c.config.getString(
        'underindent-escape-string') or '\\-'

    << define the dispatch dictionary used by scanText4 >>
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel,
    # New 4.8 sentinels
    self.endRef: self.readEndRef,
}
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__
#@+node:ekr.20041005105605.10:initCommonIvars
def initCommonIvars (self):

    """Init ivars common to both reading and writing.

    The defaults set here may be changed later."""

    c = self.c

    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict

    << set defaults for arguments and options >>
    << init common ivars >>
#@+node:ekr.20041005105605.11:<< set defaults for arguments and options >>
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.at_auto_encoding = c.config.default_at_auto_file_encoding
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
#@-node:ekr.20041005105605.11:<< set defaults for arguments and options >>
#@+node:ekr.20041005105605.12:<< init common ivars >>
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root (a position) of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
self.writing_to_shadow_directory = False
#@nonl
#@-node:ekr.20041005105605.12:<< init common ivars >>
#@-node:ekr.20041005105605.10:initCommonIvars
#@+node:ekr.20041005105605.13:initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):

    importing = importFileName is not None

    self.initCommonIvars()

    << init ivars for reading >>

    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = False # 2010/01/22: was thinFile
    self.atShadow = atShadow
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.atAllFlag = False # True if @all seen.
self.cloneSibCount = 0
    # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
    # Contains entries for +node sentinels only when not readVersion5
self.endSentinelNodeStack = []
    # Used only when readVersion5.
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None
    # The last thin node at this level.
    # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.readVersion = '' # New in Leo 4.8: "4" or "5" for new-style thin files.
self.readVersion5 = False # synonym for new_read and at.readVersion >= '5'
self.rootSeen = False
self.tnodeList = []
    # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.vStack = [] # Stack of at.v values.
self.thinNodeStack = [] # Entries are vnodes.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@-node:ekr.20041005105605.13:initReadIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    atAuto=False,
    atEdit=False,
    atShadow=False,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None,
):

    self.initCommonIvars()
    << init ivars for writing >>

    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels,
            issuePathWarning=True)

    # g.trace(forcePythonSentinels,
    #    self.startSentinelComment,self.endSentinelComment)

    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root

    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'

    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        self.root.v._p_changed = True
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the
temporary file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False
    # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.atAuto = atAuto
self.atEdit = atEdit
self.atShadow = atShadow
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False
self.force_newlines_in_at_nosent_bodies = self.c.config.getBool(
    'force_newlines_in_at_nosent_bodies')

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = g.u('')
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005105605.7:at.Birth & init
#@+node:ekr.20100619222623.5917:Notes
@nocolor

#@+node:ekr.20100619222623.5918:How to read new sentinels
http://groups.google.com/group/leo-editor/browse_thread/thread/3c3d52f652386d25

How to read new sentinels

The old scheme uses three stacks:

- The **node stack**, at.thinNodeStack, contains the vnode being read at every
nesting level.

- The **indent stack**, at.indentStack, contains the leading whitespace (in
  units of blanks) to be removed from all body lines at a particular level. This
  is *not* the same as the outline level of the node! In particular, it does not
  depend on level stars.

- The **sentinel stack**, at.endSentinelStack, contains an entry for every pair
  of sentinels. For example, when Leo appends an -others item to this stack when
  it reads a +others sentinel.  The old scheme appends -node entries when it reads
  a +node sentinel: the new scheme probably won't.

- The **sentinel-level stack**, at.sentinelLevelStack. Only the new scheme uses
  this stack. This stack contains the outline level in effect when the opening
  sentinel is seen. When the closing sentinel is seen we cut back the node and
  indent stacks to that level.

In general, +node sentinels push, pop and change entries on the node and indent
stacks, while paired sentinels push and pop entries on the sentinel and
sentinel-level stacks. The node and indent stacks always have the same number of
entries, as do the sentinel and sentinel-level stacks (in the new scheme). Thus
we could speak of the **node/indent** stack, containing entries (v,indent), and
the **sentinel/level** stack, containing entries (kind,n).

In more details, we handle sentinels as follows:

Case 1. -others and -<<

This terminates the previous node, if it hasn't already been terminated.

- Pop the sentinel/level stack into kind,n.
- Check that kind is +others or +<<.
- Cut back the node/indent stack to level n. The top of the stack is (v,indent).
  The present node becomes v, and indent becomes the present indentation level.

Case 2. +node.

This terminates the previous node, if it hasn't already been terminated.

Unlike in the old scheme, outline level is indicated by the **level stars** in
the +node sentinel. Let N be the indentation of the new +node, and M be the
previous indentation. In a well-formed file N <= M+1.

Case 2a: N == M + 1.  Create a new node as the first child of the previous current node.

Case 2b: N == M.  Create a new node as the next sibling of the previous current node.

Case 3c: N < M. Cut back the node/indent stack to level N. In a well-formed thin file,
cutting back the stack can not terminate any section reference or @others range. Check this
by ensuring that N is not less than the indent item for all entries in the sentinel/level stack.
#@-node:ekr.20100619222623.5918:How to read new sentinels
#@+node:ekr.20100619222623.5920:Example
#@verbatim
#@+leo-ver=5-thin
#@verbatim
#@leo-data <list of gnx's>
#@verbatim
#@node 1 * @thin sentinels_test.py
#@verbatim
#@@
# This is a doc part.
#@verbatim
#@c

#@verbatim
#@+<< a >>
#@verbatim
#@node 2 ** << a >>
a
#@verbatim
#@-<< a >>

#@verbatim
#@+others
#@verbatim
#@node 3 *** a-1
a-1
#@verbatim
#@node 4 *** a-2
a-2
#@verbatim
#@-others

b

#@verbatim
#@+others
#@verbatim
#@node 5 ** 1-1
1-1
#@verbatim
#@node 6 *** 2-1
2-1
#@verbatim
#@node 7 **** 3-1
3-1
#@verbatim
#@node 8 ** 1-2
1-2
#@verbatim
#@-others
#@nonl
#@-node:ekr.20100619222623.5920:Example
#@-node:ekr.20100619222623.5917:Notes
#@+node:ekr.20100518100915.5898:Utils
#@+node:ekr.20041005105605.5:<< define class constants >>
# These constants must be global to this module
# because they are shared by several classes.

# The kind of at_directives.
noDirective     =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective    =  3 # @doc.
atDirective     =  4 # @<space> or @<newline>
codeDirective   =  5 # @code
cDirective      =  6 # @c<space> or @c<newline>
othersDirective =  7 # at-others
miscDirective   =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel   = 20 # Not a sentinel
endAt        = 21 # @-at
endBody      = 22 # @-body
# not used   = 23
endDoc       = 24 # @-doc
endLeo       = 25 # @-leo
endNode      = 26 # @-node
endOthers    = 27 # @-others

# not used     = 40
startAt        = 41 # @+at
startBody      = 42 # @+body
startDoc       = 43 # @+doc
startLeo       = 44 # @+leo
startNode      = 45 # @+node
startOthers    = 46 # @+others

startComment   = 60 # @comment
startDelims    = 61 # @delims
startDirective = 62 # @@
startRef       = 63 # @< < ... > >
startVerbatim  = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)

# New in 4.8.
endRef         = 84 # @-<<
#@-node:ekr.20041005105605.5:<< define class constants >>
#@+node:ekr.20041005105605.198:directiveKind4 (write logic)
def directiveKind4(self,s,i):

    """Return the kind of at-directive or noDirective."""

    trace = False and not g.unitTesting
    at = self
    n = len(s)

    if trace and s.startswith('@'): g.trace(s.rstrip())

    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective),
        ("@verbatim",at.startVerbatim))

    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # New in Leo 4.4.3: add support for add_directives plugin.
    for name in g.globalDirectiveList:
        if g.match_word(s,i+1,name):
            return at.miscDirective

    return at.noDirective
#@-node:ekr.20041005105605.198:directiveKind4 (write logic)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):

    at = self

    sentinelNameDict = {
        at.endAll:        "@-all", # 4.x
        at.endAt:         "@-at",
        at.endBody:       "@-body", # 3.x only.
        at.endDoc:        "@-doc",
        at.endLeo:        "@-leo",
        at.endMiddle:     "@-middle", # 4.x
        at.endNode:       "@-node",
        at.endOthers:     "@-others",
        at.endRef:        "@-<<", # 4.8
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",
        at.startBody:     "@+body",
        at.startDoc:      "@+doc",
        at.startLeo:      "@+leo",
        at.startNode:     "@+node",
        at.startOthers:   "@+others",
        at.startAll:      "@+all",    
        at.startMiddle:   "@+middle", 
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef", # 3.x only.
    } 

    return sentinelNameDict.get(kind,"<unknown sentinel: %s>" % kind)
#@-node:ekr.20041005105605.243:sentinelName
#@+node:ekr.20041005105605.114:sentinelKind4 & helper (read logic)
def sentinelKind4(self,s):

    """Return the kind of sentinel at s."""

    trace = False and not g.unitTesting
    at = self

    val = at.sentinelKind4_helper(s)

    if trace: g.trace('%-20s %s' % (
        at.sentinelName(val),s.rstrip()))

    return val
#@+node:ekr.20100518083515.5896:sentinelKind4_helper
def sentinelKind4_helper(self,s):

    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + s[i:].replace('@@','@')

    # New sentinels.
    if g.match(s,i,"@+"):
        if g.match(s,i+2,"others"):
            return at.startOthers
        elif g.match(s,i+2,"<<"):
            return at.startRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"<<"):
                return at.startRef
    elif g.match(s,i,"@-"):
        if g.match(s,i+2,"others"):
            return at.endOthers
        elif g.match(s,i+2,"<<"):
            return at.endRef
        else:
            j = g.skip_ws(s,i+2)
            if g.match(s,j,"<<"):
                return at.endRef
    # Old sentinels.
    elif g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"@-others"):
                return at.endOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and key in at.sentinelDict:
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@-node:ekr.20100518083515.5896:sentinelKind4_helper
#@-node:ekr.20041005105605.114:sentinelKind4 & helper (read logic)
#@+node:ekr.20041005105605.120:at.parseLeoSentinel
def parseLeoSentinel (self,s):

    trace = False and not g.unitTesting
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    start = '' ; end = '' ; isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    if trace and not new_df:
        g.trace('not new_df(!)',repr(s))
    if trace: g.trace('valid',valid,'isThin',isThinDerivedFile)
    return valid,new_df,start,end,isThinDerivedFile
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False

#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@
REM hack: leading whitespace is significant before the
@+leo. We do this so that sentinelKind need not skip
whitespace following self.startSentinelComment. This is
correct: we want to be as restrictive as possible about what
is recognized as a sentinel. This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line,
    #                or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i < len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1
    at.readVersion = s[j:i] # 2010/05/18.
    at.readVersion5 = new_read and at.readVersion >= '5'

    if j < i:
        pass
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            g.es_print("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@-node:ekr.20041005105605.120:at.parseLeoSentinel
#@+node:ekr.20041005105605.72:at.createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees."""

    trace = False and not g.unitTesting
    verbose = False
    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode
    lastIndex = last.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last,gnxString,headline))

    parent = at.lastThinNode # A vnode.
    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(parent,child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies,headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace:g.trace('found last',last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child',child)
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the vnode only if it does not already exist.
        gnxDict = c.fileCommands.gnxDict
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.trace('can not happen: v.fileIndex: %s gnx: %s' % (
                    v.fileIndex,gnx))
        else:
            v = leoNodes.vnode(context=c)
            v._headString = headline # Allowed use of v._headString.
            v.fileIndex = gnx
            gnxDict[gnxString] = v

        child = v
        child._linkAsNthChild(parent,parent.numberOfChildren())

    if trace: g.trace('new node: %s' % child)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
#@-node:ekr.20041005105605.72:at.createThinChild4
#@+node:ekr.20100619120205.5915:int/base62
import string
digits62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
if 0: # a check.
    digits62a = []
    for z in string.digits: digits62a.append(z)
    for z in string.letters: digits62a.append(z)
    digits62a = ''.join(digits62a)
    assert digits62 == digits62a
assert len(digits62) == 62

def intToBase62 (i):
    if i == 0: return '0'
    result = []
    while i > 0:
        i,r = divmod(i,62)
        result.append(digits62[r])
    result.reverse()
    return ''.join(result)

def base62ToInt(s):
    if s == '0': return 0
    result = 0
    for ch in s:
        result = 62 * result + (digits62.find(ch)) # A dict would be faster.
    return result

for i in range(5000):
    s = intToBase62(i)
    # print('%s = %s' % (i,s))
    n = base62ToInt(s)
    assert n == i,'s: %s n: %s, i: %s' % (s,n,i)
if 1:
    for i in (0,1,9,99,999,9999,99999,999999,61,62,62**2-1,62**2,62**3-1,62**3):
        print('%10s = %s' % (i,intToBase62(i)))
print('done',62**2,62**3)
#@nonl
#@-node:ekr.20100619120205.5915:int/base62
#@-node:ekr.20100518100915.5898:Utils
#@+node:ekr.20100518100915.5902:Writing
#@+node:ekr.20041005105605.188:nodeSentinelText 4.x
def nodeSentinelText(self,p):

    """Return the text of a @+node or @-node sentinel for p."""

    at = self ; h = p.h
    << remove comment delims from h if necessary >>

    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.fileIndex)
        if new_write:
            level = 1 + p.level() - self.root.level()
            stars = '*' * level
            if 1: # Put the gnx in the traditional place.
                return "%s: %s %s" % (gnx,stars,h)
            else: # Hide the gnx to the right.
                pad = max(1,100-len(stars)-len(h)) * ' '
                return '%s %s%s::%s' % (stars,h,pad,gnx)
        else:
            return "%s:%s" % (gnx,h)
    else:
        return h
#@+node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
#@-node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
#@-node:ekr.20041005105605.188:nodeSentinelText 4.x
#@+node:ekr.20041005105605.167:putatAllBody
def putAtAllBody(self,p):

    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.b

    p.v.setVisited()
    # g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.

    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag and not new_write:
        at.putSentinel("@nonl")
#@+node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@-node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
#@-node:ekr.20041005105605.167:putatAllBody
#@+node:ekr.20041005105605.173:putAtOthersLine
def putAtOthersLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta

    lws = at.leadingWs or ''

    if lws:
        # Note: there are *two* at signs here.
        at.putSentinel("@" + lws + "@+others")
    else:
        at.putSentinel("@+others")

    for child in p.children():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    if new_write and lws:
        # This is a more consistent convention.
        at.putSentinel("@" + lws + "@-others")
    else:
        at.putSentinel("@-others")
    at.indent -= delta
#@-node:ekr.20041005105605.173:putAtOthersLine
#@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,middle=False):

    at = self

    if new_write:
        return

    s = self.nodeSentinelText(p)

    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
#@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
#@+node:ekr.20041005105605.193:putOpenNodeSentinel
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):

    """Write @+node sentinel for p."""

    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.h)
        return

    # g.trace(at.thinFile,p)

    s = at.nodeSentinelText(p)

    if new_write:
        at.putSentinel('@+node %s' % s)
    elif middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    # Leo 4.7 b2: we never write tnodeLists.
#@-node:ekr.20041005105605.193:putOpenNodeSentinel
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):

    """Put a reference at s[n1:n2+2] from p."""

    at = self ; c = at.c ; name = s[n1:n2+2]

    ref = g.findReference(c,name,p)
    if not ref:
        if not g.unitTesting:
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                    ( name,p.h))
        return None

    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)

    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()

    at.indent += delta

    lws = at.leadingWs or ''
    if new_write:
        at.putSentinel("@+" + lws + name)
    else:
        at.putSentinel("@" + lws + name)

    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)

    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)

    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)

    if new_write:
        at.putSentinel("@-" + lws + name)

    at.indent -= delta

    return delta
#@-node:ekr.20041005105605.177:putRefAt
#@-node:ekr.20100518100915.5902:Writing
#@+node:ekr.20100519091824.5874:Reading
#@+node:ekr.20100625184546.5978:Ref
#@+node:ekr.20041005105605.21:at.read & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    trace = False and not g.unitTesting
    if trace: g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    s,loaded,fileKey = c.cacher.readFile(fileName,root)
    # 2010/02/24: Never read an external file
    # with file-like sentinels from the cache.
    isFileLike = loaded and at.isFileLike(s)
    if not loaded or isFileLike:
        # if trace: g.trace('file-like file',fileName)
        force = True # Disable caching.
    if loaded and not force:
        if trace: g.trace('in cache',fileName)
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    if isFileLike:
        if g.unitTesting:
            if 0: print("converting @file format in",root.h)
            g.app.unitTestDict['read-convert']=True
        else:
            g.es("converting @file format in",root.h,color='red')
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if isFileLike:
        # 2010/02/24: Make the root @file node dirty so it will
        # be written automatically when saving the file.
        root.setDirty()
        c.setChanged(True) # Essential, to keep dirty bit set.
    if at.errors == 0 and not isFileLike:
        c.cacher.writeFile(root,fileKey)

    if trace: g.trace('root.isDirty',root.isDirty())

    return at.errors == 0
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
        if hasattr(v,"tempBodyList"):
            delattr(v,"tempBodyList")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20100122130101.6174:deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@-node:ekr.20100122130101.6174:deleteTnodeList
#@+node:ekr.20041005105605.22:initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName
#@-node:ekr.20041005105605.22:initFileName
#@+node:ekr.20100224050618.11547:at.isFileLike
def isFileLike (self,s):

    '''Return True if s has file-like sentinels.'''

    trace = False and not g.unitTesting
    at = self ; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        if trace: g.trace('found: False',repr(s))
        return True # Don't use the cashe.
    else:
        j,k = g.getLine(s,i)
        line = s[j:k]
        valid,new_df,start,end,isThin = \
            at.parseLeoSentinel(line)
        if trace: g.trace('found: True isThin:',
            isThin,repr(line))
        return not isThin
#@-node:ekr.20100224050618.11547:at.isFileLike
#@+node:ekr.20071105164407:warnAboutUnvisitedNodes
def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
#@-node:ekr.20071105164407:warnAboutUnvisitedNodes
#@-node:ekr.20041005105605.21:at.read & helpers
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel'
        # The first '@' has already been eaten.

    if trace: g.trace(repr(s[i:]))
        # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    # An @c ends the doc part when using new sentinels.
    if at.readVersion5 and s2 in ('@c','@c\n'):
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
        at.inCode = True # End the doc part.

    at.appendToOut(s2)
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,unused_s,unused_i):

    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,unused_s,unused_i):

    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self

    at.popSentinelStack(at.endOthers)

    if at.readVersion5:
        at.v = at.endSentinelNodeStack.pop()
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20100625140824.5968:readEndRef
def readEndRef (self,unused_s,unused_i):

    """Read an @-<< sentinel."""

    at = self

    at.popSentinelStack(at.endRef)

    if at.readVersion5:
        at.v = at.endSentinelNodeStack.pop()
#@-node:ekr.20100625140824.5968:readEndRef
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.appendToOut(tag + s)
    at.docOut = []
#@-node:ekr.20041005105605.99:readLastDocLine
#@+node:ekr.20041005105605.77:readNormalLine & appendToDocPart
def readNormalLine (self,s,i): # i not used.

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.appendToOut(s)
    else:
        at.appendToDocPart(s)
#@+node:ekr.20100624082003.5942:appendToDocPart
def appendToDocPart (self,s):

    trace = False and not g.unitTesting
    at = self

    # Skip the leading stuff
    if len(at.endSentinelComment) == 0:
        # Skip the single comment delim and a blank.
        i = g.skip_ws(s,0)
        if g.match(s,i,at.startSentinelComment):
            i += len(at.startSentinelComment)
            if g.match(s,i," "): i += 1
    else:
        i = at.skipIndent(s,0,at.indent)

    # Append s to docOut.
    line = s[i:-1] # remove newline for rstrip.

    if line == line.rstrip():
        # no trailing whitespace: the newline is real.
        at.docOut.append(line + '\n')
    else:
        # trailing whitespace: the newline is fake.
        at.docOut.append(line)

    if trace: g.trace(repr(line))
#@-node:ekr.20100624082003.5942:appendToDocPart
#@-node:ekr.20041005105605.77:readNormalLine & appendToDocPart
#@+node:ekr.20041005105605.111:readRef (paired using new sentinels)
@
The sentinel contains an @ followed by a section name in angle brackets.
This code is different from the code for the @@ sentinel: the expansion
of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @<< sentinel."""

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+")
        i += 1 # Skip the new plus sign.
    j = g.skip_ws(s,i)
    assert g.match(s,j,"<<"),'missing @<< sentinel'

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    if new_read and at.readVersion == '5':
        # Put the newline back: there is no longer an @nl sentinel.
        line = line + '\n'

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.appendToOut(line)
    if at.readVersion5:
        at.endSentinelStack.append(at.endRef)
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.111:readRef (paired using new sentinels)
#@+node:ekr.20041005105605.82:readStartAt/Doc & helper
#@+node:ekr.20100624082003.5938:readStartAt
def readStartAt (self,s,i):

    """Read an @+at sentinel."""

    at = self
    assert g.match(s,i,"+at"),'missing +at'
    i += 3

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
#@-node:ekr.20100624082003.5938:readStartAt
#@+node:ekr.20100624082003.5939:readStartDoc
def readStartDoc (self,s,i):

    """Read an @+doc sentinel."""

    at = self
    assert g.match(s,i,"+doc"),'missing +doc'
    i += 4

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]+'\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
#@-node:ekr.20100624082003.5939:readStartDoc
#@+node:ekr.20100624082003.5940:skipToEndSentinel
def skipToEndSentinel(self,s,i):

    '''Skip to the end of the sentinel line.'''

    at = self
    end = at.endSentinelComment

    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@-node:ekr.20100624082003.5940:skipToEndSentinel
#@-node:ekr.20041005105605.82:readStartAt/Doc & helper
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self

    j = g.skip_ws(s,i)
    leadingWs = s[i:j]

    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    at.appendToOut(leadingWs + "@others\n")
    at.endSentinelStack.append(at.endOthers)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.89:readStartOthers
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):

    """Scan a 4.x derived file non-recursively."""

    trace = False and not g.unitTesting
    verbose = False
    at = self
    << init ivars for scanText4 >>
    if trace: g.trace('filename:',fileName)
    try:
        while at.errors == 0 and not at.done:
            s = at.readLine(theFile)
            if trace and verbose: g.trace(repr(s))
            at.lineNumber += 1
            if len(s) == 0:
                if at.readVersion5:
                    at.popSentinelStack(at.endLeo)
                    at.done = True
                break
            kind = at.sentinelKind4(s)
            if kind == at.noSentinel:
                i = 0
            else:
                i = at.skipSentinelStart4(s,0)
            func = at.dispatch_dict[kind]
            if trace: g.trace('%15s %16s %s' % (
                at.sentinelName(kind),func.__name__,repr(s)))
            func(s,i)
    except AssertionError:
        junk, message, junk = sys.exc_info()
        at.error('unexpected assertion failure in',fileName,'\n',message)
        if g.unitTesting:
            raise

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.lineNumber = 0
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.endSentinelNodeStack = [None]
at.out = [] ; at.outStack = []
at.v = p.v
at.vStack = []
# New code: always identify root @thin node with self.root:
at.lastThinNode = None
at.thinNodeStack = []
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert at.endSentinelStack,'empty sentinel stack'

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine & appendToDocPart
def readNormalLine (self,s,i): # i not used.

    at = self

    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.appendToOut(s)
    else:
        at.appendToDocPart(s)
#@+node:ekr.20100624082003.5942:appendToDocPart
def appendToDocPart (self,s):

    trace = False and not g.unitTesting
    at = self

    # Skip the leading stuff
    if len(at.endSentinelComment) == 0:
        # Skip the single comment delim and a blank.
        i = g.skip_ws(s,0)
        if g.match(s,i,at.startSentinelComment):
            i += len(at.startSentinelComment)
            if g.match(s,i," "): i += 1
    else:
        i = at.skipIndent(s,0,at.indent)

    # Append s to docOut.
    line = s[i:-1] # remove newline for rstrip.

    if line == line.rstrip():
        # no trailing whitespace: the newline is real.
        at.docOut.append(line + '\n')
    else:
        # trailing whitespace: the newline is fake.
        at.docOut.append(line)

    if trace: g.trace(repr(line))
#@-node:ekr.20100624082003.5942:appendToDocPart
#@-node:ekr.20041005105605.77:readNormalLine & appendToDocPart
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:at.readStartAll
def readStartAll (self,s,i):

    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert g.match(s,j,"@+all"),'missing @+all'
    else:
        assert g.match(s,j,"+all"),'missing +all'

    # g.trace('root_seen',at.root_seen,at.root.h,repr(s))
    at.atAllFlag = True

    # Make sure that the generated at-all is properly indented.
    at.appendToOut(leadingWs + "@all\n")
    at.endSentinelStack.append(at.endAll)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.81:at.readStartAll
#@+node:ekr.20041005105605.85:at.readStartNode & helpers
def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    at = self
    gnx,headline,i,level,ok = at.parseNodeSentinel(s,i,middle)
    if not ok: return
    at.root_seen = True

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out)
    at.out = []
    at.vStack.append(at.v)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        at.v = at.createNewThinNode(gnx,headline,level)
    else:
        at.v = at.findChild4(headline)

    if not at.readVersion5:
        at.endSentinelStack.append(at.endNode)
#@+node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
def createNewThinNode (self,gnx,headline,level):

    trace = False and not g.unitTesting
    at = self

    if at.thinNodeStack:
        if at.readVersion5:
            oldLevel = len(at.thinNodeStack)
            newLevel = level - 1
            assert newLevel >= 0
            at.closePreviousNode(oldLevel,newLevel)
            v = at.createThinChild4(gnx,headline)
            at.thinNodeStack.append(v)
            if trace: g.trace(
                '** oldLvl: %s, newLvl: %s, v: %s, last: %s, stack: \n%s\n' % (
                oldLevel,newLevel,v.h,at.lastThinNode.h,
                [z.h for z in at.thinNodeStack]))
        else:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
    else:
        v = at.root.v
        at.thinNodeStack.append(v)

    at.lastThinNode = v
    return v
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@-node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
#@+node:ekr.20100625184546.5979:parseNodeSentinel & helpers
def parseNodeSentinel (self,s,i,middle):

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+node"),'bad start node sentinel'
        i += 1
    elif middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        assert g.match(s,i,"+node:"),'missing +node'
        i += 6

    # Get the gnx and the headline.
    if at.thinFile:
        gnx,i,level,ok = at.parseThinNodeSentinel(s,i)
        if not ok: None,None,None,False

    headline = at.getNodeHeadline(s,i)
    return gnx,headline,i,level,True
#@+node:ekr.20100625085138.5955:getNodeHeadline
def getNodeHeadline (self,s,i):

    '''Set headline to the rest of the line.
    Don't strip leading whitespace.'''

    at = self

    if len(at.endSentinelComment) == 0:
        h = s[i:-1].rstrip()
    else:
        k = s.rfind(at.endSentinelComment,i)
        h = s[i:k].rstrip() # works if k == -1

    # Undo the CWEB hack: undouble @ signs if\
    # the opening comment delim ends in '@'.
    if at.startSentinelComment[-1:] == '@':
        h = h.replace('@@','@')

    return h
#@-node:ekr.20100625085138.5955:getNodeHeadline
#@+node:ekr.20100625085138.5953:parseThinNodeSentinel
def parseThinNodeSentinel (self,s,i):

    at = self

    def oops(s):
        at.readError(s)
        return None,None,None,False

    j = s.find(':',i)
    if j == -1:
        return oops('Expecting gnx in @+node sentinel')
    else:
        gnx = s[i:j]

    if at.readVersion5:
        if not g.match(s,j,': '):
            return oops('Expecting space after gnx')
        i = j + 2
        level = 0
        while i < len(s) and s[i] == '*':
            i += 1
            level += 1
        if level == 0:
            return oops('No level stars')
        if not g.match(s,i,' '):
            return oops('No space after level stars')
        i += 1
    else: # not readVersion5.
        i = j + 1 # Skip the gnx.
        level = 0

    return gnx,i,level,True
#@-node:ekr.20100625085138.5953:parseThinNodeSentinel
#@-node:ekr.20100625184546.5979:parseNodeSentinel & helpers
#@-node:ekr.20041005105605.85:at.readStartNode & helpers
#@+node:ekr.20041005105605.111:readRef (paired using new sentinels)
@
The sentinel contains an @ followed by a section name in angle brackets.
This code is different from the code for the @@ sentinel: the expansion
of the reference does not include a trailing newline.
@c

def readRef (self,s,i):

    """Handle an @<< sentinel."""

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+")
        i += 1 # Skip the new plus sign.
    j = g.skip_ws(s,i)
    assert g.match(s,j,"<<"),'missing @<< sentinel'

    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.

    if new_read and at.readVersion == '5':
        # Put the newline back: there is no longer an @nl sentinel.
        line = line + '\n'

    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.appendToOut(line)
    if at.readVersion5:
        at.endSentinelStack.append(at.endRef)
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.111:readRef (paired using new sentinels)
#@+node:ekr.20041005105605.82:readStartAt/Doc & helper
#@+node:ekr.20100624082003.5938:readStartAt
def readStartAt (self,s,i):

    """Read an @+at sentinel."""

    at = self
    assert g.match(s,i,"+at"),'missing +at'
    i += 3

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ['@' + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endAt)
#@-node:ekr.20100624082003.5938:readStartAt
#@+node:ekr.20100624082003.5939:readStartDoc
def readStartDoc (self,s,i):

    """Read an @+doc sentinel."""

    at = self
    assert g.match(s,i,"+doc"),'missing +doc'
    i += 4

    if at.readVersion5: # Append whatever follows the sentinel.
        j = at.skipToEndSentinel(s,i)
        follow = s[i:j]+'\n'
        at.appendToOut('@' + follow + '\n')
        at.docOut = []
        at.inCode = False
    else:
        j = g.skip_ws(s,i)
        ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n']
            # This newline may be removed by a following @nonl
        at.inCode = False
        at.endSentinelStack.append(at.endDoc)
#@-node:ekr.20100624082003.5939:readStartDoc
#@+node:ekr.20100624082003.5940:skipToEndSentinel
def skipToEndSentinel(self,s,i):

    '''Skip to the end of the sentinel line.'''

    at = self
    end = at.endSentinelComment

    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@-node:ekr.20100624082003.5940:skipToEndSentinel
#@-node:ekr.20041005105605.82:readStartAt/Doc & helper
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):

    """Read an unexpected @+leo sentinel."""

    at = self
    assert g.match(s,i,"+leo"),'missing +leo sentinel'
    at.readError("Ignoring unexpected @+leo sentinel")
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):

    """Read an @+middle sentinel."""

    at = self

    at.readStartNode(s,i,middle=True)
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):

    """Read an @+others sentinel."""

    at = self

    j = g.skip_ws(s,i)
    leadingWs = s[i:j]

    if leadingWs:
        assert g.match(s,j,"@+others"),'missing @+others'
    else:
        assert g.match(s,j,"+others"),'missing +others'

    # Make sure that the generated at-others is properly indented.
    at.appendToOut(leadingWs + "@others\n")
    at.endSentinelStack.append(at.endOthers)
    if at.readVersion5:
        at.endSentinelNodeStack.append(at.v)
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll
def readEndAll (self,unused_s,unused_i):

    """Read an @-all sentinel."""

    at = self
    at.popSentinelStack(at.endAll)
#@-node:ekr.20041005105605.91:readEndAll
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,unused_s,unused_i):

    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True

def readEndDoc (self,unused_s,unused_i):

    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,unused_s,unused_i):

    """Read an @-leo sentinel."""

    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):

    """Read an @-middle sentinel."""

    at = self

    at.readEndNode(s,i,middle=True)
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:at.readEndNode
def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle @-node sentinels."""

    trace = False and not g.unitTesting
    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    if at.readVersion5:
        if hasattr(at.v,'tempBodyList'):
            s = ''.join(at.v.tempBodyList)
        else:
            s = ''
    else:
        s = ''.join(at.out)

    s = g.toUnicode(s)
    # g.trace('%20s %s' % (at.v.h,repr(s)))

    if at.importing:
        at.v._bodyString = s # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if at.v == at.root.v:
            old = None # Don't issue warnings for the root.
        elif hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None

        if old:
            << indicate that the node has been changed >>

        # *Always* update the text.
        if at.readVersion5:
            if trace and hasattr(at.v,"tempBodyString") and at.v.tempBodyString:
                g.trace('*** can not happen: tempBodyString',at.v.h,repr(s))
        else:
            at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.vStack.pop()

    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    if not at.readVersion5:
        at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty()
        # Mark the node dirty. Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # 2010/02/05: removed special case for @all.
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx=at.v.gnx,
        fileName = at.root.h,
        b_old=old,
        b_new=s,
        h_old=at.v._headString,
        h_new=at.v._headString,
    ))

    g.es_print("uncached read node changed",at.v.h,color="red")

    at.v.setDirty()
        # Just set the dirty bit. Ancestors will be marked dirty later.
    c.changed = True
        # Important: the dirty bits won't stick unless we set c.changed here.
        # Do *not* call c.setChanged(True) here: that would be too slow.
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:at.readEndNode
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,unused_s,unused_i):

    """Read an @-others sentinel."""

    at = self

    at.popSentinelStack(at.endOthers)

    if at.readVersion5:
        at.v = at.endSentinelNodeStack.pop()
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20100625140824.5968:readEndRef
def readEndRef (self,unused_s,unused_i):

    """Read an @-<< sentinel."""

    at = self

    at.popSentinelStack(at.endRef)

    if at.readVersion5:
        at.v = at.endSentinelNodeStack.pop()
#@-node:ekr.20100625140824.5968:readEndRef
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):

    """Read the @c line that terminates the doc part.
    tag is @doc or @."""

    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)

    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.appendToOut(tag + s)
    at.docOut = []
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
# Ooops: shadow files are cleared if there is a read error!!
#@nonl
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,unused_i):

    """Ignore an 3.x sentinel."""

    g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):

    """Read an @afterref sentinel."""

    at = self
    assert g.match(s,i,"afterref"),'missing afterref'

    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.appendToOut(s)
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):

    at = self ; tag = "clone"

    assert g.match(s,i,tag),'missing clone sentinel'

    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))

    # Get the clone count.
    junk,val = g.skip_long(s,i)

    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount = val
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):

    """Read an @comment sentinel."""

    assert g.match(s,i,"comment"),'missing comment sentinel'

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):

    """Read an @delims sentinel."""

    at = self
    assert g.match(s,i-1,"@delims"),'missing @delims'

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)

    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1

    if j < i:
        at.startSentinelComment = s[j:i]

        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.appendToOut(line+'\n')
        else:
            at.endSentinelComment = end
            line = s[i0:i]
            line = line.rstrip()
            at.appendToOut(line+'\n')
    else:
        at.readError("Bad @delims")
        at.appendToOut("@delims")
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):

    """Read an @@sentinel."""

    trace = False and not g.unitTesting
    at = self
    assert g.match(s,i,"@"),'missing @@ sentinel'
        # The first '@' has already been eaten.

    if trace: g.trace(repr(s[i:]))
        # g.trace(g.get_line(s,i))

    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False

    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'

    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')

    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    # An @c ends the doc part when using new sentinels.
    if at.readVersion5 and s2 in ('@c','@c\n'):
        if at.docOut:
            at.appendToOut(''.join(at.docOut))
        at.inCode = True # End the doc part.

    at.appendToOut(s2)
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

if trace:
    g.trace(g.get_line(s,i))
    g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @language sentinel:",line,color="red")
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("ignoring bad @comment sentinel:",line,color="red")
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nl"),'missing nl sentinel'

    if at.inCode:
        at.appendToOut('\n')
    else:
        at.docOut.append('\n')
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):

    """Handle an @nonl sentinel."""

    at = self
    assert g.match(s,i,"nonl"),'missing nonl sentinel'

    if at.inCode:
        s = ''.join(at.out)
        # 2010/01/07: protect against a mostly-harmless read error.
        if s:
            if s[-1] == '\n':
                at.out = [s[:-1]] # Do not use at.appendToOut here!
            else:
                g.trace("out:",s)
                at.readError("unexpected @nonl directive in code part")
    else:
        s = ''.join(at.pending)
        if s:
            if s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):

    """Read an @verbatim sentinel."""

    at = self
    assert g.match(s,i,"verbatim"),'missing verbatim sentinel'

    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    # Do **not** insert the verbatim line itself!
        # at.out.append("@verbatim\n")
    at.appendToOut(s[i:])
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
def badEndSentinel (self,expectedKind):

    """Handle a mismatched ending sentinel."""

    at = self
    assert at.endSentinelStack,'empty sentinel stack'
    s = "(badEndSentinel) Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)

def popSentinelStack (self,expectedKind):

    """Pop an entry from endSentinelStack and check it."""

    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        if 1: g.trace('%s\n%s' % (
            [at.sentinelName(z) for z in at.endSentinelStack],
            g.callers(4)))
        at.badEndSentinel(expectedKind)
#@-node:ekr.20041005105605.113:badEndSentinel, popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@-node:ekr.20100625184546.5978:Ref
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.atAllFlag = False # True if @all seen.
self.cloneSibCount = 0
    # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.correctedLines = 0
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
    # Contains entries for +node sentinels only when not readVersion5
self.endSentinelNodeStack = []
    # Used only when readVersion5.
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None
    # The last thin node at this level.
    # Used by createThinChild4.
self.leadingWs = ""
self.lineNumber = 0 # New in Leo 4.4.8.
self.out = None
self.outStack = []
self.readVersion = '' # New in Leo 4.8: "4" or "5" for new-style thin files.
self.readVersion5 = False # synonym for new_read and at.readVersion >= '5'
self.rootSeen = False
self.tnodeList = []
    # Needed until old-style @file nodes are no longer supported.
self.tnodeListIndex = 0
self.v = None
self.vStack = [] # Stack of at.v values.
self.thinNodeStack = [] # Entries are vnodes.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@+node:ekr.20100625092449.5963:at.appendToOut
def appendToOut (self,s):

    '''Append s to at.out (old sentinels) or
       at.v.tempBodyList (new sentinels).'''

    trace = False and not g.unitTesting
    at = self

    if at.readVersion5:
        if not at.v: at.v = at.root.v
        if hasattr(at.v,"tempBodyList"):
            at.v.tempBodyList.append(s)
        else:
            at.v.tempBodyList = [s]
    else:
        at.out.append(s)

    if trace:
        g.trace('%4s %25s %s' % (
            g.choose(at.inCode,'code','doc'),at.v.h,repr(s)))
        # g.trace(g.listToString(at.out))
#@-node:ekr.20100625092449.5963:at.appendToOut
#@+node:ekr.20041005105605.85:at.readStartNode & helpers
def readStartNode (self,s,i,middle=False):

    """Read an @+node or @+middle sentinel."""

    at = self
    gnx,headline,i,level,ok = at.parseNodeSentinel(s,i,middle)
    if not ok: return
    at.root_seen = True

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent

    at.outStack.append(at.out)
    at.out = []
    at.vStack.append(at.v)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.v = p.v
    elif at.thinFile:
        at.v = at.createNewThinNode(gnx,headline,level)
    else:
        at.v = at.findChild4(headline)

    if not at.readVersion5:
        at.endSentinelStack.append(at.endNode)
#@+node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
def createNewThinNode (self,gnx,headline,level):

    trace = False and not g.unitTesting
    at = self

    if at.thinNodeStack:
        if at.readVersion5:
            oldLevel = len(at.thinNodeStack)
            newLevel = level - 1
            assert newLevel >= 0
            at.closePreviousNode(oldLevel,newLevel)
            v = at.createThinChild4(gnx,headline)
            at.thinNodeStack.append(v)
            if trace: g.trace(
                '** oldLvl: %s, newLvl: %s, v: %s, last: %s, stack: \n%s\n' % (
                oldLevel,newLevel,v.h,at.lastThinNode.h,
                [z.h for z in at.thinNodeStack]))
        else:
            at.thinNodeStack.append(at.lastThinNode)
            v = at.createThinChild4(gnx,headline)
    else:
        v = at.root.v
        at.thinNodeStack.append(v)

    at.lastThinNode = v
    return v
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@-node:ekr.20100625085138.5957:createNewThinNode & closePreviousNode
#@+node:ekr.20100625184546.5979:parseNodeSentinel & helpers
def parseNodeSentinel (self,s,i,middle):

    at = self

    if at.readVersion5:
        assert g.match(s,i,"+node"),'bad start node sentinel'
        i += 1
    elif middle:
        assert g.match(s,i,"+middle:"),'missing +middle'
        i += 8
    else:
        assert g.match(s,i,"+node:"),'missing +node'
        i += 6

    # Get the gnx and the headline.
    if at.thinFile:
        gnx,i,level,ok = at.parseThinNodeSentinel(s,i)
        if not ok: None,None,None,False

    headline = at.getNodeHeadline(s,i)
    return gnx,headline,i,level,True
#@+node:ekr.20100625085138.5955:getNodeHeadline
def getNodeHeadline (self,s,i):

    '''Set headline to the rest of the line.
    Don't strip leading whitespace.'''

    at = self

    if len(at.endSentinelComment) == 0:
        h = s[i:-1].rstrip()
    else:
        k = s.rfind(at.endSentinelComment,i)
        h = s[i:k].rstrip() # works if k == -1

    # Undo the CWEB hack: undouble @ signs if\
    # the opening comment delim ends in '@'.
    if at.startSentinelComment[-1:] == '@':
        h = h.replace('@@','@')

    return h
#@-node:ekr.20100625085138.5955:getNodeHeadline
#@+node:ekr.20100625085138.5953:parseThinNodeSentinel
def parseThinNodeSentinel (self,s,i):

    at = self

    def oops(s):
        at.readError(s)
        return None,None,None,False

    j = s.find(':',i)
    if j == -1:
        return oops('Expecting gnx in @+node sentinel')
    else:
        gnx = s[i:j]

    if at.readVersion5:
        if not g.match(s,j,': '):
            return oops('Expecting space after gnx')
        i = j + 2
        level = 0
        while i < len(s) and s[i] == '*':
            i += 1
            level += 1
        if level == 0:
            return oops('No level stars')
        if not g.match(s,i,' '):
            return oops('No space after level stars')
        i += 1
    else: # not readVersion5.
        i = j + 1 # Skip the gnx.
        level = 0

    return gnx,i,level,True
#@-node:ekr.20100625085138.5953:parseThinNodeSentinel
#@-node:ekr.20100625184546.5979:parseNodeSentinel & helpers
#@-node:ekr.20041005105605.85:at.readStartNode & helpers
#@+node:ekr.20100624082003.5944:closePreviousNode
def closePreviousNode (self,oldLevel,newLevel):

    trace = False and not g.unitTesting
    at = self

    if trace: g.trace('******',
        [at.sentinelName(z) for z in at.endSentinelStack])

    if newLevel <= oldLevel:
        # Pretend we have seen -node sentinels.
        for z in range(oldLevel - newLevel):
            at.readEndNode('',0)

        at.lastThinNode = at.thinNodeStack[newLevel-1]
    else:
        at.lastThinNode = at.thinNodeStack[-1]
#@-node:ekr.20100624082003.5944:closePreviousNode
#@+node:ekr.20041005105605.95:at.readEndNode
def readEndNode (self,unused_s,unused_i,middle=False):

    """Handle @-node sentinels."""

    trace = False and not g.unitTesting
    at = self ; c = at.c

    # End raw mode.
    at.raw = False

    # Set the temporary body text.
    if at.readVersion5:
        if hasattr(at.v,'tempBodyList'):
            s = ''.join(at.v.tempBodyList)
        else:
            s = ''
    else:
        s = ''.join(at.out)

    s = g.toUnicode(s)
    # g.trace('%20s %s' % (at.v.h,repr(s)))

    if at.importing:
        at.v._bodyString = s # Allowed use of _bodyString.
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if at.v == at.root.v:
            old = None # Don't issue warnings for the root.
        elif hasattr(at.v,"tempBodyString") and s != at.v.tempBodyString:
            old = at.v.tempBodyString
        elif at.v.hasBody() and s != at.v.getBody():
            old = at.v.getBody()
        else:
            old = None

        if old:
            << indicate that the node has been changed >>

        # *Always* update the text.
        if at.readVersion5:
            if trace and hasattr(at.v,"tempBodyString") and at.v.tempBodyString:
                g.trace('*** can not happen: tempBodyString',at.v.h,repr(s))
        else:
            at.v.tempBodyString = s

    # Indicate that the vnode has been set in the derived file.
    at.v.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.v = at.vStack.pop()

    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    if not at.readVersion5:
        at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    at.v._bodyString = s # Allowed use of _bodyString.
        # Just setting at.v.tempBodyString won't work here.
    at.v.setDirty()
        # Mark the node dirty. Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    # 2010/02/05: removed special case for @all.
    c.nodeConflictList.append(g.bunch(
        tag='(uncached)',
        gnx=at.v.gnx,
        fileName = at.root.h,
        b_old=old,
        b_new=s,
        h_old=at.v._headString,
        h_new=at.v._headString,
    ))

    g.es_print("uncached read node changed",at.v.h,color="red")

    at.v.setDirty()
        # Just set the dirty bit. Ancestors will be marked dirty later.
    c.changed = True
        # Important: the dirty bits won't stick unless we set c.changed here.
        # Do *not* call c.setChanged(True) here: that would be too slow.
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree():
    if p.v == at.v:
        found = True ; break

if found:
    if 0: # For debugging.
        g.pr('\n','-' * 40)
        g.pr("old",len(old))
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
        g.pr("new",len(s))
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            g.pr(repr(str(line)))
        g.pr('\n','-' * 40)
else:
    # This should never happen.
    g.es("correcting hidden node: v=",repr(at.v),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:at.readEndNode
#@-node:ekr.20100519091824.5874:Reading
#@-node:ekr.20100517130356.5809:New sentinels
#@-all
#@-node:ekr.20100120072650.6089:@thin leoProjects.txt
#@-leo
