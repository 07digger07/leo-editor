#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090714085726.5991:Leo 4.6.1 projects
#@+node:ekr.20090717092906.12764:Bugs
#@+node:ekr.20090717092906.6000:How does Leo write encoding in the first line?
@nocolor-node

There was a documentation bug related to the new_leo_file_encoding setting.
#@nonl
#@+node:ekr.20031218072017.1247:putXMLLine
def putXMLLine (self):

    '''Put the **properly encoded** <?xml> element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
#@nonl
#@-node:ekr.20031218072017.1247:putXMLLine
#@+node:ekr.20090218115025.5:initIvars
def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.python23 = g.CheckVersion(version,'2.3')

    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentTnodeUaDictList = []
    self.descendentVnodeUaDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
    self.vnodesDict = {}
        # keys are gnx strings; values are ignored
#@-node:ekr.20090218115025.5:initIvars
#@-node:ekr.20090717092906.6000:How does Leo write encoding in the first line?
#@+node:ekr.20090717140657.5980:Fixed file-open focus bug
@nocolor-node

Opening a file from the File menu doesn't work well.
The new window does not come to the front.
#@nonl
#@-node:ekr.20090717140657.5980:Fixed file-open focus bug
#@-node:ekr.20090717092906.12764:Bugs
#@+node:ekr.20090717112235.10330:Features
#@+node:ekr.20090715082137.5989:Added leoVersion.py & improved startup messages
@nocolor-node

This was surprisingly tricky.

- app.computeSignon computes signon messages *after* plugins have been loaded.
  This is necessary because we don't know the gui until then.
- Added app.printWaiting to queue up messages before we are ready to sign on.
- Core code never has to insert entries in app.logWaiting or app.printWaiting.
- app.writeWaitingLog now prints the signon message,
  ensuring that the signon is always first.
- c.new now must call app.writeWaitingLog.
#@nonl
#@+node:ekr.20041120064303:readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen and g.os_path_exists(path):
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.es_print(s,color='blue')
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20051013161232:updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:updateSettings
#@-node:ekr.20041120064303:readSettingsFiles & helpers (g.app.config)
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_finalize(theFile) for theFile in files]

    s = g.app.config.getEnabledPlugins()
    if not s: return

    if tag == 'open0' and not g.app.silentMode and not g.app.batchMode:
        s2 = '@enabled-plugins found in %s' % (
            g.app.config.enabledPluginsFileName)
        g.es_print(s2,color='blue')

    enabled_files = getEnabledFiles(s,plugins_path)

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile,tag=tag)

    # Warn about any non-existent enabled file.
    if warn_on_failure and tag == 'open0':
        for z in enabled_files:
            if z not in files:
                g.es_print('plugin does not exist:',
                    g.shortFileName(z),color="red")

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    '''Return a list of plugins mentioned in non-comment lines of s.'''

    enabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s and not s.startswith('#'):
            path = g.os_path_finalize_join(plugins_path,s)
            enabled_files.append(path)

    return enabled_files
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            s = 'using menus from: %s' % c.shortFileName()
            g.es_print(s,color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.h)
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        # if trace:
            # if p.h==after.h:
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.b
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.h)
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    s2 = g.toEncodedString(s,encoding)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2+nl)
        except Exception:
            if not g.pr_warning_given:
                g.pr_warning_given = True
                print('unexpected Exception in g.pr')
                print('make sure your sitecustomize.py contains::')
                print('    sys.setdefaultencoding("utf-8")')
                g.es_exception()
                g.trace(g.callers())
            s2 = s.encode('ascii',"replace")
            sys.stdout.write(s2+nl)
    else:
        app.printWaiting.append(s2)
#@-node:ekr.20080710101653.1:g.pr
#@+node:ekr.20070626132332:g.es & minitest
def es(*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    if not app or app.killed: return
    log = app.log

    # Compute the effective args.
    d = {'color':'black','commas':False,'newline':True,'spaces':True,'tabName':'Log'}
    d = g.doKeywordArgs(keys,d)
    color = d.get('color')
    if color == 'suppress': return # New in 4.3.
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args,d)
    # print app,s,g.callers(5)

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # New in Leo 4.5 b4: this is no longer needed.
            # This makes the output of unit tests match the output of scripts.
            # s = g.toEncodedString(s,'ascii')
            g.pr(s,newline=newline)
    else:
        if log and log.isNull and app.logInited:
            pass
        elif log and app.logInited:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:g.es & minitest
#@+node:ekr.20090717112235.6007:app.computeSignon
def computeSignon (self):

    app = self
    build,date  = leoVersion.build,leoVersion.date
    guiVersion  = app.gui.getFullVersion()
    leoVer      = leoVersion.version
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            sysVersion += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: sysVersion = sys.platform

    app.signon = 'Leo %s, build %s, %s' % (
        leoVer,build,date)
    app.signon2 = 'Python %s.%s.%s, %s\n%s' % (
        n1,n2,n3,guiVersion,sysVersion)
#@nonl
#@-node:ekr.20090717112235.6007:app.computeSignon
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self,c,forceLog=False):

    app = self
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    # print 'writeWaitingLog',c,g.callers(4)
    table = [
        ('Leo Log Window','red'),
        (app.signon,'black'),
        (app.signon2,'black'),
    ]
    table.reverse()

    if app.log:
        if not app.logInited:
            app.logInited = True # Prevent recursive call.
            print app.signon
            print app.signon2
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        elif forceLog:
            for s,color in table:
                app.logWaiting.insert(0,(s+'\n',color),)
        # The test for isNull would probably interfere with batch mode.
        for s in app.printWaiting:
            print s
        app.printWaiting = []
        for s,color in app.logWaiting:
            g.es('',s,color=color,newline=0)
                # The caller must write the newlines.
        app.logWaiting = []
    else:
        print('writeWaitingLog: still no log!')
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    defaultFileName = None
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')
            defaultFileName = fileName

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    if not fileName: fileName = defaultFileName

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.5:finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")

#@-node:ekr.20080921060401.5:finishInitApp (runLeo.py)
#@-node:ekr.20090715082137.5989:Added leoVersion.py & improved startup messages
#@-node:ekr.20090717112235.10330:Features
#@-node:ekr.20090714085726.5991:Leo 4.6.1 projects
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self
    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn)
        return True

    if g.app.unitTesting:
        return False

    # g.trace(timeStamp, timeStamp2)
    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)
    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090828080035.5984:enableDB logic
@nocolor-node

What I did:

- Added no-cache option.
- Added g.enableDB constant.
- Added g.enableDB logic from one-node branch.
#@nonl
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('-f', '--file',   dest="fileName")
    parser.add_option('--no-cache',     dest='no_cache',action="store_true")
    parser.add_option('--gui',          dest="gui", help = 'gui to use (qt/tk)')
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")
    parser.add_option('--ipython',      action="store_true",dest="use_ipython")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --no-cache
    if options.no_cache:
        g.trace('disabling caching')
        g.enableDB = False

    # -f or --file
    fileName = options.fileName

    # -- gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui not in ('tk','qt','wx'):
            g.trace('unknown gui: %s' % gui)
            gui = None

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # --ipython
    g.app.useIpython = options.use_ipython

    # Compute the return values.
    windowFlag = script and script_path_w
    return fileName, gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ville.20090620122043.6275:app.setGlobalDb
def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """

    # g.trace('g.enableDB',g.enableDB)

    if g.enableDB:
        dbdirname = self.homeLeoDir + "/db/global"
        self.db = leo.external.pickleshare.PickleShareDB(dbdirname, protocol='picklez')
    else:
        self.db = {}


#@-node:ville.20090620122043.6275:app.setGlobalDb
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>

    doCache = g.enableDB and (thinFile or atShadow)
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.at_read = True # Create the attribute.

    if doCache and cachefile in c.db:
        # This message isn't so useful.
        # if not g.unitTesting: # g.es('uncache:',root.h)

        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        tree = c.db[cachefile]
        g.create_tree_at_vnode(c, root.v, tree)
        at.inputFile.close() # Bug fix.
        root.clearDirty() # Bug fix.
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    if thinFile or atShadow:
        root.v.at_read = True # Create the attribute
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ville.20090606131405.6362:writeCachedTree (atFile)
def writeCachedTree(self, p, cachefile):

    trace = False and not g.unitTesting
    c = self.c

    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif cachefile in c.db:
        if trace: g.trace('already cached')
    else:
        if trace: g.trace('caching ',p.h)
        tree = g.tree_at_position(p)
        c.db[cachefile] = tree
#@-node:ville.20090606131405.6362:writeCachedTree (atFile)
#@-node:ekr.20090828080035.5984:enableDB logic
#@-node:ekr.20090721093155.5986:Bugs
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
