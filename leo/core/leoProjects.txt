#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090831095817.6067:Leo 4.6.3
- Put caching bug fixes into 46-maint branch
- Fixed bug in g.adjustTripleString.
- Created .nsi script.
#@nonl
#@-node:ekr.20090831095817.6067:Leo 4.6.3
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
# only on Linux.
#@nonl
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@+node:ekr.20090822060128.6035:Improved the install docs
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/add6242d6f4fc476

From Matt Wilkie

I've installed Leo several times on windows, yet this morning still
took me a few minutes to find the section you reference above because
there are at least two other document sections with phrases similar to
"installing leo". Anyway, this is my simplified recipe for a virgin
install:

-------------------------
Installing Leo On Windows
-------------------------
//skip any step not needed//

1. Install Python - There are many sources, but from
http://www.python.org/download/releases/ is good

2. Install PyQt - acquire and run Binary Package from
http://www.riverbankcomputing.co.uk/software/pyqt/download which
matches installed Python version (so for python 2.5 scan for the
"Py2.5" in filename)

3. Install Leo
   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
   - Unpack python *site-packages* folder, e.g.
C:\Python25\Lib\site-packages\leo-4-6-2-final

   - [optional] Generate/update a junction link from unpacked
leo-4-6-2-final to ...\site-packages\leo

      cd C:\Python25\Lib\site-packages\
      junction leo leo-4-6-2-final

   - Create windows shortcut (edit paths as necessary):

      Target   =  C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt
      Start in =  D:\code

   - Associate .leo filetype batch file:

      ftype LeoFile=C:\Python25\pythonw.exe
"C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
      assoc .leo=LeoFile

   - [optional] Put this leo.bat in %PATH%:

      @C:\Python25\python.exe -i
"C:\Python25\Lib\site-packages\leo\launchLeo.py" --gui=qt %*

-------------------------

Further reading / Sources used:

   Junction links -
http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
   FTYPE - http://ss64.com/nt/ftype.html
   ASSOC - http://ss64.com/nt/assoc.html


=====================
Ville's comments

On Thu, Aug 20, 2009 at 10:49 PM, Matt Wilkie<map...@gmail.com> wrote:
> 3. Install Leo
>   - Head to http://sourceforge.net/projects/leo/ and slap [Download Now]
>   - Unpack python *site-packages* folder, e.g.
> C:\Python25\Lib\site-packages\leo-4-6-2-final

I don't think you need to use site-packages. Just extract it anywhere
you want (e.g. c:/opt/leo). But I could be wrong.

>   - Associate .leo filetype batch file:
>n
>      ftype LeoFile=C:\Python25\pythonw.exe
> "C:\Python25\Lib\site-packages\leo\launchLeo.py" "--gui=qt" "%1"
>      assoc .leo=LeoFile

--gui=qt us not needed anymore. 
#@nonl
#@-node:ekr.20090822060128.6035:Improved the install docs
#@+node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20041005105605.21:read (atFile)
def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    << set fileName >>

    doCache = g.enableDB and (thinFile or atShadow)
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False

    fileContent = open(fileName, "rb").read()
    cachefile = self._contentHashFile(root, fileContent)

    # Remember that we have read this file.
    root.v.t.at_read = True # Create the attribute for all clones.

    if doCache and cachefile in c.db:
        # This message isn't so useful.
        # if not g.unitTesting: # g.es('uncache:',root.h)

        # Delete the previous tree, regardless of the @<file> type.
        while root.hasChildren():
            root.firstChild().doDelete()
        aList = c.db[cachefile]
        root.v.createOutlineFromCacheList(c,aList)
        at.inputFile.close()
        root.clearDirty()
        return

    # Delete all children, but **not** for @file and @nosent nodes!
    if thinFile or atShadow:
        root.v.t.at_read = True # Create the attribute for all clones.
        while root.hasChildren():
            root.firstChild().doDelete()

    if not g.unitTesting:
        g.es("reading:",root.h)

    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>

    # write out the cache version
    self.writeCachedTree(root, cachefile)

    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
resurrected = 0
for p in root.self_and_subtree_iter():
    if p.v.t.isVisited():
        pass
        # g.trace('visited',p.v.t,p.h)
    else:
        g.trace('**** not visited',p.v.t,p.h)
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >> atFile.read
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    try:
        fileContent = open(fileName, "rb").read()
        cachefile = self._contentHashFile(p, fileContent)
    except IOError:
        cachefile = None

    # Remember that we have read this file.
    p.v.at_auto_read = True # Create the attribute

    if cachefile is not None and cachefile in c.db:        
        # g.es('uncache:',p.h)
        aList = c.db[cachefile]
        p.v.createOutlineFromCacheList(c,aList)
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        # c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        self.writeCachedTree(p, cachefile)
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

    p = self
    p.v.clearDirty()
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes (changed)
def findAllPotentiallyDirtyNodes(self):

    p = self
    return p.v.findAllPotentiallyDirtyNodes()

#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes (changed)
#@+node:ekr.20040702104823:p.inAtIgnoreRange
def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False
#@-node:ekr.20040702104823:p.inAtIgnoreRange
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print v.t.isDirty(),v.isAnyAtFileNode(),v

    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    if trace: g.trace(dirtyVnodeList) #,g.callers(5))

    return dirtyVnodeList
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20031218072017.3390:v.clearDirty
def clearDirty (self):
    v = self
    v.t.statusBits &= ~ v.t.dirtyBit

#@-node:ekr.20031218072017.3390:v.clearDirty
#@+node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes (new)
def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    v = self ; c = v.context

    # Set the starting nodes.
    nodes = []
    if g.unified_nodes:
        newNodes = [v]
    else:
        newNodes = v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        # g.trace(len(newNodes))
        nodes.extend(newNodes)
        for v in newNodes:
            if not g.unified_nodes:
                for v2 in v.t.vnodeList:
                    if v2 not in nodes and v2 not in addedNodes:
                        addedNodes.append(v2)
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    # g.trace('done',len(nodes))
    if trace: g.trace(nodes)
    return nodes
#@-node:ekr.20090830051712.6153:v.findAllPotentiallyDirtyNodes (new)
#@+node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty (new)
# Unlike p.setAllAncestorAtFileNodesDirty,
# there is no setDescendentsDirty arg.

def setAllAncestorAtFileNodesDirty (self):

    trace = False and not g.unitTesting
    verbose = False
    v = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = v.findAllPotentiallyDirtyNodes()

    if trace and verbose:
        for v in nodes:
            print v.t.isDirty(),v.isAnyAtFileNode(),v

    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]

    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    if trace: g.trace(dirtyVnodeList)

    return dirtyVnodeList
#@-node:ekr.20090830051712.6157:v.setAllAncestorAtFileNodesDirty (new)
#@+node:ekr.20080429053831.12:v.setDirty
def setDirty (self):

    self.t.statusBits |= self.t.dirtyBit
#@-node:ekr.20080429053831.12:v.setDirty
#@-node:ekr.20090830051712.6151: v.Dirty bits
#@+node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
def createOutlineFromCacheList(self,c,aList):
    """ Create outline structure from recursive aList
    built by p.makeCacheList.

    Clones will be automatically created by gnx,
    but *not* for the top-level node.
    """

    parent_v = self

    #import pprint ; pprint.pprint(tree)
    parent_v = self
    h,b,gnx,children = aList
    if h is not None:
        t = parent_v.t
        t._headString = h    
        t._bodyString = b

    for z in children:
        h,b,gnx,grandChildren = z
        isClone,child_v = parent_v.fastAddLastChild(c,gnx)
        if isClone:
            if child_v.b != b: # or child_v.h
                # Bug fix: the last seen clone rules.
                child_v.h = h
                child_v.b = b
                # Bug fix: mark @<file> nodes dirty.
                child_v.setAllAncestorAtFileNodesDirty()
                child_v.setMarked()
                g.es("changed:",child_v.h,color="blue")
        else:
            child_v.createOutlineFromCacheList(c,z)
#@+node:ekr.20090829064400.6042:v.fastAddLastChild
# Similar to createThinChild4
def fastAddLastChild(self,c,gnxString):
    '''Create new vnode as last child of the receiver.

    If the gnx exists already, create a clone instead of new vnode.
    '''

    trace = False and not g.unitTesting
    parent_v = self
    indices = g.app.nodeIndices
    tnodesDict = c.fileCommands.tnodesDict

    if gnxString is None: t = None
    else:                 t = tnodesDict.get(gnxString)
    is_clone = t is not None

    if trace: g.trace(
        'clone','%-5s' % (is_clone),
        'parent_v',parent_v,'gnx',gnxString,'t',repr(t))

    if not is_clone:
        if g.unified_nodes: t = vnode(context=c)
        else:               t = tnode()
        if gnxString:
            gnx = indices.scanGnx(gnxString,0)
            t.fileIndex = gnx
        tnodesDict[gnxString] = t

    if g.unified_nodes: child_v = t
    else:               child_v = vnode(context=c,t=t)

    if g.unified_nodes:
        pass
    else:
        if child_v not in t.vnodeList:
            t.vnodeList.append(child_v)

    child_v._linkAsNthChild(parent_v,parent_v.numberOfChildren())

    child_v.t.setVisited() # Supress warning/deletion of unvisited nodes.

    return is_clone,child_v
#@-node:ekr.20090829064400.6042:v.fastAddLastChild
#@-node:ekr.20090829064400.6040:v.createOutlineFromCacheList & helpers
#@-node:ekr.20090829175108.6133:Marked @<file> nodes dirty if nodes change during read.
#@+node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20050211120242.2:g.removeExtraLws & test
def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws,tab_width)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
#@+node:ekr.20090517020744.5881:@test g.removeExtraLws
if g.unitTesting:

    c,p = g.getTestVars()

    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@-node:ekr.20090517020744.5881:@test g.removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & test
#@+node:ekr.20051014175117:g.adjustTripleString
def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    trace = True and not g.unitTesting
    lines = g.splitLines(s)
    w = 0 ; val = -1
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w2 = g.computeWidth(lws,tab_width)
            # The sign of w does not matter.
            if w == 0 or abs(w2) < w:
                w = abs(w2)

    if w == 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20090901175503.6098:@test g.adjustTripleString
if g.unitTesting:

    c,p = g.getTestVars()

    s = '''\
    a
      b

c
    d'''

    s2 = 'a\n  b\n\nc\nd'

    result = g.adjustTripleString(s,c.tab_width)
    assert result == s2,repr(result)


#@-node:ekr.20090901175503.6098:@test g.adjustTripleString
#@-node:ekr.20051014175117:g.adjustTripleString
#@+node:ekr.20031218072017.3202:removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0 ; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@-node:ekr.20031218072017.3202:removeLeadingWhitespace
#@-node:ekr.20090901175503.6096:Fixed bug in g.adjustTripleString
#@+node:ekr.20090822054806.6003:Converted buttons and docs to use leoRst.py
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/95687c7a2dba5e18

The rst3 plugin is required to use the script examples given in the
"@@button rst" example in the leoSettings.leo file and in Chapter 14
of the users guide (shown below).  They should be updated to utilize
the new rST functionality in Leo's core.

Until that is done, can someone post a working "@button rst" script
that doesn't require the rst3 plugin?  I would like to test the rST
implementation in Leo's core.

Script in "@@button rst" example in the leoSettings.leo file:
|   import leoPlugins
|   rst3 = leoPlugins.getPluginModule('rst3')
|   if rst3:
|       controller = rst3.controllers.get(c)
|       if controller:
|           controller.processTopTree(p)
|   else:
|       rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
|       if rst3:
|           g.es('rst3 loaded')
|           rst3.onCreate('tag',{'c':c})
|       else:
|           # Ask to be removed.
|           g.app.scriptDict['removeMe'] = True

Script in Chapter 14 of the users guide:
|   import leo.core.leoPlugins as leoPlugins
|   rst3 = leoPlugins.getPluginModule('rst3')
|   if rst3:
|       controller = rst3.controllers.get(c)
|       if controller:
|           p,s = controller.writeNodeToString(ext='.html')
|           print '*' * 40,p
|           print s 
#@nonl
#@-node:ekr.20090822054806.6003:Converted buttons and docs to use leoRst.py
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@+node:ekr.20090822054806.6002:Merged clean-sys-path branch
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b868abd65fb57759

I noted that leo adds all of its directories to sys.path. This is
considered "bad form" and can cause nasty surprises. I believe this is
an artifact of the old "leo-as-package" work; now that leo-as-package
stuff works well, I don't think this is needed anymore.

It's not a lot of work to fix either - it's just a matter of removing
the call to adjustSysPath in runLeo.py, and fixing some plugins. (yes,
I tried it). e.g. quicksearch.py needed this trivial change:

+++ leo/plugins/quicksearch.py  2009-08-15 20:22:20 +0000

-import qt_quicksearch
+from leo.plugins import qt_quicksearch 

What I did:

- disabled adjustSysPath.
- g.importModule now imports from 'extensions' and 'external' directories as needed.
- Modified two plugins to import from leo.plugins.
- Added __init__.py to 'extensions' folder.
#@nonl
#@-node:ekr.20090822054806.6002:Merged clean-sys-path branch
#@-node:ekr.20090817080059.5996:Features
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
