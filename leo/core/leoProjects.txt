#@+leo-ver=4-thin
#@+node:ekr.20100120072650.6089:@thin leoProjects.txt
#@+at
# This part of the tree shows views of the outline related to specific 
# projects or
# tasks. I put such headlines in parentheses, and that is just my convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the
# cloned headlines under the task headline. This greatly increases my focus. 
# Any
# changes made in a task view to clone headlines affect the other clones 
# scattered
# throughout the outline. In particular, all @file nodes containing changed 
# clones
# become marked as dirty, so they will be written when the entire outline is
# saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20100212095952.5727:4.7 final projects
#@+node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@+node:ekr.20100212095952.5729:changed...
#@+node:ekr.20050415134809.1:c.sortSiblings
# New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self,event=None,key=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20060202161935:printGcAll
def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    if not g.unitTesting:
        g.pr('-' * 30)
        g.pr('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except Exception: pass
        # if type(obj) == type(()):
            # g.pr(id(obj),repr(obj))
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = list(d.items())
        items.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        if not g.unitTesting:
            for z in items:
                g.pr('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        for t in sorted(d):
            g.pr('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20050920084036.118:sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines commands
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()

    def key(s):
        return g.os_path_basename(s).lower()
    orig.sort(key=key) # 2010/01/12
    orig.reverse() # 2010/01/12
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20100212095952.5729:changed...
#@-node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@+node:ekr.20100215121737.5600:Fixed possible segfault in c.save/As/To
@nocolor-node

The segfault happens on Linux at the (now removed) call
to c.widgetWantsFocusNow(w) at the end of c.save, c.saveAs and c.saveTo
when w no longer exists in the tree.
#@-node:ekr.20100215121737.5600:Fixed possible segfault in c.save/As/To
#@+node:ekr.20100204052559.5792:Made goto-global-line work with @auto files
@nocolor-node

Fix bug 363406: goto global line doesn't seem to be working in @auto files
#@+node:ekr.20100216141722.5620:class gotoLineNumber and helpers (commands)
class goToLineNumber:

    '''A class implementing goto-global-line.'''

    @others
#@+node:ekr.20100216141722.5621: __init__ (gotoLineNumber)
def __init__ (self,c):

    # g.trace('(c.gotoLineNumber)')
    self.c = c
    self.p = c.p.copy()
#@-node:ekr.20100216141722.5621: __init__ (gotoLineNumber)
#@+node:ekr.20100216141722.5622:go
def go (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self.c
    if n < 0: return

    if scriptData:
        fileName,lines,p,root = self.setup_script(scriptData)
    else:
        if not p: p = c.p
        fileName,lines,n,root = self.setup_file(n,p)

    isRaw = not root or (
        root.isAtEditNode() or root.isAtAsisFileNode() or
        root.isAtAutoNode() or root.isAtNoSentFileNode())
    ignoreSentinels = root and root.isAtNoSentFileNode()
    if not root:
        if scriptData:  root = p.copy()
        else:           root = c.p

    if isRaw:
        p,n2,found = self.countLines(root,n)
        n2 += 1 # Convert to one-based.
    # elif n<=1
        # p,n2,found = root,1,True
    # elif n > len(lines):
        # p,n2,found = root,root.b.count('\n'),False
    else:
        # if n == 0: n = 1
        vnodeName,gnx,n2,delim = self.findVnode(root,lines,n,ignoreSentinels)
        p,found = self.findGnx(delim,root,gnx,vnodeName)

    self.showResults(found,p or root,n,n2,lines)
    return found
#@-node:ekr.20100216141722.5622:go
#@+node:ekr.20100216141722.5623:countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False # and not g.unitTesting
    c = self.c

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624:countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n,
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0 ; n1 = n
    effective_lines = 0 ; skipped_lines = 0
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n + skipped_lines is the target line number.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %s effective %s skipped %s %s' % (
            i,effective_lines,skipped_lines,line.rstrip()))
        if line.strip().startswith('@'):
            skipped_lines += 1
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        assert effective_lines2 <= new_n
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        elif i == n + skipped_lines: # Found the line.
            if trace:
                g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
            return p,i,-1,True # effective_lines doesn't matter.
        else:
            effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@-node:ekr.20100216141722.5624:countLinesHelper
#@+node:ekr.20100216141722.5625:countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*5,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            assert effective_lines2 <= new_n
            # i2 is not used
            effective_lines += effective_lines2
            if trace:
                g.trace('Not found. effective_lines2: %s %s' % (
                    effective_lines2,child.h))
    else:
        return p,-1,effective_lines,False # i does not matter.
#@-node:ekr.20100216141722.5625:countLinesInChildren
#@-node:ekr.20100216141722.5623:countLines & helpers
#@+node:ekr.20100216141722.5626:findGnx
def findGnx (self,delim,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    if delim and gnx:
        gnx = g.app.nodeIndices.scanGnx(gnx,0)
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(),True
        return None,False
    else:
        return root,False
#@-node:ekr.20100216141722.5626:findGnx
#@+node:ekr.20100216141722.5627:findRoot
def findRoot (self,p):

    '''Find the closest ancestor @<file> node, except @all nodes.

    return root, fileName.'''

    c = self.c ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions():
        if p.v == p1.v and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20100216141722.5627:findRoot
#@+node:ekr.20100216141722.5628:findVnode & helpers
def findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self.c
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    delim,thinFile = self.setDelimFromLines(lines)
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    nodeLine,offset = self.findNodeSentinel(delim,lines,n)
    if nodeLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeLine]
    gnx,vnodeName = self.getNodeLineInfo(s,thinFile)
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20100216141722.5629:findNodeSentinel & helper
def findNodeSentinel(self,delim,lines,n):

    '''
    Scan backwards from the line n, looking for an @-body line. When found,
    get the vnode's name from that line and set p to the indicated vnode. This
    will fail if vnode names have been changed, and that can't be helped.

    We compute the offset of the requested line **within the found node**.
    '''

    c = self.c
    offset = 0 # This is essentially the Tk line number.
    nodeSentinelLine = -1
    line = n - 1 # Start with the requested line.
    while line >= 0 and nodeSentinelLine == -1:
        progress = line
        s = lines[line]
        i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            line,nodeSentinelLine,offset = self.handleDelim(
                delim,s,i,line,lines,n,offset)
        else:
            # offset += 1
                # Assume the line is real.
                # A dubious assumption.
            line -= 1
        assert nodeSentinelLine > -1 or line < progress
    return nodeSentinelLine,offset
#@+node:ekr.20100216141722.5630:handleDelim
def handleDelim (self,delim,s,i,line,lines,n,offset):

    '''Handle the delim while scanning backward.'''

    c = self.c
    if line == n:
        g.es("line",str(n),"is a sentinel line")
    i += len(delim)
    nodeSentinelLine = -1

    if g.match(s,i,"-node"):
        # The end of a nested section.
        old_line = line
        line = self.skipToMatchingNodeSentinel(lines,line,delim)
        assert line < old_line
        # g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"+node"):
        # g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"<<") or g.match(s,i,"@first"):
        # if not ignoreSentinels:
            # offset += 1 # Count these as a "real" lines.
        line -= 1
    else:
        line -= 1
        nodeSentinelLine = -1
    return line,nodeSentinelLine,offset
#@-node:ekr.20100216141722.5630:handleDelim
#@-node:ekr.20100216141722.5629:findNodeSentinel & helper
#@+node:ekr.20100216141722.5631:getNodeLineInfo
def getNodeLineInfo (self,s,thinFile):

    i = 0 ; gnx = None ; vnodeName = None

    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:   gnx = s[i:j]
            else:       i = len(s) # Force an error.
        else:
            i = len(s) # Force an error.

    # vnode name is everything following the first or second':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    else:
        vnodeName = None
        g.es_print("bad @+node sentinel",color='red')

    return gnx,vnodeName
#@-node:ekr.20100216141722.5631:getNodeLineInfo
#@+node:ekr.20100216141722.5632:setDelimFromLines
def setDelimFromLines (self,lines):

    # Find the @+leo line.
    c = self.c ; at = c.atFileCommands
    i = 0 
    while i < len(lines) and lines[i].find("@+leo")==-1:
        i += 1
    leoLine = i # Index of the line containing the leo sentinel

    # Set delim and thinFile from the @+leo line.
    delim,thinFile = None,False

    if leoLine < len(lines):
        s = lines[leoLine]
        valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
        # New in Leo 4.5.1: only support 4.x files.
        if valid and newDerivedFile:
            delim = start + '@'

    return delim,thinFile
#@-node:ekr.20100216141722.5632:setDelimFromLines
#@+node:ekr.20100216141722.5633:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20100216141722.5633:skipToMatchingNodeSentinel
#@-node:ekr.20100216141722.5628:findVnode & helpers
#@+node:ekr.20100216141722.5634:getFileLines
def getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self.c
    isAtEdit = root.isAtEditNode()
    isAtNoSent = root.isAtNoSentFileNode()

    if isAtNoSent or isAtEdit:
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        kind = g.choose(isAtNoSent,'@nosent','@edit')
        at.write(root,kind=kind,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = self.openFile(fileName)

    return lines
#@-node:ekr.20100216141722.5634:getFileLines
#@+node:ekr.20100216141722.5635:openFile (gotoLineNumber)
def openFile (self,filename):
    """
    Open a file and check if a shadow file exists.
    Construct a line mapping. This ivar is empty if no shadow file exists.
    Otherwise it contains a mapping, shadow file number -> real file number.
    """

    c = self.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20100216141722.5635:openFile (gotoLineNumber)
#@+node:ekr.20100216141722.5636:setup_file
def setup_file (self,n,p):

    '''Return (lines,n) where:

    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    '''

    c = self.c ; x = c.shadowController

    root,fileName = self.findRoot(p)

    if root and fileName:
        c.shadowController.line_mapping = [] # Set by open.
        lines = self.getFileLines(root,fileName)
            # This will set x.line_mapping for @shadow files.
        if len(x.line_mapping) > n:
            n = x.line_mapping[n]
    else:
        if not g.unitTesting:
            g.es("no ancestor @<file node>: using script line numbers",
                color="blue")
        lines = g.getScript(c,p,useSelectedText=False)
        lines = g.splitLines(lines)

    return fileName,lines,n,root
#@-node:ekr.20100216141722.5636:setup_file
#@+node:ekr.20100216141722.5637:setup_script
def setup_script (self,scriptData):

    c = self.c

    p = scriptData.get('p')
    root,fileName = self.findRoot(p)
    lines = scriptData.get('lines')

    return fileName,lines,p,root
#@-node:ekr.20100216141722.5637:setup_script
#@+node:ekr.20100216141722.5638:showResults
def showResults(self,found,p,n,n2,lines):

    trace = False
    c = self.c ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    if trace and g.unitTesting:
        i,j = g.getLine(s,ins)
        g.trace('%2s %2s %15s %s' % (n,n2,p.h,repr(s[i:j])))

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20100216141722.5638:showResults
#@-node:ekr.20100216141722.5620:class gotoLineNumber and helpers (commands)
#@-node:ekr.20100204052559.5792:Made goto-global-line work with @auto files
#@-node:ekr.20100212095952.5727:4.7 final projects
#@-all
#@-node:ekr.20100120072650.6089:@thin leoProjects.txt
#@-leo
