#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20090718091653.5982:Leo 4.7 projects
#@+node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:bwmulder.20050101094804:openForWrite (atFile)
def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False and not g.unitTesting
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
#@-node:bwmulder.20050101094804:openForWrite (atFile)
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090721091726.5982:Fixed crasher when writing to a newly-deleted file
#@+node:ekr.20090812165611.5973:Fixed registerHandler bug
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

On Aug 10, 12:25 pm, tfer <tfethers...@aol.com> wrote:
> Well from vim.py:
> When properly installed, this plugin does the following:
>
> 1. - Double clicking on a node's icon opens that node in VIM. You can
> open nodes in VIM with
>         a single-click if you set useDoubleClick = False.

I tried setting "useDoubleClick = False" under the vim plugin node in
leoPluginsRef.leo work. It doesn't seem to work. I get the message:

exception loading plugin
Traceback (most recent call last):

 File "C:\Program Files\Leo-4-6-2-final\leo\core\leoPlugins.py", line
437, in loadOnePlugin
   init_result = result.init()

 File "C:\Program Files\Leo-4-6-2-final\leo\plugins\vim.py", line
232, in init
   leoPlugins.registerHandler(event,open_in_vim,val=True)

TypeError: registerHandler() got an unexpected keyword argument 'val'

The variable val doesn't get modified in the "open_in_vim
(tag,keywords,val=None)" function.
- Show quoted text -
#@nonl
#@-node:ekr.20090812165611.5973:Fixed registerHandler bug
#@+node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
# at_read attribute in the tnode, not the vnode.
#@nonl
#@+node:ekr.20090712050729.6017:promptForDangerousWrite
def promptForDangerousWrite (self,fileName,kind):

    c = self.c

    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None,True)

    # g.trace(timeStamp, timeStamp2)
    message = '%s %s\n%s\n%s' % (
        kind, fileName,
        g.tr('already exists.'),
        g.tr('Overwrite this file?'))

    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite existing file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090712050729.6017:promptForDangerousWrite
#@-node:ekr.20090813084945.5977:Suppressed dangerous write prompt for clones
#@+node:ekr.20090813084404.5974:Fix crasher when writing to a renamed file
@nocolor-node

.....  File "C:\Python25\Lib\site-packages\Leo-4-6-final\leo\core
\leoCommands.py", line 7705, in checkFileTimeStamp
.....    timeStamp2 = os.path.getmtime(fn)
.....  File "C:\Python25\lib\ntpath.py", line 232, in getmtime
.....    return os.stat(filename).st_mtime
.....WindowsError: [Error 2] The system cannot find the file
specified: u'C:\\fina\\POSTE\\work.leo'

The fix: checkFileTimeStamp now makes the check for existing file first.
#@nonl
#@+node:ekr.20090103070824.11:c.checkFileTimeStamp
def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    trace = False and not g.unitTesting
    c = self

    # Don't assume the file still exists.
    if not g.os_path_exists(fn):
        if trace: g.trace('file no longer exists',fn)
        return True

    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        if trace: g.trace('no time stamp',fn)
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        if trace: g.trace('time stamps match',fn,timeStamp)
        return True

    if g.app.unitTesting:
        return False

    if trace:
        g.trace('mismatch',timeStamp,timeStamp2)

    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)

    return ok == 'yes'
#@-node:ekr.20090103070824.11:c.checkFileTimeStamp
#@-node:ekr.20090813084404.5974:Fix crasher when writing to a renamed file
#@+node:ekr.20090804091109.5985:Fixed double prompt in c.close()
# only on Linux.
#@nonl
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocus()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20090804091109.5985:Fixed double prompt in c.close()
#@+node:ekr.20090817080059.5995:Select main chapter initially
It can be alarming to select a small chapter in a large outline.
#@nonl
#@-node:ekr.20090817080059.5995:Select main chapter initially
#@+node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/33e87adbff5d69d9

Latest trunk.  qt gui

I used multiple body editors (2) for the first time in a long time and the
scroll position was moving at times that it shouldn't.

For example if I scrolled partially down the page and copied some text and then
pasted the text somewhere else that was visible without scrolling, the scroll
position would change significantly although the new text would remain visible.

It may not sound particularly serious but I found it very difficult to use.

The fix was to leoQtGui.updateEditors.
#@nonl
#@-node:ekr.20090813084945.5978:Fixed scrolling problem with multiple editors
#@-node:ekr.20090721093155.5986:Bugs
#@+node:ekr.20090817080059.5996:Features
#@+node:ekr.20090815073537.5991:Added options to vim plugin
@nocolor-node

The setting::

    @string vim_trigger_event = icondclick2

is the default.  It opens vim when the user double-clicks the icon box.

Alternatives are::

    @string vim_trigger_event = iconclick2
    @string vim_trigger_event = select2

The former opens vim on single clicks in the icon bar.
The latter opens vim whenever a new node is selected in Leo.
#@nonl
#@-node:ekr.20090815073537.5991:Added options to vim plugin
#@-node:ekr.20090817080059.5996:Features
#@-node:ekr.20090718091653.5982:Leo 4.7 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
