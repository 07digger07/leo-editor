#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20080917153158.11:4.6
#@+node:ekr.20080917153158.12:Bugs
#@+node:ekr.20081003084608.4:Not bugs
@ This contains investigations which revealed no bug at present.
#@nonl
#@+node:ekr.20080918164844.7:Investigated settings strangeness re @string debugger_path
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d38704eb27eb9340

I find that
@settings
  @string debugger_path = /usr/bin/winpdb

sets the config string successfully if in
home/.leo/myLeoSettings.leo
not if in
cwd/myLeoSettings.leo

============

This works as expected, provided that by 'cwd' you mean the directory from which the .leo file was loaded.

#@-node:ekr.20080918164844.7:Investigated settings strangeness re @string debugger_path
#@+node:ekr.20080918164844.9:Don't put relative paths on the recent file list
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/5c6653927911de0d#

Code-->Core classes-->@thin runLeo.py -->utils-->createFrame (leo.py)

        c.updateRecentFiles(relativeFileName or fileName)

I don't think relative filenames should be passed to
c.updateRecentFiles()?  They get stuff in the recent file list but
don't work there.

Also appears to happen here:

Code-->Core classes-->@thin leoCommands.py-->class commands-->Command
handlers...-->File Menu-->Recent Files submenu &
allies-->clearRecentFiles

c.updateRecentFiles(c.relativeFileName())

and here

Code-->Core classes-->@thin leoGlobals.py-->Files &
Directories...-->g.openWithFileName

c.updateRecentFiles(relativeFileName or fileName)

The only way I've seen a relative path get into the list is from
command line invocation, so I'm not sure if all these routes are
active, but I think it should be avoided.

Cheers -Terry 


======

c.updateRecentFiles calls g.os_path_finalize/join so only abs paths can be put on the list.

@color
#@nonl
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    c = self

    if g.app.unitTesting: return

    def munge(name):
        return c.os_path_finalize(name or '').lower()
    def munge2(name):
        return c.os_path_finalize_join(g.app.loadDir,name or '')

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20080918164844.9:Don't put relative paths on the recent file list
#@-node:ekr.20081003084608.4:Not bugs
#@+node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@-node:ekr.20080917153158.13:Ensure that Python\Scripts exists in installer script
#@+node:ekr.20080917153158.14:Fix config crasher
@nocolor

Latest revision from trunk.

To reproduce:

- open a new outline.
- create a @settings node.
- create two children of the @settings node with the following
headlines "@string xxx = aaa" and "@button xxx".
- save the outline and close it.
- reopen the outline.

I'm getting the following traceback:

Traceback (most recent call last):
 File "/home/shadow/leo/leo-current/leo/core/leoGlobals.py", line
2818, in doHook
   return f(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 97,
in doPlugins
   return doHandlersForTag(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 76,
in doHandlersForTag
   val = callTagHandler(bunch,tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 55,
in callTagHandler
   result = handler(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 197, in onCreate
   sc.createAllButtons()
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 261, in createAllButtons
   self.handleAtButtonNode(p)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 533, in handleAtButtonNode
   b =
self.createAtButtonHelper(p,h,statusLine,shortcut,verbose=False)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 681, in createAtButtonHelper
   pane='button',verbose=verbose)
 File "/home/shadow/leo/leo-current/leo/core/leoKeys.py", line 3161,
in registerCommand
   junk,bunchList = c.config.getShortcut(commandName)
 File "/home/shadow/leo/leo-current/leo/core/leoCommands.py", line
7271, in getShortcut
   return g.app.config.getShortcut(self.c,shortcutName)
 File "/home/shadow/leo/leo-current/leo/core/leoConfig.py", line
1682, in getShortcut
   if bunch.val and bunch.val.lower() != 'none']
AttributeError: 'unicode' object has no attribute 'val'

@color
#@nonl
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20080917153158.14:Fix config crasher
#@+node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2

@nocolor

I recently discovered leo and decided to give it a try. I'm using the
rst3 plugin for generating latex docs. In general it works like a
charm, but I'm having some problems with the text encoding. The most
annoying one follows. If in my rst tree I've nodes with the character

ŀ (U+0140)

(or other character from the catalan alphabet) in the body text, I get
conversion errors in the log pane when the Write-Restructured-Text
command is executed. For instance, a node with the following body text

Nuŀla

causes the following error in the log pane:

1 errors converting Nu?la.

 to iso-8859-1

If I process the generated .tex file via pdflatex the character is
displayed as a ? symbol in the pdf.

The rst-options are:

@ @rst-options
default_path=latex
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--output-
encoding=utf-8,--stylesheet=/home/vmas/.leo/custom_style.sty
@c

If, instead of using leo, I put the problematic text content in a
plain rst file and process it via rst2latex I get no conversion
errors. The command line is:

rst2latex --language=ca --output-encoding=utf-8 --stylesheet=/home/
vmas/.leo/custom_style.sty prova.txt prova.tex 
#@nonl
#@-node:ekr.20080915083836.2:Fixed encoding problems with rst3 plugin
#@+node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@-node:ekr.20080918122745.1:Simplified c.scanAtPathDirectives
#@+node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080827175609.39:c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.currentPosition()

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }
#@nonl
#@-node:ekr.20080827175609.39:c.scanAllDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080710082231.10:c.gotoLineNumber and helpers
def goToLineNumber (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self
    delim = None ; gnx = None ; vnodeName = None
    if n < 0: return

    fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p,scriptData)

    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; n2 = root.bodyString().count('\n') ; found = False
    elif isRaw:
        p,n2,found = c.goto_countLines(root,n)
    else:
        vnodeName,gnx,n2,delim = c.goto_findVnode(root,lines,n,ignoreSentinels)
        if delim:
            p,found = c.goto_findPosition(
                root,lines,vnodeName,gnx,n,delim)
        else:
            p,found = root,False
    if 0:
        << trace gotoLineNumber results >>
    c.goto_showResults(found,p or root,n,n2,lines)
#@+node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
g.trace(
    '\n  found',found,'n2',n2,'gnx',gnx,'delim',repr(delim),
    '\n  vnodeName',vnodeName,
    '\n  p        ',p and p.headString(),
    '\n  root     ',root and root.headString())
#@-node:ekr.20080905130513.40:<< trace gotoLineNumber results >>
#@+node:ekr.20080708094444.65:goto_applyLineNumberMapping
def goto_applyLineNumberMapping(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) > n:
        return x.line_mapping[n]
    else:
        return n
#@-node:ekr.20080708094444.65:goto_applyLineNumberMapping
#@+node:ekr.20080904071003.12:goto_countLines
def goto_countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,n2,found) where p is the found node,
    n2 is the actural line found, and found is True if the line was found.'''

    p = lastv = root
    prev = 0 ; found = False
    isNosent = root.isAtNoSentFileNode()
    isAuto = root.isAtAutoNode()

    for p in p.self_and_subtree_iter():
        lastv = p.copy()
        s = p.bodyString()
        if isNosent or isAuto:
            s = ''.join([z for z in g.splitLines(s) if not z.startswith('@')])
        n_lines = s.count('\n')
        if len(s) > 0 and s[-1] != '\n': n_lines += 1
        # g.trace(n,prev,n_lines,p.headString())
        if prev + n_lines >= n:
            found = True ; break
        prev += n_lines

    p = lastv
    n2 = max(1,n-prev)

    return p,n2,found
#@-node:ekr.20080904071003.12:goto_countLines
#@+node:ekr.20080904071003.4:goto_findPosition & helpers
def goto_findPosition(self,root,lines,vnodeName,gnx,n,delim):

    c = self

    # if scriptFind:
        # p,found = c.scanForVnodeName(root,vnodeName

    if gnx:
        p,found = c.goto_findGnx(root,gnx,vnodeName)
    else:
        p,found = c.goto_scanTnodeList(root,delim,lines,n,vnodeName)

    # if not found:
        # g.es("not found:",vnodeName,color="red")

    return p,found
#@+node:ekr.20080904071003.18:goto_findGnx
def goto_findGnx (self,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    gnx = g.app.nodeIndices.scanGnx(gnx,0)

    for p in root.self_and_subtree_iter():
        if p.matchHeadline(vnodeName):
            if p.v.t.fileIndex == gnx:
                return p.copy(),True

    return None,False
#@-node:ekr.20080904071003.18:goto_findGnx
#@+node:ekr.20080904071003.19:goto_scanTnodeList
def goto_scanTnodeList (self,root,delim,lines,n,vnodeName):

    # This is about the best that can be done without replicating the entire atFile write logic.
    found = False
    ok = hasattr(root.v.t,"tnodeList")

    if ok:
        # Use getattr to keep pylint happy.
        tnodeList = getattr(root.v.t,'tnodeList')
        << set tnodeIndex to the number of +node sentinels before line n >>
        tnodeIndex = max(0,tnodeIndex)
        << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
    else:
        g.es_print("no child index for",root.headString(),color="red")

    if not ok:
        # Fall back to the old logic.
        << set p to the first node whose headline matches vnodeName >>

    return p,found
#@+node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>

tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@-node:ekr.20080904071003.8:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@-node:ekr.20080904071003.9:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@-node:ekr.20080904071003.10:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20080904071003.19:goto_scanTnodeList
#@-node:ekr.20080904071003.4:goto_findPosition & helpers
#@+node:ekr.20031218072017.2877:goto_findVnode
def goto_findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self ; at = c.atFileCommands
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es('no sentinels in:',root.headString())
        return None,None,None,None

    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.headString(),gnx,1,delim

    s = lines[nodeSentinelLine]

    << set gnx and vnodeName from s >>
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

# Set delim from the @+leo line.
delim = None
if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
    # New in Leo 4.5.1: only support 4.x files.
    if valid and newDerivedFile:
        delim = start + '@'
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
@
Scan backwards from the requested line, looking for an @-body line. When found,
we get the vnode's name from that line and set p to the indicated vnode. This
will fail if vnode names have been changed, and that can't be helped.

We compute the offset of the requested line **within the found node**.
@c

offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1 # Start with the requested line.
while line >= 0:
    progress = line
    s = lines[line]
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        ### offset += 1 # Assume the line is real.  A dubious assumption.
        line -= 1
    assert line < progress
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    old_line = line
    line = c.goto_skipToMatchingNodeSentinel(lines,line,delim)
    assert line < old_line
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"+node"):
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    # if not ignoreSentinels:
        # offset += 1 # Count these as a "real" lines.
    line -= 1
else:
    line -= 1
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
i = 0 ; gnx = None ; vnodeName = None

if thinFile:
    # gnx is lies between the first and second ':':
    i = s.find(':',i)
    if i > 0:
        i += 1
        j = s.find(':',i)
        if j > 0:   gnx = s[i:j]
        else:       i = len(s) # Force an error.
    else:
        i = len(s) # Force an error.

# vnode name is everything following the first or second':'
i = s.find(':',i)
if i > -1:
    vnodeName = s[i+1:].strip()
else:
    vnodeName = None
    g.es_print("bad @+node sentinel",color='red')
#@-node:ekr.20031218072017.2881:<< set gnx and vnodeName from s >>
#@-node:ekr.20031218072017.2877:goto_findVnode
#@+node:ekr.20080904071003.28:goto_setup & helpers
def goto_setup (self,n,p=None,scriptData=None):

    '''Return (fileName,isRaw,lines,n,p,root) where:

    fileName is the name of the nearest @file node, or None.
    isRaw is True if there are no sentinels in the file.
    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    root is the nearest @file node, or c.currentPosition.'''

    c = self

    if scriptData:
        assert p is None
        lines = scriptData.get('lines')
        p = scriptData.get('p')
        root,fileName = c.goto_findRoot(p)
    else:
        # p is for unit testing only!
        if not p: p = c.currentPosition()
        root,fileName = c.goto_findRoot(p)
        if root and fileName:
            c.shadowController.line_mapping = [] # Set by goto_open.
            lines = c.goto_getFileLines(root,fileName)
            n = c.goto_applyLineNumberMapping(n)
        else:
            lines = c.goto_getScriptLines(p)

    isRaw = not root or (
        root.isAtAsisFileNode() or root.isAtNoSentFileNode() or root.isAtAutoNode())

    ignoreSentinels = root and root.isAtNoSentFileNode()

    if scriptData:
        if not root: root = p.copy()
    else:
        if not root: root = c.currentPosition()

    return fileName,ignoreSentinels,isRaw,lines,n,root
#@+node:ekr.20080904071003.25:goto_findRoot
def goto_findRoot (self,p):

    '''Find the closest ancestor @file node, of any type, except @all nodes.

    return root, fileName.'''

    c = self ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents_iter():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions_iter():
        # if p.v.t == p1.v.t: g.trace('p1',p1,'p',p)
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents_iter():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20080904071003.25:goto_findRoot
#@+node:ekr.20080904071003.26:goto_getFileLines
def goto_getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self

    if root.isAtNoSentFileNode():
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        at.write(root,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = c.goto_open(fileName)

    return lines
#@-node:ekr.20080904071003.26:goto_getFileLines
#@+node:ekr.20080904071003.27:goto_getScriptLines
def goto_getScriptLines (self,p):

    c = self

    if not g.unitTesting:
        g.es("no ancestor @file node: using script line numbers", color="blue")

    lines = g.getScript (c,p,useSelectedText=False)
    lines = g.splitLines(lines)

    return lines
#@-node:ekr.20080904071003.27:goto_getScriptLines
#@+node:ekr.20080708094444.63:goto_open
def goto_open (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -> real file number.
    """

    c = self ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20080708094444.63:goto_open
#@-node:ekr.20080904071003.28:goto_setup & helpers
#@+node:ekr.20080904071003.14:goto_showResults
def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    c.redraw()

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace(p.headString(),g.callers())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20080904071003.14:goto_showResults
#@+node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
def goto_skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20031218072017.2882:goto_skipToMatchingNodeSentinel
#@-node:ekr.20080710082231.10:c.gotoLineNumber and helpers
#@-node:ekr.20080918084804.1:Fixed goto-global-line crasher
#@+node:ekr.20080923143214.1:Removed pychecker stuff
# It's time.
#@nonl
#@-node:ekr.20080923143214.1:Removed pychecker stuff
#@+node:ekr.20080921154026.3:Fixed new rst3 crash
# Calls g.makeAllNonExistentDirectories instead of os.mkdir.
#@nonl
#@+node:ekr.20080923163444.2:Report
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

I receive the following traceback, when I try to create an HTML-
File from a @rst-Node.

<Traceback>

Leo Log Window...
Leo 4.5.1 final, build  1.244 , September 14, 2008
python 2.5.2, Tk 8.4.12, Pmw 1.3
Windows 5, 1, 2600, 2, Service Pack 3

Can not load c:\aspell\bin\aspell-15.dll
leoID=vr20080824 (in C:\Dokumente und Einstellungen\VR\.leo)
load dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
global config dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\.leo
\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene Dateien
\Tools\Leo\Leo-20080921.leo
rewriting empty .leo file: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\Leo-20080921.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\Tools\Leo
\Leo-20080921.leo
saved: Leo-20080921.leo
SilverCity not present so no syntax highlighting
exception executing command
Traceback (most recent call last):
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 309, in doCommand
    val = command(event)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 482, in minibufferCallback
    retval = function(keywords)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 675, in rst3PluginCallback
    self.processTopTree(c.currentPosition())
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1152, in processTopTree

self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1184, in processTree
    ok =
self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1222, in writeSpecialTree
    os.mkdir(dir)
WindowsError: [Error 3] Das System kann den angegebenen Pfad nicht
finden: u'C:\\Python25\\Lib\\site-packages\\Leo-4-5-1-2-final\\2008\
\09'

</Traceback>

The related outline can be reduced to:

Worklog-->2008-->09-->@rst WLE-2008-09-21.html

The content of the right-most node is:

@ @rst-options
default_path=./2008/09
@c
======================
Worklog for 2008-09-21
======================

Kind regards,

Viktor 
#@nonl
#@-node:ekr.20080923163444.2:Report
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@-node:ekr.20080921154026.3:Fixed new rst3 crash
#@+node:ekr.20080924032842.2:Fixed two c syntax-coloring bugs
@
There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

Happily, no changes were required in the modes/c.py or modes/c.xml.
#@nonl
#@+node:ekr.20080709161540.1:Bug 1
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

Coloring of macro definitions is not extended after '\'.

More than that - refer again to the screenshot and look at the
comments and #defines at the bottom. The comments after the multi-line
macro are either not coloured or are coloured incorrectly. At the top,
the '#define ADDPRIM_CO' macro is only partially coloured. The macros
below the multi-line macro are incorrectly comment-coloured.

@color
#@nonl
#@+node:ekr.20080729064227.4:@url http://www.freenet.org.nz/misc/leo-c-screenshot.jpg
#@-node:ekr.20080729064227.4:@url http://www.freenet.org.nz/misc/leo-c-screenshot.jpg
#@-node:ekr.20080709161540.1:Bug 1
#@+node:ekr.20080924032842.1:Bug 2
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

I've noticed a strange behaviour of the "@language cplusplus" mode
using doxygen style comments.
I wrote this code doxygen java-like commenting style:

/**
 * first comment
 */

/**
 * second comment
 */

now I've the string "first comment" highlited as code and the string
"second comment" highlithed as comment.
Qt-style doxygen comments have the same behaviour and if I don't use
doxygen comments it's all ok.
I'm using leo 4.5.1 final on Windows XP.
It's a bug or I haven't understood something?

@color
#@nonl
#@-node:ekr.20080924032842.1:Bug 2
#@+node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i >= len(s): return len(s) # Bug fix: 2007/5/22
    if i < 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i >= len(s): return len(s)
    if i <= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
#@-node:ekr.20031218072017.3187:skip_line, skip_to_start/end_of_line
#@-node:ekr.20080924032842.2:Fixed two c syntax-coloring bugs
#@+node:ekr.20081001062423.3:Restored deleted unit tests for p.textOffset
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/6f744c2a5819e3

I was browsing the source code and I've incidentally found that the
tests for p.textOffset() are not in the trunk. Perhaps they were lost
during a merge.

Relevant pointers:

------------------------------------------------------------
revno: 903
committer: Edward K. Ream <edream...@gmail.com>
branch nick: trunk
timestamp: Mon 2008-08-25 11:14:15 -0500
message:
  commit after merge
    ------------------------------------------------------------
    revno: 899.1.3
    committer: zpcspm zpc...@gmail.com
    branch nick: leo-fcol
    timestamp: Mon 2008-08-25 17:53:37 +0300
    message:
      commit after merge

The following command shows that the tests disappeared here.

$ bzr diff leo/test/unitTest.leo -r 899.1.3..903 
#@nonl
#@-node:ekr.20081001062423.3:Restored deleted unit tests for p.textOffset
#@+node:ekr.20080930072519.10:Fixed bug that prevented Leo from opening files on the XP desktop
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@-node:ekr.20080930072519.10:Fixed bug that prevented Leo from opening files on the XP desktop
#@+node:ekr.20081001062423.2:Fixed nested @path problem
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30

I'm finding

@path project
 \
   @shadow one.py
   @shadow two.py
   @path subdir
     \
       @shadow three.py

I'm finding three.py is considered project/three.py instead of
project/subdir/three.py 

===========

The problem was that leoAtFile/leoImport.scanDefaultDirectory did not support
nested @path directives.

I refactored them so all the common work is done in g.setDefaultDirectory.

@color
#@nonl
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20080211085914:scanDefaultDirectory (leoImport)
def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory, error = g.setDefaultDirectory(c,p,importing=False)

    if error: self.error(error)
#@-node:ekr.20080211085914:scanDefaultDirectory (leoImport)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory,error = g.setDefaultDirectory(c,p,importing)

    if error: at.error(error)
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20081001062423.9:g.setDefaultDirectory
# This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefault directory

def setDefaultDirectory(c,p,importing=False):

    '''Set default_directory by scanning @path directives.
    Return (default_directory,error_message).'''

    default_directory = '' ; error = ''
    if not p: return default_directory,error

    << Set path from @file node >>

    if not default_directory:
        # Scan for @path directives.
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        if path:
            << handle @path >>

    if not default_directory:
        << Set current directory >>

    if not default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    # g.trace('returns',default_directory)
    return default_directory, error
#@+node:ekr.20081001062423.10:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        default_directory = theDir
    else:
        default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not default_directory:
            error = "Directory \"%s\" does not exist" % theDir
#@-node:ekr.20081001062423.10:<< Set path from @file node >>
#@+node:ekr.20081001062423.11:<< handle @path >>
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        if g.os_path_exists(path):
            default_directory = path
        else:
            default_directory = g.makeAllNonExistentDirectories(path,c=c)
            if not default_directory:
                error = "invalid @path: %s" % path
            else:
                error = "ignoring bad @path: %s" % path
else:
    error = "ignoring empty @path"
#@-node:ekr.20081001062423.11:<< handle @path >>
#@+node:ekr.20081001062423.12:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not default_directory)

if c.frame:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    default_directory = theDir ; break
                else:
                    default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20081001062423.12:<< Set current directory >>
#@-node:ekr.20081001062423.9:g.setDefaultDirectory
#@-node:ekr.20081001062423.2:Fixed nested @path problem
#@+node:ekr.20080313032655.1:Fixed one failed unit test on Linux
@

This happened at line 36 of leo/test/unittest/perfectImport/formatter.py

It was caused by non-Linux line-endings.

I also fixed a bug that caused the unit test not to fail.
#@nonl
#@+node:ekr.20070703122141.104:checkTrialWrite
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite
#@+node:ekr.20070730093735:compareHelper
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
#@nonl
#@-node:ekr.20070730093735:compareHelper
#@+node:ekr.20070911110507:reportMismatch
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.headString(),bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in range(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in range(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@-node:ekr.20070911110507:reportMismatch
#@+node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20051104075904.78:makeImportExportSuite
def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite
#@-node:ekr.20051104075904.78:makeImportExportSuite
#@+node:ekr.20051104075904.79:class importExportTestCase
class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
#@+node:ekr.20051104075904.80:__init__
def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.currentPosition()
#@-node:ekr.20051104075904.80:__init__
#@+node:ekr.20051104075904.81: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.81: fail
#@+node:ekr.20051104075904.82:importExport
def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.headString()
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
#@-node:ekr.20051104075904.82:importExport
#@+node:ekr.20051104075904.83:runTest
def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
#@-node:ekr.20051104075904.83:runTest
#@+node:ekr.20051104075904.84:setUp
def setUp(self):

    c = self.c ; temp_p = self.temp_p ; d = self.dialog

    temp_p.setBodyString('',g.app.tkEncoding)

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import test: " + self.p.headString())
    c.selectVnode(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
#@-node:ekr.20051104075904.84:setUp
#@+node:ekr.20051104075904.85:shortDescription
def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.headString(),self.fileName)
    except Exception:
        return "ImportExportTestCase"
#@-node:ekr.20051104075904.85:shortDescription
#@+node:ekr.20051104075904.86:tearDown
def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("",g.app.tkEncoding)
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
#@-node:ekr.20051104075904.86:tearDown
#@-node:ekr.20051104075904.79:class importExportTestCase
#@-node:ekr.20051104075904.77:Import/Export test code (leoTest.py)
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        << Create a parent for two files having a common prefix >>
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw()

    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@-node:ekr.20080313032655.1:Fixed one failed unit test on Linux
#@+node:ekr.20080330085343.3:Save/restore tnodeList in atFile.write
The code should save/restore, just as in the clean_file function (from scripts.leo)
#@nonl
#@+node:ekr.20041005105605.144:write & helper
# This is the entry point to the write code.  root should be an @file vnode.

def write (self,root,
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
    write_strips_blank_lines = None,
):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    if hasattr(root.v.t,'tnodeList'):# 2008/10/3
        has_list,old_list = True,root.v.t.tnodeList[:]
    else:
        has_list,old_list = False,[]

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString,
        write_strips_blank_lines = write_strips_blank_lines)

    if nosentinels and not scriptWrite and not toString:
        fileName = c.os_path_finalize_join(at.default_directory,at.targetFileName)
        exists = g.os_path_exists(fileName)
        if not self.shouldWriteAtNosentNode(root,exists):
            return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    self.remove(at.outputFileName) # Delete the temp file.
    g.es("not written:",at.outputFileName)
else:
    at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@+node:ekr.20080620095343.1:shouldWriteAtNosentNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don ' t want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.headString(),'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
#@-node:ekr.20080620095343.1:shouldWriteAtNosentNode
#@-node:ekr.20041005105605.144:write & helper
#@+node:ekr.20080330085343.1:clean_file
def clean_file(p):

    at = c.atFileCommands

    if hasattr(p.v.t,'tnodeList'):
        has_list = True
        old_list =  p.v.t.tnodeList[:]
    else:
        has_list = False

    at.write(
        root=p,nosentinels=True,
        thinFile=False,
        scriptWrite=True,
        toString=True,
        write_strips_blank_lines=False)

    if has_list:
        p.v.t.tnodeList = old_list

    fileName = g.os_path_normpath(g.os_path_join(
        at.default_directory,
        'clean',
        g.os_path_basename(p.anyAtFileNodeName())))

    # g.trace(p.headString(),len(at.stringOutput),fileName)

    # Adapted from at.openFileForWritingHelper
    path = g.os_path_dirname(fileName)
    if not g.os_path_exists(path):
        g.es('clean directory does not exist',path)
        return

    try:
        f = file(fileName,'w')
        f.write(at.stringOutput)
        f.close()
        g.es_print('wrote',fileName)
    except IOError:
        g.es_print('can not write',fileName,color='red')
        g.es_exception()
#@-node:ekr.20080330085343.1:clean_file
#@-node:ekr.20080330085343.3:Save/restore tnodeList in atFile.write
#@+node:ekr.20081003155540.1:Fixed (?) bug in plugins dispatcher
@nocolor-node

callTagHandler now checks c.exists when possible.
#@nonl
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):

    handler = bunch.fn ; moduleName = bunch.moduleName

    # if tag != 'idle': g.pr('callTagHandler',tag,keywords.get('c'))

    # Make sure the new commander exists.
    if True: ### tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    g.pr('skipping tag %s: c does not exists or does not have a frame.' % tag)
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@-node:ekr.20050102094729:callTagHandler
#@-node:ekr.20081003155540.1:Fixed (?) bug in plugins dispatcher
#@-node:ekr.20080917153158.12:Bugs
#@+node:ekr.20080922124033.2:Documentation
#@+node:ekr.20080921154026.9:Added getInput example to Leo's docs
http://webpages.charter.net/edreamleo/scripting.html#getting-interactive-input-from-scripts
#@nonl
#@-node:ekr.20080921154026.9:Added getInput example to Leo's docs
#@+node:ekr.20080924164654.1:Drive Leo's autocompleter from a list
@nocolor

How can I hook my own completer into this?

What I need is that leo will call my own hook function when the user tries to
autocomplete, and my own function will tell leo what completions are suggested
(and thus what leo should show for the user).

@color
#@nonl
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
    g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
    g.es(s,color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace('(autocompleter)',self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion (autocompleter)
def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion (autocompleter)
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.34:finish
def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning (not used)
if 0: # Not used at present.
    @others
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('','.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        for key in sorted(self.watchwords):
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        for key in sorted(self.calltips):
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning (not used)
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) ### Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):

    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@-node:ekr.20080924164654.1:Drive Leo's autocompleter from a list
#@+node:ekr.20080406075855.3:Added warning about running test unitTest.leo when it is opened from another .leo file
@nocolor

I was playing around with this and I discovered that if I open
unitTest.leo from the File->Open menu pick of another leo outline and
then I run a unit test, then all the nodes from unitTest.leo appear in
the original document.  If I execute a save on the original document
(now with the unitTest.leo nodes), then the leo file gets overwritten
with the contents unitTest.leo.

=====

Added a warning in unitTest.leo:

Do not run tests from this file after opening unitTest.leo from another .leo
file. The unit tests in this file open and close many .leo files and many
strange things can happen if you have opened this file from another file.
#@nonl
#@-node:ekr.20080406075855.3:Added warning about running test unitTest.leo when it is opened from another .leo file
#@-node:ekr.20080922124033.2:Documentation
#@+node:ekr.20080918201437.1:Leo3k work
#@+node:ekr.20080918164844.16:use sorted(dict) everywhere
This removed about half of the instances of g.isPython3.
#@nonl
#@-node:ekr.20080918164844.16:use sorted(dict) everywhere
#@+node:ekr.20080918164844.17:Fixed pylint warnings
************* Module leo.core.leoAtFile
#fixed E0602:873:atFile.scanText4: Undefined variable 'message'
#fixed E0602:874:atFile.scanText4: Undefined variable 'message'
# fixed E0602:874:atFile.scanText4: Undefined variable 'sys'

************* Module leo.core.leoCommands
#fixed E0602:3930:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3933:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3935:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3938:baseCommands.tabNannyNode: Undefined variable 'msg'
#fixed E0602:3940:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3942:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3943:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E0602:3944:baseCommands.tabNannyNode: Undefined variable 'nag'
#fixed E1101:5849:baseCommands.scanAtRootDirectives:
    Instance of 'configSettings' has no 'at_root_bodies_start_in_doc_mode' member

************* Module leo.core.leoEditCommands
# fixed E0602:1064:controlCommandsClass.executeSubprocess: Undefined variable 'x'
# fixed E0602:1065:controlCommandsClass.executeSubprocess: Undefined variable 'x'
# fixed E0601:3379:editCommandsClass.linesHelper: Using variable 'x' before assignment
# fixed E0602:8792:AspellClass.updateDictionary: Undefined variable 'err'
# fixed E0602:8793:AspellClass.updateDictionary: Undefined variable 'err'
# fixed E0601:3372:editCommandsClass.linesHelper: Using variable 'x' before assignment

************* Module leo.core.leoFileCommands
# fixed E0602:618:baseFileCommands.checkLeoFile: Undefined variable 'message'
# fixed E0602:620:baseFileCommands.checkLeoFile: Undefined variable 'message'
# fixed E0602:744:baseFileCommands.getLeoFile: Undefined variable 'message'

************* Module leo.core.leoGlobals
# fixed W0311:3086: Bad indentation. Found 9 spaces, expected 8
# fixed W0311:3088: Bad indentation. Found 9 spaces, expected 8
# fixed E0602:1522:print_dict: Undefined variable 'keys'
# fixed E0602:1538:dictToString: Undefined variable 'keys'

************* Module leo.core.leoTangle
# E1101:1992:baseTangleCommands.st_dump: Instance of 'baseTangleCommands' has no 'txt' member
# changed to tst.
#@-node:ekr.20080918164844.17:Fixed pylint warnings
#@+node:ekr.20080919084526.1:Removed many calls to d.keys
Many, but not all, of these calls are unnecessary.
#@nonl
#@-node:ekr.20080919084526.1:Removed many calls to d.keys
#@+node:ekr.20080919085541.4:Fixed hangs in Leo3k
# They were due to __cmp__ not being called.
# Replaced p.__cmp__ with p.__eq__ and p.__ne__.
#@nonl
#@+node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.headString())
            # if p.headString() == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.headString(),color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@-node:ekr.20080919121250.1:leoConfig
#@+node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@-node:ekr.20080919121250.2:leoFileCommands
#@+node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@-node:ekr.20080919121250.3:leoPlugins
#@+node:ekr.20080919121250.4:runLeo
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.4:runLeo
#@+node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@-node:ekr.20080919121250.5:Major short circuits
#@+node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20060919110638.14:parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@-node:ekr.20060919110638.14:parse_leo_file
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@-node:ekr.20080919121250.6:Problems opening .leo files
#@+node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.204:os
def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    at = self

    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except Exception:
            at.exception("exception writing:" + s)
#@-node:ekr.20041005105605.204:os
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
#@+node:ekr.20050404151753: ctor
def __init__(self,encoding='utf-8',fromString=None):

    # g.trace('g.fileLikeObject:__init__','fromString',fromString)

    # New in 4.2.1: allow the file to be inited from string s.

    self.encoding = encoding

    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):

    self.list = []
#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):

    pass

    # The StringIo version free's the memory buffer.
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):

    pass
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue & read
def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
#@-node:ekr.20050404151753.4:get & getvalue & read
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):

    if s:
        if g.isBytes(s):
            s = g.toUnicode(s,self.encoding)

        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20080919153256.1:Problems reading derived files
#@+node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080816125725.2:g.isBytes & g.isString
def isBytes (s):

    '''Return True if s is Python3k bytes type.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: always returns False.'''

    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isString (s):

    '''Return True if s is a string.

    Python 3.x: s must be a unicode string, not bytes.
    Python 2.x: s may be either a unicode string or a regular string.'''

    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes
#@-node:ekr.20080816125725.2:g.isBytes & g.isString
#@+node:ekr.20050208093800:g.toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if isPython3:
        if g.isString(s):
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")

    else:
        if type(s) == types.UnicodeType:
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")
    return s
#@-node:ekr.20050208093800:g.toEncodedString
#@+node:ekr.20050208093800.1:g.toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s
#@nonl
#@-node:ekr.20050208093800.1:g.toUnicode
#@+node:ekr.20031218072017.2317:g.trace
# Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception: name = ''
    if name == "?":
        name = "<unknown>"

    # Pad the caller name.
    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = []
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg,'utf-8')
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)
    try:
        g.pr('%s: %s' % (name,s),newline=newline)
    except Exception:
        s = g.toEncodedString(s,'ascii')
        g.pr('%s: %s' % (name,s),newline=newline)

#@-node:ekr.20031218072017.2317:g.trace
#@+node:ekr.20080710101653.1:g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.

    try: # We can't use any print keyword args in Python 2.x!
        # print(s) # Not quite right.
        if d.get('newline'):
            sys.stdout.write(s+'\n')
        else:
            sys.stdout.write(s)
    except Exception:
        print('unexpected Exception in g.pr')
        g.es_exception()
        g.trace(g.callers())
#@-node:ekr.20080710101653.1:g.pr
#@-node:ekr.20080919153256.2:Unicode problems
#@+node:ekr.20080920052058.1:Unbounded loops
@
The problem was that __cmp__ was not being called.
It has now been replaced by the __eq__ and __ne__ operators.
#@nonl
#@+node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20080416161551.190: p.__init__
def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
#@-node:ekr.20080416161551.190: p.__init__
#@+node:ekr.20080920052058.3:p.__eq__ & __ne__
def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.headString(),p2 and p2.v and p2.headString()))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
#@-node:ekr.20080920052058.3:p.__eq__ & __ne__
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                g.pr("unknown position attribute:",attr)
                import traceback ; traceback.print_stack()
            raise AttributeError(attr)
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040117173448:p.__nonzero__ & __bool__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

if g.isPython3:

    def __bool__ ( self):

        """Return True if a position is valid."""

        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())

        return self.v is not None

else:

    def __nonzero__ ( self):

        """Return True if a position is valid."""

        # if g.app.trace: "__nonzero__",self.v

        # g.trace(repr(self))

        return self.v is not None
#@-node:ekr.20040117173448:p.__nonzero__ & __bool__
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d childIndex: %d lvl: %d [%d] %s>" % (
            id(p),p._childIndex,p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20061006092649:p.archivedPosition
def archivedPosition (self,root_p=None):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self

    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents_iter()]
    else:
        aList = []
        for z in p.self_and_parents_iter():
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
        # g.trace(aList)

    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061006092649:p.archivedPosition
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    g.pr('-'*10,label,p)
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20080416161551.191:p.key
def key (self):

    p = self

    vList = [z[0] for z in p.stack]

    return '%s:%s.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(z)) for z in vList])
    )
#@-node:ekr.20080416161551.191:p.key
#@-node:ekr.20040228094013: p.ctor & other special methods...
#@+node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.headString())
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.headString())
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.headString(),'after',after and after.headString())
    while p and p != after:
        self.debug_count += 1
        h = p.headString()
        # if trace:
            # if p.headString()==after.headString():
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count >= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helpers (ParserBaseClass)
#@-node:ekr.20080920052058.1:Unbounded loops
#@-node:ekr.20080919085541.4:Fixed hangs in Leo3k
#@+node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@-node:ekr.20080918164844.1:Leo now requires Python 2.4 or higher
#@-node:ekr.20080918201437.1:Leo3k work
#@+node:ekr.20080917153158.15:New features
#@+node:ekr.20080124083629.1:Improved @path handling
@nocolor





@color
#@nonl
#@+node:ekr.20080917154206.1:Done
What I did:

- Changed g.scanDirectives(c,p) to c.scanAllDirectives(p) in core.

- A deprecated g.scanDirectives just calls c.scanAllDirectives.
#@nonl
#@+node:ekr.20050121081635:Cumulative @path directives
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2936513
By: ktenney

In the @view plugin is a method, currentPath() which examines the current headline
and body, and the headlines and bodies of it's parents, looking for @path and
@view directives. It builds a path from them and checks for validity.

if a top level node contains;
@path /home/ktenney

and a descendant of that node contains;
@path projects/myproject

Then a node further down the tree which contains;
@view readme.txt

will display /home/ktenney/projects/myproject/readme.txt

I like this principle of cumulative paths, and would like other plugins to work
the same way ... @image, @url etc.

This brings me to my question, would it make sense for Leo to offer a 'Plugin'
class to inherit from? It seems that there are some operations that are being
re-written in many plugins.


============

QQQQQQ
nested @paths don't do what I expected: 

For a leo file in directory foo: 

@path src 
....@path tmpl

should refer to foo/src and foo/src/tmpl

using @path src/tmpl works fine though.
QQQQQQQ
#@nonl
#@-node:ekr.20050121081635:Cumulative @path directives
#@-node:ekr.20080917154206.1:Done
#@+node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
# This is the elegant, clear way to support os.path.expanduser.
#@nonl
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@-node:ekr.20080921060401.15:Replaced g.os_path.abspath with g.os_path_finalize/_join
#@+node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@-node:ekr.20080921091311.5:Make sure '~' is handled properly in all contexts: add unit tests
#@+node:ekr.20080921154026.7:Added support for {{exp}}
#@+node:ekr.20080922170408.1:Made {{exp}} work in @path
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20080922124033.6:os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.currentPosition()
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
#@-node:ekr.20080922124033.6:os_path_expandExpression
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20080729142651.2:os_path_getsize
def os_path_getsize (path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getsize(path)
#@-node:ekr.20080729142651.2:os_path_getsize
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20080605064555.2:os_path_realpath
def os_path_realpath(path,encoding=None):


    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@-node:ekr.20080605064555.2:os_path_realpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory,error = g.setDefaultDirectory(c,p,importing)

    if error: at.error(error)
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
#@-node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20071109165315:g.computeRelativePath
def computeRelativePath (path):

    if len(path) > 2 and (
        (path[0]=='<' and path[-1] == '>') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
#@-node:ekr.20071109165315:g.computeRelativePath
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
#@-node:ekr.20080921060401.14:os_path_finalize & os_path_finalize_join
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@-node:ekr.20080922170408.1:Made {{exp}} work in @path
#@-node:ekr.20080921154026.7:Added support for {{exp}}
#@+node:ekr.20080917154206.3:Finished at-path branch items
@nocolor

- Replaced g.scanDirectives with c.scanAllDirectives in scripts.leo, unitTest.leo and plugins.
- Removed obsolete helper methods.
- Rewrote tangle.scanAllDirectives.
- Rewrote scanForTabWidth.
- Replaced scanColorDirectives with new version.
- Replaced at.scanAllDirectives with new version.

@color
#@nonl
#@+node:ekr.20080901124540.1:c.Directive scanning
# These are all new in Leo 4.5.1.
#@nonl
#@+node:ekr.20080827175609.39:c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.currentPosition()

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }
#@nonl
#@-node:ekr.20080827175609.39:c.scanAllDirectives
#@+node:ekr.20080828103146.15:c.scanAtPathDirectives

def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = False

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or <path> to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
#@-node:ekr.20080828103146.15:c.scanAtPathDirectives
#@+node:ekr.20080828103146.12:c.scanAtRootDirectives
# Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
#@-node:ekr.20080828103146.12:c.scanAtRootDirectives
#@+node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
#@-node:ekr.20080922124033.5:c.os_path_finalize and c.os_path_finalize_join
#@+node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    filename = p.isAnyAtFileNode()
    return filename and g.os_path_finalize_join(path,filename) or None
#@-node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
#@-node:ekr.20080901124540.1:c.Directive scanning
#@+node:ekr.20031218072017.1380:g.Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20071109165315:g.computeRelativePath
def computeRelativePath (path):

    if len(path) > 2 and (
        (path[0]=='<' and path[-1] == '>') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
#@-node:ekr.20071109165315:g.computeRelativePath
#@+node:ekr.20031218072017.1385:g.findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@+node:ekr.20031218072017.1260:g.get_directives_dict
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(p,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    global globalDirectiveList

    if root: root_node = root[0]
    d = {'_p':p.copy()}

    # The headline has higher precedence because it is more visible.
    for kind,s in (
        ('body',p.v.t._headString),
        ('head',p.v.t._bodyString),
    ):
        i = 0 ; n = len(s)
        while i < n:
            if s[i] == '@' and i+1 < n:
                << set d for @ directives >>
            elif kind == 'body' and root and g.match(s,i,"<<"):
                << set d["root"] for noweb * chunks >>
            i = g.skip_line(s,i)
    return d
#@+node:ekr.20031218072017.1261:<< set d for @ directives >>
j = g.skip_id(s,i+1,chars='-')
word = s[i+1:j]

if word in globalDirectiveList:
    if d.get(word):
        # Ignore second value.
        pass
        # g.es("warning: conflicting values for",word,color="blue")
    else:
        k = g.skip_line(s,j)
        d[word] = s[j:k].strip()
#@nonl
#@-node:ekr.20031218072017.1261:<< set d for @ directives >>
#@+node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)

if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            d["root"]=0 # value not immportant
        else:
            g.es('',g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:g.get_directives_dict
#@+node:ekr.20080827175609.1:g.get_directives_dict_list
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to the start of each directive"""

    result = [] ; p1 = p1.copy()

    for p in p1.self_and_parents_iter():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    return result
#@-node:ekr.20080827175609.1:g.get_directives_dict_list
#@+node:ekr.20031218072017.1386:g.getOutputNewline
def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))
    return s
#@-node:ekr.20031218072017.1386:g.getOutputNewline
#@+node:ekr.20080827175609.52:g.scanAtCommentAndLanguageDirectives
def scanAtCommentAndAtLanguageDirectives(aList):

    '''Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.'''

    lang = None

    for d in aList:

        comment = d.get('comment')
        language = d.get('language')

        # Important: assume @comment follows @language.
        if language:
            # if g.unitTesting: g.trace('language',language)
            lang,delim1,delim2,delim3 = g.set_language(language,0)

        if comment:
            # if g.unitTesting: g.trace('comment',comment)
            delim1,delim2,delim3 = g.set_delims_from_string(comment)

        if comment or language:
            delims = delim1,delim2,delim3
            return {'language':lang,'comment':comment,'delims':delims}

    return None
#@-node:ekr.20080827175609.52:g.scanAtCommentAndLanguageDirectives
#@+node:ekr.20080827175609.32:g.scanAtEncodingDirectives
def scanAtEncodingDirectives(aList):

    '''Scan aList for @encoding directives.'''

    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            # g.trace(encoding)
            return encoding
        elif encoding and not g.app.unitTesting:
            g.es("invalid @encoding:",encoding,color="red")

    return None
#@-node:ekr.20080827175609.32:g.scanAtEncodingDirectives
#@+node:ekr.20080827175609.53:g.scanAtHeaderDirectives
def scanAtHeaderDirectives(aList):

    '''scan aList for @header and @noheader directives.'''

    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.es_print("conflicting @header and @noheader directives",color='red')
#@nonl
#@-node:ekr.20080827175609.53:g.scanAtHeaderDirectives
#@+node:ekr.20080827175609.33:g.scanAtLineendingDirectives
def scanAtLineendingDirectives(aList):

    '''Scan aList for @lineending directives.'''

    for d in aList:

        e = d.get('lineending')
        if e in ("cr","crlf","lf","nl","platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.es("invalid @lineending directive:",e,color="red")

    return None
#@-node:ekr.20080827175609.33:g.scanAtLineendingDirectives
#@+node:ekr.20080827175609.34:g.scanAtPagewidthDirectives
def scanAtPagewidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @pagewidth directives.'''

    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s,0)
            if val != None and val > 0:
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @pagewidth",s,color="red")

    return None
#@-node:ekr.20080827175609.34:g.scanAtPagewidthDirectives
#@+node:ekr.20031218072017.3154:g.scanAtRootOptions
def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        << scan another @root option >>

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    return i,mode
#@+node:ekr.20031218072017.3155:<< scan another @root option >>
i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i < len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err > -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s,i)
    g.es("unknown option:",z_opt,"in",z_line)
#@-node:ekr.20031218072017.3155:<< scan another @root option >>
#@-node:ekr.20031218072017.3154:g.scanAtRootOptions
#@+node:ekr.20080827175609.37:g.scanAtTabwidthDirectives
def scanAtTabwidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @tabwidth directives.'''

    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk,val = g.skip_long(s,0)

            if val not in (None,0):
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @tabwidth",s,color="red")

    return None
#@-node:ekr.20080827175609.37:g.scanAtTabwidthDirectives
#@+node:ekr.20080831084419.4:g.scanAtWrapDirectives
def scanAtWrapDirectives(aList,issue_error_flag=False):

    '''Scan aList for @wrap and @nowrap directives.'''

    for d in aList:
        if d.get('wrap') is not None:
            return True
        elif d.get('nowrap') is not None:
            return False

    return None
#@nonl
#@-node:ekr.20080831084419.4:g.scanAtWrapDirectives
#@+node:ekr.20070302160802:g.scanColorDirectives
def scanColorDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None: return # c may be None for testing.

    language = c.target_language and c.target_language.lower() or 'python'

    p = p.copy()
    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        z = d.get('language')
        if z is not None:
            language,junk,junk,junk = g.set_language(z,0)
            return language

    return language
#@-node:ekr.20070302160802:g.scanColorDirectives
#@+node:ekr.20080901195858.4:g.scanDirectives  (for compatibility only)
def scanDirectives(c,p=None):

    return c.scanAllDirectives(p)
#@nonl
#@-node:ekr.20080901195858.4:g.scanDirectives  (for compatibility only)
#@+node:ekr.20040715155607:g.scanForAtIgnore
def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True

    return False
#@-node:ekr.20040715155607:g.scanForAtIgnore
#@+node:ekr.20040712084911.1:g.scanForAtLanguage
def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
#@-node:ekr.20040712084911.1:g.scanForAtLanguage
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20081001062423.9:g.setDefaultDirectory
# This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefault directory

def setDefaultDirectory(c,p,importing=False):

    '''Set default_directory by scanning @path directives.
    Return (default_directory,error_message).'''

    default_directory = '' ; error = ''
    if not p: return default_directory,error

    << Set path from @file node >>

    if not default_directory:
        # Scan for @path directives.
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        if path:
            << handle @path >>

    if not default_directory:
        << Set current directory >>

    if not default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    # g.trace('returns',default_directory)
    return default_directory, error
#@+node:ekr.20081001062423.10:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        default_directory = theDir
    else:
        default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not default_directory:
            error = "Directory \"%s\" does not exist" % theDir
#@-node:ekr.20081001062423.10:<< Set path from @file node >>
#@+node:ekr.20081001062423.11:<< handle @path >>
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        if g.os_path_exists(path):
            default_directory = path
        else:
            default_directory = g.makeAllNonExistentDirectories(path,c=c)
            if not default_directory:
                error = "invalid @path: %s" % path
            else:
                error = "ignoring bad @path: %s" % path
else:
    error = "ignoring empty @path"
#@-node:ekr.20081001062423.11:<< handle @path >>
#@+node:ekr.20081001062423.12:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not default_directory)

if c.frame:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    default_directory = theDir ; break
                else:
                    default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20081001062423.12:<< Set current directory >>
#@-node:ekr.20081001062423.9:g.setDefaultDirectory
#@+node:ekr.20031218072017.1382:g.set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    # g.trace(g.callers())

    val = g.app.language_delims_dict.get(language)
    # if language.startswith('huh'): g.pdb()

    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:g.set_delims_from_language
#@+node:ekr.20031218072017.1383:g.set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in range(0,3):
        if delims[i]:
            delims[i] = delims[i].replace("__",'\n').replace('_',' ')

    return delims[0], delims[1], delims[2]
#@-node:ekr.20031218072017.1383:g.set_delims_from_string
#@+node:ekr.20031218072017.1384:g.set_language
def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring:",g.get_line(s,i))

    return None, None, None, None,
#@-node:ekr.20031218072017.1384:g.set_language
#@-node:ekr.20031218072017.1380:g.Directive utils...
#@+node:ekr.20080923070954.12:Rewrote
#@+node:ekr.20080828103146.8:scanColorDirectives
def scanColorDirectives(self,p):

    '''Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.'''

    c = self.c
    if not c: return # May be None for testing.

    table = (
        ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
        ('root',        c.scanAtRootDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,func in table:
        val = func(aList)
        if val: d[key]=val

    # Post process.
    lang_dict       = d.get('lang-dict')
    self.rootMode   = d.get('root') or None

    if lang_dict:
        self.language       = lang_dict.get('language')
        self.comment_string = lang_dict.get('comment')
    else:
        self.language       = c.target_language and c.target_language.lower()
        self.comment_string = None

    # g.trace('self.language',self.language)
    return self.language # For use by external routines.
#@-node:ekr.20080828103146.8:scanColorDirectives
#@+node:ekr.20080923070954.4:atFile.scanAllDirectives
def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    at = self ; c = self.c

    << set ivars >>

    lang_dict = {'language':at.language,'delims':delims,}

    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    delims          = lang_dict.get('delims')
    lineending      = d.get('lineending')
    if lineending:
        at.explicitLineEnding = True
        at.output_newline = lineending
    else:
        at.output_newline = g.getOutputNewline(c=c) # Init from config settings.

    at.encoding             = d.get('encoding')
    at.language             = lang_dict.get('language')
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>

    # For unit testing.
    return {
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
#@+node:ekr.20080923070954.14:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@-node:ekr.20080923070954.14:<< Set ivars >>
#@+node:ekr.20080923070954.13:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims ### g.set_delims_from_language(at.language)

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@-node:ekr.20080923070954.13:<< Set comment strings from delims >>
#@-node:ekr.20080923070954.4:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1375:frame.scanForTabWidth
def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    aList = g.get_directives_dict_list(p)
    w = g.scanAtTabwidthDirectives(aList)
    c.frame.setTabWidth(w or c.tab_width)
#@-node:ekr.20031218072017.1375:frame.scanForTabWidth
#@+node:ekr.20080923124254.16:tangle.scanAllDirectives
def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>

    # delims = (self.single_comment_string,self.start_comment_string,self.end_comment_string)
    lang_dict = {'language':self.language,'delims':None,} # Delims not used

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.page_width           = d.get('pagewidth')
    self.default_directory    = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.default_directory,
        "tabwidth"  : self.tab_width,
    }

#@+node:ekr.20080923124254.17:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
#@-node:ekr.20080923124254.17:<< Collect @first attributes >>
#@-node:ekr.20080923124254.16:tangle.scanAllDirectives
#@-node:ekr.20080923070954.12:Rewrote
#@-node:ekr.20080917154206.3:Finished at-path branch items
#@-node:ekr.20080124083629.1:Improved @path handling
#@+node:ekr.20080917154206.4:Merge leo-30 branch
@nocolor 

This make's Leo's syntax compatible with Python 3.0.
#@nonl
#@-node:ekr.20080917154206.4:Merge leo-30 branch
#@+node:ekr.20080919085541.2:Open a default .leo file if no other is specified
# Added support for @string default_leo_file = ~/.leo/workbook.leo
#@nonl
#@+node:ekr.20080921060401.7: Request
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Now it's easier than ever to add *quick* notes with leo. ILeo knows of
"special" leo file ~/.ipython/ipython_notebook.leo, which is opened
automatically when you do:

lleo

("launch leo" without specifying a .leo file to open. The old
behaviour was to open untitled file, saving of which iIs pain).

lno This is my note

("leo note")

This opens ipython_notebook.leo if leo is not running already, and
adds a headline with "This is my note" under headline "Scratch". Of
course the focus still remains in the ipython window, so you can
proceed adding more notes with %lno without losing your concentration
or touching your mouse. If you run  %lno with a note string that
already exists, the existing note is focused instead.

To enable all this goodness, you just need to add

_ip.load('ipy_leo')

to your ipy_user_conf.py.

You also need to install leo with "setup.py develop".

I guess this is leo's equivalent of Chandler's "Quick entry bar",
described here:

http://www.youtube.com/watch?v=JJBxajDwmLI 

@color
#@nonl
#@-node:ekr.20080921060401.7: Request
#@+node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.9:doEarlyInits
def doEarlyInits(verbose):

    import leo.core.leoGlobals as g
    import leo.core.leoNodes as leoNodes
    import leo.core.leoConfig as leoConfig

    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.

    # There is a circular dependency between leoCommands and leoEditCommands.
    import leo.core.leoCommands as leoCommands

    # New in Leo 4.5 b3: make sure we call the new leoPlugins.init top-level function.
    # This prevents a crash when run is called repeatedly from IPython's lleo extension.
    import leo.core.leoPlugins as leoPlugins
    leoPlugins.init()

    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921060401.9:doEarlyInits
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1934:run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    gui,script,windowFlag = scanOptions()
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.currentPosition()
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
#@+node:ekr.20070306085724:adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
#@-node:ekr.20070306085724:adjustSysPath
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@+node:ekr.20080921060401.5:finishInitApp
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@-node:ekr.20080921060401.5:finishInitApp
#@+node:ekr.20071117060958:getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125:completeFileName
def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    ### fileName = g.os_path_finalize_join(os.getcwd(),fileName)
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
#@-node:ekr.20041124083125:completeFileName
#@-node:ekr.20071117060958:getFileName & helper
#@+node:ekr.20080921091311.2:initApp
def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
#@-node:ekr.20080921091311.2:initApp
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8:<< define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9:__init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@-node:ekr.20080822065427.9:__init__ (emergencyDialog)
#@+node:ekr.20080822065427.12:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20080822065427.12:createButtons
#@+node:ekr.20080822065427.14:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@-node:ekr.20080822065427.14:createTopFrame
#@+node:ekr.20080822065427.10:okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@-node:ekr.20080822065427.10:okButton
#@+node:ekr.20080822065427.21:onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@-node:ekr.20080822065427.21:onKey
#@+node:ekr.20080822065427.16:run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@-node:ekr.20080822065427.16:run
#@-node:ekr.20080822065427.8:<< define emergency dialog class >>
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20040411081633:startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:startPsyco
#@-node:ekr.20031218072017.1934:run & helpers
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@-node:ekr.20080921060401.11:Refactoring runLeo.run
#@+node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@+node:ekr.20080921060401.13:os_path_expanduser
def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
#@-node:ekr.20080921060401.13:os_path_expanduser
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@-node:ekr.20080921060401.12:Support for @string default_leo_file = ~/.leo/workbook.leo
#@-node:ekr.20080919085541.2:Open a default .leo file if no other is specified
#@+node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

I'm wondering, would it make sense for leo to do "something" when launched
directly against a .py file, i.e.

"leo test.py".

Of course that's a perfectly sensible thing to do, considering that leo is,
among other things, a python editor ;-)

Perhaps it might create create a (unsaved) leo document  where the .py file
is present as @shadow node, or something.

@color
#@nonl
#@+node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@-node:ekr.20080919085541.1:@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626
#@+node:ekr.20080921154026.4:Not changed
#@+node:ekr.20070412082527:g.openLeoOrZipFile
def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    # if not g.app.initing:
        # g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame

    # Set c.openDirectory
    theDir = g.os_path_dirname(fileName)
    if theDir: c.openDirectory = theDir

    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)

    if ok:
        frame.resizePanesToRatio(ratio,frame.secondary_ratio)

    return ok
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20080921154026.4:Not changed
#@+node:ekr.20080921154026.5:Changed
#@+node:ekr.20080211085914:scanDefaultDirectory (leoImport)
def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory, error = g.setDefaultDirectory(c,p,importing=False)

    if error: self.error(error)
#@-node:ekr.20080211085914:scanDefaultDirectory (leoImport)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20031218072017.1624:createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (runLeo.py)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if 1: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None,None
        p = c.currentPosition()
        if p:
            p.setHeadString(fileName)
            p.setBodyString(s)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.currentPosition()
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.currentPosition()
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.currentPosition()
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw_now() # Only needed by menu commands.
    return c,frame
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@-node:ekr.20080921154026.5:Changed
#@+node:ekr.20080921154026.6:tests
leo c:\leo.repo\trunk\leo\modes\python.py

# --silent optional below
leo --script c:\leo.repo\trunk\leo\test\unittest\batchTest.py
#@nonl
#@-node:ekr.20080921154026.6:tests
#@-node:ekr.20080918164844.15:Allow Leo to open .py files directly (or any other kind of file)
#@+node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e

The suggestion: paste fonts into myLeoSettings.leo.

Can they be a better default?
#@nonl
#@+node:ekr.20080921154026.11:Fonts
@nocolor
@

Valid values:

weight: bold, normal, None
slant: roman, italic, None

Use the show-fonts command to pick fonts, then copy the values shown
by the show-fonts command to the values here.

@c

import sys ; print sys.platform
#@+node:ekr.20080921154026.12:@font body text font
body_text_font_family = fixed
body_text_font_size = 11
body_text_font_slant = None
body_text_font_weight = None
#@-node:ekr.20080921154026.12:@font body text font
#@+node:ekr.20080921154026.13:@font button font
button_text_font_family = fixed
button_text_font_size = 8
button_text_font_slant = roman
button_text_font_weight = normal
#@-node:ekr.20080921154026.13:@font button font
#@+node:ekr.20080921154026.14:@font log font
# The font for the log pane. Default is
default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
#
# Default size is 12 for Linux, 9 otherwise.

log_text_font_family = Courier
log_text_font_size = 9
log_text_font_slant = roman
log_text_font_weight = normal
#@-node:ekr.20080921154026.14:@font log font
#@+node:ekr.20080921154026.15:@font menu text font
menu_text_font_family = None
menu_text_font_size = None
menu_text_font_slant = None
menu_text_font_weight = None
#@nonl
#@-node:ekr.20080921154026.15:@font menu text font
#@+node:ekr.20080921154026.16:@font outline font
headline_text_font_family = fixed
headline_text_font_size = 11
headline_text_font_slant = roman
headline_text_font_weight = normal
#@-node:ekr.20080921154026.16:@font outline font
#@-node:ekr.20080921154026.11:Fonts
#@-node:ekr.20080921154026.10:Added better default fonts for Leo on Linux
#@+node:ekr.20080922124033.3:Enter tree pane after clone-find-all
# It's surprisingly annoying not to be able to move the tree just created.
#@nonl
#@-node:ekr.20080922124033.3:Enter tree pane after clone-find-all
#@+node:ekr.20080918164844.10:Added autoCompleter.getExternalCompletions
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

> As I said, all I need would be is for leo to call callback/hook with
> signature like
> def complete(line-up-to-cursor, current_node) => list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color
#@nonl
#@+node:ekr.20061031131434.4:class autoCompleterClass
class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.9:autoComplete
def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20061031131434.9:autoComplete
#@+node:ekr.20061031131434.10:autoCompleteForce
def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
#@-node:ekr.20061031131434.10:autoCompleteForce
#@+node:ekr.20061031131434.11:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20061031131434.11:autoCompleterStateHandler
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@+node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20061031131434.12:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20061031131434.13:showCalltips
def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
#@-node:ekr.20061031131434.13:showCalltips
#@+node:ekr.20061031131434.14:showCalltipsForce
def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
#@-node:ekr.20061031131434.14:showCalltipsForce
#@+node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
    g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
    g.es(s,color='red')
#@nonl
#@-node:ekr.20061031131434.15:showAutocompleter/CalltipsStatus
#@-node:ekr.20061031131434.8:Top level
#@+node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.17:.abort & exit (autocompleter) (test)
#@+node:ekr.20061031131434.18:append/begin/popTabName
def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
#@-node:ekr.20061031131434.18:append/begin/popTabName
#@+node:ekr.20061031131434.19:appendToKnownObjects
def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20061031131434.19:appendToKnownObjects
#@+node:ekr.20061031131434.20:calltip
def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>

    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    # s = s.rstrip(')') # Not so convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    << put the status line >>
#@+node:ekr.20061031131434.21:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20061031131434.21:<< try to set s from a Python global function >>
#@+node:ekr.20061031131434.22:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20061031131434.22:<< get s using inspect >>
#@+node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20061031131434.23:<< remove 'self' from s, but not from args >>
#@+node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20061031131434.24:<< remove 's' from s *and* args >>
#@+node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
#@-node:ekr.20061031131434.25:<< insert the text and set j1 and j2 >>
#@+node:ekr.20061031131434.26:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20061031131434.26:<< put the status line >>
#@-node:ekr.20061031131434.20:calltip
#@+node:ekr.20061031131434.27:chain
def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20061031131434.27:chain
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20061031131434.29:doBackSpace (autocompleter)
def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace('(autocompleter)',self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 <= i-1 < len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
#@nonl
#@-node:ekr.20061031131434.29:doBackSpace (autocompleter)
#@+node:ekr.20061031131434.30:doTabCompletion (autocompleter)
def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.30:doTabCompletion (autocompleter)
#@+node:ekr.20061031131434.31:extendSelection
def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@nonl
#@-node:ekr.20061031131434.31:extendSelection
#@+node:ekr.20061031131434.33:findCalltipWord
def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i > 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''
#@nonl
#@-node:ekr.20061031131434.33:findCalltipWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.34:finish
def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
#@-node:ekr.20061031131434.34:finish
#@+node:ekr.20061031131434.35:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20061031131434.35:getAttr and hasAttr
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20061031131434.37:getMembersList
def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20061031131434.37:getMembersList
#@+node:ekr.20061031131434.38:info
def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
#@-node:ekr.20061031131434.38:info
#@+node:ekr.20061031131434.39:insertNormalChar
def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20061031131434.39:insertNormalChar
#@+node:ekr.20061031131434.40:push, pop, clear, stackNames
def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20061031131434.40:push, pop, clear, stackNames
#@+node:ekr.20061031131434.41:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
#@+node:ekr.20061031131434.42:getObjectFromAttribute
def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
#@-node:ekr.20061031131434.42:getObjectFromAttribute
#@+node:ekr.20061031131434.43:completeSelf
def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.43:completeSelf
#@+node:ekr.20061031131434.44:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
#@-node:ekr.20061031131434.44:completeFromObject
#@-node:ekr.20061031131434.41:setObjectAndMembersList & helpers
#@+node:ekr.20061031131434.45:setSelection
def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20061031131434.45:setSelection
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@-node:ekr.20061031131434.16:Helpers
#@+node:ekr.20061031131434.47:Scanning (not used)
if 0: # Not used at present.
    @others
#@+node:ekr.20061031131434.48:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
#@-node:ekr.20061031131434.48:initialScan
#@+node:ekr.20061031131434.49:scan
def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20061031131434.49:scan
#@+node:ekr.20061031131434.50:definePatterns
def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20061031131434.50:definePatterns
#@+node:ekr.20061031131434.51:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('','.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        for key in sorted(self.watchwords):
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        for key in sorted(self.calltips):
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20061031131434.51:scanOutline
#@+node:ekr.20061031131434.52:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
#@-node:ekr.20061031131434.52:scanForCallTip
#@+node:ekr.20061031131434.53:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20061031131434.54:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20061031131434.55:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20061031131434.55:reverseFindWhitespace
#@+node:ekr.20061031131434.56:getCleanString
def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20061031131434.56:getCleanString
#@-node:ekr.20061031131434.54:makeAutocompletionList
#@-node:ekr.20061031131434.53:scanForAutoCompleter
#@-node:ekr.20061031131434.47:Scanning (not used)
#@+node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.58:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20061031131434.58:createProxyObjectFromClass
#@+node:ekr.20061031131434.59:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) ### Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
#@-node:ekr.20061031131434.59:createClassObjectFromString
#@-node:ekr.20061031131434.57:Proxy classes and objects
#@+node:ekr.20061031131434.60:class forgivingParserClass
class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
#@+node:ekr.20061031131434.61:ctor (forgivingParserClass)
def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20061031131434.61:ctor (forgivingParserClass)
#@+node:ekr.20061031131434.62:parse
def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


#@-node:ekr.20061031131434.62:parse
#@+node:ekr.20061031131434.63:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20061031131434.63:forgivingParser
#@+node:ekr.20061031131434.64:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20061031131434.64:computeErrorNode
#@+node:ekr.20061031131434.65:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20061031131434.65:newPutBody
#@-node:ekr.20061031131434.60:class forgivingParserClass
#@+node:ekr.20061031131434.66:class classScannerClass
class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
#@+node:ekr.20061031131434.67:ctor
def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20061031131434.67:ctor
#@+node:ekr.20061031131434.68:scan
def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
#@-node:ekr.20061031131434.68:scan
#@+node:ekr.20061031131434.69:findParentClass
def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
#@-node:ekr.20061031131434.69:findParentClass
#@+node:ekr.20061031131434.70:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20061031131434.71:endsDoc
def endsDoc (self,s):

    return s.startswith('@c')
#@-node:ekr.20061031131434.71:endsDoc
#@+node:ekr.20061031131434.72:startsClass
def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20061031131434.72:startsClass
#@+node:ekr.20061031131434.73:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20061031131434.73:startsDoc
#@-node:ekr.20061031131434.70:findClass & helpers
#@-node:ekr.20061031131434.66:class classScannerClass
#@-node:ekr.20061031131434.4:class autoCompleterClass
#@+node:ekr.20061031131434.5: ctor (autocompleter)
def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20061031131434.6:defineClassesDict
def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20061031131434.6:defineClassesDict
#@+node:ekr.20061031131434.7:defineObjectDict
def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
#@-node:ekr.20061031131434.7:defineObjectDict
#@-node:ekr.20061031131434.5: ctor (autocompleter)
#@+node:ekr.20061031131434.46:start
def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i > 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
#@-node:ekr.20061031131434.46:start
#@+node:ekr.20061031131434.36:getLeadinWord
def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 <= i < start and i <len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20061031131434.36:getLeadinWord
#@+node:ekr.20080924032842.5:findAnchor
def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i <= 1.
    while i > 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word
#@nonl
#@-node:ekr.20080924032842.5:findAnchor
#@+node:ekr.20061031131434.28:computeCompletionList
def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            z = '%s' % (name)
            g.es('',z,tabName=self.tabName)
#@-node:ekr.20061031131434.28:computeCompletionList
#@+node:ekr.20080924032842.3:getExternalCompletions
def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.currentPosition()

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i > 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
#@-node:ekr.20080924032842.3:getExternalCompletions
#@-node:ekr.20080918164844.10:Added autoCompleter.getExternalCompletions
#@+node:ekr.20081003123804.1:Added @nocolor-node directive
# Useful: we don't need a closing @color to enable coloring in descendants.
#@nonl
#@+node:ekr.20031218072017.2805:useSyntaxColoring
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    self.killFlag = False

    # New in Leo 4.6: @nocolor-node disables one node only.
    theDict = g.get_directives_dict(p)
    if 'nocolor-node' in theDict:
        return False

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        no_color = 'nocolor' in theDict
        color = 'color' in theDict
        kill_color = 'killcolor' in theDict
        # A killcolor anywhere disables coloring.
        if kill_color:
            self.killFlag = True
            return False
        # A color anywhere in the target enables coloring.
        elif color and p == first:
            return True
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            return False
        elif color and not no_color:
            return True

    return True
#@-node:ekr.20031218072017.2805:useSyntaxColoring
#@+node:EKR.20040610094819:<< define global data structures >>
# Visible externally so plugins may add to the list of directives.

globalDirectiveList = [
    # New in Leo 4.6:
    'markup', # Make this an official directive,
              # even if the color_markup directive is not enabled.
    'nocolor-node',
    # New in Leo 4.4.4: these used to be in leoKeywords.
    'all','c','code','delims','doc','end_raw',
    'first','last','others','raw','root-code','root-doc',
    # Old.
    "color", "comment", "encoding", "header", "ignore", "killcolor",
    "language", "lineending", "nocolor", "noheader", "nowrap",
    "pagewidth", "path", "quiet", "root", "silent",
    "tabwidth", "terse", "unit", "verbose", "wrap",
]
#@-node:EKR.20040610094819:<< define global data structures >>
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@nonl
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.1260:g.get_directives_dict
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(p,root=None):

    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    global globalDirectiveList

    if root: root_node = root[0]
    d = {'_p':p.copy()}

    # The headline has higher precedence because it is more visible.
    for kind,s in (
        ('body',p.v.t._headString),
        ('head',p.v.t._bodyString),
    ):
        i = 0 ; n = len(s)
        while i < n:
            if s[i] == '@' and i+1 < n:
                << set d for @ directives >>
            elif kind == 'body' and root and g.match(s,i,"<<"):
                << set d["root"] for noweb * chunks >>
            i = g.skip_line(s,i)
    return d
#@+node:ekr.20031218072017.1261:<< set d for @ directives >>
j = g.skip_id(s,i+1,chars='-')
word = s[i+1:j]

if word in globalDirectiveList:
    if d.get(word):
        # Ignore second value.
        pass
        # g.es("warning: conflicting values for",word,color="blue")
    else:
        k = g.skip_line(s,j)
        d[word] = s[j:k].strip()
#@nonl
#@-node:ekr.20031218072017.1261:<< set d for @ directives >>
#@+node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)

if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            d["root"]=0 # value not immportant
        else:
            g.es('',g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set d["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:g.get_directives_dict
#@+node:ekr.20080827175609.1:g.get_directives_dict_list
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to the start of each directive"""

    result = [] ; p1 = p1.copy()

    for p in p1.self_and_parents_iter():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    return result
#@-node:ekr.20080827175609.1:g.get_directives_dict_list
#@+node:ekr.20081003155540.2:Failed unit test
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20080828103146.12:c.scanAtRootDirectives
# Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
#@-node:ekr.20080828103146.12:c.scanAtRootDirectives
#@-node:ekr.20081003155540.2:Failed unit test
#@-node:ekr.20081003123804.1:Added @nocolor-node directive
#@+node:ekr.20081006100835.2:Added c.getNodePath and c.getNodeFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7
#@nonl
#@+node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    filename = p.isAnyAtFileNode()
    return filename and g.os_path_finalize_join(path,filename) or None
#@-node:ekr.20081006100835.1:c.getNodePath & c.getNodeFileName
#@-node:ekr.20081006100835.2:Added c.getNodePath and c.getNodeFileName
#@+node:ekr.20081022080424.1:Added support for meta keys
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1

Patches made to leoKeys.py
#@nonl
#@-node:ekr.20081022080424.1:Added support for meta keys
#@-node:ekr.20080917153158.15:New features
#@+node:ekr.20080930072519.8:New options
#@+node:ekr.20080910054558.2:Added -c option to specify config files
@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color
#@nonl
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    << define s, a minimalMyLeoSettings.leo string >>

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
#@+node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
s = '''<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="26" left="122" height="781" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070411164127" str_leo_pos="0"><vh>@chapters</vh>
<v t="ekr.20070411164127.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070411164127.2"><vh>@settings</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20070411164127"></t>
<t tx="ekr.20070411164127.1">trash</t>
<t tx="ekr.20070411164127.2"></t>
</tnodes>
</leo_file>
'''
#@-node:ekr.20080811174246.6:<< define s, a minimalMyLeoSettings.leo string >>
#@-node:ekr.20080811174246.5:g.app.config.createMyLeoSettingsFile (not used)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080910054558.2:Added -c option to specify config files
#@+node:ekr.20080917153158.16:Added c.config.getSettingSource
@nocolor

c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo

theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

@color
#@nonl
#@-node:ekr.20080917153158.16:Added c.config.getSettingSource
#@+node:ekr.20080930072519.1:Added support for @int icon_bar_widgets_per_row setting
#@+node:ekr.20061119120006:Icon area convenience methods
def addIconButton (self,*args,**keys):
    if self.iconBar: return self.iconBar.add(*args,**keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self,w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar (self):
    if self.iconBar: self.iconBar.clear()

def createIconBar (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar (self):
    if self.iconBar: self.iconBar.hide()

def showIconBar (self):
    if self.iconBar: self.iconBar.show()
#@-node:ekr.20061119120006:Icon area convenience methods
#@+node:ekr.20041223102225:class tkIconBarClass
class tkIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20041223102225.1: ctor
def __init__ (self,c,parentFrame):

    self.c = c

    self.buttons = {}

    # Create a parent frame that will never be unpacked.
    # This allows us to pack and unpack the container frame without it moving.
    self.iconFrameParentFrame = Tk.Frame(parentFrame)
    self.iconFrameParentFrame.pack(fill="x",pady=0)

    # Create a container frame to hold individual row frames.
    # We hide all icons by doing pack_forget on this one frame.
    self.iconFrameContainerFrame = Tk.Frame(self.iconFrameParentFrame)
        # Packed in self.show()

    self.addRow()
    self.font = None
    self.parentFrame = parentFrame
    self.visible = False
    self.widgets_per_row = c.config.getInt('icon_bar_widgets_per_row') or 10
    self.show() # pack the container frame.
#@-node:ekr.20041223102225.1: ctor
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080930072519.2:addRow
def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
#@-node:ekr.20080930072519.2:addRow
#@+node:ekr.20080930072519.5:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n >= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
#@-node:ekr.20080930072519.5:addRowIfNeeded
#@+node:ekr.20080930072519.6:addWidget
def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


#@-node:ekr.20080930072519.6:addWidget
#@+node:ekr.20031218072017.3956:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    f = self.iconFrameContainerFrame

    for slave in f.pack_slaves():
        slave.pack_forget()
    f.pack_forget()

    self.addRow(height='0m')

    self.visible = False

    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clear
#@+node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
def deleteButton (self,w):

    w.pack_forget()
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
#@+node:ekr.20041223114821:getFrame & getNewFrame
def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

#@-node:ekr.20041223114821:getFrame & getNewFrame
#@+node:ekr.20041223102225.2:pack (show)
def pack (self):

    """Show the icon bar by repacking it"""

    if not self.visible:
        self.visible = True
        self.iconFrameContainerFrame.pack(fill='x',pady=2)

show = pack
#@-node:ekr.20041223102225.2:pack (show)
#@+node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
def setCommandForButton(self,b,command):

    b.configure(command=command)
#@-node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
#@+node:ekr.20031218072017.3955:unpack (hide)
def unpack (self):

    """Hide the icon bar by unpacking it."""

    if self.visible:
        self.visible = False
        w = self.iconFrameContainerFrame
        w.pack_forget()

hide = unpack
#@-node:ekr.20031218072017.3955:unpack (hide)
#@-node:ekr.20041223102225:class tkIconBarClass
#@+node:ekr.20080930072519.7:New/changed code
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080930072519.6:addWidget
def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


#@-node:ekr.20080930072519.6:addWidget
#@+node:ekr.20080930072519.5:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n >= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
#@-node:ekr.20080930072519.5:addRowIfNeeded
#@+node:ekr.20080930072519.2:addRow
def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
#@-node:ekr.20080930072519.2:addRow
#@+node:ekr.20041223114821:getFrame & getNewFrame
def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

#@-node:ekr.20041223114821:getFrame & getNewFrame
#@+node:ekr.20070317073819.2:tt.createControl
def createControl (self):

    tt = self ; c = tt.c

    # Create the main container, possibly in a new row.
    tt.frame = c.frame.getNewIconFrame()

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)

    # Actually add tt.frame to the icon row.
    c.frame.addIconWidget(tt.frame)
#@nonl
#@-node:ekr.20070317073819.2:tt.createControl
#@-node:ekr.20080930072519.7:New/changed code
#@-node:ekr.20080930072519.1:Added support for @int icon_bar_widgets_per_row setting
#@-node:ekr.20080930072519.8:New options
#@+node:ekr.20081001140516.16:Plugins
#@+node:ekr.20081001140516.1:Improved nav_buttons plugin and corresponding nodeHistory class
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20070615131604:class nodeHistory
class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
#@+node:ekr.20070615131604.1: ctor (nodeHistory)
def __init__ (self,c):

    self.c = c
    self.beadList = []
        # list of (position,chapter) tuples for
        # nav_buttons and nodenavigator plugins.
    self.beadPointer = -1
    self.trace = False
#@nonl
#@-node:ekr.20070615131604.1: ctor (nodeHistory)
#@+node:ekr.20070615131604.3:canGoToNext/Prev
def canGoToNextVisited (self):

    if self.trace:
        g.trace(
            self.beadPointer + 1 < len(self.beadList),
            self.beadPointer,len(self.beadList))

    return self.beadPointer + 1 < len(self.beadList)

def canGoToPrevVisited (self):

    if self.trace:
        g.trace(self.beadPointer > 0,
            self.beadPointer,len(self.beadList))

    return self.beadPointer > 0
#@-node:ekr.20070615131604.3:canGoToNext/Prev
#@+node:ekr.20070615132939:clear
def clear (self):

    self.beadList = []
    self.beadPointer = -1
#@-node:ekr.20070615132939:clear
#@+node:ekr.20070615134813:goNext/Prev
def goNext (self):

    '''Return the next visited node, or None.'''
    if self.beadPointer + 1 < len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None

def goPrev (self):

    '''Return the previous visited node, or None.'''
    if self.beadPointer > 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None
#@-node:ekr.20070615134813:goNext/Prev
#@+node:ekr.20070615132939.1:remove
def remove (self,p):

    '''Remove an item from the nav_buttons list.'''

    c = self.c
    target = self.beadPointer > -1 and self.beadList[self.beadPointer]

    self.beadList = [z for z in self.beadList
                        if z[0] != p and c.positionExists(z[0])]

    try:
        self.beadPointer = self.beadList.index(target)
    except ValueError:
        self.beadPointer = max(0,self.beadPointer-1)

    if self.trace:
        g.trace('bead list',p.headString())
        g.pr([z[0].headString() for z in self.beadList])
#@-node:ekr.20070615132939.1:remove
#@+node:ekr.20070615140032:selectChapter
def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController

    if cc and chapter and chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
#@-node:ekr.20070615140032:selectChapter
#@+node:ekr.20070615131604.2:update
def update (self,p):

    c = self.c

    self.beadList = [z for z in self.beadList
                        if c.positionExists(z[0])]

    positions = [z[0] for z in self.beadList]

    try:
        self.beadPointer = positions.index(p)
    except ValueError:
        cc = c.chapterController
        theChapter = cc and cc.getSelectedChapter()
        data = (p.copy(),theChapter)
        self.beadList.append(data)
        self.beadPointer = len(self.beadList)-1

    if self.trace:
        g.trace('bead list',p.headString())
        g.pr([z[0].headString() for z in self.beadList])

#@-node:ekr.20070615131604.2:update
#@+node:ekr.20070615140655:visitedPositions
def visitedPositions (self):

    return [p.copy() for p,chapter in self.beadList]
#@-node:ekr.20070615140655:visitedPositions
#@-node:ekr.20070615131604:class nodeHistory
#@-node:ekr.20081001140516.1:Improved nav_buttons plugin and corresponding nodeHistory class
#@+node:ekr.20081005065934.11:Created qtGui plugin
#@-node:ekr.20081005065934.11:Created qtGui plugin
#@-node:ekr.20081001140516.16:Plugins
#@-node:ekr.20080917153158.11:4.6
#@+node:ekr.20081019140728.1:New in qtGui branch
#@+node:ekr.20081011035102.1:Expand/contract problems...
#@+node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.1549:cutOutline
def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@-node:ekr.20031218072017.1549:cutOutline
#@+node:ekr.20031218072017.1550:copyOutline
def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    s = c.fileCommands.putLeoOutline()
    # g.trace('type(s)',type(s))
    g.app.gui.replaceClipboardWith(s)
#@-node:ekr.20031218072017.1550:copyOutline
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
    c.endEditing()
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)
    # paste as first child if back is expanded.
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw()
    c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_vnodes_iter():
    t = v.t
    if t not in tnodeInfoDict:
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=v.headString(),body=v.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict:
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@-node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()

        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()

        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20070910105044:checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
#@-node:ekr.20070910105044:checkMoveWithParentWithWarning
#@+node:ekr.20070910105044.1:checkDrag
def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.headString(),'target',target.headString())

    for z in root.subtree_iter():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True
#@nonl
#@-node:ekr.20070910105044.1:checkDrag
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.selectPosition(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20071005173203.1:c.insertChild
def insertChild (self,event=None):

    '''Insert a node after the presently selected node.'''

    c = self

    return c.insertHeadline(event=event,op_name='Insert Child',as_child=True)
#@-node:ekr.20071005173203.1:c.insertChild
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)

    c.redraw()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@-node:ekr.20031218072017.1765:c.validateOutline
#@-node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20080425060424.1:Sort...
#@+node:ekr.20050415134809:c.sortChildren
def sortChildren (self,event=None,cmp=None):

    '''Sort the children of a node.'''

    c = self ; p = c.currentPosition()

    if p and p.hasChildren():
        c.sortSiblings(p=p.firstChild(),sortChildren=True)
#@-node:ekr.20050415134809:c.sortChildren
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self,event=None,cmp=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.currentPosition()
    if not p: return

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.t.children[:]
    newChildren = parent_v.t.children[:]

    def key (self):
        return (self.headString().lower(), self)

    if cmp: newChildren.sort(cmp,key=key)
    else:   newChildren.sort(key=key)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.t.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    c.setPositionAfterSort(sortChildren)
    c.redraw()
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20080503055349.1:c.setPositionAfterSort
def setPositionAfterSort (self,sortChildren):

    c = self
    p = c.currentPosition()
    p_v = p.v
    parent = p.parent()
    parent_v = p._parentVnode()

    if sortChildren:
        c.selectPosition(parent or c.rootPosition())
    else:
        if parent:
            p = parent.firstChild()
        else:
            p = leoNodes.position(parent_v.t.children[0])
        while p and p.v != p_v:
            p.moveToNext()
        c.selectPosition(p or parent)
#@-node:ekr.20080503055349.1:c.setPositionAfterSort
#@-node:ekr.20080425060424.1:Sort...
#@-node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,event=None,verbose=True,unittest=False,full=True,root=None):

    """Report any possible clone errors in the outline.

    Remove any unused tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    if root: iter = root.self_and_subtree_iter
    else:    iter = c.allNodes_iter 

    for p in iter():  # c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
    v.t._p_changed = True
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 1000 == 0:
        g.es('','.',newline=False)
    if count % 8000 == 0:
        g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), 'p!=back.next(),  back: %s back.next: %s' % (
        back,back.next())

if next:
    assert p == next.back(), 'p!=next.back, next: %s next.back: %s' % (
        next,next.back())
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    for z in p.v.t.vnodeList:
        assert z.t == p.v.t
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList

for v in vnodeList:

    try:
        assert v.t == p.v.t
    except AssertionError:
        g.pr("p",p)
        g.pr("v",v)
        g.pr("p.v",p.v)
        g.pr("v.t",v.t)
        g.pr("p.v.t",p.v.t)
        raise AssertionError("v.t == p.v.t")

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = c.edit_widget(p)
    if t:
        s = t.getAllText()
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@+node:ekr.20080426051658.1:assert consistency of t.parent and t.children arrays
@
Every nodes gets visited, so we only check consistency
between p and its parent, not between p and its children.

In other words, this is a strong test.
@c

parent_v = p._parentVnode()
n = p.childIndex()

assert parent_v.t.children[n] == p.v,'fail 1'

if not g.unified_nodes:

    assert parent_v in p.v.parents,'fail 2: parent_v: %s\nparents: %s' % (
        parent_v,g.listToString(p.v.parents))

    for z in p.v.parents:
        assert p.v in z.t.children,'fail 3'
#@-node:ekr.20080426051658.1:assert consistency of t.parent and t.children arrays
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314044652:<< give test failed message >>
junk, value, junk = sys.exc_info()

s = "test failed at position %s\n%s" % (repr(p),value)

g.es_print(s,color="red")
#@-node:ekr.20040314044652:<< give test failed message >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    g.enl()

if errors or verbose:
    color = g.choose(errors,'red','blue')
    g.es_print('',count,'nodes checked',errors,'errors',color=color)
#@-node:ekr.20040314043900:<<print summary message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_with_unique_tnodes_iter():

        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    g.pr("Syntax error in %s" % p.cleanHeadString())
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("check complete",color="blue")

    return result
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20040723094220.3:checkPythonCode
def checkPythonCode (self,event=None,unittest=False,ignoreAtIgnore=True,suppressErrors=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.currentPosition().self_and_subtree_iter():

        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@+node:ekr.20040723094220.4:<< print dots >>
if count % 100 == 0:
    g.es('','.',newline=False)

if count % 2000 == 0:
    g.enl()
#@-node:ekr.20040723094220.4:<< print dots >>
#@-node:ekr.20040723094220.3:checkPythonCode
#@+node:ekr.20040723094220.5:checkPythonNode
def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self

    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            c.setMarked(p)

    c.tabNannyNode(p,h,body,unittest,suppressErrors)
#@-node:ekr.20040723094220.5:checkPythonNode
#@+node:ekr.20040723094220.6:tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return

    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.es("ParserError in",headline,color="blue")
            g.es('',str(msg))

    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.es("TokenError in",headline,color="blue")
            g.es('',str(msg))

    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("indentation error in",headline,"line",badline,color="blue")
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n",line2)

    except Exception:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: c.setMarked(p)
#@-node:ekr.20040723094220.6:tabNannyNode
#@-node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self

    for p in c.allNodes_iter():
        p.dump()
#@-node:ekr.20040412060927:c.dumpOutline
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_with_unique_tnodes_iter():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    return self.prettyPrintAllPythonCode (event,dump)
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree to make it look more beautiful.'''

    c = self

    if p: root = p.copy()
    else: root = c.currentPosition()

    pp = c.prettyPrinter(c)

    for p in root.self_and_subtree_iter():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    return self.prettyPrintPythonCode (event,dump)

#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20050729211526:prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.currentPosition()

    pp = c.prettyPrinter(c)

    # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
#@-node:ekr.20050729211526:prettyPrintPythonNode
#@+node:ekr.20071001075704:prettyPrintPythonTree
def prettyPrintPythonTree (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; p = c.currentPosition() ; pp = c.prettyPrinter(c)

    for p in p.self_and_subtree_iter():

        # Unlike c.scanAllDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonTree (self,event=None,dump=False):
    return self.prettyPrintPythonTree (event,dump)
#@nonl
#@-node:ekr.20071001075704:prettyPrintPythonTree
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:

    @others
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding

    g.pr('\n','-'*10,p.cleanHeadString())

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            g.pr(line2,newline=False) # Don't add a trailing newline!)
    else:
        for i in range(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            g.pr("%3d" % i, repr(lines[i]))
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        g.pr("----- line",srow,repr(line))
    self.line = srow

    g.pr("%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val)))
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return

    readlines = g.readLinesClass(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("error pretty-printing",h,"not changed.",color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):

    self.putArray()
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):

    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):

    g.pr("unknown PrettyPrinting code: %s" % (self.name))
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.bodyString()
    body = ''.join(lines)

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2899:Commands (outline menu)
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    for p in c.all_positions_with_unique_vnodes_iter():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.currentPosition()
    while p and p.hasParent():
        p.moveToParent()
    c.selectPosition(p)
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20080819075811.3:contractAllOtherNodes & helper
def contractAllOtherNodes (self,event=None):

    '''Contract all nodes except those needed to make the
    presently selected node visible.'''

    c = self ; leaveOpen = c.currentPosition()

    for p in c.rootPosition().self_and_siblings_iter():
        c.contractIfNotCurrent(p,leaveOpen)

    c.redraw()

#@+node:ekr.20080819075811.7:contractIfNotCurrent
def contractIfNotCurrent(self,p,leaveOpen):

    c = self

    if p == leaveOpen or not p.isAncestorOf(leaveOpen):
        p.contract()

    for child in p.children_iter():
        if child != leaveOpen and child.isAncestorOf(leaveOpen):
            c.contractIfNotCurrent(child,leaveOpen)
        else:
            for p2 in child.self_and_subtree_iter():
                p2.contract()
#@-node:ekr.20080819075811.7:contractIfNotCurrent
#@-node:ekr.20080819075811.3:contractAllOtherNodes & helper
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    p.contract()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()

    if p.hasChildren() and p.isExpanded():
        # g.trace('contract',p.headString())
        c.contractNode()
    elif p.hasParent() and p.parent().isVisible(c):
        # g.trace('goto parent',p.headString())
        c.goToParent()

    c.treeFocusHelper()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20031218072017.2902:contractParent
def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.currentPosition()

    parent = p.parent()
    if not parent: return

    parent.contract()

    c.treeSelectHelper(parent)
#@-node:ekr.20031218072017.2902:contractParent
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    p = c.rootPosition()
    while p:
        c.expandSubtree(p)
        p.moveToNext()
    c.selectVnode(c.rootPosition())
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.expandSubtree(v)
    while child:
        c.expandSubtree(child)
        child = child.next()
    c.selectVnode(v)
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20031218072017.2905:expandLevel1..9
def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
#@-node:ekr.20031218072017.2905:expandLevel1..9
#@+node:ekr.20031218072017.2906:expandNextLevel
def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
#@-node:ekr.20031218072017.2906:expandNextLevel
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; p = c.currentPosition()

    p.expand()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    if not p.isExpanded():
        c.expandNode()

    c.selectVnode(p.firstChild())
    c.redraw()
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.selectVnode(p.firstChild())
            c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20060928062431:expandOnlyAncestorsOfNode
def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    for p in c.all_positions_with_unique_vnodes_iter():
        p.contract()
    for p in c.currentPosition().parents_iter():
        p.expand()
        level += 1
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = level # Reset expansion level.
#@-node:ekr.20060928062431:expandOnlyAncestorsOfNode
#@+node:ekr.20031218072017.2908:expandPrevLevel
def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
#@-node:ekr.20031218072017.2908:expandPrevLevel
#@-node:ekr.20031218072017.2899:Commands (outline menu)
#@+node:ekr.20031218072017.2909:Utilities
#@+node:ekr.20031218072017.2910:contractSubtree
def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
#@-node:ekr.20031218072017.2910:contractSubtree
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.redraw()
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    current = c.currentPosition()
    n = current.level()
    for p in current.self_and_subtree_iter():
        if p.level() - n + 1 < level:
            p.expand()
        else:
            p.contract()
    c.expansionLevel = level
    c.expansionNode = c.currentPosition()
    c.redraw()
#@-node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
#@-node:ekr.20031218072017.2909:Utilities
#@-node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()

#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty
def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    while p:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty
def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2926:markAtFileNodesDirty
#@+node:ekr.20031218072017.2927:markClones
def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('the current node is not a clone',color='blue')
        return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.v.t == current.v.t:
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline & est
def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoType = g.choose(p.isMarked(),'Unmark','Mark')
    bunch = u.beforeMark(p,undoType)
    if p.isMarked():
        c.clearMarked(p)
    else:
        c.setMarked(p)
    dirtyVnodeList = p.setDirty()
    c.setChanged(True)
    u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2928:markHeadline & est
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in current.children_iter():
        if not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    changed = False
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isMarked():
            bunch = u.beforeMark(p,undoType)
            # c.clearMarked(p) # Very slow: calls a hook.
            p.v.clearMarked()
            p.v.t.setDirty()
            u.afterMark(p,undoType,bunch)
            changed = True
    dirtyVnodeList = [p.v for p in c.all_positions_with_unique_vnodes_iter() if p.v.isDirty()]
    if changed:
        g.doHook("clear-all-marks",c=c,p=p,v=p)
        c.setChanged(True)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2930:unmarkAll
#@-node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20070420092425:cantMoveMessage
def cantMoveMessage (self):

    c = self ; h = c.rootPosition().headString()
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("can't move node out of",kind,color="blue")
#@-node:ekr.20070420092425:cantMoveMessage
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.currentPosition()
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.t.children[n+1:]
    # g.trace('sibs2\n',g.listToString(followingSibs2))
    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=followingSibs)
    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]
    # Add the moved nodes to p's children
    p.v.t.children.extend(followingSibs)
    p.expand()
    # Even if p is an @ignore node there is no need to mark the demoted children dirty.
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterDemote(p,followingSibs,dirtyVnodeList)
    c.selectPosition(p)  # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    << Move p down & set moved if successful >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(parent)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
    if sparseMove: # New in Leo 4.4.2
        parent.contract()
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back,n)
    # g.trace(p,p.parent())
    # Moving an outline right can never bring it outside the range of @ignore.
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
    dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    << Move p up >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.endEditing()
    parent_v = p._parentVnode()
    children = p.v.t.children
    # Add the children to parent_v's children.
    n = p.childIndex()+1
    z = parent_v.t.children[:]
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(children)
    parent_v.t.children.extend(z[n:])
    # Remove v's children.
    p.v.t.children = []
    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=children)
    c.setChanged(True)
    if not inAtIgnoreRange and isAtIgnoreNode:
        # The promoted nodes have just become newly unignored.
        dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    u.afterPromote(p,children,dirtyVnodeList)
    c.selectPosition(p)
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@+node:ekr.20071213185710:c.toggleSparseMove
def toggleSparseMove (self,event=None):

    c = self ; p = c.currentPosition()
    tag = 'sparse_move_outline_left'

    sparseMove = not c.config.getBool(tag)
    c.config.set(p, tag, sparseMove)
    g.es(tag,'=',sparseMove,color='blue')
#@-node:ekr.20071213185710:c.toggleSparseMove
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.2914:goToFirstNode
def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self ; p = c.rootPosition()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2914:goToFirstNode
#@+node:ekr.20051012092453:goToFirstSibling
def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
#@-node:ekr.20051012092453:goToFirstSibling
#@+node:ekr.20070615070925:goToFirstVisibleNode
def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
#@-node:ekr.20070615070925:goToFirstVisibleNode
#@+node:ekr.20031218072017.2915:goToLastNode
def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2915:goToLastNode
#@+node:ekr.20051012092847.1:goToLastSibling
def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
#@-node:ekr.20051012092847.1:goToLastSibling
#@+node:ekr.20050711153537:c.goToLastVisibleNode
def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
#@-node:ekr.20050711153537:c.goToLastVisibleNode
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.currentPosition()
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.headString(),color='blue')
        return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")

    if cc:
        name = cc.findChapterNameForPosition(p)
        cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)

    c.selectPosition(p)
    c.redraw()
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20071213123942:findNextClone
def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.currentPosition() ; flag = False
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        cc = c.chapterController
        if cc:
            name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
    else:
        g.es('no more clones',color='blue')
#@-node:ekr.20071213123942:findNextClone
#@+node:ekr.20031218072017.2917:goToNextDirtyHeadline
def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@-node:ekr.20031218072017.2917:goToNextDirtyHeadline
#@+node:ekr.20031218072017.2918:goToNextMarkedHeadline
def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
#@-node:ekr.20031218072017.2918:goToNextMarkedHeadline
#@+node:ekr.20031218072017.2919:goToNextSibling
def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.next())
#@-node:ekr.20031218072017.2919:goToNextSibling
#@+node:ekr.20031218072017.2920:goToParent
def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.parent())
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20031218072017.2921:goToPrevSibling
def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.back())
#@-node:ekr.20031218072017.2921:goToPrevSibling
#@+node:ekr.20031218072017.2993:selectThreadBack
def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
#@-node:ekr.20031218072017.2993:selectThreadBack
#@+node:ekr.20031218072017.2994:selectThreadNext
def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)
#@nonl
#@-node:ekr.20031218072017.2994:selectThreadNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
#@-node:ekr.20031218072017.2995:selectVisBack
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20070417112650:utils
#@+node:ekr.20070226121510: treeFocusHelper
def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
#@-node:ekr.20070226121510: treeFocusHelper
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        flag = c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        if redraw or flag:
            c.redraw()

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@-node:ekr.20070417112650:utils
#@-node:ekr.20031218072017.2913:Goto
#@-node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    if trace: g.trace('limit',limit,'limitIsVisible',limitIsVisible)

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done:
                if trace: g.trace('done')
                return val
            if p.isVisible(c):
                if trace: g.trace('isVisible')
                return p
    else:
        # assert not p.
        return p
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        if trace: g.trace(
            'hasChildren',p.hasChildren(),
            'isExpanded',p.isExpanded(),
            p.headString())
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p
#@nonl
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@+node:ekr.20080416161551.196:p.isVisible
def isVisible (self,c):

    p = self ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # It's much easier with a full stack.
    n = len(p.stack)-1
    while n >= 0:
        progress = n
        # v,n = p.vParentWithStack(v,p.stack,n)
        v,junk = p.stack[n]
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded:',v.t._headString,p.headString())
            return False
        n -= 1
        assert progress > n

    return True
#@-node:ekr.20080416161551.196:p.isVisible
#@+node:ekr.20070609122713:c.visLimit
def visLimit (self):

    '''Return the topmost visible node.
    This is affected by chapters and hoists.'''

    c = self ; cc = c.chapterController

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.headString().startswith('@chapter')
        return p,limitIsVisible
    else:
        return None,None
#@-node:ekr.20070609122713:c.visLimit
#@+node:ekr.20031218072017.3395:v.contract & expand & initExpandedBit
def contract(self):

    # g.trace(self,g.callers(4))

    self.statusBits &= ~ self.expandedBit

def expand(self):

    # g.trace(self,g.callers(4))

    self.statusBits |= self.expandedBit

def initExpandedBit (self):

    # g.trace(self.t._headString)

    self.statusBits |= self.expandedBit
#@-node:ekr.20031218072017.3395:v.contract & expand & initExpandedBit
#@+node:ekr.20031218072017.3370:v.isExpanded
def isExpanded (self):

    # g.trace( ( self.statusBits & self.expandedBit ) != 0, g.callers())

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20031218072017.3370:v.isExpanded
#@-node:ekr.20081011035102.1:Expand/contract problems...
#@+node:ekr.20081014095651.1:Focus stuff...
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = True

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20080514131122.9:c.get/request/set_focus
def get_focus (self):

    c = self
    return g.app.gui and g.app.gui.get_focus(c)

def get_requested_focus (self):

    c = self
    return c.requestedFocusWidget

def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w

def set_focus (self,w,force=False):

    c = self
    if w and g.app.gui and c.requestedFocusWidget:
        g.app.gui.set_focus(c,w)

    c.requestedFocusWidget = None
#@-node:ekr.20080514131122.9:c.get/request/set_focus
#@+node:ekr.20080610085158.2:c.add_command
def add_command (self,menu,**keys):

    c = self ; command = keys.get('command')

    if command:

        def add_commandCallback(c=c,command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys ['command'] = add_commandCallback

        menu.add_command(**keys)

    else:
        g.trace('can not happen: no "command" arg')
#@-node:ekr.20080610085158.2:c.add_command
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('menu',menu)

    c = self.c ; f = c.frame ; k = c.k ; trace = False
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel,addKey=False) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (c=c,k=k,stroke=stroke,command=command,commandName=commandName,event=None):
            #k.clearState()
            #g.trace(stroke)
            return k.masterMenuHandler(stroke,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>

        # c.add_command ensures that c.outerUpdate is called.
        if menu:
            c.add_command(menu,label=realLabel,
                accelerator=accelerator,
                command=masterMenuCallback,
                underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if g.isString(data):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                if trace: g.trace('1','%20s' % (bunch.val),commandName)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            if trace: g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            if trace: g.trace('2','%20s' % (bunch.val),commandName)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val
                    if trace: g.trace('3','%20s' % (bunch.val),commandName)
                    break
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20061031131434.155:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@-node:ekr.20061031131434.155:masterMenuHandler
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)

        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@-node:ekr.20081014095651.1:Focus stuff...
#@+node:ekr.20081020151805.1:Crash in openWrapperLeoFile
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if 1: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None,None
        p = c.currentPosition()
        if p:
            p.setHeadString(fileName)
            p.setBodyString(s)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.currentPosition()
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.currentPosition()
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.currentPosition()
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw_now() # Only needed by menu commands.
    return c,frame
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@-node:ekr.20081020151805.1:Crash in openWrapperLeoFile
#@+node:ekr.20081020110239.1:Suppress text updates until initCompleteHint
#@+node:ekr.20080429051644.1:leoFrame.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
#@nonl
#@-node:ekr.20080429051644.1:leoFrame.mustBeDefined
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()
    c.frame.initCompleteHint()

    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:c.new
#@-node:ekr.20081020110239.1:Suppress text updates until initCompleteHint
#@+node:ekr.20081019081958.2:Support for --gui command-line option
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -- gui
    gui = options.gui
    if gui: gui = gui.lower()
    if gui not in ('tk','qt'):
        gui = None
    # g.trace('gui',gui)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # Compute the return values.
    windowFlag = script and script_path_w
    return gui, script, windowFlag
#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20080921060401.4:createSpecialGui & helper
def createSpecialGui(gui,pymacs,script,windowFlag):

    if g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':
        leoPlugins.loadOnePlugin ('qtGui',verbose=True)
    elif gui == 'tk':
        g.app.createTkGui()
#@+node:ekr.20031218072017.1938:createNullGuiWithScript
def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript
#@-node:ekr.20080921060401.4:createSpecialGui & helper
#@-node:ekr.20081019081958.2:Support for --gui command-line option
#@+node:ekr.20081020151805.9:Too many redraws after insert
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers(5))
            # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)

        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace('leoTree',p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        self.endEditLabel()
        # This redraw *is* required so the c.edit_widget(p) will exist.
        c.redraw()
        c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if trace: g.trace('1','w',w,'focus',g.app.gui.get_focus(c))

    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
        c.k.showStateAndMode(w)

    if trace: g.trace('w',w,'focus',g.app.gui.get_focus(c))
#@-node:ekr.20040803072955.127:tree.editLabel
#@-node:ekr.20081020151805.9:Too many redraws after insert
#@+node:ekr.20081020151805.3:New redraw helpers
#@+node:ekr.20081020151805.4:Found: .redraw
#@+node:ekr.20081020151805.2:c.redraw_after methods (new)
def redraw_after_icons_changed(self,all=False):
    return self.frame.tree.redraw_after_icons_changed(all)
def redraw_after_clone(self):
    return self.frame.tree.redraw_after_clone()
def redraw_after_contract(self):
    return self.frame.tree.redraw_after_contract()
def redraw_after_delete(self):
    return self.frame.tree.redraw_after_delete()
def redraw_after_expand(self):
    return self.frame.tree.redraw_after_expand()
def redraw_after_insert(self):
    return self.frame.tree.redraw_after_insert()
def redraw_after_move_down(self):
    return self.frame.tree.redraw_after_move_down()
def redraw_after_move_left(self):
    return self.frame.tree.redraw_after_move_left()
def redraw_after_move_right(self):
    return self.frame.tree.redraw_after_move_right()
def redraw_after_move_up(self):
    return self.frame.tree.redraw_after_move_up()
def redraw_after_select(self):
    return self.frame.tree.redraw_after_select()
#@-node:ekr.20081020151805.2:c.redraw_after methods (new)
#@+node:ekr.20081020151805.8:tree.edraw_after methods (new)
# We now use the definitions in the base leoTree class.

# redraw_after_icons_changed  = redraw
# redraw_after_clone          = redraw
# redraw_after_contract       = redraw
# redraw_after_delete         = redraw
# redraw_after_expand         = redraw
# redraw_after_insert         = redraw
# redraw_after_move_down      = redraw
# redraw_after_move_left      = redraw
# redraw_after_move_right     = redraw
# redraw_after_move_up        = redraw
# redraw_after_select         = redraw
#@-node:ekr.20081020151805.8:tree.edraw_after methods (new)
#@+node:ekr.20081020151805.5: No change
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        << Create a parent for two files having a common prefix >>
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw()

    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20080921060401.6:initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw_now()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@-node:ekr.20080921060401.6:initFocusAndDraw
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20080921154026.1:g.openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if 1: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None,None
        p = c.currentPosition()
        if p:
            p.setHeadString(fileName)
            p.setBodyString(s)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.currentPosition()
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.currentPosition()
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.currentPosition()
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw_now() # Only needed by menu commands.
    return c,frame
#@-node:ekr.20080921154026.1:g.openWrapperLeoFile
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.editPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.currentPosition()
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.redraw_now()
    c.frame.initCompleteHint()

    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()

        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()

        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self,event=None,cmp=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.currentPosition()
    if not p: return

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.t.children[:]
    newChildren = parent_v.t.children[:]

    def key (self):
        return (self.headString().lower(), self)

    if cmp: newChildren.sort(cmp,key=key)
    else:   newChildren.sort(key=key)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.t.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    c.setPositionAfterSort(sortChildren)
    c.redraw()
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    for p in c.all_positions_with_unique_vnodes_iter():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.currentPosition()
    while p and p.hasParent():
        p.moveToParent()
    c.selectPosition(p)
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20080819075811.3:contractAllOtherNodes & helper
def contractAllOtherNodes (self,event=None):

    '''Contract all nodes except those needed to make the
    presently selected node visible.'''

    c = self ; leaveOpen = c.currentPosition()

    for p in c.rootPosition().self_and_siblings_iter():
        c.contractIfNotCurrent(p,leaveOpen)

    c.redraw()

#@+node:ekr.20080819075811.7:contractIfNotCurrent
def contractIfNotCurrent(self,p,leaveOpen):

    c = self

    if p == leaveOpen or not p.isAncestorOf(leaveOpen):
        p.contract()

    for child in p.children_iter():
        if child != leaveOpen and child.isAncestorOf(leaveOpen):
            c.contractIfNotCurrent(child,leaveOpen)
        else:
            for p2 in child.self_and_subtree_iter():
                p2.contract()
#@-node:ekr.20080819075811.7:contractIfNotCurrent
#@-node:ekr.20080819075811.3:contractAllOtherNodes & helper
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    p = c.rootPosition()
    while p:
        c.expandSubtree(p)
        p.moveToNext()
    c.selectVnode(c.rootPosition())
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.expandSubtree(v)
    while child:
        c.expandSubtree(child)
        child = child.next()
    c.selectVnode(v)
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20060928062431:expandOnlyAncestorsOfNode
def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    for p in c.all_positions_with_unique_vnodes_iter():
        p.contract()
    for p in c.currentPosition().parents_iter():
        p.expand()
        level += 1
    c.redraw()
    c.treeFocusHelper()

    c.expansionLevel = level # Reset expansion level.
#@-node:ekr.20060928062431:expandOnlyAncestorsOfNode
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.redraw()
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    current = c.currentPosition()
    n = current.level()
    for p in current.self_and_subtree_iter():
        if p.level() - n + 1 < level:
            p.expand()
        else:
            p.contract()
    c.expansionLevel = level
    c.expansionNode = c.currentPosition()
    c.redraw()
#@-node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.currentPosition()
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.t.children[n+1:]
    # g.trace('sibs2\n',g.listToString(followingSibs2))
    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=followingSibs)
    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]
    # Add the moved nodes to p's children
    p.v.t.children.extend(followingSibs)
    p.expand()
    # Even if p is an @ignore node there is no need to mark the demoted children dirty.
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterDemote(p,followingSibs,dirtyVnodeList)
    c.selectPosition(p)  # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.endEditing()
    parent_v = p._parentVnode()
    children = p.v.t.children
    # Add the children to parent_v's children.
    n = p.childIndex()+1
    z = parent_v.t.children[:]
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(children)
    parent_v.t.children.extend(z[n:])
    # Remove v's children.
    p.v.t.children = []
    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=children)
    c.setChanged(True)
    if not inAtIgnoreRange and isAtIgnoreNode:
        # The promoted nodes have just become newly unignored.
        dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    u.afterPromote(p,children,dirtyVnodeList)
    c.selectPosition(p)
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = True

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20070606075434:cc.removeChapterByName
def removeChapterByName (self,name):

    cc = self ; c = cc.c ; tt = cc.tt

    theChapter = cc.chaptersDict.get(name)
    if not theChapter: return

    savedRoot = theChapter.root
    bunch = cc.beforeRemoveChapter(c.currentPosition(),name,savedRoot)
    cc.deleteChapterNode(name)
    del cc.chaptersDict[name] # Do this after calling deleteChapterNode.
    if tt:tt.destroyTab(name)
    cc.selectChapterByName('main')
    cc.afterRemoveChapter(bunch,c.currentPosition())
    c.redraw()
#@nonl
#@-node:ekr.20070606075434:cc.removeChapterByName
#@+node:ekr.20070317085437.41:cc.renameChapter
# newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = cc.chaptersDict.keys()
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw_now()
#@-node:ekr.20070317085437.41:cc.renameChapter
#@+node:ekr.20070423102603.1:chapterSelectHelper
def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    if name == 'main' and cc.chaptersNode:
        cc.chaptersNode.contract()    
    c.hoistStack = self.hoistStack[:]
    c.selectPosition(p)
    c.redraw()
    g.doHook('hoist-changed',c=c)
    c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20070423102603.1:chapterSelectHelper
#@+node:ekr.20070915134101:readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)

    if fileName:    
        try:
            theFile = open(fileName,'r')
            g.chdir(fileName)
            s = theFile.read()
            s = '@nocolor\n' + s
            w = c.frame.body.bodyCtrl
            p = c.insertHeadline(op_name=undoType)
            p.setHeadString('@read-file-into-node ' + fileName)
            p.setBodyString(s)
            w.setAllText(s)
            c.redraw()
        except:
            g.es("can not open:",fileName)
#@-node:ekr.20070915134101:readFileIntoNode
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.importCommands.readAtAutoNodes()
    u.afterChangeTree(p,'Read @auto Nodes',undoData)
    c.redraw()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.fileCommands.readAtFileNodes()
    u.afterChangeTree(p,'Read @file Nodes',undoData)
    c.redraw()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20080801071227.4:readAtShadowNodes (commands)
def readAtShadowNodes (self,event=None):

    '''Read all @shadow nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    c.atFileCommands.readAtShadowNodes(p)
    u.afterChangeTree(p,'Read @shadow Nodes',undoData)
    c.redraw() 
#@-node:ekr.20080801071227.4:readAtShadowNodes (commands)
#@+node:ekr.20031218072017.1706:extract (test)
def extract (self,event=None):

    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        if not g.unitTesting:
            g.es("nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        undoData = u.beforeInsertNode(current)
        p = c.createLastChildNode(current,headline,newBody)
        u.afterInsertNode(p,undoType,undoData)
        c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
    u.afterChangeGroup(current,undoType=undoType)
    c.redraw()
#@-node:ekr.20031218072017.1706:extract (test)
#@+node:ekr.20031218072017.1708:extractSection
def extractSection (self,event=None):

    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    if not lines:
        if not g.unitTesting:
            g.es("nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        undoData = u.beforeInsertNode(current)
        p = c.createLastChildNode(current,headline,newBody)
        u.afterInsertNode(p,undoType,undoData)
        c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
    u.afterChangeGroup(current,undoType=undoType)
    c.redraw()
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("selected text should start with a section name",color="blue")
    return
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self,event=None):

    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    u.beforeChangeGroup(current,undoType)
    if 1: # In group...
        found = False
        for s in lines:
            << Find the next section name >>
            if name:
                undoData = u.beforeInsertNode(current)
                p = self.createLastChildNode(current,name,None)
                u.afterInsertNode(p,undoType,undoData)
                found = True
        c.selectPosition(current)
        c.validateOutline()
        if not found:
            g.es("selected text should contain one or more section names",color="blue")
    u.afterChangeGroup(current,undoType)
    c.redraw()

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = s.find("<<")
if head1 > -1:
    head2 = s.find(">>",head1)
else:
    head1 = s.find("@<")
    if head1 > -1:
        head2 = s.find("@>",head1)

if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.endEditing()
    undoData = u.beforeMoveNode(current)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(after)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.selectPosition(p) # Also sets root position.
    c.redraw()

    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20031218072017.2947:c.dragToNthChildOf
def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,parent): return
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.endEditing()
    undoData = u.beforeMoveNode(current)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveToNthChildOf(parent,n)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.selectPosition(p) # Also sets root position.
    c.redraw()

    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2947:c.dragToNthChildOf
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
    clone = p.clone() # Creates clone & dependents, does not set undo.
    if (
        not c.checkDrag(p,parent) or
        not c.checkMoveWithParentWithWarning(clone,parent,True)
    ):
        clone.doDelete(newNode=p) # Destroys clone and makes p the current node.
        c.selectPosition(p) # Also sets root position.
        return
    c.endEditing()
    undoData = u.beforeInsertNode(current)
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    clone.moveToNthChildOf(parent,n)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        dirtyVnodeList.extend(dirtyVnodeList2)
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    c.selectPosition(clone) # Also sets root position.
    c.redraw()

    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    clone = p.clone() # Creates clone.  Does not set undo.
    if c.checkDrag(p,after) and c.checkMoveWithParentWithWarning(clone,after.parent(),True):
        inAtIgnoreRange = clone.inAtIgnoreRange()
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveAfter(after)
        if inAtIgnoreRange and not clone.inAtIgnoreRange():
            # The moved node have just become newly unignored.
            dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        p = clone
    else:
        # g.trace("invalid clone drag")
        clone.doDelete(newNode=p)
    c.selectPosition(p) # Also sets root position.
    c.redraw()

    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20070921072910:createAllCompareClones & helper
def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.currentPosition(),undoType)
    undoData = u.beforeInsertNode(c.currentPosition())
    parent = c.currentPosition().insertAfter()
    c.setHeadString(parent,undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 

    c.redraw_now()
#@nonl
#@+node:ekr.20070921074410:createCompareClones
def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d:
        parent = parent.insertAsLastChild()
        c.setHeadString(parent,kind)

        for key in d:
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
#@-node:ekr.20070921074410:createCompareClones
#@-node:ekr.20070921072910:createAllCompareClones & helper
#@+node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()

    c.atFileCommands.readAll(p,partialFlag=True)
    c.redraw()

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
#@+node:ekr.20031218072017.3030:readOutlineOnly
def readOutlineOnly (self,theFile,fileName):

    c = self.c

    << Set the default directory >>
    ok, ratio = self.getLeoFile(theFile,fileName,readAtFileNodesFlag=False)
    c.redraw()

    c.frame.deiconify()
    junk,junk,secondary_ratio = self.frame.initialRatios()
    c.frame.resizePanesToRatio(ratio,secondary_ratio)

    return ok
#@+node:ekr.20071211134300:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20071211134300:<< Set the default directory >>
#@-node:ekr.20031218072017.3030:readOutlineOnly
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.currentPosition() ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.headString(),color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545:readOneAtAutoNode
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    u.beforeChangeGroup(current,command)
    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        << set isThin if fileName is a thin derived file >>
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAfter()
        if isThin:
            at.forceGnxOnPosition(p)
            p.initHeadString("@thin " + fileName)
            at.read(p,thinFile=True)
        else:
            p.initHeadString("Imported @file " + fileName)
            at.read(p,importFileName=fileName)
        p.contract()
        u.afterInsertNode(p,command,undoData)
    current.expand()
    ### c.redraw_after_expand()
    c.selectPosition(current)
    c.setChanged(True)
    u.afterChangeGroup(p,command)
    c.redraw()
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@+node:ekr.20051208100903.1:forceGnxOnPosition
def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051208100903.1:forceGnxOnPosition
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
# Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,first_p):
    s = s.replace("\r","")
    strings = s.split("\n")
    return self.convertMoreStringsToOutlineAfter(strings,first_p)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,first_p):

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    firstLevel, junk = self.moreHeadlineLevel(strings[0])
    lastLevel = -1 ; theRoot = last_p = None
    index = 0
    while index < len(strings):
        progress = index
        s = strings[index]
        level,junk = self.moreHeadlineLevel(s)
        level -= firstLevel
        if level >= 0:
            << Link a new position p into the outline >>
            << Set the headline string, skipping over the leader >>
            << Count the number of following body lines >>
            << Add the lines to the body text of p >>
            p.setDirty()
        else: index += 1
        assert progress < index
    if theRoot:
        theRoot.setDirty()
        c.setChanged(True)
    c.redraw()

    return theRoot
#@+node:ekr.20031218072017.3216:<< Link a new position p into the outline >>
assert(level >= 0)
if not last_p:
    # g.trace(first_p)
    theRoot = p = first_p.insertAfter()
elif level == lastLevel:
    p = last_p.insertAfter()
elif level == lastLevel + 1:
    p = last_p.insertAsNthChild(0)
else:
    assert(level < lastLevel)
    while level < lastLevel:
        lastLevel -= 1
        last_p = last_p.parent()
        assert(last_p)
        assert(lastLevel >= 0)
    p = last_p.insertAfter()
last_p = p
lastLevel = level
#@-node:ekr.20031218072017.3216:<< Link a new position p into the outline >>
#@+node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

p.initHeadString(s[j:])
#@-node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
#@+node:ekr.20031218072017.3218:<< Count the number of following body lines >>
bodyLines = 0
index += 1 # Skip the headline.
while index < len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level >= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
#@-node:ekr.20031218072017.3218:<< Count the number of following body lines >>
#@+node:ekr.20031218072017.3219:<< Add the lines to the body text of p >>
if bodyLines > 0:
    body = ""
    n = index - bodyLines
    while n < index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    p.setBodyString(body)
#@-node:ekr.20031218072017.3219:<< Add the lines to the body text of p >>
#@-node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutlineFromWeb(fileName,current)
        v.contract()
        v.setDirty()
        c.setChanged(True)
    c.selectVnode(current)
    c.redraw()
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    d = g.app.unitTestDict
    expectedErrors = d.get('expectedErrors')
    expectedErrorMessage = d.get('expectedErrorMessage')
    expectedMismatchLine = d.get('expectedMismatchLine')
    g.app.unitTestDict = {
        'expectedErrors':expectedErrors,
        'expectedErrorMessage':expectedErrorMessage,
        'expectedMismatchLine':expectedMismatchLine,
    }
    if not fileName: fileName = p.headString()
    if not s: s = self.removeSentinelsCommand([fileName],toString=True)
    title = g.choose(h.startswith('@test'),h[5:],h)
    self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
    d = g.app.unitTestDict
    ok = ((d.get('result') and expectedErrors in (None,0)) or
        (
            # checkTrialWrite returns *True* if the following match.
            # d.get('result') == False and
            d.get('actualErrors') == d.get('expectedErrors') and
            d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
            (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
        ))
    if not ok:
        g.trace('result',d.get('result'),
            'actualErrors',d.get('actualErrors'),
            'expectedErrors',d.get('expectedErrors'),
            'actualMismatchLine',d.get('actualMismatchLine'),
            'expectedMismatchLine', d.get('expectedMismatchLine'),
            '\nactualErrorMessage  ',d.get('actualErrorMessage'),
            '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
        )
    if not showTree and ok:
        while old_root.hasChildren():
            old_root.firstChild().doDelete()
        c.setChanged(oldChanged)
    c.selectPosition(old_root)
    c.redraw()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@+node:ekr.20031218072017.3478:untangle
def untangle(self,event=None):

    c = self.c ; p = c.currentPosition()
    self.initUntangleCommand()

    self.untangleTree(p,report_errors)
    if not g.unitTesting:
        g.es("untangle complete")
    c.redraw()
#@-node:ekr.20031218072017.3478:untangle
#@+node:ekr.20031218072017.3479:untangleAll
def untangleAll(self,event=None):

    c = self.c
    self.initUntangleCommand()
    has_roots = False

    for p in c.rootPosition().self_and_siblings_iter():
        ok = self.untangleTree(p,False)
        if ok: has_roots = True
    c.redraw()

    self.errors += g.app.scanErrors

    if not has_roots:
        self.warning("----- the outline contains no roots")
    elif self.errors > 0:
        self.warning("----- untangle command halted because of errors")
    else:
        if not g.unitTesting:
            g.es("untangle complete")
#@-node:ekr.20031218072017.3479:untangleAll
#@+node:ekr.20031218072017.3480:untangleMarked
def untangleMarked(self,event=None):

    c = self.c ; p = c.rootPosition()
    self.initUntangleCommand()
    marked_flag = False

    while p: # Don't use an iterator.
        if p.isMarked():
            ok = self.untangleTree(p,dont_report_errors)
            if ok: marked_flag = True
            if self.errors + g.app.scanErrors > 0: break
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

    self.errors += g.app.scanErrors

    if not marked_flag:
        self.warning("----- the outline contains no marked roots")
    elif self.errors > 0:
        self.warning("----- untangle command halted because of errors")
    else:
        if not g.unitTesting:
            g.es("untangle complete")
#@-node:ekr.20031218072017.3480:untangleMarked
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c ; trace = False

    if not u.canRedo():
        if trace: g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.redoing = True 
    u.groupCount = 0

    c.endEditing()
    if u.redoHelper: u.redoHelper()
    else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.currentPosition())
    else:
        c.setCurrentPosition(c.currentPosition())
    c.setChanged(True)
    c.redraw()
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    c.redraw_now()
    c.recolor_now()
    c.bodyWantsFocusNow()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    u.newP.v._computeParentsOfChildren()
    u.newP._parentVnode()._computeParentsOfChildren()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20080425060424.9:redoDemote
def redoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()

    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]

    # Add the moved nodes to p's children
    u.p.v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    u.p.v._computeParentsOfChildren(children=u.followingSibs)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.9:redoDemote
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                # g.trace(z.redoHelper)
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('new') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.t.setDirty()

    if not g.unitTesting:
        g.es("redo",count,"instances")

    c.selectPosition(p)
    if newSel: c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP._linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.newP._restoreLinksInTree()

    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setBodyString(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.oldParent_v.t.children[u.oldN] == v
    del u.oldParent_v.t.children[u.oldN]
    u.newParent_v.t.children.insert(u.newN,v)

    # Recompute the parent links.
    u.newParent_v._computeParentsOfChildren()

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20080425060424.13:redoPromote
def redoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children[:]
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(u.children)
    parent_v.t.children.extend(z[n:])

    # Remove v's children.
    u.p.v.t.children = []

    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=u.children)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.13:redoPromote
#@+node:ekr.20080425060424.4:redoSort
def redoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.newChildren
    c.setPositionAfterSort(u.sortChildren)
#@nonl
#@-node:ekr.20080425060424.4:redoSort
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    u = self ; c = u.c ; trace = False

    if not u.canUndo():
        if trace: g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    if trace: g.trace(u.dumpBead(u.bead))

    u.undoing = True
    u.groupCount = 0

    c.endEditing()
    if u.undoHelper: u.undoHelper()
    else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    c.frame.body.updateEditors() # New in Leo 4.4.8.
    if 0: # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.currentPosition())
    else:
        c.setCurrentPosition(c.currentPosition())
    c.setChanged(True)
    c.redraw()
    # New in Leo 4.5: Redrawing *must* be done here before setting u.undoing to False.
    c.redraw_now()
    c.recolor_now()
    c.bodyWantsFocusNow()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p._linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.p._restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20080425060424.10:undoDemote
def undoDemote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)

    # Remove the demoted nodes from p's children.
    u.p.v.t.children = u.p.v.t.children[:-n]

    # Add the demoted nodes to the parent's children.
    parent_v.t.children.extend(u.followingSibs)

    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=u.followingSibs)

    c.setCurrentPosition(u.p)
#@nonl
#@-node:ekr.20080425060424.10:undoDemote
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            # g.trace(z.undoHelper)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)

    u.groupCount -= 1

    u.updateMarks('old') # Bug fix: Leo 4.4.6.

    for v in dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.

    if not g.unitTesting:
        g.es("undo",count,"instances")

    c.selectPosition(p)
    if oldSel: c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)

    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setBodyString(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty() # Bug fix: Leo 4.4.6.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c ; v = u.p.v
    assert(u.oldParent_v)
    assert(u.newParent_v)
    assert(v)

    # Adjust the children arrays.
    assert u.newParent_v.t.children[u.newN] == v
    del u.newParent_v.t.children[u.newN]
    u.oldParent_v.t.children.insert(u.oldN,v)

    # Recompute the parent links.
    u.oldParent_v._computeParentsOfChildren()

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setBodyString(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20080425060424.14:undoPromote
def undoPromote (self):

    u = self ; c = u.c
    parent_v = u.p._parentVnode()

    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1
    z = parent_v.t.children
    parent_v.t.children = z[:n]
    parent_v.t.children.extend(z[n+len(u.children):])

    # Add the demoted nodes to v's children.
    u.p.t.children = u.children[:]

    # Adjust the parent links of all moved nodes.
    u.p.v._computeParentsOfChildren(children=u.children)

    c.setCurrentPosition(u.p)
#@-node:ekr.20080425060424.14:undoPromote
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):


    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:ekr.20080425060424.5:undoSort
def undoSort (self):

    u = self ; c = u.c

    parent_v = u.p._parentVnode()
    parent_v.t.children = u.oldChildren
    c.setPositionAfterSort(u.sortChildren)

#@-node:ekr.20080425060424.5:undoSort
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 4.4.6.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20031218072017.2039:undo & helpers...
#@+node:ekr.20031218072017.3069:changeAll
def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current,undoType)
    while 1:
        pos1, pos2 = self.findNextMatch()
        if pos1 is None: break
        count += 1
        self.batchChange(pos1,pos2)
        s = w.getAllText()
        i,j = g.getLine(s,pos1)
        line = s[i:j]
        # self.printLine(line,allFlag=True)
    p = c.currentPosition()
    u.afterChangeGroup(p,undoType,reportFlag=True)
    g.es("changed:",count,"instances")
    c.redraw()
    self.restore(saveData)
#@-node:ekr.20031218072017.3069:changeAll
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")
#@+node:ekr.20051113110735:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20051113110735:<< create the found node >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfig()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@-node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
#@+node:ekr.20070317074824.3:tt.selectTab
def selectTab (self,tabName):

    tt = self

    if tabName not in self.tabNames:
        tt.createTab(tabName)

    tt.cc.selectChapterByName(tabName)

    self.c.redraw()
    self.c.outerUpdate()
#@-node:ekr.20070317074824.3:tt.selectTab
#@-node:ekr.20081020151805.5: No change
#@+node:ekr.20081020151805.6: Changed
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)
    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
    c.endEditing()
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)
    # paste as first child if back is expanded.
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw()
    c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_vnodes_iter():
    t = v.t
    if t not in tnodeInfoDict:
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=v.headString(),body=v.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict:
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.selectPosition(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)

    c.redraw()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    p.contract()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; p = c.currentPosition()

    p.expand()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    if not p.isExpanded():
        c.expandNode()

    c.selectVnode(p.firstChild())
    c.redraw()
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.selectVnode(p.firstChild())
            c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()

#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty
def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    while p:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty
def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2926:markAtFileNodesDirty
#@+node:ekr.20031218072017.2927:markClones
def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('the current node is not a clone',color='blue')
        return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.v.t == current.v.t:
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline & est
def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoType = g.choose(p.isMarked(),'Unmark','Mark')
    bunch = u.beforeMark(p,undoType)
    if p.isMarked():
        c.clearMarked(p)
    else:
        c.setMarked(p)
    dirtyVnodeList = p.setDirty()
    c.setChanged(True)
    u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2928:markHeadline & est
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in current.children_iter():
        if not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    changed = False
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isMarked():
            bunch = u.beforeMark(p,undoType)
            # c.clearMarked(p) # Very slow: calls a hook.
            p.v.clearMarked()
            p.v.t.setDirty()
            u.afterMark(p,undoType,bunch)
            changed = True
    dirtyVnodeList = [p.v for p in c.all_positions_with_unique_vnodes_iter() if p.v.isDirty()]
    if changed:
        g.doHook("clear-all-marks",c=c,p=p,v=p)
        c.setChanged(True)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2930:unmarkAll
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    << Move p down & set moved if successful >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(parent)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
    if sparseMove: # New in Leo 4.4.2
        parent.contract()
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back,n)
    # g.trace(p,p.parent())
    # Moving an outline right can never bring it outside the range of @ignore.
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
    dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    << Move p up >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.currentPosition()
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.headString(),color='blue')
        return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")

    if cc:
        name = cc.findChapterNameForPosition(p)
        cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)

    c.selectPosition(p)
    c.redraw()
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20071213123942:findNextClone
def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.currentPosition() ; flag = False
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        cc = c.chapterController
        if cc:
            name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
    else:
        g.es('no more clones',color='blue')
#@-node:ekr.20071213123942:findNextClone
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        flag = c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        if redraw or flag:
            c.redraw()

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = c.scanAllDirectives()
    tabWidth  = d.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree_iter():
        # g.trace(p.headString(),tabWidth)
        innerUndoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = c.convertBlanks(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            changed = False ; result = []
            text = p.t._bodyString
            assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,innerUndoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("blanks converted to tabs in",count,"nodes") # Must come before c.redraw().
    if count > 0:
        c.redraw()
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self,event=None):

    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = c.scanAllDirectives()
    tabWidth  = theDict.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree_iter():
        undoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = self.convertTabs(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            result = [] ; changed = False
            text = p.t._bodyString
            assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,undoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("tabs converted to blanks in",count,"nodes")
    if count > 0:
        c.redraw()
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.setChanged(True)
    if p.isDirty():
        dirtyVnodeList = []
    else:
        dirtyVnodeList = p.setDirty()
    c.redraw()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t._bodyString != s:
        v.setBodyString(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        c.redraw()
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20050920084036.35:appendToBuffer
def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Append to buffer: ')
    self.getBufferName(self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        w = self.w
        c.selectPosition(p)
        self.beginCommand('append-to-buffer: %s' % p.headString())
        w.insert('end',s)
        w.setInsertPoint('end')
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@nonl
#@-node:ekr.20050920084036.35:appendToBuffer
#@+node:ekr.20050920084036.36:copyToBuffer
def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Copy to buffer: ')
    self.getBufferName(self.copyToBufferFinisher)

def copyToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('copy-to-buffer: %s' % p.headString())
        w.insert('end',s)
        w.setInsertPoint('end')
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@-node:ekr.20050920084036.36:copyToBuffer
#@+node:ekr.20050920084036.37:insertToBuffer
def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('insert-to-buffer: %s' % p.headString())
        i = w.getInsertPoint()
        w.insert(i,s)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
#@-node:ekr.20050920084036.37:insertToBuffer
#@+node:ekr.20050920084036.39:prependToBuffer
def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('prepend-to-buffer: %s' % p.headString())
        w.insert(0,s)
        w.setInsertPoint(0)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@-node:ekr.20050920084036.39:prependToBuffer
#@+node:ekr.20050920084036.43:renameBuffer
def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.setHeadString(p,name)
        c.redraw()
#@-node:ekr.20050920084036.43:renameBuffer
#@+node:ekr.20050920084036.40:switchToBuffer
def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20050920084036.40:switchToBuffer
#@+node:ekr.20071114082418:deleteFirstIcon
def deleteFirstIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[1:])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114082418:deleteFirstIcon
#@+node:ekr.20071114092622:deleteIconByName
def deleteIconByName (self,t,name,relPath):
    """for use by the right-click remove icon callback"""
    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)
    if not aList: return

    basePath = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    absRelPath = c.os_path_finalize_join(basePath,relPath)
    name = c.os_path_finalize(name)

    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = c.os_path_finalize(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)

    if len(newList) != len(aList):
        self.setIconList(p, newList)       
        c.setChanged(True)
        c.redraw()
    else:
        g.trace('not found',name)



#@-node:ekr.20071114092622:deleteIconByName
#@+node:ekr.20071114085054:deleteLastIcon
def deleteLastIcon (self,event=None):

    c = self.c ;  p = c.currentPosition()

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[:-1])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114085054:deleteLastIcon
#@+node:ekr.20071114082418.1:deleteNodeIcons
def deleteNodeIcons (self,event=None):

    c = self.c ; p = c.currentPosition()

    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        p.v.t._p_changed = 1
        self.setIconList(p,[])
        a["lineYOffset"] = 0
        p.setDirty()
        c.setChanged(True)
        c.redraw()
#@-node:ekr.20071114082418.1:deleteNodeIcons
#@+node:ekr.20071114081313.1:insertIcon
def insertIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20071114081313.1:insertIcon
#@+node:ekr.20080108090719:insertIconFromFile
def insertIconFromFile (self,path,p=None,pos=None,**kargs):

    c = self.c
    if p is None: p = c.currentPosition()

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    aList = [] ; xoffset = 2
    xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset,**kargs)

    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos,aList[0])
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20080108090719:insertIconFromFile
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.selectPosition(p)
            c.redraw()


            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.selectPosition(p)
            c.redraw()

            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    sparseFind = c.config.getBool('collapse_nodes_while_spelling')
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.headString() or '<no p>')
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.headString() or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if sparseFind and not c.currentPosition().isAncestorOf(p):
                    for p2 in c.currentPosition().self_and_parents_iter():
                        p2.contract()
                        redraw = True
                for p2 in p.parents_iter():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                # c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                if redraw:
                    c.redraw()
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if word.lower() in self.dictionary:
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20031218072017.1720:save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        self.putSavedMessage(fileName)
        if ok:
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@-node:ekr.20031218072017.1720:save (fileCommands)
#@+node:ekr.20031218072017.3043:saveAs
def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        if self.write_Leo_file(fileName,False): # outlineOnlyFlag
            c.setChanged(False) # Clears all dirty bits.
            self.putSavedMessage(fileName)
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3043:saveAs
#@+node:ekr.20031218072017.3044:saveTo
def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        self.write_Leo_file(fileName,False) # outlineOnlyFlag
        self.putSavedMessage(fileName)
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3044:saveTo
#@+node:ekr.20031218072017.3575:update_current_vnode
def update_current_vnode (self,s):

    """Called from within the Untangle logic to update the body text of self.p."""

    c = self.c ; p = self.p
    assert(self.p)
    c.setBodyString(p,s)

    c.setChanged(True)
    p.setDirty()
    p.setMarked()
    # c.redraw()
    c.update_after_icons_changed()
#@-node:ekr.20031218072017.3575:update_current_vnode
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    if sparseFind and not c.currentPosition().isAncestorOf(p):
        # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
        for p2 in c.currentPosition().self_and_parents_iter():
            p2.contract()
            redraw = True
    for p in self.p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw = True
    p = self.p
    if not p: g.trace('can not happen: self.p is None')

    c.selectPosition(p)
    if redraw:
        c.redraw_now() # was c.redraw.
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    if not w: return
    c.widgetWantsFocusNow(w)
    c.k.showStateAndMode(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.3896:go
def go(self,event=None):

    """Handle clicks in the "go" button in a list box dialog."""

    c = self.c ; box = self.box

    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        p = self.positionList[n]
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
#@-node:ekr.20031218072017.3896:go
#@-node:ekr.20081020151805.6: Changed
#@-node:ekr.20081020151805.4:Found: .redraw
#@-node:ekr.20081020151805.3:New redraw helpers
#@+node:ekr.20081022105412.1:Missing _rootPosition
@nocolor-node

@ This could happen when opening a non-existent file.
#@nonl
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):

    f = self ; c = f.c

    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20070325101652:cc.createChaptersNode
def createChaptersNode (self):

    cc = self ; c = cc.c ; root = c.rootPosition()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    # g.trace('root',root)
    p = root.insertAsLastChild()
    p.initHeadString('@chapters')
    p.moveToRoot(oldRoot=root)
    c.setRootPosition(p)
    cc.chaptersNode = p.copy()
    t = p.v.t
    if t.fileIndex:
        self.error('***** t.fileIndex already exists')
    else:
        t.setFileIndex(g.app.nodeIndices.getNewIndex())
    c.setChanged(True)
#@-node:ekr.20070325101652:cc.createChaptersNode
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p == c._currentPosition:
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p == c._rootPosition:
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20060906131836:c.setRootVnode New in 4.4.2
def setRootVnode (self, v):

    c = self
    newRoot = leoNodes.position(v)
    c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20060906131836:c.setRootVnode New in 4.4.2
#@-node:ekr.20081022105412.1:Missing _rootPosition
#@+node:ekr.20081021132739.2:Selection problem with optimized code
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        flag = c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        if redraw or flag:
            c.redraw()

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20080416161551.211:p.moveToVisNext
def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        if trace: g.trace(
            'hasChildren',p.hasChildren(),
            'isExpanded',p.isExpanded(),
            p.headString())
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p
#@nonl
#@-node:ekr.20080416161551.211:p.moveToVisNext
#@-node:ekr.20081021132739.2:Selection problem with optimized code
#@+node:ekr.20081021132739.3:Calls to redraw_after_expand
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; p = c.currentPosition()

    p.expand()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    if not p.isExpanded():
        c.expandNode()

    c.selectVnode(p.firstChild())
    c.redraw()
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.selectVnode(p.firstChild())
            c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@-node:ekr.20081021132739.3:Calls to redraw_after_expand
#@+node:ekr.20081021132739.1:Editing healdines
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)

        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace('leoTree',p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        self.endEditLabel()
        # This redraw *is* required so the c.edit_widget(p) will exist.
        c.redraw()
        c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if trace: g.trace('1','w',w,'focus',g.app.gui.get_focus(c))

    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
        c.k.showStateAndMode(w)

    if trace: g.trace('w',w,'focus',g.app.gui.get_focus(c))
#@-node:ekr.20040803072955.127:tree.editLabel
#@-node:ekr.20081021132739.1:Editing healdines
#@+node:ekr.20081019081958.1:Problems with multiple windows
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    # if not g.app.initing:
        # g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.currentPosition()
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.currentPosition()) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20081019081958.1:Problems with multiple windows
#@+node:ekr.20081023124006.1:Colorizing
#@+node:ekr.20080514131122.20:c.outerUpdate
def outerUpdate (self):

    c = self ; aList = [] ; trace = False ; verbose = True

    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    scrollFlag = c.requestRedrawScrollFlag
    c.requestRedrawFlag = False
    c.requestRedrawScrollFlag = False

    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        # g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw') # : scroll: %s' % (c.requestRedrawScrollFlag))
        c.frame.tree.redraw_now(scroll=scrollFlag,forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        c.recolor_now(incremental=c.incrementalRecolorFlag)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if verbose: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList),c.shortFileName() or '<no name>',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''
    c.requestedRedrawScrollFlag = False
#@-node:ekr.20080514131122.20:c.outerUpdate
#@+node:ekr.20080514131122.13:c.recolor_now
def recolor_now(self,p=None,incremental=False,interruptable=True):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,
        incremental=incremental,interruptable=interruptable)
#@-node:ekr.20080514131122.13:c.recolor_now
#@+node:ekr.20080514131122.12:c.recolor & requestRecolor
def requestRecolor (self):

    c = self
    # g.trace(g.callers(4))
    c.requestRecolorFlag = True

recolor = requestRecolor
#@-node:ekr.20080514131122.12:c.recolor & requestRecolor
#@-node:ekr.20081023124006.1:Colorizing
#@+node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@+node:ekr.20070130115927.5:copyText
def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
#@-node:ekr.20070130115927.5:copyText
#@+node:ekr.20070130115927.6:leoFrame.cutText
def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
#@-node:ekr.20070130115927.6:leoFrame.cutText
#@+node:ekr.20070130115927.7:leoFrame.pasteText
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    s = g.toUnicode(s,encoding=g.app.tkEncoding)

    # g.trace('pasteText','wname',wname,'s',s,g.callers())

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20070130115927.7:leoFrame.pasteText
#@+node:ekr.20061016071937:OnPaste (To support middle-button paste)
def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)
#@nonl
#@-node:ekr.20061016071937:OnPaste (To support middle-button paste)
#@-node:ekr.20070130115927.4:Cut/Copy/Paste (leoFrame)
#@+node:ekr.20081026160305.3:Found: .redraw_after
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)
    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    c.redraw()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20080904071003.14:goto_showResults
def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    c.redraw()

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace(p.headString(),g.callers())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20080904071003.14:goto_showResults
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = c.scanAllDirectives()
    tabWidth  = d.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree_iter():
        # g.trace(p.headString(),tabWidth)
        innerUndoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = c.convertBlanks(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            changed = False ; result = []
            text = p.t._bodyString
            assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,innerUndoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("blanks converted to tabs in",count,"nodes") # Must come before c.redraw().
    if count > 0:
        c.redraw()
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self,event=None):

    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = c.scanAllDirectives()
    tabWidth  = theDict.get("tabwidth")
    count = 0 ; dirtyVnodeList = []
    u.beforeChangeGroup(current,undoType)
    for p in current.self_and_subtree_iter():
        undoData = u.beforeChangeNodeContents(p)
        if p == current:
            changed,dirtyVnodeList2 = self.convertTabs(event)
            if changed:
                count += 1
                dirtyVnodeList.extend(dirtyVnodeList2)
        else:
            result = [] ; changed = False
            text = p.t._bodyString
            assert(g.isUnicode(text))
            lines = text.split('\n')
            for line in lines:
                i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                if s != line: changed = True
                result.append(s)
            if changed:
                count += 1
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                result = '\n'.join(result)
                p.setBodyString(result)
                u.afterChangeNodeContents(p,undoType,undoData)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    if not g.unitTesting:
        g.es("tabs converted to blanks in",count,"nodes")
    if count > 0:
        c.redraw()
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.setChanged(True)
    if p.isDirty():
        dirtyVnodeList = []
    else:
        dirtyVnodeList = p.setDirty()
    c.redraw()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
    c.endEditing()
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)
    # paste as first child if back is expanded.
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw()
    c.recolor()
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_vnodes_iter():
    t = v.t
    if t not in tnodeInfoDict:
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=v.headString(),body=v.bodyString())
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict:
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.selectPosition(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)

    c.redraw()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    p.contract()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.expandSubtree(v)
    while child:
        c.expandSubtree(child)
        child = child.next()
    c.selectVnode(v)
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; p = c.currentPosition()

    p.expand()
    c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    if not p.isExpanded():
        c.expandNode()

    c.selectVnode(p.firstChild())
    c.redraw()
    c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.selectVnode(p.firstChild())
            c.redraw()
    c.treeFocusHelper()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    u.beforeChangeGroup(current,undoType)
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType)
    if not g.unitTesting:
        g.es("done",color="blue")
    c.redraw()

#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty
def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    while p:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty
def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode() and not p.isDirty():
            p.setDirty()
            c.setChanged(True)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw()

#@-node:ekr.20031218072017.2926:markAtFileNodesDirty
#@+node:ekr.20031218072017.2927:markClones
def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('the current node is not a clone',color='blue')
        return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.v.t == current.v.t:
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            c.setChanged(True)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline & est
def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    undoType = g.choose(p.isMarked(),'Unmark','Mark')
    bunch = u.beforeMark(p,undoType)
    if p.isMarked():
        c.clearMarked(p)
    else:
        c.setMarked(p)
    dirtyVnodeList = p.setDirty()
    c.setChanged(True)
    u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2928:markHeadline & est
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    dirtyVnodeList = []
    for p in current.children_iter():
        if not p.isMarked():
            bunch = u.beforeMark(p,undoType)
            c.setMarked(p)
            dirtyVnodeList2 = p.setDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMark(p,undoType,bunch)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    u.beforeChangeGroup(current,undoType)
    changed = False
    for p in c.all_positions_with_unique_vnodes_iter():
        if p.isMarked():
            bunch = u.beforeMark(p,undoType)
            # c.clearMarked(p) # Very slow: calls a hook.
            p.v.clearMarked()
            p.v.t.setDirty()
            u.afterMark(p,undoType,bunch)
            changed = True
    dirtyVnodeList = [p.v for p in c.all_positions_with_unique_vnodes_iter() if p.v.isDirty()]
    if changed:
        g.doHook("clear-all-marks",c=c,p=p,v=p)
        c.setChanged(True)
    u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

#@-node:ekr.20031218072017.2930:unmarkAll
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    p = c.currentPosition()
    if not p or not p.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,p,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.t.children[n+1:]
    # g.trace('sibs2\n',g.listToString(followingSibs2))
    # Adjust the parent links of all moved nodes.
    parent_v._computeParentsOfChildren(children=followingSibs)
    # Remove the moved nodes from the parent's children.
    parent_v.t.children = parent_v.t.children[:n+1]
    # Add the moved nodes to p's children
    p.v.t.children.extend(followingSibs)
    p.expand()
    # Even if p is an @ignore node there is no need to mark the demoted children dirty.
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterDemote(p,followingSibs,dirtyVnodeList)
    c.selectPosition(p)  # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    << Move p down & set moved if successful >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.moveAfter(parent)
    if inAtIgnoreRange and not p.inAtIgnoreRange():
        # The moved nodes have just become newly unignored.
        p.setDirty() # Mark descendent @thin nodes dirty.
    else: # No need to mark descendents dirty.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
    if sparseMove: # New in Leo 4.4.2
        parent.contract()
    c.selectPosition(p) # Also sets rootPosition.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back,n)
    # g.trace(p,p.parent())
    # Moving an outline right can never bring it outside the range of @ignore.
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
    dirtyVnodeList.extend(dirtyVnodeList2)
    c.setChanged(True)
    u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    << Move p up >>
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.selectPosition(p) # Also sets root position.
    c.redraw()
    c.treeFocusHelper()

    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; cc = c.chapterController ; p = c.currentPosition()
    if not p: return
    if not p.isCloned():
        g.es('not a clone:',p.headString(),color='blue')
        return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")

    if cc:
        name = cc.findChapterNameForPosition(p)
        cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)

    c.selectPosition(p)
    c.redraw()
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20071213123942:findNextClone
def findNextClone (self,event=None):

    '''Select the next cloned node.'''

    c = self ; p = c.currentPosition() ; flag = False
    if not p: return

    if p.isCloned():
        p.moveToThreadNext()

    while p:
        if p.isCloned():
            flag = True ; break
        else:
            p.moveToThreadNext()

    if flag:
        cc = c.chapterController
        if cc:
            name = cc.findChapterNameForPosition(p)
            cc.selectChapterByName(name)
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
    else:
        g.es('no more clones',color='blue')
#@-node:ekr.20071213123942:findNextClone
#@+node:ekr.20070226113916: treeSelectHelper
def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        flag = c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        if redraw or flag:
            c.redraw()

    c.treeFocusHelper()
#@-node:ekr.20070226113916: treeSelectHelper
#@+node:ekr.20081020151805.2:c.redraw_after methods (new)
def redraw_after_icons_changed(self,all=False):
    return self.frame.tree.redraw_after_icons_changed(all)
def redraw_after_clone(self):
    return self.frame.tree.redraw_after_clone()
def redraw_after_contract(self):
    return self.frame.tree.redraw_after_contract()
def redraw_after_delete(self):
    return self.frame.tree.redraw_after_delete()
def redraw_after_expand(self):
    return self.frame.tree.redraw_after_expand()
def redraw_after_insert(self):
    return self.frame.tree.redraw_after_insert()
def redraw_after_move_down(self):
    return self.frame.tree.redraw_after_move_down()
def redraw_after_move_left(self):
    return self.frame.tree.redraw_after_move_left()
def redraw_after_move_right(self):
    return self.frame.tree.redraw_after_move_right()
def redraw_after_move_up(self):
    return self.frame.tree.redraw_after_move_up()
def redraw_after_select(self):
    return self.frame.tree.redraw_after_select()
#@-node:ekr.20081020151805.2:c.redraw_after methods (new)
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t._bodyString != s:
        v.setBodyString(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        c.redraw()
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20060923202156:c.onCanvasKey
def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    # g.trace(event and event.char)

    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.currentPosition() ; p1 = p.copy()
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event.char
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        if allFlag:
            c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.headString())
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
#@+node:ekr.20061002095711.1:c.navQuickKey
def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        return nearTime
#@nonl
#@-node:ekr.20061002095711.1:c.navQuickKey
#@+node:ekr.20061002095711:c.navHelper
def navHelper (self,p,ch,extend):

    c = self ; h = p.headString().lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent','noref'):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@nonl
#@-node:ekr.20061002095711:c.navHelper
#@-node:ekr.20060923202156:c.onCanvasKey
#@+node:ekr.20050920084036.35:appendToBuffer
def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Append to buffer: ')
    self.getBufferName(self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        w = self.w
        c.selectPosition(p)
        self.beginCommand('append-to-buffer: %s' % p.headString())
        w.insert('end',s)
        w.setInsertPoint('end')
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@nonl
#@-node:ekr.20050920084036.35:appendToBuffer
#@+node:ekr.20050920084036.36:copyToBuffer
def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Copy to buffer: ')
    self.getBufferName(self.copyToBufferFinisher)

def copyToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('copy-to-buffer: %s' % p.headString())
        w.insert('end',s)
        w.setInsertPoint('end')
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@-node:ekr.20050920084036.36:copyToBuffer
#@+node:ekr.20050920084036.37:insertToBuffer
def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('insert-to-buffer: %s' % p.headString())
        i = w.getInsertPoint()
        w.insert(i,s)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
#@-node:ekr.20050920084036.37:insertToBuffer
#@+node:ekr.20050920084036.39:prependToBuffer
def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('prepend-to-buffer: %s' % p.headString())
        w.insert(0,s)
        w.setInsertPoint(0)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw()
        c.recolor_now()
#@-node:ekr.20050920084036.39:prependToBuffer
#@+node:ekr.20050920084036.43:renameBuffer
def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.setHeadString(p,name)
        c.redraw()
#@-node:ekr.20050920084036.43:renameBuffer
#@+node:ekr.20050920084036.40:switchToBuffer
def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.selectPosition(p)
        c.redraw()

#@-node:ekr.20050920084036.40:switchToBuffer
#@+node:ekr.20071114082418:deleteFirstIcon
def deleteFirstIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[1:])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114082418:deleteFirstIcon
#@+node:ekr.20071114092622:deleteIconByName
def deleteIconByName (self,t,name,relPath):
    """for use by the right-click remove icon callback"""
    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)
    if not aList: return

    basePath = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    absRelPath = c.os_path_finalize_join(basePath,relPath)
    name = c.os_path_finalize(name)

    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = c.os_path_finalize(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)

    if len(newList) != len(aList):
        self.setIconList(p, newList)       
        c.setChanged(True)
        c.redraw()
    else:
        g.trace('not found',name)



#@-node:ekr.20071114092622:deleteIconByName
#@+node:ekr.20071114085054:deleteLastIcon
def deleteLastIcon (self,event=None):

    c = self.c ;  p = c.currentPosition()

    c = self.c ; p = c.currentPosition()

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[:-1])
        c.setChanged(True)
        c.redraw()
#@nonl
#@-node:ekr.20071114085054:deleteLastIcon
#@+node:ekr.20071114082418.1:deleteNodeIcons
def deleteNodeIcons (self,event=None):

    c = self.c ; p = c.currentPosition()

    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        p.v.t._p_changed = 1
        self.setIconList(p,[])
        a["lineYOffset"] = 0
        p.setDirty()
        c.setChanged(True)
        c.redraw()
#@-node:ekr.20071114082418.1:deleteNodeIcons
#@+node:ekr.20071114081313.1:insertIcon
def insertIcon (self,event=None):

    c = self.c ; p = c.currentPosition()

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20071114081313.1:insertIcon
#@+node:ekr.20080108090719:insertIconFromFile
def insertIconFromFile (self,path,p=None,pos=None,**kargs):

    c = self.c
    if p is None: p = c.currentPosition()

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    aList = [] ; xoffset = 2
    xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset,**kargs)

    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos,aList[0])
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw()
#@-node:ekr.20080108090719:insertIconFromFile
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.selectPosition(p)
            c.redraw()


            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.selectPosition(p)
            c.redraw()

            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    w = c.frame.body.bodyCtrl
    aspell = self.aspell ; alts = None ; word = None
    sparseFind = c.config.getBool('collapse_nodes_while_spelling')
    trace = False
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.headString() or '<no p>')
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.headString() or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if sparseFind and not c.currentPosition().isAncestorOf(p):
                    for p2 in c.currentPosition().self_and_parents_iter():
                        p2.contract()
                        redraw = True
                for p2 in p.parents_iter():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                # c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                if redraw:
                    c.redraw()
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if word.lower() in self.dictionary:
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20031218072017.1720:save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        self.putSavedMessage(fileName)
        if ok:
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@-node:ekr.20031218072017.1720:save (fileCommands)
#@+node:ekr.20031218072017.3043:saveAs
def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        if self.write_Leo_file(fileName,False): # outlineOnlyFlag
            c.setChanged(False) # Clears all dirty bits.
            self.putSavedMessage(fileName)
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3043:saveAs
#@+node:ekr.20031218072017.3044:saveTo
def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        self.write_Leo_file(fileName,False) # outlineOnlyFlag
        self.putSavedMessage(fileName)
        c.redraw()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
#@-node:ekr.20031218072017.3044:saveTo
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    if sparseFind and not c.currentPosition().isAncestorOf(p):
        # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
        for p2 in c.currentPosition().self_and_parents_iter():
            p2.contract()
            redraw = True
    for p in self.p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw = True
    p = self.p
    if not p: g.trace('can not happen: self.p is None')

    c.selectPosition(p)
    if redraw:
        c.redraw_now() # was c.redraw.
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    if not w: return
    c.widgetWantsFocusNow(w)
    c.k.showStateAndMode(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20070423102603:selectEditorHelper
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    # g.trace('expanding ancestors of ',w.leo_p.headString(),g.callers())
    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p) # Calls assignPositionToEditor.
    c.redraw()

    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@+node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20070423102603:selectEditorHelper
#@+node:ekr.20031218072017.3896:go
def go(self,event=None):

    """Handle clicks in the "go" button in a list box dialog."""

    c = self.c ; box = self.box

    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        p = self.positionList[n]
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
#@-node:ekr.20031218072017.3896:go
#@-node:ekr.20081026160305.3:Found: .redraw_after
#@+node:ekr.20081025160314.1:Selecting a new node
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    c = self.c ; cc = c.chapterController ; redraw_flag = False
    # inChapter = cc and cc.inChapter()

    for p in p.parents_iter():
        # g.trace('testing',p)
        if cc and p.headString().startswith('@chapter'):
            break
        if not p.isExpanded():
            # g.trace('inChapter',inChapter,'p',p,g.callers())
            p.expand()
            redraw_flag = True

    return redraw_flag
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    if sparseFind and not c.currentPosition().isAncestorOf(p):
        # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
        for p2 in c.currentPosition().self_and_parents_iter():
            p2.contract()
            redraw = True
    for p in self.p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw = True
    p = self.p
    if not p: g.trace('can not happen: self.p is None')

    c.selectPosition(p)
    if redraw:
        c.redraw_now() # was c.redraw.
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    if not w: return
    c.widgetWantsFocusNow(w)
    c.k.showStateAndMode(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    # g.trace('leoTree',p and p.headString(),g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; trace = False
    w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw(scroll=False)
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.128:leoTree.select & helper
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.currentPosition()
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.treeSelectHelper(p,scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:treeSelectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,scroll):

    c = self.c ; frame = c.frame ; trace = False
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.currentPosition()

    if not p:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace: g.trace(
        '\nold:',old_p and old_p.headString(),
        '\nnew:',p and p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p: ### c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t._bodyString,"utf-8")
old_s = w.getAllText()

if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:treeSelectHelper
#@-node:ekr.20040803072955.128:leoTree.select & helper
#@-node:ekr.20081025160314.1:Selecting a new node
#@+node:ekr.20081029075424.1:Closing & reopening windows
#@+node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@-node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    # g.trace('frame',frame,g.callers(4))

    c.endEditing() # Commit any open edits.

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocusNow()
        frame.c.outerUpdate()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@+node:ekr.20031218072017.2615:app.destroyWindow
def destroyWindow (self,frame):

    # g.trace(frame in g.app.windowList,frame)
    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        # g.trace(g.app.windowList)
        g.app.windowList.remove(frame)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()
#@-node:ekr.20031218072017.2615:app.destroyWindow
#@+node:ekr.20031218072017.3692:promptForSave (leoFrame)
def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # g.pr(answer)
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            << Put up a file save dialog to set mFileName >>
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@+node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
# Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
#@-node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
#@-node:ekr.20031218072017.3692:promptForSave (leoFrame)
#@-node:ekr.20081029075424.1:Closing & reopening windows
#@-node:ekr.20081019140728.1:New in qtGui branch
#@+node:ekr.20081011035102.2:Key stuff...
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand ; verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)
        # g.trace('callers',g.callers(5))
            # 'state.kind:',k.state.kind),'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
# g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

# g.trace('w_name',w_name,'stroke',stroke,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(d.keys(),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    k = self ; c = k.c ; trace = False
    modesTuple = ('insert','overwrite')

    if trace:
        # if stroke: g.trace('***unexpected stroke***')
        g.trace('keysym:',repr(event.keysym),'ch:',repr(event.char))
            # 'state.kind:',k.state.kind),'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20070423101911:treeSelectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,scroll):

    c = self.c ; frame = c.frame ; trace = False
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.currentPosition()

    if not p:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace: g.trace(
        '\nold:',old_p and old_p.headString(),
        '\nnew:',p and p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p: ### c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t._bodyString,"utf-8")
old_s = w.getAllText()

if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:treeSelectHelper
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'

    trace = True
    << set local vars >>
    if trace: g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = c.scanAllDirectives(p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20080610085158.2:c.add_command
def add_command (self,menu,**keys):

    c = self ; command = keys.get('command')

    if command:

        def add_commandCallback(c=c,command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys ['command'] = add_commandCallback

        menu.add_command(**keys)

    else:
        g.trace('can not happen: no "command" arg')
#@-node:ekr.20080610085158.2:c.add_command
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20061031131434.111:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):

    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            g.trace('*** tab completion')
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20061031131434.111:fullCommand (alt-x) & helper
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    # g.trace('ins',ins,'prefix',k.mb_prefix)
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@+node:ekr.20061031131434.178:k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.minibufferWantsFocusNow()
#@-node:ekr.20061031131434.178:k.doTabCompletion
#@+node:ekr.20050920084036.138:insertNewLine (changed)
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    oldSel = w.getSelectionRange()
    # g.trace('oldSel',oldSel)

    self.beginCommand(undoType='newline')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand()

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (changed)
#@-node:ekr.20081011035102.2:Key stuff...
#@+node:ekr.20081030074602.2:Tree selection stuff...
#@+node:ekr.20070418073400:g.app.config.printSettings & helper
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following letters indicate where the active setting came from:

    - D indicates default settings.
    - F indicates the file being loaded,
    - L indicates leoSettings.leo,
    - M indicates myLeoSettings.leo,
    '''

    settings = {} # Keys are setting names, values are (letter,val)

    if c:
        d = self.localOptionsDict.get(c.hash())
        self.printSettingsHelper(settings,d,letter='[F]')

    for d in self.localOptionsList:
        self.printSettingsHelper(settings,d)

    for d in self.dictList:
        self.printSettingsHelper(settings,d)

    result = []
    for key in sorted(settings):
        data = settings.get(key)
        letter,val = data
        # g.pr('%45s = %s %s' % (key,letter,val))
        result.append('%s %s = %s\n' % (letter,key,val))

    # Use a single g.es statement.
    g.es('',''.join(result),tabName='Settings')

#@+node:ekr.20070418075804:printSettingsHelper
def printSettingsHelper(self,settings,d,letter=None):

    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')

    if d:
        << set letter >>
        for key in d:
            if key not in suppressKeys and key not in settings:
                bunch = d.get(key)
                if bunch.kind not in suppressKind:
                    settings[key] = (letter,bunch.val)
#@nonl
#@+node:ekr.20070418084502:<< set letter >>
theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

# g.trace(letter,theHash)
#@nonl
#@-node:ekr.20070418084502:<< set letter >>
#@-node:ekr.20070418075804:printSettingsHelper
#@-node:ekr.20070418073400:g.app.config.printSettings & helper
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace('leoTree',p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        self.endEditLabel()
        # This redraw *is* required so the c.edit_widget(p) will exist.
        c.redraw()
        c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if trace: g.trace('1','w',w,'focus',g.app.gui.get_focus(c))

    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
        c.k.showStateAndMode(w)

    if trace: g.trace('w',w,'focus',g.app.gui.get_focus(c))
#@-node:ekr.20040803072955.127:tree.editLabel
#@+node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; trace = False
    w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw(scroll=False)
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    # g.trace('leoTree',p and p.headString(),g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20040803072955.90:head key handlers (leoTree)
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(p)
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)

    c.redraw()

    c.editPosition(p,selectAll=True)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)

        c.frame.tree.editLabel(p,selectAll=selectAll)

        if k:
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@+node:ekr.20040803072955.128:leoTree.select & helper
tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.currentPosition()
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.treeSelectHelper(p,scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
#@+node:ekr.20070423101911:treeSelectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,scroll):

    c = self.c ; frame = c.frame ; trace = False
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.currentPosition()

    if not p:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace: g.trace(
        '\nold:',old_p and old_p.headString(),
        '\nnew:',p and p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p: ### c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t._bodyString,"utf-8")
old_s = w.getAllText()

if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:treeSelectHelper
#@-node:ekr.20040803072955.128:leoTree.select & helper
#@+node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):

    c = self ; k = c.k

    c.frame.tree.endEditLabel()

    c.frame.tree.setSelectedLabelState(p=c.currentPosition())

    # The following code would be wrong; c.endEditing is a utility method.
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.bodyCtrl)
#@-node:ekr.20031218072017.2992:c.endEditing (calls tree.endEditLabel)
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    # g.trace('leoTree',p and p.headString(),g.callers(4))

    self.setEditPosition(None) # That is, self._editPosition = None

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
        k.setDefaultInputState()
        k.showStateAndMode()

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
#@-node:ekr.20040803072955.126:endEditLabel
#@-node:ekr.20081030074602.2:Tree selection stuff...
#@+node:ekr.20081110080625.5:Running unit tests
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    c = self.c

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20080416161551.210:p.moveToVisBack
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    if trace: g.trace('limit',limit,'limitIsVisible',limitIsVisible)

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if trace: g.trace(
            'back',back,'hasChildren',bool(back and back.hasChildren()),
            'isExpanded',bool(back and back.isExpanded()))
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done:
                if trace: g.trace('done')
                return val
            if p.isVisible(c):
                if trace: g.trace('isVisible')
                return p
    else:
        # assert not p.
        return p
#@-node:ekr.20080416161551.210:p.moveToVisBack
#@+node:ekr.20070609122713:c.visLimit
def visLimit (self):

    '''Return the topmost visible node.
    This is affected by chapters and hoists.'''

    c = self ; cc = c.chapterController

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.headString().startswith('@chapter')
        return p,limitIsVisible
    else:
        return None,None
#@-node:ekr.20070609122713:c.visLimit
#@+node:ekr.20080416161551.196:p.isVisible
def isVisible (self,c):

    p = self ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # It's much easier with a full stack.
    n = len(p.stack)-1
    while n >= 0:
        progress = n
        # v,n = p.vParentWithStack(v,p.stack,n)
        v,junk = p.stack[n]
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded:',v.t._headString,p.headString())
            return False
        n -= 1
        assert progress > n

    return True
#@-node:ekr.20080416161551.196:p.isVisible
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.endEditing() # Make sure we capture the headline for Undo.

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
                return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    undoData = u.beforeDeleteNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    p.doDelete(newNode)
    c.selectPosition(newNode)
    c.setChanged(True)
    u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redraw()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@-node:ekr.20081110080625.5:Running unit tests
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
