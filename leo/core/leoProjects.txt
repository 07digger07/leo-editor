#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071217134533:Pylint
#@+node:ekr.20071217231348:Pylint docs
@nocolor



















#@+node:ekr.20071217231348.1:options
General options

rcfile:	Specify a configuration file.
init-hook:	Python code to execute, usually for sys.path manipulation such as pygtk.require().
rpython-mode:	enable the rpython checker which is disabled by default
errors-only:	In debug mode, checkers without error messages are disabled and for others, only the ERROR messages are displayed, and no reports are done by default
profile:	Profiled execution.
ignore:	Add <file or directory> to the black list. It should be a base name, not a path. You may set this option multiple times. Default: CVS
persistent:	Pickle collected data for later comparisons. Default: yes
cache-size:	Set the cache size for astng objects. Default: 500
load-plugins:	List of plugins (as comma separated values of python modules names) to load, usually to register additional checkers.

Commands options

help-msg:	Display a help message for the given message id and exit. The value may be a comma separated list of message ids.
list-msgs:	Generate pylint's full documentation.
generate-rcfile:
 	Generate a sample configuration file according to the current configuration. You can put other options before this one to get them in the generated configuration.
generate-man:	Generate pylint's man page.

Messages control options

enable-checker:	Enable only checker(s) with the given id(s). This option conflict with the disable-checker option
disable-checker: Enable all checker(s) except those with the given id(s). This option conflict with the disable-checker option
enable-msg-cat:	Enable all messages in the listed categories.
disable-msg-cat: Disable all messages in the listed categories.
enable-msg:	Enable the message(s) with the given id(s).
disable-msg:	Disable the message(s) with the given id(s).

Reports options

output-format:	set the output format. Available formats are text, parseable, colorized, msvs (visual studio) and html Default: text
include-ids:	Include message's id in output
files-output:	Put messages in a separate file for each module / package specified on the command line instead of printing them on stdout. Reports (if any) will be written in a file name "pylint_global.[txt|html]".
reports:	Tells wether to display a full report or only the messages Default: yes
evaluation:	Python expression which should return a note less than 10 (10 is the highest note).You have access to the variables errors warning, statement which respectivly contain the number of errors / warnings messages and the total number of statements analyzed. This is used by the global evaluation report (R0004). Default: 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
comment:	Add a comment according to your evaluation note. This is used by the global evaluation report (R0004).
enable-report:	Enable the report(s) with the given id(s).
disable-report:	Disable the report(s) with the given id(s).
#@nonl
#@-node:ekr.20071217231348.1:options
#@+node:ekr.20071217231348.2:Main messages and reports
Main messages

E0001:	Used when a syntax error is raised for a module.
E0011:	Unrecognized file option %r Used when an unknown inline option is encountered.
E0012:	Bad option value %r Used when a bad value for an inline option is encountered.

I0001:	Unable to run raw checkers on built-in module %s Used to inform that a built-in module has not been checked using the raw checkers.
I0010:	Unable to consider inline option %r Used when an inline option is either badly formatted or can't be used inside modules.
I0011:	Locally disabling %s Used when an inline option disable a message or a messages category.
I0012:	Locally enabling %s Used when an inline option enable a message or a messages category.
I0013:	Ignoring entire file Used to inform that the file will not be checked
F0001:	Used when an error occured preventing the analyzing of a module (unable to find it for instance).
F0002:	%s: %s Used when an unexpected error occured while building the ASTNG representation. This is usually accomopagned by a traceback. Please report such errors !
F0003:	ignored builtin module %s Used to indicate that the user asked to analyze a builtin module which has been skipped.
F0004:	unexpected infered value %s Used to indicate that some value of an unexpected type has been infered.

Main reports

R0001:	Messages by category
R0002:	% errors / warnings by module
R0003:	Messages
R0004:	Global evaluation
#@nonl
#@-node:ekr.20071217231348.2:Main messages and reports
#@+node:ekr.20071217231348.3:Basic
Basic checker

Options

required-attributes:
 	Required attributes for module, separated by a comma
no-docstring-rgx:
 	Regular expression which should only match functions or classes name which do not require a docstring Default: __.*__
module-rgx:	Regular expression which should only match correct module names Default: (([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$
const-rgx:	Regular expression which should only match correct module level names Default: (([A-Z_][A-Z1-9_]*)|(__.*__))$
class-rgx:	Regular expression which should only match correct class names Default: [A-Z_][a-zA-Z0-9]+$
function-rgx:	Regular expression which should only match correct function names Default: [a-z_][a-z0-9_]{2,30}$
method-rgx:	Regular expression which should only match correct method names Default: [a-z_][a-z0-9_]{2,30}$
attr-rgx:	Regular expression which should only match correct instance attribute names Default: [a-z_][a-z0-9_]{2,30}$
argument-rgx:	Regular expression which should only match correct argument names Default: [a-z_][a-z0-9_]{2,30}$
variable-rgx:	Regular expression which should only match correct variable names Default: [a-z_][a-z0-9_]{2,30}$
inlinevar-rgx:	Regular expression which should only match correct list comprehension / generator expression variable names Default: [A-Za-z_][A-Za-z0-9_]*$
good-names:	Good variable names which should always be accepted, separated by a comma Default: i,j,k,ex,Run,_
bad-names:	Bad variable names which should always be refused, separated by a comma Default: foo,bar,baz,toto,tutu,tata
bad-functions:	List of builtins function names that should not be used, separated by a comma Default: map,filter,apply,input

Messages

E0100:	__init__ method is a generator Used when the special class method __init__ is turned into a generator by a yield in its body.
E0101:	Explicit return in __init__ Used when the special class method __init__ has an explicit return value.
E0102:	%s already defined line %s Used when a function / class / method is redefined.
E0103:	%r not properly in loop Used when break or continue keywords are used outside a loop.
E0104:	return outside function Used when a "return" statement is found outside a function or method.
E0105:	yield outside function Used when a "yield" statement is found outside a function or method.
E0106:	return with argument inside generator Used when a "return" statement with an argument is found outside in a generator function or method (e.g. with some "yield" statements).

W0101:	Unreachable code Used when there is some code behind a "return" or "raise" statement, which will never be accessed.
W0102:	Dangerous default value %s as argument Used when a mutable value as list or dictionary is detected in a default value for an argument.
W0104:	Statement seems to have no effect Used when a statement doesn't have (or at least seems to) any effect.
W0105:	String statement has no effect Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments.
W0106:	Unnecessary semicolon Used when a statement is endend by a semi-colon (";"), which isn't necessary (that's python, not C ;).
W0107:	Unnecessary pass statement Used when a "pass" statement that can be avoided is encountered.)
W0122:	Use of the exec statement Used when you use the "exec" statement, to discourage its usage. That doesn't mean you can not use it !
W0141:	Used builtin function %r Used when a black listed builtin function is used (see the bad-function option). Usual black listed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.
W0142:	Used * or * magic* Used when a function or method is called using *args or **kwargs to dispatch arguments. This doesn't improve readility and should be used with care.

C0102:	Black listed name "%s" Used when the name is listed in the black list (unauthorized names).
C0103:	Invalid name "%s" (should match %s) Used when the name doesn't match the regular expression associated to its type (constant, variable, class...).
C0111:	Missing docstring Used when a module, function, class or method has no docstring. Some special methods like __init__ doesn't necessary require a docstring.
C0112:	Empty docstring Used when a module, function, class or method has an empty docstring (it would be too easy ;).
C0121:	Missing required attribute "%s" Used when an attribute required for modules is missing.

Reports

R0101:	Statistics by type
#@-node:ekr.20071217231348.3:Basic
#@+node:ekr.20071217231348.4:Type
Typecheck checker

Options

ignore-mixin-members:
 	Tells wether missing members accessed in mixin class should be ignored. A mixin class is detected if its name ends with "mixin" (case insensitive). Default: yes
zope:	When zope mode is activated, consider the acquired-members option to ignore access to some undefined attributes.
acquired-members:
 	List of members which are usually get through zope's acquisition mecanism and so shouldn't trigger E0201 when accessed (need zope=yes to be considered). Default: REQUEST,acl_users,aq_parent

Messages

E1101:	%s %r has no %r member  A variable is accessed for an unexistant member.
E1102:	%s is not callable      An object being called has been infered to a non callable object
E1103:	%s %r has no %r member (but some types could not be inferred) 
                               A variable is accessed for an unexistant member, but astng was not able to interpret all possible types of this variable.
E1111:	Assigning to function call which doesn't return     An assigment is done on a function call but the infered function doesn't return anything.
W1111:	Assigning to function call which only returns None  An assigment is done on a function call but the infered function returns nothing but None.
#@nonl
#@-node:ekr.20071217231348.4:Type
#@+node:ekr.20071217231348.5:Variables
Variables checker

Options

init-import:	Tells wether we should check for unused import in __init__ files.
dummy-variables-rgx:
 	A regular expression matching names used for dummy variables (i.e. not used). Default: _|dummy
additional-builtins:
 	List of additional names supposed to be defined in builtins. Remember that you should avoid to define new builtins when possible.

Messages

E0601:	Using variable %r before assignment Used when a local variable is accessed before it's assignment.
E0602:	Undefined variable %r Used when an undefined variable is accessed.
E0611:	No name %r in module %r Used when a name cannot be found in a module.

W0601:	Global variable %r undefined at the module level Used when a variable is defined through the "global" statement but the variable is not defined in the module scope.
W0602:	Using global for %r but no assigment is done Used when a variable is defined through the "global" statement but no assigment to this variable is done.
W0603:	Using the global statement Used when you use the "global" statement to update a global variable.
PyLint just try to discourage this usage. That doesn't mean you can not use it !
W0604:	Using the global statement at the module level Used when you use the "global" statement at the module level since it has no effect
W0611:	Unused import %s Used when an imported module or variable is not used.
W0612:	Unused variable %r Used when a variable is defined but not used.
W0613:	Unused argument %r Used when a function or method argument is not used.
W0614:	Unused import %s from wildcard import Used when an imported module or variable is not used from a 'from X import *' style import.

W????: Inline emphasis start-string without end-string.
W0621:	Redefining name %r from outer scope (line %s) Used when a variable's name hide a name defined in the outer scope.
W0622:	Redefining built-in %r Used when a variable or function override a built-in.
W0631:	Using possibly undefined loop variable %r Used when an loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.
#@nonl
#@-node:ekr.20071217231348.5:Variables
#@+node:ekr.20071217231501:Classes
Classes checker

Options

ignore-iface-methods:
 	List of interface methods to ignore, separated by a comma. This is used for instance to not check methods defines in Zope's Interface base class. Default: isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf,adaptWith,is_implemented_by
defining-attr-methods:
 	List of method names used to declare (i.e. assign) instance attributes. Default: __init__,__new__,setUp

Messages

E0202:	An attribute inherited from %s hide this method Used when a class defines a method which is hiden by an instance attribute from an ancestor class.
E0203:	Access to member %r before its definition line %s Used when an instance member is accessed before it's actually assigned.
E0211:	Method has no argument Used when a method which should have the bound instance as first argument has no argument defined.
E0213:	Method should have "self" as first argument Used when a method has an attribute different the "self" as first argument. This is considered as an error since this is a soooo common convention that you should'nt break it!
E0221:	Interface resolved to %s is not a class Used when a class claims to implement an interface which is not a class.
E0222:	Missing method %r from %s interface Used when a method declared in an interface is missing from a class implementing this interface

W0201:	Attribute %r defined outside __init__ Used when an instance attribute is defined outside the __init__ method.
W0211:	Static method with %r as first argument Used when a static method has "self" or "cls" as first argument.
W0212:	Access to a protected member %s of a client class Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined.
W0221:	Arguments number differs from %s method Used when a method has a different number of arguments than in the implemented interface or in an overridden method.
W0222:	Signature differs from %s method Used when a method signature is different than in the implemented interface or in an overridden method.
W0223:	Method %r is abstract in class %r but is not overridden Used when an abstract method (ie raise NotImplementedError) is not overridden in concrete class.
W0231:	__init__ method from base class %r is not called Used when an ancestor class method has an __init__ method which is not called by a derived class.
W0232:	Class has no __init__ method Used when a class has no __init__ method, neither its parent classes.
W0233:	__init__ method from a non direct base class %r is called Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.
R0201:	Method could be a function Used when a method doesn't use its bound instance, and so could be written as a function.
C0202:	Class method should have "cls" as first argument Used when a class method has an attribute different than "cls" as first argument, to easily differentiate them from regular instance methods.
C0203:	Metaclass method should have "mcs" as first argument Used when a metaclass method has an attribute different the "mcs" as first argument.
F0202:	Unable to check methods signature (%s / %s) Used when PyLint has been unable to check methods signature compatibility for an unexpected raison. Please report this kind if you don't make sense of it.
F0220:	failed to resolve interfaces implemented by %s (%s) Used when a PyLint as failed to find interfaces implemented by a class
#@-node:ekr.20071217231501:Classes
#@+node:ekr.20071217231501.1:Design
Design checker

Options
max-args:	Maximum number of arguments for function / method Default: 5
max-locals:	Maximum number of locals for function / method body Default: 15
max-returns:	Maximum number of return / yield for function / method body Default: 6
max-branchs:	Maximum number of branch for function / method body Default: 12
max-statements:	Maximum number of statements in function / method body Default: 50
max-parents:	Maximum number of parents for a class (see R0901). Default: 7
max-attributes:	Maximum number of attributes for a class (see R0902). Default: 7
min-public-methods:
 	Minimum number of public methods for a class (see R0903). Default: 2
max-public-methods:
 	Maximum number of public methods for a class (see R0904). Default: 20

Messages

R0901:	Too many ancestors (%s/%s) Used when class has too many parent classes, try to reduce this to get a more simple (and so easier to use) class.
R0902:	Too many instance attributes (%s/%s) Used when class has too many instance attributes, try to reduce this to get a more simple (and so easier to use) class.
R0903:	Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
R0904:	Too many public methods (%s/%s) Used when class has too many public methods, try to reduce this to get a more simple (and so easier to use) class.
R0911:	Too many return statements (%s/%s) Used when a function or method has too many return statement, making it hard to follow.
R0912:	Too many branches (%s/%s) Used when a function or method has too many branches, making it hard to follow.
R0913:	Too many arguments (%s/%s) Used when a function or method takes too many arguments.
R0914:	Too many local variables (%s/%s) Used when a function or method has too many local variables.
R0915:	Too many statements (%s/%s) Used when a function or method has too many statements. You should then split it in smaller functions / methods.
R0921:	Abstract class not referenced Used when an abstract class is not used as ancestor anywhere.
R0922:	Abstract class is only referenced %s times Used when an abstract class is used less than X times as ancestor.
R0923:	Interface not implemented Used when an interface class is not implemented anywhere.
#@nonl
#@-node:ekr.20071217231501.1:Design
#@+node:ekr.20071217231501.2:Imports
Imports checker

Options

deprecated-modules:
 	Deprecated modules which should not be used, separated by a comma Default: regsub,string,TERMIOS,Bastion,rexec
import-graph:	Create a graph of every (i.e. internal and external) dependencies in the given file (report R0402 must not be disabled)
ext-import-graph:
 	Create a graph of external dependencies in the given file (report R0402 must not be disabled)
int-import-graph:
 	Create a graph of internal dependencies in the given file (report R0402 must not be disabled)

Messages

W0401:	Wildcard import %s Used when from module import * is detected.
W0402:	Uses of a deprecated module %r Used a module marked as deprecated is imported.
W0403:	Relative import %r Used when an import relative to the package directory is detected.
W0404:	Reimport %r (imported line %s) Used when a module is reimported multiple times.
W0406:	Module import itself Used when a module is importing itself.
W0410:	__future__ import is not the first non docstring statement Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.
R0401:	Cyclic import (%s) Used when a cyclic import between two or more modules is detected.
F0401:	Unable to import %r (%s) Used when pylint has been unable to import a module.

Reports

R0401:	External dependencies
R0402:	Modules dependencies graph
#@nonl
#@-node:ekr.20071217231501.2:Imports
#@+node:ekr.20071217231501.3:Newstyle
Newstyle checker


Messages

E1001:	Use __slots__ on an old style class Used when an old style class use the __slots__ attribute.
E1002:	Use super on an old style class Used when an old style class use the super builtin.
E1003:	Bad first argument %r given to super class Used when another argument than the current class is given as first argument of the super builtin.
E1010:	Raising a new style class Used when a new style class is raised since it's not possible with python < 2.5.
W1001:	Use of "property" on an old style class Used when PyLint detect the use of the builtin "property" on an old style class while this is relying on new style classes 
features
W1010:	Exception doesn't inherit from standard "Exception" class Used when a custom exception class is raised but doesn't inherit from the builtin "Exception" class.
#@nonl
#@-node:ekr.20071217231501.3:Newstyle
#@+node:ekr.20071217231828:Exceptions
Exceptions checker

Messages

E0701:	Bad except clauses order (%s) Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be catched by the most specific handler.
E0702:	Raising %s while only classes, instances or string are allowed Used when something which is neither a class, an instance or a string is raised (i.e. a TypeError will be raised).
W0701:	Raising a string exception Used when a string exception is raised.
W0702:	No exception's type specified Used when an except clause doesn't specify exceptions type to catch.
W0703:	Catch "Exception" Used when an except catch Exception instances.
W0704:	Except doesn't do anything Used when an except clause does nothing but "pass" and there is no "else" clause.
W0706:	Identifier %s used to raise an exception is assigned to %s Used when a variable used to raise an exception is initially assigned to a value which can't be used as an exception.
#@nonl
#@-node:ekr.20071217231828:Exceptions
#@+node:ekr.20071217231828.1:Format
Format checker

Options

max-line-length:
 	Maximum number of characters on a single line. Default: 80
max-module-lines:
 	Maximum number of lines in a module Default: 1000
indent-string:	String used as indentation unit. This is usually " " (4 spaces) or "t" (1 tab). Default: ' '

Messages

W0311:	Bad indentation. Found %s %s, expected %s Used when an unexpected number of indentation's tabulations or spaces has been found.
W0312:	Found indentation with %ss instead of %ss Used when there are some mixed tabs and spaces in a module.
W0331:	Use of the <> operator Used when the deprecated "<>" operator is used instead of "!=".
W0332:	Use l as long integer identifier Used when a lower case "l" is used to mark a long integer. You should use a upper case "L" since the letter "l" looks too much like the digit "1"
C0301:	Line too long (%s/%s) Used when a line is longer than a given number of characters.
C0302:	Too many lines in module (%s) Used when a module has too much lines, reducing its readibility.
C0321:	More than one statement on a single line Used when more than on statement are found on the same line.
C0322:	Operator not preceded by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not preceded by a space.
C0323:	Operator not followed by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not followed by a space.
C0324:	Comma not followed by a space Used when a comma (",") is not followed by a space.
F0321:	Format detection error in %r Used when an unexpected error occured in bad format detection. Please report the error if it occurs.
#@nonl
#@-node:ekr.20071217231828.1:Format
#@+node:ekr.20071217231828.2:Miscellaneous
Miscellaneous checker

Options

notes:	List of note tags to take in consideration, separated by a comma. Default: FIXME,XXX,TODO

Messages

E0501:	Non ascii characters found but no encoding specified (PEP 263) Used when some non ascii characters are detected but now encoding is specified, as explicited in the PEP 263.
E0502:	Wrong encoding specified (%s) Used when a known encoding is specified but the file doesn't seem to be actually in this encoding.
E0503:	Unknown encoding specified (%s) Used when an encoding is specified, but it's unknown to Python.
W0511:	Used when a warning note as FIXME or XXX is detected.
#@nonl
#@-node:ekr.20071217231828.2:Miscellaneous
#@+node:ekr.20071217231828.3:Metrics
Metrics checker


Reports

R0701:	Raw metrics
#@-node:ekr.20071217231828.3:Metrics
#@+node:ekr.20071217231828.4:Simularities
Similarities checker

min-similarity-lines:
 	Minimum lines number of a similarity. Default: 4
ignore-comments:
 	Ignore comments when computing similarities. Default: yes
ignore-docstrings:
 	Ignore docstrings when computing similarities. Default: yes

Messages

R0801:	Similar lines in %s files Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.

Reports

R0801:	Duplication
#@-node:ekr.20071217231828.4:Simularities
#@-node:ekr.20071217231348:Pylint docs
#@+node:ekr.20071220081732:pylint report
@killcolor


*** Erroneous errors in Leo 4.4.8



--- old --

************* Module leoTkinterTree

W0221:2377:leoTkinterTree.setSelectedLabelState: Arguments number differs from overridden method
W0221:2387:leoTkinterTree.setUnselectedLabelState: Arguments number differs from overridden method
#@+node:ekr.20080304084023:leoEditCommands
*** All these error messages are WRONG.

E1101:114:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:115:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:116:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member

E1101:8091:spellCommandsClass.openSpellTab: Instance of 'spellTabHandler' has no 'bringToFront' member
E1101:8121:spellCommandsClass.changeAll: Instance of 'spellTabHandler' has no 'changeAll' member
E1101:8129:spellCommandsClass.changeThenFind: Instance of 'spellTabHandler' has no 'changeThenFind' member
#@nonl
#@-node:ekr.20080304084023:leoEditCommands
#@+node:ekr.20080304084023.1:leoGlobals
*** All these error messages are WRONG.

E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
W0104:3915: Statement seems to have no effect

E0602:3931:getpreferredencoding: Undefined variable 'LC_CTYPE'
E0602:3932:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3933:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3933:getpreferredencoding: Undefined variable 'CODESET'
E0602:3934:getpreferredencoding: Undefined variable 'LC_CTYPE'
E1101:3937:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
E0602:3937:getpreferredencoding: Undefined variable 'CODESET'
E1101:4432:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
#@-node:ekr.20080304084023.1:leoGlobals
#@+node:ekr.20080304091441:leoTkinterFind
*** All these error messages are WRONG.

************* Module leoTkinterFind
E1101: 95:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'title' member
E1101:101:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:104:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'newStringKeys' member
E1101:113:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'createTopFrame' member
E1101:115:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:116:leoTkinterFind.__init__: Instance of 'leoTkinterFind' has no 'top' member
E1101:123:leoTkinterFind.init: Instance of 'leoTkinterFind' has no 'intKeys' member
E1101:177:leoTkinterFind.destroySelf: Instance of 'leoTkinterFind' has no 'top' member
E1101:185:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'frame' member
E1101:213:leoTkinterFind.createFrame.setFocus: Instance of 'leoTkinterFind' has no 'c' member
E1101:298:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:305:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1103:325:leoTkinterFind.createFrame.findButtonCallback: Instance of 'leoTkinterFind' has no 'findButton' member (but some types c
ould not be inferred)
E1101:341:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'findAllButton' member
E1101:348:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeButton' member
E1101:354:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeThenFindButton' member
E1101:360:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'changeAllButton' member
E1101:367:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1101:368:leoTkinterFind.createFrame: Instance of 'leoTkinterFind' has no 'top' member
E1103:378:leoTkinterFind.createBindings.findButtonCallback2: Instance of 'leoTkinterFind' has no 'findButton' member (but some typ
es could not be inferred)
E1101:382:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:383:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'resetWrap' member
E1101:384:leoTkinterFind.createBindings: Instance of 'leoTkinterFind' has no 'selectAllFindText' member
E1101:396:leoTkinterFind.onCloseWindow: Instance of 'leoTkinterFind' has no 'top' member
E1101:401:leoTkinterFind.dismiss: Instance of 'leoTkinterFind' has no 'top' member
E1101:408:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'c' member
E1101:410:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:411:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:412:leoTkinterFind.bringToFront: Instance of 'leoTkinterFind' has no 'top' member
E1101:438:tkFindTab.initGui: Instance of 'tkFindTab' has no 'intKeys' member
E1101:441:tkFindTab.initGui: Instance of 'tkFindTab' has no 'newStringKeys' member
E1101:448:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'c' member
E1101:489:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:504:tkFindTab.createFrame.setFocus: Instance of 'tkFindTab' has no 'c' member
E1101:538:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:591:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:599:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'resetWrap' member
E1101:606:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'optionsOnly' member
E1101:623:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findButtonCallback' member
E1101:624:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'findAllButton' member
E1101:626:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeButton' member
E1101:627:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeThenFindButton' member
E1101:628:tkFindTab.createFrame: Instance of 'tkFindTab' has no 'changeAllButton' member
E1101:647:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'c' member
E1103:650:tkFindTab.createBindings.resetWrapCallback: Instance of 'tkFindTab' has no 'resetWrap' member (but some types could not
be inferred)
E1103:654:tkFindTab.createBindings.findButtonBindingCallback: Instance of 'tkFindTab' has no 'findButton' member (but some types c
ould not be inferred)
E1101:664:tkFindTab.createBindings: Instance of 'tkFindTab' has no 'hideTab' member
E1101:677:tkFindTab.init: Instance of 'tkFindTab' has no 'intKeys' member
E1101:746:tkFindTab.setOption: Instance of 'tkFindTab' has no 'intKeys' member
E1101:758:tkFindTab.toggleOption: Instance of 'tkFindTab' has no 'intKeys' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304091441:leoTkinterFind
#@+node:ekr.20080304091441.1:leoTkinterGui
*** All these error messages are WRONG.

************* Module leoTkinterGui
E1101:179:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
E1101:183:tkinterGui.runMainLoop: Instance of 'tkinterGui' has no 'script' member
#@-node:ekr.20080304091441.1:leoTkinterGui
#@+node:ekr.20080304092628:leoTkinterFrame
*** All these error messages are WRONG.

leoTkinterFrame.py Harmless: W0221: mismatch between Tk.Text methods and overridden methods.
leoTkinterFrame.py Dangerous: E1101
************* Module leoTkinterFrame
E1101: 53:leoTkinterBody.__init__: Instance of 'leoTkinterBody' has no 'c' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'frame' member
E1101: 67:leoTkinterBody.createBindings: Instance of 'leoTkinterBody' has no 'c' member
E1101: 88:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'c' member
E1101:102:leoTkinterBody.createControl: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:109:leoTkinterBody.createTextWidget: Instance of 'leoTkinterBody' has no 'c' member
E1101:176:leoTkinterBody.setColorFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:224:leoTkinterBody.setFontFromConfig: Instance of 'leoTkinterBody' has no 'c' member
E1101:241:leoTkinterBody.hasFocus: Instance of 'leoTkinterBody' has no 'frame' member
E1101:245:leoTkinterBody.setFocus: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'c' member
E1101:351:leoTkinterBody.setEditorColors: Instance of 'leoTkinterBody' has no 'editorWidgets' member
E1101:379:leoTkinterFrame.__init__: Class 'leoTkinterFrame' has no 'instances' member
E1101:437:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:439:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createIconBar' member
E1101:442:leoTkinterFrame.finishCreate: Instance of 'leoTkinterFrame' has no 'createStatusLine' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'comparePanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'colorPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'fontPanel' member
E1101:938:leoTkinterFrame.destroyAllPanels: Instance of 'leoTkinterFrame' has no 'prefsPanel' member
E1101:1347:leoTkinterFrame.setMinibufferBindings: Instance of 'leoTkinterFrame' has no 'OnPaste' member
E1101:1901:leoTkinterFrame.toggleTkSplitDirection: Instance of 'leoTkinterFrame' has no 'initialRatios' member
E1101:2111:leoTkinterLog.createCanvasWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2138:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2140:leoTkinterLog.createTextWidget: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2303:leoTkinterLog.onActivateLog: Instance of 'leoTkinterLog' has no 'frame' member
E1101:2423:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2424:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'logNumber' member
E1101:2431:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2432:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2433:leoTkinterLog.createCanvas: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2462:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2463:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2464:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2475:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2476:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2477:leoTkinterLog.createTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2489:leoTkinterLog.cycleTabFocus: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2514:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'canvasDict' member
E1101:2515:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2516:leoTkinterLog.deleteTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2556:leoTkinterLog.numberOfVisibleTabs: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2573:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2574:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2587:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2589:leoTkinterLog.selectTab: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2600:leoTkinterLog.setTabBindings: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2787:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2788:leoTkinterLog.createColorPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:2845:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'frameDict' member
E1101:2846:leoTkinterLog.createFontPicker: Instance of 'leoTkinterLog' has no 'textDict' member
E1101:3018:leoTkinterTreeTab.createControl: Instance of 'leoTkinterTreeTab' has no 'c' member
E1101:3065:leoTkinterTreeTab.selectTab: Instance of 'leoTkinterTreeTab' has no 'cc' member
"*****done*****"
Press any key to continue . . .
#@nonl
#@-node:ekr.20080304092628:leoTkinterFrame
#@+node:ekr.20080304093027:leoTkinterKeys
*** All these error messages are WRONG.

************* Module leoTkinterKeys
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'useTextWidget' member
E1101: 27:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
E1101: 29:tkinterKeyHandlerClass.createTkIvars: Instance of 'tkinterKeyHandlerClass' has no 'widget' member
#@-node:ekr.20080304093027:leoTkinterKeys
#@+node:ekr.20080304093258:leoTkinterMenu
*** All these error messages are WRONG.

leoTkinterMenu.py
************* Module leoTkinterMenu
E1101: 62:leoTkinterMenu.computeMenuPositions: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:136:leoTkinterMenu.insert: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:172:leoTkinterMenu.clearAccel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:183:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'updateAllMenus' member
E1101:186:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'setMenu' member
E1101:187:leoTkinterMenu.createMenuBar: Instance of 'leoTkinterMenu' has no 'createMenusFromTables' member
E1101:208:leoTkinterMenu.disableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:225:leoTkinterMenu.enableMenu: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:255:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:258:leoTkinterMenu.setMenuLabel: Instance of 'leoTkinterMenu' has no 'getRealMenuName' member
E1101:297:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'getMenu' member
E1101:301:leoTkinterMenu.getMacHelpMenu: Instance of 'leoTkinterMenu' has no 'createMenuEntries' member
#@-node:ekr.20080304093258:leoTkinterMenu
#@-node:ekr.20071220081732:pylint report
#@-node:ekr.20071217134533:Pylint
#@+node:ekr.20080408060320.4:4.5 b1
# The first 4.5 release will be 4.5 b1.
#@nonl
#@+node:ekr.20080506135044.2:Unposted posting about removing .parents list
@nocolor

Unless I hear a truly convincing reason why I shouldn't, I plan to removed v.parents entirely from the sax-graph world. My reasons are as follows:

1. v.parents is actually used in exactly one place, namely p.setAllAncestorAtFileNodesDirty.  Because this is a position method, the full position stack is available, so the vnodes of all direct parents are available.  This means, in turn, that v.t.vnodeList is available, so at each level all clones of v are also available.

This is only a special case.  In general, given a position, it is possible to *compute* all information about parents.

2. As a result, all the work following work is essentially wasted: initing v.parents during reads, and updating v.parents during moves, clones, insertions, deletions, promotions, demotions, and the corresponding undo/redo for all these operations.

It's not so much that the work is odious: it's not.  It's just that conceptually it is completely unnecessary.  Because the work exists, it must be checked: unit tests written, code added to the check-outline command, etc.  All for nothing.

3. Conceptually, the big aha in the unified node world, and *also* in the graph world, is that the *combination* of positions and nodes is what defines the graph.  In any context containing a position p, the combination of p and p.v.t.children is the minimum needed to get *all* information about the graph.  That being so, the parents list adds nothing. 

4. Continuing with the idea in 3, good things often happen when one eliminates an entire area of complexity.  Not only does eliminating the parents list give us the "simplest thing that could possibly work", there is the as-yet-unexplored possibility of future improvements.  That is, this is not merely an implementation issue--by generalizing and simplifying the data structure we open the door to using that data structure in previously unimagined contexts.

So to repeat, I am very likely to get rid of v.parents. I must rewrite p.setAllAncestorAtFileNodesDirty first, so there is still time to voice any objections.  They had better be good :-)

Edward
#@nonl
#@-node:ekr.20080506135044.2:Unposted posting about removing .parents list
#@+node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080506135044.14:Fixed paste outline
#@-node:ekr.20080506135044.14:Fixed paste outline
#@+node:ekr.20080506135044.15:Fixed two recent node bugs
@nocolor

1. clone-find-all truncated the outline.
   The fix was in p.linkAsRoot.

2. The move outline down command skipped nodes.
   The fix was to p.moveAfter.

3. Added defensive code to p.unlink.

@color
#@nonl
#@-node:ekr.20080506135044.15:Fixed two recent node bugs
#@+node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@-node:ekr.20080506135044.16:Fixed bug: Deleting the root didn't select another node
#@+node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@-node:ekr.20080506135044.17:The str_leo_pos uA was not being cleared
#@+node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@-node:ekr.20080506135044.18:Fixed bug: Moving a clone to the root lost the clone mark
#@+node:ekr.20080506135044.19:Fixed paste-retaining-clones
# getLeoOutlineFromClipboard now recreates the tnodesDict as needed.
#@nonl
#@-node:ekr.20080506135044.19:Fixed paste-retaining-clones
#@+node:ekr.20080506135044.20:Rewrote sort code
#@-node:ekr.20080506135044.20:Rewrote sort code
#@+node:ekr.20080506135044.21:Rewrote promote/demote code
#@-node:ekr.20080506135044.21:Rewrote promote/demote code
#@+node:ekr.20080506135044.22:Fixed undo/redo move
#@-node:ekr.20080506135044.22:Fixed undo/redo move
#@+node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@-node:ekr.20080506135044.23:Fixed inconsistencies between parents and children arrays
#@+node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@-node:ekr.20080506135044.24:Rewrote scanForClonedSibs
#@+node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@-node:ekr.20080506135044.25:Fixed bug: ancestors were not being marked dirty properly
#@+node:ekr.20080506135044.26:Bug: Undo move crashes
@nocolor

This was fixed by calling p._adjustPositionBeforeUnlink.

Traceback (most recent call last):
  File "C:\leo.repo\sax-graph\leo\src\leoCommands.py", line 289, in doCommand
    val = command(event)
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1736, in undo
    if u.undoHelper: u.undoHelper()
  File "C:\leo.repo\sax-graph\leo\src\leoUndo.py", line 1921, in undoMove
    assert u.newParent_v.t.children[u.newN] == v
IndexError: list index out of range

#@-node:ekr.20080506135044.26:Bug: Undo move crashes
#@+node:ekr.20080506135044.27:Bug: Selection gets lost
# when moving node down into child
# when expanding node with alt-rtArrow

# This was fixed by calling p._adjustPositionBeforeUnlink.
#@nonl
#@-node:ekr.20080506135044.27:Bug: Selection gets lost
#@+node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.29:Posting
@nocolor

A brief period of testing revealed two, possibly three bugs that must be
fixed before the sax-graph branch will be usable.  One bug in particular is
interesting.  Code similar to the following code appears in several places
in leoNodes.py:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    p._linkAsNthChild(parent)

This works in the "linked" world, but it must be modified for the graph
world.  Indeed, unlinking p can change the position at which p is to be
linked.  For example, suppose we have:

A
B
C

And we wish to move B to the first child of C.  After unlinking B, we will
have:

A
C

Notice: C's childIndex has changed from 2 to 1 but it has *not* changed in
the parent arg to p._linkAsNthChild(parent).  To handle this, Leo will need
code such as:

def insertAsNthChild(self,parent):
    p = self
    p._unlink()
    parent = p._adjustPositionAfterUnlink(parent)
    p._linkAsNthChild(parent)

p._adjustPositionAfterUnlink(parent) can adjust the parent position as
needed **provided** that p._unlink() does *not* change position p, but only
changes p.v.t.children, p.v.t.parents and p.v.t.vnodeList.  In particular,
p._adjustPositionAfterUnlink(parent) only needs to compare the stacks of
positions p and parent in order to adjust parent.  This breaks the circular
dependency: the position can be adjusted even after the actual links
(parents, children arrays) have be changed. 
#@nonl
#@-node:ekr.20080506135044.29:Posting
#@-node:ekr.20080506135044.28:Fixed bug involving p._unlink
#@+node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@-node:ekr.20080506135044.30:Moved parents ivar into vnodes
#@+node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@-node:ekr.20080506135044.31:Bug: clone-find-all fails check-outline
#@+node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@-node:ekr.20080506135044.32:Linking/unlinking all clones into parents list
#@+node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@-node:ekr.20080506135044.33:Fixed bug: check-outline failed after clone and clone-find-all
#@+node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@-node:ekr.20080506135044.34:Fixed bug: sort did not select a node
#@+node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@-node:ekr.20080506135044.35:Fixed bug in clone (caused undo to fail)
#@+node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.36:Fixed bug in createChapterByName
#@-node:ekr.20080506135044.13:Recent graph-world bugs
#@+node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):

    files = [theFile.strip() for theFile in files]

    # g.trace(files)

    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles[:]:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20080425062953.1:Fixed bug in appendToRecentFiles
#@+node:ekr.20080408060320.2:Fixed bug in install script
@nocolor

On Mon, Apr 7, 2008 at 7:07 PM, SegundoBob <bhossley@ieee.org> wrote:

I installed Leo 4.4..8 final on Ubuntu.  The installation failed
because the installation put files in /usr/lib/leo/leo.  The
duplicated leo is a mistake.
On line 13 of install I changed:
LEO_LIB_DIR="${LEO_PREFIX}/lib/leo"
to
LEO_LIB_DIR="${LEO_PREFIX}/lib"

With the change the installation worked.
#@nonl
#@-node:ekr.20080408060320.2:Fixed bug in install script
#@+node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@-node:ekr.20080506135044.12:Fixed bug: no focus after save-as and save-to commands
#@+node:ekr.20080501180847.1:Fixed find bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/294866696257802e

For some reason if you remove the key mapping for the "replace-string"
entry in myLeoSettings or leoSettings.leo ( replace-string = None)
then the "search-with-present-options" function (ctrl-f) or the
"search-forward" function (if mapped) displays the request for a
search string in the mini-buffer but returns immediately when any key
is pressed and searches with the "Find:" entry in the "Find" tab.

@color
#@nonl
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060205170335.1:aproposFindCommands
def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es_print('',s)
#@+node:ekr.20060209082023.1:<< define s >>
s = '''
Note: all bindings shown are the default bindings for these commands.  You may change any of these bindings using @shortcuts nodes in leoSettings.leo.

Settings

leoSettings.leo now contains several settings related to the Find tab:

- @bool show_only_find_tab_options = True

When True (recommended), the Find tab does not show the 'Find', 'Change', 'Change, Then Find', 'Find All' and 'Change All' buttons.

- @bool minibufferSearchesShowFindTab = True

When True, Leo shows the Find tab when executing most of the commands discussed below.

Basic find commands

- open-find-tab makes the Find tab visible.  The Find tab does **not** need to be visible to execute any search command discussed below.

- hide-find-tab hides the Find tab, but retains all the present settings.

- search-with-present-options (Control-F) prompts for a search string.  Typing the <Return> key puts the search string in the Find tab and executes a search based on all the settings in the Find tab. This is a recommended default search command.

- show-search-options shows the present search options in the status line.  This command also makes the Find tab visible.

- find-next (F3) is the same as search-with-present-options, except that it uses the search string in the find-tab.  Recommended as the default 'search again' command.

- Similarly, find-previous (F2) repeats the command specified by the Find tab, but in reverse.

- find-again is the same as find-next if a search pattern is not '<find pattern here>'.
  Otherwise, find-again is the same as search-with-present-options.

Setting find options

- Several minibuffer commands toggle the checkboxes and radio buttons in the Find tab, and thus affect the operation of the search-with-present-options command. Some may want to bind these commands to keys. Others, will prefer to toggle options in a mode.

Here are the commands that toggle checkboxes: toggle-find-ignore-case-option, toggle-find-in-body-option, toggle-find-in-headline-option, toggle-find-mark-changes-option, toggle-find-mark-finds-option, toggle-find-regex-option, toggle-find-reverse-option, toggle-find-word-option, and toggle-find-wrap-around-option.

Here are the commands that set radio buttons: set-find-everywhere, set-find-node-only, and set-find-suboutline-only.

- enter-find-options-mode (Ctrl-Shift-F) enters a mode in which you may change all checkboxes and radio buttons in the Find tab with plain keys.  As always, you can use the mode-help (Tab) command to see a list of key bindings in effect for the mode.

Search commands that set options as a side effect

The following commands set an option in the Find tab, then work exactly like the search-with-present-options command.

- search-backward and search-forward set the 'Whole Word' checkbox to False.

- word-search-backward and word-search-forward set the 'Whole Word' checkbox to True.

- re-search-forward and re-search-backward set the 'Regexp' checkbox to True.

Find all commands

- find-all prints all matches in the log pane.

- clone-find-all replaces the previous 'Clone Find' checkbox.  It prints all matches in the log pane, and creates a node at the beginning of the outline containing clones of all nodes containing the 'find' string.  Only one clone is made of each node, regardless of how many clones the node has, or of how many matches are found in each node.

Note: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by the find-all and clone-find-all commands.

Search and replace commands

- replace-string prompts for a search string.  Type <Return> to end the search string.  The command will then prompt for the replacement string.  Typing a second <Return> key will place both strings in the Find tab and executes a **find** command, that is, search-with-present-options.

So the only difference between replace-string and search-with-present-options is that replace-string has the side effect of setting 'change' string in the Find tab.  However, this is an extremely useful side effect, because of the following commands...

- change (Ctrl-=) replaces the selected text with the 'change' text in the Find tab.

- change-then-find (Ctrl--) replaces the selected text with the 'change' text in the Find tab, then executes the find command again.

find-next, change and change-then-find can simulate any kind of query-replace command.  **Important**: Leo presently has separate query-replace and query-replace-regex commands, but they are buggy and 'under-powered'.  Fixing these commands has low priority.

- change-all changes all occurrences of the 'find' text with the 'change' text.  Important: the radio buttons in the Find tab (Entire Outline, Suboutline Only and Node only) control how much of the outline is affected by this command.

Incremental search commands

Leo's incremental search commands are completely separate from Leo's legacy search commands.  At present, incremental search commands do not cross node boundaries: they work only in the body text of single node.

Eventually, the incremental commands will maintain a list of previous matches.  This allows for

a) support for backspace and
b) an incremental-search-again command.

Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

Here is the list of incremental find commands: isearch-backward, isearch-backward-regexp, isearch-forward and
isearch-forward-regexp.'''
#@-node:ekr.20060209082023.1:<< define s >>
#@-node:ekr.20060205170335.1:aproposFindCommands
#@-node:ekr.20080501180847.1:Fixed find bug
#@+node:ekr.20080406075855.1:Fixed find completion bug
@nocolor

Trying to edit the minibuffer, when I backspace to a character and
press delete the cursor moves to the end of the buffer and deletes the
last character instead.

@nocolor
#@nonl
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@-node:ekr.20080406075855.1:Fixed find completion bug
#@+node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
@nocolor

find-word
=========
This command is supposed to:

"Put the cursor at the next word (on a line) that starts with a
character"

It does not. You have to type in a whole word to get any result and
even then
it only selects the word it does not move the cursor to it.


goto-charachter
==============
'''Put the cursor at the n'th character of the buffer.'''

Doesn't do anything.

@color
#@nonl
#@+node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
class baseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None

def finishCreate(self):

    # Class delegators.
    self.k = self.k = self.c.k
    try:
        self.w = self.c.frame.body.bodyCtrl # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):

    '''Called from k.keyboardQuit to init all classes.'''

    pass
#@nonl
#@-node:ekr.20050920084036.2: ctor, finishCreate, init (baseEditCommandsClass)
#@+node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand (baseEditCommands)
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    # if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        # self.w = w
    # else:
        # self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.5:getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@-node:ekr.20050920084036.5:getPublicCommands & getStateCommands
#@+node:ekr.20050920084036.6:getWSString
def getWSString (self,s):

    return ''.join([g.choose(ch=='\t',ch,' ') for ch in s])
#@-node:ekr.20050920084036.6:getWSString
#@+node:ekr.20050920084036.7:oops
def oops (self):

    print("baseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20050920084036.7:oops
#@+node:ekr.20050929161635:Helpers
#@+node:ekr.20050920084036.249:_chckSel
def _chckSel (self,event,warning='no selection'):

    c = self.c ; k = self.k

    w = self.editWidget(event)

    val = w and w.hasSelection()

    if warning and not val:
        k.setLabelGrey(warning)

    return val
#@-node:ekr.20050920084036.249:_chckSel
#@+node:ekr.20050920084036.250:_checkIfRectangle
def _checkIfRectangle (self,event):

    k = self.k ; key = event.keysym.lower()

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@-node:ekr.20050920084036.250:_checkIfRectangle
#@+node:ekr.20050920084036.233:getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@-node:ekr.20050920084036.233:getRectanglePoints
#@+node:ekr.20051002090441:keyboardQuit
def keyboardQuit (self,event):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit(event)
#@-node:ekr.20051002090441:keyboardQuit
#@-node:ekr.20050929161635:Helpers
#@-node:ekr.20050920084036.1:<< define class baseEditCommandsClass >>
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20061007105001:editWidget
def editWidget (self,event):

    c = self.c ; w = event and event.widget

    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and g.app.gui.isTextWidget(w):
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    # if w and g.app.gui.isTextWidget(w) and w != c.frame.miniBufferWidget:
        # self.w = w
    # else:
        # self.w = self.c.frame.body and self.c.frame.body.bodyCtrl

    if self.w:
        c.widgetWantsFocusNow(self.w)

    return self.w
#@nonl
#@-node:ekr.20061007105001:editWidget
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            # start = s.rfind('\n',0,i)
            # if start == -1: start = 0
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            # end = s.find('\n',i)
            # if end == -1: end = len(s)
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1:findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
#@-node:ekr.20080408060320.1:findWordHelper
#@-node:ekr.20060417194232.2:findWord and FindWordOnLine & helper
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@-node:ekr.20080407090400.1:Fixed how-many, find-word and goto-character commands
#@+node:ekr.20080424115643.5:Fixed import PHP bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/b068e88a577a0547

I have just started using Leo and though not familiar with Python, I
am finding it to be a great program.
I am however having difficulty understanding the ins & outs, for
example;

I am trying to use Leo to organize all my different php scripts I have
on my hard drive, when I try to import any php file I get errors. (see
example) I was able to import html files just fine but I don't
understand what I need to do to import my php files one by one so that
I can organize them in a useful manner.

ex error;
exception executing command
Traceback (most recent call last):
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 275, in
doCommand
    val = command(event)
  File "C:\Program Files (x86)\Leo\src\leoCommands.py", line 1508, in
importAtFile
    c.importCommands.importFilesCommand(names,"@file")
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1004, in
importFilesCommand
    v = self.createOutline(fileName,current)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 869, in
createOutline
    self.scanPHPText(s,p,atAuto=atAuto)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 1671, in
scanPHPText
    scanner.run(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2929, in
run
    self.scan(s,parent)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2394, in
scan
    i = self.skipDecls(s,0,len(s),inClass=False)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 2615, in
skipDecls
    i = self.skipString(s,i)
  File "C:\Program Files (x86)\Leo\src\leoImport.py", line 3461, in
skipString
    return self.skipString()
TypeError: skipString() takes exactly 3 arguments (1 given)

@color
#@nonl
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080424115643.5:Fixed import PHP bug
#@+node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@-node:ekr.20080506135044.7:Fixed keyword handling in g.es and g.es_print
#@+node:ekr.20080405074410.39:Fixed new @auto bug
@nocolor

Leo's running, so I create a new outline with File->New

Then I save as in a location where foo.py exists.

The I create a node '@auto foo.py'

Then I use File->Read/Write->Read @auto (with that node selected)

Leo says it can't read it.

I close the leo file, re-open in from the recent files menu of the
outline that spawned it, and the @auto file is read no problems.

@color
#@nonl
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self,event=None):

    '''Read all @file nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.fileCommands.readAtFileNodes()
        u.afterChangeTree(p,'Read @file Nodes',undoData)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
def readAtFileNodes (self):

    c = self.c ; p = c.currentPosition()

    c.beginUpdate()
    try:
        c.atFileCommands.readAll(p,partialFlag=True)
    finally:
        c.endUpdate()

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20031218072017.3029:readAtFileNodes (fileCommands)
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            # g.trace('@auto',p.headString(),'name',p.atAutoNodeName())
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    if not g.unitTesting:
        g.es("reading:",p.headString())

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        #c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        g.doHook('after-auto', p = p)  # call after-auto callbacks
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setBodyString('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # print 'found',e,'in',line1
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

path = theDict["path"]
path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@-node:ekr.20080405074410.39:Fixed new @auto bug
#@+node:ekr.20080424061644.1:Fixed recent files bug
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c6c4faf6fdead672

To reproduce:

Run leo.
Go to "File->Save as" and save the empty outline template somewhere,
for example to /tmp/test.leo
It will appear in "File->Recent files"
When trying to open it from there, I get the following traceback:

---
Error: 1
<type 'exceptions.AttributeError'> Exception in Tk callback
 Function: <function recentFilesCallback at 0x8ba8df4> (type: <type
'function'>)
 Args: ()
Traceback (innermost last):
 File "/home/shadow/leo/extensions/Pmw/Pmw_1_3/lib/PmwBase.py", line
1747, in __call__
   return apply(self.func, args)
 File "/home/shadow/leo/src/leoMenu.py", line 1599, in
recentFilesCallback
   c.openRecentFile(name)
 File "/home/shadow/leo/src/leoCommands.py", line 1173, in
openRecentFile
   c = frame.c # Switch to the new commander so the "recentfiles2"
hook doesn't crash.
<type 'exceptions.AttributeError'>: leoTkinterFrame instance has no
attribute 'c'
---

leo seems to crash, I hit Ctrl-C to stop it.
When I run leo again, there is no entry for test.leo in "File->Recent
files"

Leo 4.4.8 final, build  1.244 , April 6, 2008
python 2.5.1, Tk 8.4.16, Pmw 1.3
OS: Linux

This behaviour doesn't hurt me at all, I've found it accidentally.

@color
#@nonl
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            frame.c.outerUpdate()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)
    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
        p = c.currentPosition()
        # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
        if not g.doHook("menu1",c=c,p=p,v=p):
            frame.menu.createMenuBar(frame)
            c.updateRecentFiles(relativeFileName or fileName)
            g.doHook("menu2",c=frame.c,p=p,v=p)
            g.doHook("after-create-leo-frame",c=c)

    finally:
        c.endUpdate()
        assert frame.c == c and c.frame == frame
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.chapterController:
            c.chapterController.finishCreate()
        k = c.k
        if k:
            k.setDefaultInputState()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
        if k:
            k.showStateAndMode()

    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self,event=None):

    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer

    bunch = u.beforeClearRecentFiles()

    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.deleteRecentFilesMenuItems(recentFilesMenu)

    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.relativeFileName())

    g.app.config.appendToRecentFiles(c.recentFiles)

    # g.trace(c.recentFiles)

    u.afterClearRecentFiles(bunch)

    # New in Leo 4.4.5: write the file immediately.
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):

    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>

    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag and frame != c.frame:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_normpath(name or '').lower()
    def munge2(name):
        return g.os_path_abspath(g.os_path_join(g.app.loadDir,name or ''))

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:tbrown.20080509212202.6:cleanRecentFiles
def cleanRecentFiles(self,event=None):

    c = self

    dat = c.config.getData('path-demangle')
    if not dat:
        g.es('No @data path-demangle setting')
        return

    changes = []
    replace = None
    for line in dat:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es('%s -> %s' % changes[-1])

    orig = [i for i in c.recentFiles if i.startswith("/")]
    c.clearRecentFiles()

    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)

        c.updateRecentFiles(t)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.6:cleanRecentFiles
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()
    import os
    orig.sort(cmp=lambda a,b:cmp(os.path.basename(b).lower(),     
        os.path.basename(a).lower()))
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@-node:ekr.20080424061644.1:Fixed recent files bug
#@+node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20031218072017.2062:getPrefs
# Note: Leo 4.3 does not write these settings to local .leo files.
# Instead, corresponding settings are contained in leoConfig.leo files.

def getPrefs (self):

    c = self.c

    if self.getOpenTag("<preferences"):
        return # <preferences/> seen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))

    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                    # g.trace(var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/>"):
                done = True ; break
            if self.matchTag(">"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done:
        while 1:
            if self.matchTag("<defaultDirectory>"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("</defaultDirectory>")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:",c.tangle_directory)
            elif self.matchTag("<TSyntaxMemo_options>"):
                self.getEscapedString() # ignored
                self.getTag("</TSyntaxMemo_options>")
            else: break
        self.getTag("</preferences>")
#@+node:ekr.20031218072017.2063:getTargetLanguage
def getTargetLanguage (self):

    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language

    return "c" # default
#@-node:ekr.20031218072017.2063:getTargetLanguage
#@-node:ekr.20031218072017.2062:getPrefs
#@+node:ekr.20031218072017.3579:error, pathError, warning
def error (self,s):
    self.errors += 1
    g.es_error(g.translateString(s))

def pathError (self,s):
    if not self.path_warning_given:
        self.path_warning_given = True
        self.error(s)

def warning (self,s):
    g.es_error(g.translateString(s))
#@-node:ekr.20031218072017.3579:error, pathError, warning
#@-node:ekr.20080418154703.1:Fixed Tangle bugs
#@+node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
# findAll now just creates undo info for clone-find-all for one inserted node.
#@nonl
#@+node:ekr.20080506135044.9:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                undoData = u.beforeInsertNode(c.currentPosition())
                << create the found node >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        # u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    self.restore(data)
    c.redraw_now()
    g.es("found",count,"matches")

#@+node:ekr.20080506135044.10:<< create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
#@-node:ekr.20080506135044.10:<< create the found node >>
#@+node:ekr.20080506135044.11:<< create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@-node:ekr.20080506135044.11:<< create a clone of p under the find node >>
#@-node:ekr.20080506135044.9:findAll
#@-node:ekr.20080506135044.8:Greatly increased speed of undo clone-find-all
#@+node:ekr.20080502114149.2:Temporary fix for php import bug
#@+node:ekr.20080502114149.3:file
ok here is short form of the php file for your review; I am trying to
explain that this is the way Leo imported the file into 2 sections,
instead of having the complete begining and end php tags on the same
'section', it separated them.  I hope this helps.

***FIST SECTION BEGINS***

//@+leo-ver=4
//@+node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@@language php
//@@tabwidth -4
//@+others
//@+node:0_sitedef declarations
<?php /*Cascade Style Sheet style1.css*/
?>
<link href="../stex.css" rel="stylesheet" type="text/css" />

<?php
/*
Choice of language for website yes/no
*/
$ADD_LANGUAGE_CHOICE = 'yes';
/*
If 'Yes' you need to create images based on content/filename.htm
ex: /imgs/bttns_index.jpg
$NAV_IMAGES ='yes';
*/

?>

<?php /* Contact information */
$domain = "domain.com";

?>

<?php /* Content Script; reads .htm files in Content Directory */

*** FIRST SECTION ENDS => NOTICE THE LAST LINE OF FILE IS A BEGINING <?
PHP TAG THAT SHOULD BE FIRST LINE ON SECOND SECTION ***

*** SECOND SECTION BEGINS ***

//@-node:0_sitedef declarations
//@+node:include
include('language.php');

$mycontentdir = "content"."/".$mylanguage;
if ($main_page == "") $main_page = "index";


$pagename = $main_page;
$ptitle = $company . " " . $main_page . " page " . $tel ." " . $city .
" " . $state . " " . $zip;

$main_page = "" . $main_page . ".htm";

/* if (is_file("$mycontentdir/$main_page")) {
$open = fopen("$mycontentdir/$main_page", "r");
$size = filesize("$mycontentdir/$main_page");
$content = fread($open, $size); */
//}
?>

<?php
/*Echo's Website*/
function hpo(){
echo '<div class="hpo">whatever text goes here</a> </div>';
}
//@-node:include
//@-others
?>
//@-node:@file C:\inetpub\wwwroot\0_PHP_Template\incl\0_sitedef.php
//@-leo

*** SECOND SECTION ENDS ***
#@nonl
#@-node:ekr.20080502114149.3:file
#@+node:ekr.20031218072017.3210:createOutline (leoImport)
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = g.os_path_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    << convert s to the proper encoding >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setBodyString('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    elif ext in ('.html','.htm','.xml'):
        self.scanXmlText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    z = g.choose(atAuto,'@auto ','')
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (z,fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@+node:ekr.20080212092908:<< convert s to the proper encoding >>
if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # print 'found',e,'in',line1
            self.encoding = e

s = g.toUnicode(s,self.encoding)
#@-node:ekr.20080212092908:<< convert s to the proper encoding >>
#@-node:ekr.20031218072017.3210:createOutline (leoImport)
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = phpScanner(importCommands=self,atAuto=atAuto)
    scanner.run(s,parent)

    # if scanner.isPurePHP(s):
        # scanner.run(s,parent)
    # else:
        # fileName = scanner.fileName
        # if atAuto:
            # print('seems to be mixed HTML and PHP:',fileName)
        # else:
            # g.es_print('seems to be mixed HTML and PHP:',fileName)
        # scanner.createHeadline(
            # parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = False
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner
#@-node:ekr.20080502114149.2:Temporary fix for php import bug
#@+node:ekr.20080517075806.21:Fixed unbounded loop in autocompleter.findAnchor
#@-node:ekr.20080517075806.21:Fixed unbounded loop in autocompleter.findAnchor
#@+node:ekr.20080517184420.1:Fixed insert-newline bug
exception executing command
Traceback (most recent call last):
 File "C:\_Proj\Leo\key-handling\leo\src\leoCommands.py", line 298, in doCommand
   val = command(event)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 2946, in insertNewLine
   self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
 File "C:\_Proj\Leo\key-handling\leo\src\leoEditCommands.py", line 3104, in insertNewlineHelper
   w.setInsertPoint(i+1)
TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
truncating headline to one line
#@+node:ekr.20050920084036.138:insertNewLine (changed)
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    oldSel =  w.getSelectionRange()

    self.beginCommand(undoType='newline')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand()

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine (changed)
#@+node:ekr.20050920084036.86:insertNewLineAndTab (changed)
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    c = self.c ; k = c.k
    w = self.editWidget(event) ; p = c.currentPosition()
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    self.updateTab(p,w)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab (changed)
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@-node:ekr.20080517184420.1:Fixed insert-newline bug
#@+node:ekr.20080520084355.2:Single click did not color body correctly
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
#@-node:ekr.20061031131434.192:showStateAndMode
#@+node:ekr.20080512115455.1:showStateColors
def showStateColors (self,inOutline,w):

    k = self ; c = k.c ; state = k.unboundKeyAction

    body = c.frame.body ; bodyCtrl = body.bodyCtrl

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    # g.trace(state,w,g.app.gui.widget_name(w),g.callers(4))

    # if inOutline and w == bodyCtrl:
        # return # Don't recolor the body.
    if w != bodyCtrl and not g.app.gui.widget_name(w).startswith('head'):
        # Don't recolor the minibuffer, log panes, etc.
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    # g.trace(id(w),bg,fg,self)

    if w == bodyCtrl:
        body.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
#@-node:ekr.20080512115455.1:showStateColors
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")

    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@-node:ekr.20080520084355.2:Single click did not color body correctly
#@+node:ekr.20080520084355.1:Body not colored correctly after find
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.body.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    c.beginUpdate()
    try:
        if sparseFind and not c.currentPosition().isAncestorOf(p):
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p2 in c.currentPosition().self_and_parents_iter():
                    p2.contract()
                    redraw = True
        for p in self.p.parents_iter():
            if not p.isExpanded():
                p.expand()
                redraw = True
        p = self.p
        if not p: g.trace('can not happen: self.p is None')
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    c.k.showStateAndMode(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    if p:
        c.selectPosition(p)
    else:
        c.selectPosition(c.rootPosition()) # New in Leo 4.5.

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        c.k.showStateAndMode(c.frame.body.bodyCtrl)
    else:
        c.widgetWantsFocusNow(t)
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
#@-node:ekr.20061031131434.192:showStateAndMode
#@-node:ekr.20080520084355.1:Body not colored correctly after find
#@+node:ekr.20080527084425.2:Fixed big performance bug in contract-all command
#@+node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.7:newBox
def newBox (self,p,x,y,image):

    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        # theId = self.freeBoxes.pop(0)
        d = self.freeBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleBoxes: 
        self.visibleBoxes.append(theId)

    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.7:newBox
#@+node:ekr.20040803072955.8:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):

    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        # theId = self.freeClickBoxes.pop(0)
        d = self.freeClickBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleClickBoxes:
        self.visibleClickBoxes.append(theId)
    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.8:newClickBox
#@+node:ekr.20040803072955.9:newIcon
def newIcon (self,p,x,y,image):

    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        # theId = self.freeIcons.pop(0)
        d = self.freeIcons ; theId = d.keys()[0] ; del d[theId]
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleIcons:
        self.visibleIcons.append(theId)

    if p:
        data = p,self.generation
        self.iconIds[theId] = data # Remember which vnode belongs to the icon.
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.9:newIcon
#@+node:ekr.20040803072955.10:newLine
def newLine (self,p,x1,y1,x2,y2):

    canvas = self.canvas

    if self.freeLines:
        # theId = self.freeLines.pop(0)
        d = self.freeLines ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if p:
        self.ids[theId] = p

    if theId not in self.visibleLines:
        self.visibleLines.append(theId)

    return theId
#@-node:ekr.20040803072955.10:newLine
#@+node:ekr.20040803072955.11:newText (tkTree) and helper
def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        # w,theId = self.freeText.pop()
        d = self.freeText ; data = d.keys()[0] ; w,theId = data ; del d[data]
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
        ### self.visibleText[id(p.v)] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "<Button-4>", PropagateButton4)
w.bind_class(instance_tag, "<Button-5>", PropagateButton5)
w.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@+node:ekr.20040803072955.32:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    # __pychecker__ = '--no-argsused' # theId not used.

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20040803072955.32:tree.setHeadlineText
#@-node:ekr.20040803072955.11:newText (tkTree) and helper
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@+node:ekr.20040803072955.13:destroyWidgets
def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}

    self.freeText = {}
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}

    self.canvas.delete("all")
#@-node:ekr.20040803072955.13:destroyWidgets
#@+node:ekr.20060202125419:showStats
def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))

    s = '\n' + '\n'.join(z)
    g.es_print('',s)
#@-node:ekr.20060202125419:showStats
#@-node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    c.beginUpdate()
    try: # update...
        for p in c.all_positions_with_unique_vnodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectPosition(p)
    finally:
        c.endUpdate()

    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):

    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())

def endUpdate (self,flag,scroll=False):

    self.updateCount -= 1
    # g.trace(self.updateCount,'scroll',scroll,g.callers())

    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return

    c = self.c

    # g.trace('scroll',scroll,g.callers())

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        if trace: g.trace('scroll',scroll,g.callers())
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        # g.trace('canvas',self.canvas,'bbox',bbox)
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):

    c = self.c

    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)

    if 0:
        self.canvas.delete("all")

    self.drawTopTree()

    if self.trace:
        g.trace(self.redrawCount)
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7

    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)

    if theId is None:
        # if self.trace_gc: g.printNewObjects(tag='box 1')
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        # if self.trace_gc: g.printNewObjects(tag='box 2')
        return theId
    else:
        return theId
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height

    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):

    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    # if self.trace_gc: g.printNewObjects(tag='icon 1')

    c = self.c ; v = p.v
    << compute x,y and iconVal >>
    v.iconVal = val

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)

    return 0,self.icon_width # dummy icon height,width
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.computeIcon()
assert(0 <= val <= 15)
# g.trace(v,val)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):

    theId = self.newLine(p,x1,y1,x2,y2)

    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    c = self.c

    # g.trace(x,y,p,id(self.canvas))

    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0

    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.

    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2

    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)

    self.drawClickBox(p,y)

    return h,indent
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):

    """draw text for position p at nominal coordinates x,y."""

    assert(p)

    c = self.c
    x += self.text_indent

    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    self.newText(p,x,y+self.lineyoffset)

    self.configureTextState(p)

    return self.line_height
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons & helper
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    com = self.c.editCommands
    iconsList = com.getIconList(p)
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    c = self.c ; h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        ### not ready yet.
        # s = theDict.get("icon")
        pass
    elif theType == "file":
        theFile = theDict.get("file")
        relPath = theDict.get('relPath')
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
if relPath:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",relPath)
else:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image)

    tag='userIcon-%s' % theId
    self.canvas.itemconfigure(theId,tag=(tag,'userIcon')) #BJ
    self.ids[theId] = p.copy()

    def deleteButtonCallback(event=None,c=c,p=p,fullname=fullname,relPath=relPath):
        #g.trace()
        c.editCommands.deleteIconByName(p,fullname,relPath)
        self._block_canvas_menu = True
        return 'break'

    self.canvas.tag_bind(tag,'<3>',deleteButtonCallback)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@-node:ekr.20040803072955.46:drawUserIcons & helper
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]

    # g.trace(name)

    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("exception loading:",fullname)
        g.es_exception()
        return None
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):

    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.

def inExpandedVisibleArea (self,y1):

    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):

    c = self.c

    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext(c)
    return n
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    # __pychecker__ = '--no-argsused' # event not used.
    # __pychecker__ = '--no-intdivide' # suppress warning about integer division.

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            # g.trace(delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f %3d %3d %3d" % (frac0,h1,htot,wtot))
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f %3d %3d %1.2f %1.2f" % (frac, h1,h2,lo,hi))
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f %3d %3d %1.2f %1.2f" % (frac2,h1,h2,lo,hi))

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@+node:ekr.20061030091926:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # g.trace('geom',geom,'wtot',wtot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20061030091926:<< compute frac0 >>
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.70:yoffset (tkTree)
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: print "yoffset fails:",h,v1
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = False
    if not c.positionExists(p):
        if trace: g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else: theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()
    for p2 in theIter:
        if p2 == p1:
            if trace and verbose: g.trace(h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace(h,p1.headString())
                return h, True

    if trace: g.trace('not found',p1.headString())
    return h, False
#@-node:ekr.20040803072955.70:yoffset (tkTree)
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        if trace: g.trace('scroll',scroll,g.callers())
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        # g.trace('canvas',self.canvas,'bbox',bbox)
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@-node:ekr.20080527084425.2:Fixed big performance bug in contract-all command
#@+node:ekr.20080527084425.5:Changed bindings so Home and end keys work as expected when editing a headline
#@-node:ekr.20080527084425.5:Changed bindings so Home and end keys work as expected when editing a headline
#@+node:ekr.20080509153731.1:Fixed bug: myLeoSettings.leo sometimes read twice
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/35a8ea2024036623s

> Leo will read myLeoSettings.leo twice if that's the file you are
> actually opening.  It's not worth "fixing".

It's not the file I'm actually opening, it's $HOME/myLeoSettings.leo
and $PWD/myLeoSettings.leo (using $PWD as notation for the directory
from which python was run).

I.e. when $PWD == $HOME, a command like

  python path/to/leo.py foo.leo

will read mySettings.leo and leoSettings.leo twice. 

@color
#@nonl
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        path = g.os_path_abspath(g.os_path_normpath(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080509153731.1:Fixed bug: myLeoSettings.leo sometimes read twice
#@+node:ekr.20080129103436:Compute menus list for each c
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1858451&forum_id=10228

If I create a @settings->@menus->@menu node in a file, open 
the file, then open another Leo file, the next file opens with the 
redefined menu. 

@color
#@nonl
#@+node:ekr.20080603052650.464:Reference
#@+node:ekr.20041118104831.1:class configSettings (leoCommands)
class configSettings:

    """A class to hold config settings for commanders."""

    @others
#@+node:ekr.20041118104831.2:configSettings.__init__ (c.configSettings)
def __init__ (self,c):

    self.c = c

    # Init these here to keep pylint happy.
    self.default_derived_file_encoding = None
    self.new_leo_file_encoding = None
    self.redirect_execute_script_output_to_log_pane = None
    self.tkEncoding = None

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad", "%s: %s" % (encodingName,encoding))
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__ (c.configSettings)
#@+node:ekr.20041118053731:Getters (c.configSettings)
def get (self,setting,theType):
    '''A helper function: return the commander's setting, checking the type.'''
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict (self):
    '''return the commander's abbreviation dictionary.'''
    return g.app.config.getAbbrevDict(self.c)

def getBool (self,setting,default=None):
    '''Return the value of @bool setting, or the default if the setting is not found.'''
    return g.app.config.getBool(self.c,setting,default=default)

def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getColor (self,setting):
    '''Return the value of @color setting.'''
    return g.app.config.getColor(self.c,setting)

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.

def getData (self,setting):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    return g.app.config.getData(self.c,setting)

def getDirectory (self,setting):
    '''Return the value of @directory setting, or None if the directory does not exist.'''
    return g.app.config.getDirectory(self.c,setting)

def getFloat (self,setting):
    '''Return the value of @float setting.'''
    return g.app.config.getFloat(self.c,setting)

def getFontFromParams (self,family,size,slant,weight,defaultSize=12):

    '''Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.'''

    return g.app.config.getFontFromParams(self.c,
        family, size, slant, weight, defaultSize = defaultSize)

def getInt (self,setting):
    '''Return the value of @int setting.'''
    return g.app.config.getInt(self.c,setting)

def getLanguage (self,setting):
    '''Return the value of @string setting.

    The value of this setting should be a language known to Leo.'''
    return g.app.config.getLanguage(self.c,setting)

def getMenusList (self):
    '''Return the list of entries for the @menus tree.'''
    return g.app.config.getMenusList(self.c) # Changed in Leo 4.5.

def getOpenWith (self):
    '''Return a list of dictionaries corresponding to @openwith nodes.'''
    return g.app.config.getOpenWith(self.c)

def getRatio (self,setting):
    '''Return the value of @float setting.
    Warn if the value is less than 0.0 or greater than 1.0.'''
    return g.app.config.getRatio(self.c,setting)

def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles()

def getShortcut (self,shortcutName):
    '''Return the tuple (rawKey,accel) for shortcutName in @shortcuts tree.'''
    return g.app.config.getShortcut(self.c,shortcutName)

def getString (self,setting):
    '''Return the value of @string setting.'''
    return g.app.config.getString(self.c,setting)
#@-node:ekr.20041118053731:Getters (c.configSettings)
#@+node:ekr.20041118195812:Setters... (c.configSettings)
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):

    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):

    # __pychecker__ = '--no-argsused' # p not used.

    return g.app.config.setString(self.c,setting,val)

setString = set
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters... (c.configSettings)
#@-node:ekr.20041118104831.1:class configSettings (leoCommands)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        path = g.os_path_abspath(g.os_path_normpath(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace(c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
#@+node:ekr.20041119204103:ctor
def __init__ (self,c,localFlag=True):

    # Init the base class.
    parserBaseClass.__init__(self,c,localFlag)
#@-node:ekr.20041119204103:ctor
#@+node:ekr.20041119204714:visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.headString())

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p,kind,name,val)
            except Exception:
                g.es_exception()
        else:
            print "*** no handler",kind

    return None
#@-node:ekr.20041119204714:visitNode (settingsTreeParser)
#@-node:ekr.20041119203941.3:class settingsTreeParser (parserBaseClass)
#@+node:ekr.20041119203941.2:<< class parserBaseClass >>
class parserBaseClass:

    """The base class for settings parsers."""

    << parserBaseClass data >>

    @others
#@+node:ekr.20041121130043:<< parserBaseClass data >>
# These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','buttons','commands','data','enabledplugins','font',
    'if','ifgui','ifhostname','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts',
    'buttons','menus', # New in Leo 4.4.4.
    'popup', # New in Leo 4.4.8.
    ]

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
#@-node:ekr.20041121130043:<< parserBaseClass data >>
#@+node:ekr.20041119204700: ctor (parserBaseClass)
def __init__ (self,c,localFlag):

    self.c = c
    self.localFlag = localFlag
        # True if this is the .leo file being opened,
        # as opposed to myLeoSettings.leo or leoSettings.leo.
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'buttons':      self.doButtons, # New in 4.4.4
        'color':        self.doColor,
        'commands':     self.doCommands, # New in 4.4.8.
        'data':         self.doData, # New in 4.4.6
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifhostname':   self.doIfHostname,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'menus':        self.doMenus, # New in 4.4.4

        'popup': self.doPopup, # New in 4.4.8

        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
#@-node:ekr.20041119204700: ctor (parserBaseClass)
#@+node:ekr.20080514084054.4:computeModeName (parserBaseClass)
def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j > -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i > -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    modeName = s + '-mode'
    return modeName
#@-node:ekr.20080514084054.4:computeModeName (parserBaseClass)
#@+node:ekr.20060102103625:createModeCommand (parserBaseClass)
def createModeCommand (self,modeName,name,modeDict):

    modeName = 'enter-' + modeName.replace(' ','-')

    i = name.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = name[i+2:].strip()
        modeDict ['*command-prompt*'] = prompt
        # g.trace('modeName',modeName,'*command-prompt*',prompt)

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [modeName] = modeDict
#@-node:ekr.20060102103625:createModeCommand (parserBaseClass)
#@+node:ekr.20041120103012:error
def error (self,s):

    print s

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
#@-node:ekr.20041120103012:error
#@+node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20060608221203:doAbbrev
def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
#@-node:ekr.20060608221203:doAbbrev
#@+node:ekr.20041120094940.1:doBool
def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.1:doBool
#@+node:ekr.20070925144337:doButtons
def doButtons (self,p,kind,name,val):

    '''Handle an @buttons tree.'''

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.subtree_with_unique_tnodes_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonButtonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

#@-node:ekr.20070925144337:doButtons
#@+node:ekr.20080312071248.6:doCommands
def doCommands (self,p,kind,name,val):

    '''Handle an @commands tree.'''

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@command'
    for p in p.subtree_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString(aList))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.atCommonCommandsList = aList


#@-node:ekr.20080312071248.6:doCommands
#@+node:ekr.20041120094940.2:doColor
def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
#@-node:ekr.20041120094940.2:doColor
#@+node:ekr.20071214140900:doData
def doData (self,p,kind,name,val):

    s = p.bodyString()
    lines = g.splitLines(s)
    data = [z.strip() for z in lines if z.strip() and not z.startswith('#')]

    self.set(p,kind,name,data)
#@-node:ekr.20071214140900:doData
#@+node:ekr.20041120094940.3:doDirectory & doPath
def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
#@-node:ekr.20041120094940.3:doDirectory & doPath
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20041120094940.6:doFloat
def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.6:doFloat
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120103933:doIf
def doIf(self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
#@-node:ekr.20041120103933:doIf
#@+node:ekr.20041121125416:doIfGui
@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        # __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
#@-node:ekr.20041121125416:doIfGui
#@+node:dan.20080410121257.2:doIfHostname
def doIfHostname (self,p,kind,name,val):
    """headline: @ifhostname bob,!harry,joe

    Logical AND with the comma-separated list of host names, NO SPACES.

    descends this node iff:
        h = os.environ('HOSTNAME')
        h == 'bob' and h != 'harry' and h == 'joe'"""

    __pychecker__ = '--no-argsused' # args not used.

    h = g.computeMachineName()
    names = name.split(',')

    for n in names:
        if (n[0] == '!' and h == n[1:]) or (h != n):
            # g.trace('skipping', name)
            return 'skip'

    return None

#@-node:dan.20080410121257.2:doIfHostname
#@+node:ekr.20041120104215:doIfPlatform
def doIfPlatform (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
#@-node:ekr.20041120104215:doIfPlatform
#@+node:ekr.20041120104215.1:doIgnore
def doIgnore(self,p,kind,name,val):

    return "skip"
#@-node:ekr.20041120104215.1:doIgnore
#@+node:ekr.20041120094940.5:doInt
def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.5:doInt
#@+node:ekr.20041217132253:doInts
def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041217132253:doInts
#@+node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            print
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
#@+node:ekr.20060102103625.1:doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    # __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k ; name1 = name

    # g.trace('%20s' % (name),c.fileName())
    modeName = self.computeModeName(name)

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,name1,d)
#@-node:ekr.20060102103625.1:doMode (ParserBaseClass)
#@+node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
#@-node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
#@+node:ekr.20041120104215.2:doPage
def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
#@-node:ekr.20041120104215.2:doPage
#@+node:ekr.20041121125741:doRatio
def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041121125741:doRatio
#@+node:ekr.20041120105609:doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    # __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
#@-node:ekr.20041120105609:doShortcuts (ParserBaseClass)
#@+node:ekr.20041217132028:doString
def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
#@-node:ekr.20041217132028:doString
#@+node:ekr.20041120094940.8:doStrings
def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041120094940.8:doStrings
#@+node:bobjack.20080324141020.4:doPopup & helper
def doPopup (self,p,kind,name,val):

    """
    Handle @popup menu items in @settings trees.
    """

    # __pychecker__ = '--no-argsused' # kind, not used.

    popupName = name
    popupType = val

    c = self.c ; aList = [] ; tag = '@menu'

    #g.trace(p, kind, name, val, c)

    aList = []
    p = p.copy()
    self.doPopupItems(p,aList)


    if not hasattr(g.app.config, 'context_menus'):
        g.app.config.context_menus = {}

    #if popupName in g.app.config.context_menus:
        #print '*** duplicate popup ***', popupName


    g.app.config.context_menus[popupName] = aList
#@+node:bobjack.20080324141020.5:doPopupItems
def doPopupItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s' % itemName
                        body = p.bodyString()
                        self.doPopupItems(p,aList2)
                        aList.append((kind + '\n' + body, aList2),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:bobjack.20080324141020.5:doPopupItems
#@-node:bobjack.20080324141020.4:doPopup & helper
#@-node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041124063257:munge
def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
#@-node:ekr.20041124063257:munge
#@+node:ekr.20041119204700.2:oops
def oops (self):
    print ("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20041119204700.2:oops
#@+node:ekr.20041213082558:parsers
#@+node:ekr.20041213083651:fontSettingNameToFontKind
def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
#@-node:ekr.20041213083651:fontSettingNameToFontKind
#@+node:ekr.20041213082558.1:parseFont & helper
def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@-node:ekr.20041213082558.2:parseFontLine
#@-node:ekr.20041213082558.1:parseFont & helper
#@+node:ekr.20041119205148:parseHeadline
def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
#@-node:ekr.20041119205148:parseHeadline
#@+node:ekr.20070411101643.2:parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4:parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
#@-node:ekr.20070411101643.4:parseOpenWithLine
#@-node:ekr.20070411101643.2:parseOpenWith & helper
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -> mode-name = binding
    command-name -> same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20060608222828:parseAbbrevLine (g.app.config)
def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i > -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
#@-node:ekr.20060608222828:parseAbbrevLine (g.app.config)
#@-node:ekr.20041213082558:parsers
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    # __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting:",name,"from",path)

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,bunch):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",bunch)

    # g.trace(bunch.pane,rawKey,bunch.val)
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            # g.es_print('skipping settings in',p.headString(),color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120094940.10:valueError
def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    # __pychecker__ = '--no-argsused' # p not used, but needed.

    self.error("%s is not a valid %s for %s" % (val,kind,name))
#@-node:ekr.20041120094940.10:valueError
#@+node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
def visitNode (self,p):

    # __pychecker__ = '--no-argsused' # p not used, but needed.

    self.oops()
#@-node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
#@-node:ekr.20041119203941.2:<< class parserBaseClass >>
#@+node:ekr.20041117081009:Getters... (g.app.config)
#@+node:ekr.20041123070429:canonicalizeSettingName (munge)
def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
#@-node:ekr.20041123070429:canonicalizeSettingName (munge)
#@+node:ekr.20041123092357:config.findSettingsPosition
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        #BJ munge will return None if a headstring is empty
        h = munge(p.headString()) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    return None
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20051015093141:typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
#@-node:ekr.20051015093141:typesMatch
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20051011105014:exists (g.app.config)
def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
#@-node:ekr.20051011105014:exists (g.app.config)
#@+node:ekr.20060608224112:getAbbrevDict
def getAbbrevDict (self,c):

    """Search all dictionaries for the setting & check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
#@-node:ekr.20060608224112:getAbbrevDict
#@+node:ekr.20041117081009.3:getBool
def getBool (self,c,setting,default=None):

    '''Return the value of @bool setting, or the default if the setting is not found.'''

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
#@-node:ekr.20041117081009.3:getBool
#@+node:ekr.20070926082018:getButtons
def getButtons (self):

    '''Return a list of tuples (x,y) for common @button nodes.'''

    return g.app.config.atCommonButtonsList
#@-node:ekr.20070926082018:getButtons
#@+node:ekr.20080312071248.7:getCommonCommands
def getCommonAtCommands (self):

    '''Return the list of tuples (headline,script) for common @command nodes.'''

    return g.app.config.atCommonCommandsList
#@-node:ekr.20080312071248.7:getCommonCommands
#@+node:ekr.20041122070339:getColor
def getColor (self,c,setting):

    '''Return the value of @color setting.'''

    return self.get(c,setting,"color")
#@-node:ekr.20041122070339:getColor
#@+node:ekr.20071214140900.1:getData
def getData (self,c,setting):

    '''Return a list of non-comment strings in the body text of @data setting.'''

    return self.get(c,setting,"data")
#@-node:ekr.20071214140900.1:getData
#@+node:ekr.20041117093009.1:getDirectory
def getDirectory (self,c,setting):

    '''Return the value of @directory setting, or None if the directory does not exist.'''

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
#@-node:ekr.20041117093009.1:getDirectory
#@+node:ekr.20070224075914.1:getEnabledPlugins
def getEnabledPlugins (self):

    '''Return the body text of the @enabled-plugins node.'''

    return g.app.config.enabledPluginsString
#@-node:ekr.20070224075914.1:getEnabledPlugins
#@+node:ekr.20041117082135:getFloat
def getFloat (self,c,setting):

    '''Return the value of @float setting.'''

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117082135:getFloat
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20041117081513:getInt
def getInt (self,c,setting):

    '''Return the value of @int setting.'''

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
#@-node:ekr.20041117081513:getInt
#@+node:ekr.20041117093009.2:getLanguage
def getLanguage (self,c,setting):

    '''Return the setting whose value should be a language known to Leo.'''

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
#@-node:ekr.20041117093009.2:getLanguage
#@+node:ekr.20070926070412:getMenusList (c.config)
def getMenusList (self,c):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get(c,'menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
#@-node:ekr.20070926070412:getMenusList (c.config)
#@+node:ekr.20070411101643:getOpenWith
def getOpenWith (self,c):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get(c,'openwithtable','openwithtable')

    return val
#@-node:ekr.20070411101643:getOpenWith
#@+node:ekr.20041122070752:getRatio
def getRatio (self,c,setting):

    '''Return the value of @float setting.

    Warn if the value is less than 0.0 or greater than 1.0.'''

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
#@-node:ekr.20041122070752:getRatio
#@+node:ekr.20041117062717.11:getRecentFiles
def getRecentFiles (self):

    '''Return the list of recently opened files.'''

    return self.recentFiles
#@-node:ekr.20041117062717.11:getRecentFiles
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.

    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@-node:ekr.20041117062717.14:getShortcut (config)
#@+node:ekr.20041117081009.4:getString
def getString (self,c,setting):

    '''Return the value of @string setting.'''

    return self.get(c,setting,"string")
#@-node:ekr.20041117081009.4:getString
#@+node:ekr.20041117062717.17:setCommandsIvars (not used) (leoConfig.py: configClass)
#@-node:ekr.20041117062717.17:setCommandsIvars (not used) (leoConfig.py: configClass)
#@+node:ekr.20041120074536:settingsRoot
def settingsRoot (self,c):

    '''Return the position of the @settings tree.'''

    # g.trace(c,c.rootPosition())

    for p in c.all_positions_with_unique_tnodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
#@-node:ekr.20041120074536:settingsRoot
#@-node:ekr.20041117081009:Getters... (g.app.config)
#@-node:ekr.20080603052650.464:Reference
#@+node:ekr.20080603052650.465:Changed
#@+node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
def doMenus (self,p,kind,name,val):

    # __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            print
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper (ParserBaseClass)
#@+node:ekr.20070926070412:getMenusList (c.config)
def getMenusList (self,c):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get(c,'menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
#@-node:ekr.20070926070412:getMenusList (c.config)
#@+node:ekr.20041118053731:Getters (c.configSettings)
def get (self,setting,theType):
    '''A helper function: return the commander's setting, checking the type.'''
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict (self):
    '''return the commander's abbreviation dictionary.'''
    return g.app.config.getAbbrevDict(self.c)

def getBool (self,setting,default=None):
    '''Return the value of @bool setting, or the default if the setting is not found.'''
    return g.app.config.getBool(self.c,setting,default=default)

def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getColor (self,setting):
    '''Return the value of @color setting.'''
    return g.app.config.getColor(self.c,setting)

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.

def getData (self,setting):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    return g.app.config.getData(self.c,setting)

def getDirectory (self,setting):
    '''Return the value of @directory setting, or None if the directory does not exist.'''
    return g.app.config.getDirectory(self.c,setting)

def getFloat (self,setting):
    '''Return the value of @float setting.'''
    return g.app.config.getFloat(self.c,setting)

def getFontFromParams (self,family,size,slant,weight,defaultSize=12):

    '''Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.'''

    return g.app.config.getFontFromParams(self.c,
        family, size, slant, weight, defaultSize = defaultSize)

def getInt (self,setting):
    '''Return the value of @int setting.'''
    return g.app.config.getInt(self.c,setting)

def getLanguage (self,setting):
    '''Return the value of @string setting.

    The value of this setting should be a language known to Leo.'''
    return g.app.config.getLanguage(self.c,setting)

def getMenusList (self):
    '''Return the list of entries for the @menus tree.'''
    return g.app.config.getMenusList(self.c) # Changed in Leo 4.5.

def getOpenWith (self):
    '''Return a list of dictionaries corresponding to @openwith nodes.'''
    return g.app.config.getOpenWith(self.c)

def getRatio (self,setting):
    '''Return the value of @float setting.
    Warn if the value is less than 0.0 or greater than 1.0.'''
    return g.app.config.getRatio(self.c,setting)

def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles()

def getShortcut (self,shortcutName):
    '''Return the tuple (rawKey,accel) for shortcutName in @shortcuts tree.'''
    return g.app.config.getShortcut(self.c,shortcutName)

def getString (self,setting):
    '''Return the value of @string setting.'''
    return g.app.config.getString(self.c,setting)
#@-node:ekr.20041118053731:Getters (c.configSettings)
#@-node:ekr.20080603052650.465:Changed
#@-node:ekr.20080129103436:Compute menus list for each c
#@+node:ekr.20080509065556.1:Fixed minor spelling bug
http://groups.google.com/group/leo-editor/browse_thread/thread/d2a9aeac0d0082f6

If the mis-spelled word  starts at position 0, it is detected but can
not be replaced.
#@+node:ekr.20051025071455.52:updateButtons (spellTab)
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()

    # Bug fix: enable buttons when start = 0.
    state = g.choose(self.suggestions and start is not None,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@-node:ekr.20051025071455.52:updateButtons (spellTab)
#@-node:ekr.20080509065556.1:Fixed minor spelling bug
#@+node:ekr.20080315083057.6:Fixed spell bug: words containing unicode characters aren't saved properly
#@+node:ekr.20051025071455.16:readDictionary
def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("can not open local dictionary",fileName,"using a blank one instead")
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            word = g.toUnicode(word,'utf-8', reportErrors=True)
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
#@-node:ekr.20051025071455.16:readDictionary
#@+node:ekr.20051025071455.37:add (spellTab)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % g.toEncodedString(word,'utf-8',reportErrors=True))
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("adding ", color= "blue", newline= False) 
                g.es('','%s' % self.currentWord)
        except IOError:
            g.es("can not add",self.currentWord,"to dictionary",color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@-node:ekr.20051025071455.37:add (spellTab)
#@-node:ekr.20080315083057.6:Fixed spell bug: words containing unicode characters aren't saved properly
#@-node:ekr.20080408060320.782:Bug fixes
#@+node:ekr.20080408060320.783:Features
#@+node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@-node:ekr.20080409081425.1:Remove useTextWidget option from leoKeys.py
#@+node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5

    self.currentVnode = None
    self.rootVnode = None

    # For writing
    self.read_only = False
    self.rootPosition = None
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    # self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20060919110638.13:setPositionsFromVnodes & helper
def setPositionsFromVnodes (self):

    c = self.c ; p = c.rootPosition()

    current = None
    d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
    if d:
        s = d.get('str_leo_pos')
        if s:
            current = self.archivedPositionToPosition(s)

    c.setCurrentPosition(current or c.rootPosition())
#@nonl
#@+node:ekr.20061006104837.1:archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.headString(),c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.headString())
    return p
#@nonl
#@-node:ekr.20061006104837.1:archivedPositionToPosition
#@-node:ekr.20060919110638.13:setPositionsFromVnodes & helper
#@-node:ekr.20080409111805.2:Set use_sax = True always
#@+node:ekr.20080506135044.54:Added g.unified_nodes
@nocolor

- Made t arg optional in vnode ctor.

- Removed the t arg from insertAsX.  Affects these plugins:

wrote:     base64Packager.py
wrote:     macros.py
wrote:     table.py
wrote:     templates.py
wrote:     xsltWithNodes.py

Search for tnode.

@color
#@-node:ekr.20080506135044.54:Added g.unified_nodes
#@+node:ekr.20080407090400.3:Added install nodes re Leo's home directory
@nocolor

Leo puts several files in the home directory: .leoID.txt,
.leoRecentFiles.txt, and myLeoSettings.leo.  There are various fallback directories if there is no home directory.

If you want more details, you can do what I did: do a clone-find-all for homeDir.

As for how the home directory is set, the code to do this is g.computeHomeDir.  We get the home directory with

home = os.getenv('HOME',default=None)

There are some mind-numbing details to be handled if there os.getenv does, in fact, return a directory.

@color
#@nonl
#@+node:ekr.20080407090400.4:Found: homeDir
#@+node:ekr.20070224115832:readRecentFiles & helpers
def readRecentFiles (self,localConfigFile):

    '''Read all .leoRecentFiles.txt files.'''

    # The order of files in this list affects the order of the recent files list.
    seen = [] 
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()
#@nonl
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
        if not g.unitTesting and not self.silent:
            print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)

    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@-node:ekr.20070224115832:readRecentFiles & helpers
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):

    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created',fileName,color='red')
                return
            except Exception:
                g.es_print('can not create',fileName,color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    written = False
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    print ('wrote recent file: %s' % fileName)
                    written = True
                self.writeRecentFilesFileHelper(fileName)
                # Bug fix: Leo 4.4.6: write *all* recent files.

    if written:
        self.recentFileMessageWritten = True
    else:
        pass # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
            # g.trace(fileName,'lines\n%s' % lines)
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing',fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.myGlobalConfigFile,
    self.myHomeConfigFile, and self.machineConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = g.computeMachineName() + 'LeoSettings.leo'

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        #non-prefixed names take priority over prefixed names
        ('myHomeConfigFile',    g.app.homeDir,          g.app.homeSettingsPrefix + mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          g.app.homeSettingsPrefix + machineConfigFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        #else:
            #if the path does not exist, only set to None if the ivar isn't already set.
            #dan: IMO, it's better to set the defaults to None in configClass.__init__().
            #     This avoids the creation of ivars in odd (non __init__) places.
            #setattr(self,ivar, getattr(self,ivar,None))
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20080220082727:@scan_g.es_results
@first # -*- coding: utf-8 -*-

@ To be translated...

#if and #else parts have different braces:
%s dir:
(in
)
*** Two exclusive handlers for
***Updating:
...
:
= requires @root in the headline
@comment disables untangle for
Indentation error in
Leo Log Window...
ParserError in
Referenced from
This is for testing if g.es blocks in a thread
Token error in
TokenError in
\nauto-completer scan complete
\ntest of es_print: Ă
adding
after
all plugin handlers...
all tests enabled: this may take awhile
already loaded
auto-saving outline
bad
bad @+leo sentinel
bad @+node sentinel
bad abbrev:
bad encoding in derived file:
bad open/close_flash_brackets setting: using defaults
bad tnode index:
blanks converted to tabs in
buffers...
c.target_language:
can not add
can not create
can not create temp file
can not create: read only:
can not execute
can not import
can not import Image module from PIL
can not import ImageTk module
can not import gc module
can not load enabled plugin:
can not load image:
can not open
can not open Aspell
can not open dictionary file:
can not open local dictionary
can not open script file:
can not open:
can not write %s
can't happen: is_sentinel
can't move node out of
changed:
check complete
check-derived-file passed
check-leo-file failed:
check-leo-file passed
checking Python code
clearing undo
collapse_nodes_during_finds
command is not valid in batch mode
command not ready yet
conflicting @header and @noheader directives
correcting hidden node: t=
correcting line endings in:
count:
created
created chapter
created directory:
created in
created:
creating menu from
creating new window
creating:
current directory:
debugger does not exist:
default tangle directory not found:
deleting tnode list for
directory
directory:
disabling save commands
done
dubious brackets in
dummy created
empty
enabled brief gc stats
enabled plugins...
enabled verbose gc stats
end of script
error handling:
error parsing
error pretty-printing
error reading:
error:
errors
errors inhibited read @auto
event
exception binding
exception creating directory:
exception creating temp file
exception creating:
exception deleting backup file:
exception deleting:
exception executing
exception executing command
exception executing script
exception executing:
exception handling
exception in
exception in g.importFromPath
exception in os.chmod
exception loading plugin
exception opening:
exception removing:
exception renaming
exception writing:
extend mode
file not found
file not found:
finished
first mismatched line at line
from
g.app.config: bad encoding:
g.init_zodb: can not import ZODB
g.init_zodb: exception creating ZODB.DB instance
generated line:
get_focus:
gui does not support a stand-alone find dialog
gui does not support the compare window
handlers for
hasFocusWidget:
head_lines:
ignoring
ignoring 3.x sentinel:
ignoring bad @comment directive:
ignoring bad @comment sentinel:
ignoring bad @language directive:
ignoring bad @language sentinel:
ignoring bad unknownAttributes key
ignoring command: already executing a command.
ignoring invalid key binding:
ignoring non-dictionary unknownAttributes for
ignoring non-pickleable attribute
ignoring non-string attribute
ignoring redundant -noref in:
ignoring redundant -nosent in:
ignoring:
ignoring: @comment
imported
in
in file:
indentation error in
info string
inhibits untangle for
ins:
inserting @ignore
instances
invalid @+leo sentinel in
invalid @encoding:
invalid @lineending directive:
invalid Paste As Clone
invalid encoding in .leo file:
is a sentinel line
is also a prefix of
is bound to:
is not
is not in the outline
len
leoID=
line
line:
lines
load dir:
loadOnePlugin: failed to load module
loaded plugin:
looking for a parent to tangle...
lossage...
may be read-only or in use
minibuffer hidden
missing lines
missing vnode:
modes conflict in:
newTnode: unexpected index type:
no @auto nodes in the selected tree
no @file node in the selected tree
no @file nodes in the selected tree
no @test or @suite nodes in selected outline
no Find script node
no ancestor @file node: using script line numbers
no bindings
no child index for
no children and less than 10 characters (excluding directives)
no debugger found.
no dirty @auto nodes in the selected tree
no dirty @file nodes
no docstring for
no file name
no matching #endif:
no more clones
no more misspellings
no previous command
no script selected
no state function for
no such command:
no text selected
no tnode with index:
nodes
nodes checked
not a clone:
not a valid MORE file
not changed.
not found
not found in
not found:
not written:
nothing follows section name
offending line...
offending line:\n
only
or
original line:
over-riding setting:
parent node:
path does not exist:
plugin
probably an outline topology error.
psyco now logging to:
psyco now running
putCount
putDescendentUnknownAttributes can't happen 2
putDescendentUnknownAttributes: unexpected pickling exception
putUaHelper: unexpected pickling exception
read only
read only:
reading:
recreating:
redefining
redo
relative path in @path directive:
relative_path_base_directory:
rename failed: no file created!
reopening:
replacing
requestedFocusWidget:
restoring
resurrected node:
running
save commands disabled
saved:
scanGnx: unexpected index type:
scanning for auto-completer...
seems to be mixed HTML and PHP:
selected text should contain one or more section names
selected text should start with a section name
skipping settings in
surprise in checkPythonNode
swap-words command not ready yet
syntax error in class node: can not continue
syntax error in:
syntax error: deleting
tabs converted to blanks in
tail_lines:
tangle complete
tangling parent
tangling...
the
the clipboard is not valid
the current node is not a clone
the text will be discarded
there may be conflicting settings!
time.strftime not available on this platform
time/count:
time:
to
to dictionary
unchanged:
undo
unexpected exception converting hexlified string to string
unexpected exception in
unexpected exception in app.setLeoID
unexpected exception in c.openWith
unexpected exception in g.create_temp_file
unexpected exception in g.getScript
unexpected exception in g.importFromPath(%s)
unexpected exception parsing
unexpected exception writing
unit tests
unknown attributes for
unknown attributes for tnode
unknown command name:
unknown language: using Python comment delimiters
unknown option:
unmatched
untangle complete
untangling...
using
using -asis option in:
using -thin option in:
using a blank one instead
using empty text.
using os.getenv('USER'):
warning:
warning: conflicting values for
warning: ignoring
warning: possible duplicate definition of:
warning: updating changed text in
with
write the @file node or use the Import Derived File command
writing erroneous:
wrote:
you may want to delete ressurected nodes
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
aList = 'aList'
args = 'args'
at_DOT_outputFileName = 'at.outputFileName'
at_DOT_root_DOT_headString_PARENS_ = 'at.root.headString()'
attrDict_DOT_get_LP_key_RP_ = 'attrDict.get(key)'
b2_DOT_pane = 'b2.pane'
backupName = 'backupName'
badline = 'badline'
base = 'base'
bindStroke = 'bindStroke'
bindings = 'bindings'
bunch_DOT_kind = 'bunch.kind'
c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_ = 'c.config.getBool(\'collapse_nodes_during_finds\')'
c_DOT_disableCommandsMessage = 'c.disableCommandsMessage'
c_DOT_shortFileName_PARENS_ = 'c.shortFileName()'
c_DOT_tangle_directory = 'c.tangle_directory'
c_DOT_target_language = 'c.target_language'
c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_ = 'c.widget_name(c.get_focus())'
c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_ = 'c.widget_name(c.hasFocusWidget)'
c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_ = 'c.widget_name(c.requestedFocusWidget)'
c_DOT_widget_name_LP_w_RP_ = 'c.widget_name(w)'
ch = 'ch'
command = 'command'
commandName = 'commandName'
computeProxyObject = 'computeProxyObject'
configDir = 'configDir'
count = 'count'
d_DOT_get_LP_ch_RP_ = 'd.get(ch)'
d2 = 'd2'
d3 = 'd3'
data = 'data'
debugger = 'debugger'
delim1 = 'delim1'
delim2 = 'delim2'
delim3 = 'delim3'
dictionaryFileName = 'dictionaryFileName'
dir2 = 'dir2'
doc = 'doc'
dst = 'dst'
e = 'e'
encoding = 'encoding'
encodingName = 'encodingName'
errors = 'errors'
eventName = 'eventName'
exctype_DOT___name__ = 'exctype.__name__'
fileName = 'fileName'
file_name = 'file_name'
filename = 'filename'
fn = 'fn'
g_DOT_angleBrackets_LP__DQ___DQ__RP_ = 'g.angleBrackets("*")'
g_DOT_app_DOT_globalOpenDir = 'g.app.globalOpenDir'
g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_ = 'g.app.gui.getFullVersion(c)'
g_DOT_app_DOT_gui_DOT_guiName_PARENS_ = 'g.app.gui.guiName()'
g_DOT_app_DOT_leoID = 'g.app.leoID'
g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_ = 'g.choose(val,\'on\',\'off\')'
g_DOT_get_line_LP_s_COMMA_i_RP_ = 'g.get_line(s,i)'
g_DOT_plugin_date_LP_m_RP_ = 'g.plugin_date(m)'
g_DOT_shortFileName_LP_fileName_RP_ = 'g.shortFileName(fileName)'
g_DOT_shortFileName_LP_path_RP_ = 'g.shortFileName(path)'
h = 'h'
head_lines = 'head_lines'
headline = 'headline'
homeDir = 'homeDir'
i = 'i'
index = 'index'
inputFileName = 'inputFileName'
ins = 'ins'
ivar = 'ivar'
k_DOT_prettyPrintKey_LP_stroke_RP_ = 'k.prettyPrintKey(stroke)'
k_DOT_state_DOT_kind = 'k.state.kind'
key = 'key'
keys = 'keys'
kind = 'kind'
len_LP_lines_RP_ = 'len(lines)'
len_LP_s_RP_ = 'len(s)'
letter = 'letter'
line = 'line'
line1 = 'line1'
line2 = 'line2'
loadDir = 'loadDir'
lp = 'lp'
m = 'm'
m_DOT___name__ = 'm.__name__'
m_DOT___version__ = 'm.__version__'
message = 'message'
min_LP_12_COMMA_n2_RP_ = 'min(12,n2)'
min_LP_20_COMMA_n1_RP_ = 'min(20,n1)'
modeName = 'modeName'
moduleName = 'moduleName'
msg = 'msg'
n = 'n'
n1 = 'n1'
n2 = 'n2'
n3 = 'n3'
name = 'name'
newFileName = 'newFileName'
p_DOT_headString_PARENS_ = 'p.headString()'
p_DOT_parent_PARENS__DOT_headString_PARENS_ = 'p.parent().headString()'
pane = 'pane'
part_DOT_name = 'part.name'
path = 'path'
prefix = 'prefix'
ratio = 'ratio'
relative_path = 'relative_path'
repr_LP_at_DOT_t_RP_ = 'repr(at.t)'
repr_LP_ch_RP_ = 'repr(ch)'
repr_LP_data_RP_ = 'repr(data)'
repr_LP_g_DOT_app_DOT_leoID_RP_ = 'repr(g.app.leoID)'
repr_LP_line_RP_ = 'repr(line)'
repr_LP_theId_RP_ = 'repr(theId)'
repr_LP_val_RP_ = 'repr(val)'
requestedType = 'requestedType'
root_DOT_headString_PARENS_ = 'root.headString()'
rp = 'rp'
s = 's'
s_DOT_strip_PARENS_ = 's.strip()'
s1 = 's1'
s2 = 's2'
s3 = 's3'
section_DOT_name = 'section.name'
self_DOT_currentWord = 'self.currentWord'
self_DOT_fileName = 'self.fileName'
self_DOT_outputFileName = 'self.outputFileName'
self_DOT_print_mode = 'self.print_mode'
self_DOT_putCount = 'self.putCount'
self_DOT_shortFileName = 'self.shortFileName'
self_DOT_tabName = 'self.tabName'
self_DOT_targetFileName = 'self.targetFileName'
sep = 'sep'
setting = 'setting'
shortcut = 'shortcut'
signon = 'signon'
spaces = 'spaces'
sparseMove = 'sparseMove'
src = 'src'
start = 'start'
start_line = 'start_line'
str_LP_i_1_RP_ = 'str(i+1)'
str_LP_index_RP_ = 'str(index)'
str_LP_message_RP_ = 'str(message)'
str_LP_msg_RP_ = 'str(msg)'
str_LP_n_RP_ = 'str(n)'
str_LP_time_RP_ = 'str(time)'
stroke = 'stroke'
tag = 'tag'
tail_lines = 'tail_lines'
target = 'target'
theDir = 'theDir'
theFile = 'theFile'
time_DOT_clock_PARENS_ = 'time.clock()'
title = 'title'
torv = 'torv'
type_LP_index_RP_ = 'type(index)'
type_LP_s_RP_ = 'type(s)'
url = 'url'
v_DOT_headString_PARENS_ = 'v.headString()'
val = 'val'
value = 'value'
version = 'version'
vnodeName = 'vnodeName'
word = 'word'
z = 'z'
z_line = 'z_line'
z_opt = 'z_opt'
zipMark = 'zipMark'
g.app.translateToUpperCase=True
# ---- @thin leo.py 
g.es_print('','-------------------- @thin leo.py ',color='red')
# -- node run
g.es("disabling save commands",color="red")
# -- node createFrame (leo.py)
g.es("file not found:",fileName)
# -- node getBatchScript
g.es_print("can not open script file:",name, color="red")
# -- node reportDirectories
g.es("%s dir:" % (kind),theDir,color="blue")
# -- node startPsyco
g.es("psyco now logging to:",theFile,color="blue")
g.es("psyco now running",color="blue")
# ---- @thin leoApp.py
g.es_print('','-------------------- @thin leoApp.py',color='red')
# -- node < < return if we can set leoID from sys.leoID> >
# g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
g.es_print("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < return if we can set leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es_print('unexpected exception in app.setLeoID',color='red')
# -- node < < return if we can set leoID from os.getenv('USER') > >
# g.es("using os.getenv('USER'):",repr(theId),color='red')
g.es("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node < < put up a dialog requiring a valid id > >
# g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
g.es('leoID=',repr_LP_g_DOT_app_DOT_leoID_RP_,spaces=False,color="blue")
# -- node < < attempt to create leoID.txt > >
g.es_print('',tag,'created in',theDir,color='red')
g.es('can not create',tag,'in',theDir,color='red')
# -- node app.writeWaitingLog
g.es('',s,color=color,newline=0)
# ---- @thin leoAtFile.py
g.es_print('','-------------------- @thin leoAtFile.py',color='red')
# -- node checkDerivedFile (atFile)
g.es_print('check-derived-file passed',color='blue')
# -- node < < warn on read-only file > >
g.es("read only:",fn,color="red")
# -- node read
# g.es("reading:",root.headString())
g.es("reading:",root_DOT_headString_PARENS_)
# -- node < < advise user to delete all unvisited nodes > >
# g.es('resurrected node:',p.headString(),color='blue')
g.es('resurrected node:',p_DOT_headString_PARENS_,color='blue')
g.es('in file:',fileName,color='blue')
g.es('you may want to delete ressurected nodes')
# -- node readAll (atFile)
g.es("no @file nodes in the selected tree")
# -- node readOneAtAutoNode (atFile)
# g.es("reading:",p.headString())
g.es("reading:",p_DOT_headString_PARENS_)
g.es_print('errors inhibited read @auto',fileName,color='red')
# -- node createNthChild3
g.es("dummy created")
# -- node handleLinesFollowingSentinel
g.es("using",s)
# g.es('',len(lines), "lines",m)
g.es('',len_LP_lines_RP_, "lines",m)
# -- node findChild4
g.es("write the @file node or use the Import Derived File command")
# -- node < < indicate that the node has been changed > >
# g.es("warning: updating changed text in",at.root.headString(),color="blue")
g.es("warning: updating changed text in",at_DOT_root_DOT_headString_PARENS_,color="blue")
# -- node < < bump at.correctedLines and tell about the correction > >
# g.es("correcting hidden node: t=",repr(at.t),color="red")
g.es("correcting hidden node: t=",repr_LP_at_DOT_t_RP_,color="red")
# -- node ignoreOldSentinel
g.es("ignoring 3.x sentinel:",s.strip(),color="blue")
# -- node < < handle @language > >
g.es("ignoring bad @language sentinel:",line,color="red")
# -- node < < handle @comment > >
g.es("ignoring bad @comment sentinel:",line,color="red")
# -- node copyAllTempBodyStringsToTnodes
# g.es("changed:",p.headString(),color="blue")
g.es("changed:",p_DOT_headString_PARENS_,color="blue")
# -- node < < read optional encoding param > >
g.es_print("bad encoding in derived file:",encoding)
# -- node < < set dirty and orphan bits on error > >
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node < < say the command is finished > >
g.es("finished")
g.es("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
# -- node writeAtAutoNodesHelper
g.es("finished")
g.es("no dirty @auto nodes in the selected tree")
g.es("no @auto nodes in the selected tree")
# -- node writeOneAtAutoNode & helpers
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# g.es("not written:",at.outputFileName)
g.es("not written:",at_DOT_outputFileName)
# -- node shouldWriteAtAutoNode
# g.es_print(p.headString(),'not written:',color='red')
g.es_print(p_DOT_headString_PARENS_,'not written:',color='red')
g.es_print('no children and less than 10 characters (excluding directives)',color='red')
# -- node writeMissing
g.es("finished")
g.es("no @file node in the selected tree")
# -- node hasSectionName
g.es('dubious brackets in',line)
# -- node < < handle @language > >
g.es("ignoring bad @language directive:",line,color="blue")
# -- node < < handle @comment > >
g.es("ignoring bad @comment directive:",line,color="blue")
# -- node replaceTargetFileIfDifferent
# g.es('unchanged:',self.shortFileName)
g.es('unchanged:',self_DOT_shortFileName)
# g.es('wrote:    ',self.shortFileName)
g.es('wrote:    ',self_DOT_shortFileName)
# g.es('created:  ',self.targetFileName)
g.es('created:  ',self_DOT_targetFileName)
# -- node < < report if the files differ only in line endings > >
# g.es("correcting line endings in:",self.targetFileName,color="blue")
g.es("correcting line endings in:",self_DOT_targetFileName,color="blue")
# -- node warnAboutOrpanAndIgnoredNodes
# g.es("parent node:",p.parent().headString(),color="blue")
g.es("parent node:",p_DOT_parent_PARENS__DOT_headString_PARENS_,color="blue")
# -- node writeException
# g.es("exception writing:",self.targetFileName,color="red")
g.es("exception writing:",self_DOT_targetFileName,color="red")
# g.es("exception deleting:",self.outputFileName,color="red")
g.es("exception deleting:",self_DOT_outputFileName,color="red")
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < Set comment strings from delims > >
g.es("unknown language: using Python comment delimiters")
# g.es("c.target_language:",c.target_language)
g.es("c_DOT_target_language:",c_DOT_target_language)
g.es('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
# ---- @thin leoBridge.py
g.es_print('','-------------------- @thin leoBridge.py',color='red')
# -- node < < try to get leoID from sys.leoID> >
# g.es("leoID=",g.app.leoID,spaces=False,color='red')
g.es("leoID=",g_DOT_app_DOT_leoID,spaces=False,color='red')
# -- node < < try to get leoID from "leoID.txt" > >
# g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('leoID=',g_DOT_app_DOT_leoID,' (in ',theDir,')',spaces=False,color="red")
g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
g.es('unexpected exception in app.setLeoID',color='red')
# -- node < < try to get leoID from os.getenv('USER') > >
# g.es_print("using os.getenv('USER'):",repr(theId),color='red')
g.es_print("using os.getenv('USER'):",repr_LP_theId_RP_,color='red')
# -- node reportDirectories
g.es('',kind,'directory','',':',theDir,color='blue')
# -- node createFrame (leoBridge)
g.es('file not found', fileName,'creating new window')
# ---- @thin leoChapters.py
g.es_print('','-------------------- @thin leoChapters.py',color='red')
# -- node cc.createChapterByName
g.es('created chapter',name,color='blue')
# -- node cc.error
g.es_print(s,color='red')
# ---- @thin leoColor.py
g.es_print('','-------------------- @thin leoColor.py',color='red')
# ---- @thin leoCommands.py
g.es_print('','-------------------- @thin leoCommands.py',color='red')
# -- node doCommand
# g.es(c.disableCommandsMessage,color='blue')
g.es(c_DOT_disableCommandsMessage,color='blue')
g.es('ignoring command: already executing a command.',color='red')
g.es("exception executing command")
# -- node c.signOnWithVersion
g.es("Leo Log Window...",color=color)
g.es(signon)
# g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g_DOT_app_DOT_gui_DOT_getFullVersion_LP_c_RP_,version))
# -- node openWith and allies
g.es("unexpected exception in c.openWith")
# -- node < < create or recreate temp file as needed > >
# g.es("reopening:",g.shortFileName(path),color="blue")
g.es("reopening:",g_DOT_shortFileName_LP_path_RP_,color="blue")
# -- node < < execute a command to open path in external editor > >
g.es("exception executing:",command)
# -- node createOpenWithTempFile
# g.es("recreating:  ",g.shortFileName(path),color="red")
g.es("recreating:  ",g_DOT_shortFileName_LP_path_RP_,color="red")
# g.es("creating:  ",g.shortFileName(path),color="blue")
g.es("creating:  ",g_DOT_shortFileName_LP_path_RP_,color="blue")
# g.es("time: " + str(time))
g.es("time: " + str_LP_time_RP_)
g.es("exception creating temp file",color="red")
# -- node save (commands)
g.es("save commands disabled",color="purple")
# -- node saveAs
g.es("save commands disabled",color="purple")
# -- node saveTo
g.es("save commands disabled",color="purple")
# -- node readOutlineOnly
g.es("can not open:",fileName)
# -- node readFileIntoFile
g.es("can not open:",fileName)
# -- node writeFileFromNode
g.es_print('wrote:',fileName,color='blue')
g.es('can not write %s',fileName,color='red')
# -- node c.executeScript & helpers
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
# -- node goToLineNumber & allies
# g.es("error handling:",root.headString())
g.es("error handling:",root_DOT_headString_PARENS_)
# -- node < < set root > >
g.es("no ancestor @file node: using script line numbers", color="blue")
# -- node < < read the file into lines > >
g.es("not found:",fileName)
# -- node < < 4.2: get node from gnx > >
g.es("not found:",vnodeName,color="red")
# -- node < < 4.x: scan for the node using tnodeList and n > >
# g.es_print("no child index for",root.headString(),color="red")
g.es_print("no child index for",root_DOT_headString_PARENS_,color="red")
# -- node < < set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false > >
g.es_print(s, color="red")
g.es_print(s, color="red")
g.es_print(s, color = "red")
# -- node < < set p to the first node whose headline matches vnodeName > >
g.es_print(s, color="red")
# -- node < < 3.x: scan for the node with the given childIndex > >
g.es("not found:",vnodeName, color="red")
# -- node < < put the cursor on line n2 of the body text > >
# g.es('only',len(lines),'lines',color="blue")
g.es('only',len_LP_lines_RP_,'lines',color="blue")
# -- node convertLineToVnodeNameIndexLine
g.es("bad @+leo sentinel")
# -- node < < handle delim while scanning backward > >
# g.es("line",str(n),"is a sentinel line")
g.es("line",str_LP_n_RP_,"is a sentinel line")
# -- node < < set vnodeName and (childIndex or gnx) from s > >
g.es("bad @+node sentinel")
# -- node convertAllBlanks
g.es("blanks converted to tabs in",count,"nodes")
# -- node convertAllTabs
g.es("tabs converted to blanks in",count,"nodes")
# -- node extract (test)
g.es("nothing follows section name",color="blue")
# -- node extractSection
g.es("nothing follows section name",color="blue")
# -- node < < Set headline for extractSection > >
g.es("selected text should start with a section name",color="blue")
# -- node extractSectionNames
g.es("selected text should contain one or more section names",color="blue")
# -- node < < trace head_lines, ins, tail_lines > >
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
# -- node c.findMatchingBracket, helper and test
# g.es("unmatched",repr(ch))
g.es("unmatched",repr_LP_ch_RP_)
# -- node getTime
g.es("time.strftime not available on this platform",color="blue")
# -- node addComments (test)
g.es('no text selected',color='blue')
# -- node deleteComments (test)
g.es('no text selected',color='blue')
g.es('',"'%s'" % (d2),"not found",color='blue')
g.es('',"'%s'" % (d3),"not found",color='blue')
# -- node showFindPanel
# g.es('the',g.app.gui.guiName(),
#             'gui does not support a stand-alone find dialog',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support a stand-alone find dialog',color='blue')
# -- node notValidInBatchMode
g.es('the',commandName,"command is not valid in batch mode")
# -- node c.checkOutline
g.es("all tests enabled: this may take awhile",color="blue")
# -- node < < remove unused tnodeList > >
g.es_print(s,color="blue")
# -- node < < do full tests > >
g.es('','.',newline=False)
# -- node < < give test failed message > >
g.es_print(s,color="red")
# -- node < <print summary message > >
g.es_print('',count,'nodes checked',errors,'errors',color=color)
# -- node checkAllPythonCode
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonCode
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("check complete",color="blue")
# -- node < < print dots > >
g.es('','.',newline=False)
# -- node checkPythonNode
g.es_print(s,color="blue")
# -- node tabNannyNode
g.es("ParserError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("TokenError in",headline,color="blue")
# g.es('',str(msg))
g.es('',str_LP_msg_RP_)
g.es("indentation error in",headline,"line",badline,color="blue")
g.es(message)
g.es("offending line:\n",line2)
# -- node prettyPrintNode
g.es("error pretty-printing",h,"not changed.",color="blue")
# -- node markChangedHeadlines
g.es("done",color="blue")
# -- node markChangedRoots
g.es("done",color="blue")
# -- node markClones
g.es('the current node is not a clone',color='blue')
# -- node cantMoveMessage
g.es("can't move node out of",kind,color="blue")
# -- node c.toggleSparseMove
g.es(tag,'=',sparseMove,color='blue')
# -- node goToNextClone
# g.es('not a clone:',p.headString(),color='blue')
g.es('not a clone:',p_DOT_headString_PARENS_,color='blue')
g.es("done",color="blue")
# -- node findNextClone
g.es('no more clones',color='blue')
# -- node goToNextDirtyHeadline
g.es("done",color="blue")
# -- node goToNextMarkedHeadline
g.es("done",color="blue")
# -- node openCompareWindow
# g.es('the',g.app.gui.guiName(),
#             'gui does not support the compare window',color='blue')
g.es('the',g_DOT_app_DOT_gui_DOT_guiName_PARENS_,
            'gui does not support the compare window',color='blue')
# -- node openLeoSettings and openMyLeoSettings
g.es('',name,"not found in",configDir)
g.es('',name,"not found in",configDir,"or",homeDir)
# -- node openLeoScripts
g.es('not found:',fileName)
# -- node leoDocumentation
g.es("not found:",name)
# -- node leoHome
g.es("not found:",url)
# -- node leoPlugins
g.es("not found:",name)
# -- node leoTutorial (version number)
g.es("not found:",url)
# -- node leoUsersGuide
g.es("not found:",url)
# -- node initEncoding
g.es("bad", "%s: %s" % (encodingName,encoding))
# ---- @thin leoConfig.py
g.es_print('','-------------------- @thin leoConfig.py',color='red')
# -- node error
g.es(s,color="blue")
# -- node doIfGui
g.es_print(s,color='blue')
# -- node doMenus & helper
# g.es_print('creating menu from',c.shortFileName(),color='blue')
g.es_print('creating menu from',c_DOT_shortFileName_PARENS_,color='blue')
# -- node set (parseBaseClass)
g.es("over-riding setting:",name,"from",path)
# -- node traverse (parserBaseClass)
# g.es_print('skipping settings in',p.headString(),color='blue')
g.es_print('skipping settings in',p_DOT_headString_PARENS_,color='blue')
# -- node initEncoding
g.es("g.app.config: bad encoding:","%s: %s" % (ivar,encoding))
# -- node getValFromDict
# g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
g.es_print('warning: ignoring',bunch_DOT_kind,'',setting,'is not',requestedType,color='red')
g.es_print('there may be conflicting settings!',color='red')
# -- node createRecentFiles
g.es_print('created',fileName,color='red')
g.es_print('can not create',fileName,color='red')
# -- node writeRecentFilesFileHelper
g.es('unexpected exception writing',fileName,color='red')
# -- node g.app.config.printSettings & helper
g.es('','%s %s = %s' % (letter,key,val))
# ---- @thin leoEditCommands.py
g.es_print('','-------------------- @thin leoEditCommands.py',color='red')
# -- node dynamicCompletion
g.es('command not ready yet',color='blue')
# -- node dynamicExpansion
g.es('command not ready yet',color='blue')
# -- node listAbbrevs
g.es('','%s=%s' % (z,s))
# -- node readAbbreviations
g.es('can not open',fileName)
# -- node writeAbbreviations
g.es('can not create',fileName)
# -- node listBuffers & listBuffersAlphabetically
g.es('buffers...')
g.es('',name)
g.es('buffers...')
g.es('',name)
# -- node debug & helper
g.es("info string")
# -- node findDebugger
g.es('debugger does not exist:',debugger,color='blue')
g.es('no debugger found.')
# -- node enable/disableGcTrace
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
# -- node printFocus
# g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
g.es_print('      hasFocusWidget:',c_DOT_widget_name_LP_c_DOT_hasFocusWidget_RP_)
# g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
g.es_print('requestedFocusWidget:',c_DOT_widget_name_LP_c_DOT_requestedFocusWidget_RP_)
# g.es_print('           get_focus:',c.widget_name(c.get_focus()))
g.es_print('           get_focus:',c_DOT_widget_name_LP_c_DOT_get_focus_PARENS__RP_)
# -- node appendImageDictToList
g.es('can not load image:',path)
# -- node getImage
g.es('can not import Image module from PIL',color='blue')
g.es('can not import ImageTk module',color='blue')
# -- node initBracketMatcher
g.es_print('bad open/close_flash_brackets setting: using defaults')
# -- node viewLossage
g.es('lossage...')
# g.es('',stroke or d.get(ch) or ch or 'None')
g.es('',stroke or d_DOT_get_LP_ch_RP_ or ch or 'None')
# -- node clear/set/ToggleExtendMode
# g.es('extend mode',g.choose(val,'on','off'),color='red')
g.es('extend mode',g_DOT_choose_LP_val_COMMA__SQ_on_SQ__COMMA__SQ_off_SQ__RP_,color='red')
# -- node swapWords
g.es('swap-words command not ready yet',color='blue')
# -- node getReadableTextFile
g.es('can not open',fileName)
# -- node saveFile
g.es('can not create',fileName)
# -- node helpForMinibuffer
g.es_print('',s)
# -- node helpForCommand
g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
# -- node aproposAutocompletion
g.es_print('',s)
# -- node aproposBindings
g.es_print('',s)
# -- node aproposDebuggingCommands
g.es_print('',s)
# -- node aproposFindCommands
g.es_print('',s)
# -- node loadFile & helpers
g.es('can not open',fileName)
# -- node saveMacros & helper
g.es('can not create',fileName)
# -- node findNextMatch (query-replace)
g.es('command not ready yet',color='blue')
# -- node Find options wrappers
# g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es('collapse_nodes_during_finds',c_DOT_config_DOT_getBool_LP__SQ_collapse_nodes_during_finds_SQ__RP_)
# -- node scolorizer LATER
g.es('command not ready yet',color='blue')
# -- node init_aspell
g.es_print('can not open dictionary file:',dictionaryFileName, color='red')
g.es_print('can not open Aspell',color='red')
# -- node readDictionary
g.es("can not open local dictionary",fileName,"using a blank one instead")
# -- node add
g.es("adding ", color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# g.es("can not add",self.currentWord,"to dictionary",color="red")
g.es("can not add",self_DOT_currentWord,"to dictionary",color="red")
# -- node find & helpers
g.es("no more misspellings")
# -- node hide
g.es(message,color='blue')
# -- node ignore
g.es("ignoring ",color= "blue", newline= False)
# g.es('','%s' % self.currentWord)
g.es('','%s' % self_DOT_currentWord)
# -- node report
g.es_print(message,color='blue')
# ---- @thin leoFileCommands.py
g.es_print('','-------------------- @thin leoFileCommands.py',color='red')
# -- node processingInstruction (stylesheet)
g.es('','%s: %s' % (target,data),color='blue')
# -- node startVnodes
# g.es("reading:",self.fileName)
g.es("reading:",self_DOT_fileName)
# -- node checkLeoFile (fileCommands)
g.es_print('check-leo-file passed',color='blue')
# g.es_print('check-leo-file failed:',str(message),color='red')
g.es_print('check-leo-file failed:',str_LP_message_RP_,color='red')
# -- node getLeoOutlineFromClipboard & helpers
g.es("invalid Paste As Clone",color="blue")
g.es("the clipboard is not valid ",color="blue")
# -- node < < warn on read-only files > >
g.es("read only:",fileName,color="red")
# -- node newTnode
# g.es("bad tnode index:",str(index),"using empty text.")
g.es("bad tnode index:",str_LP_index_RP_,"using empty text.")
# g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("newTnode: unexpected index type:",type_LP_index_RP_,index,color="red")
# -- node getAllLeoElements
g.es("reading:",fileName)
# -- node getPrefs
# g.es("default tangle directory not found:",c.tangle_directory)
g.es("default tangle directory not found:",c_DOT_tangle_directory)
# -- node getTnode
# g.es("no tnode with index:",str(index),"the text will be discarded")
g.es("no tnode with index:",str_LP_index_RP_,"the text will be discarded")
# -- node < < handle unknown attributes > >
g.es_print("unknown attributes for tnode",color = "blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node < < handle unknown vnode attributes > >
# g.es_print("unknown attributes for",v.headString(),color="blue")
g.es_print("unknown attributes for",v_DOT_headString_PARENS_,color="blue")
# g.es_print('',"%s = %s" % (key,attrDict.get(key)))
g.es_print('',"%s = %s" % (key,attrDict_DOT_get_LP_key_RP_))
# -- node getExistingVnode
g.es("missing vnode:",headline,color="red")
g.es("probably an outline topology error.")
# -- node getXmlVersionTag
g.es("invalid encoding in .leo file:",encoding,color="red")
# -- node getSaxUa
g.es_print('unexpected exception converting hexlified string to string')
# -- node parse_leo_file
g.es_print('error parsing',inputFileName,color='red')
g.es_print('unexpected exception parsing',inputFileName,color='red')
# -- node save (fileCommands)
g.es("clearing undo")
# -- node putSavedMessage
# g.es("saved:","%s%s" % (zipMark,g.shortFileName(fileName)))
g.es("saved:","%s%s" % (zipMark,g_DOT_shortFileName_LP_fileName_RP_))
# -- node deleteFileWithMessage
g.es("read only",color="red")
g.es("exception deleting backup file:",fileName)
# -- node putUnknownAttributes & helper
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
# -- node putUaHelper
g.es("ignoring non-string attribute",key,"in",torv,color="blue")
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute",key,"in",torv,color="blue")
# -- node < < Append tnodeList and unKnownAttributes to attrs> >
# g.es("deleting tnode list for",p.headString(),color="blue")
g.es("deleting tnode list for",p_DOT_headString_PARENS_,color="blue")
# -- node < < issue informational messages > >
# g.es("writing erroneous:",p.headString(),color="blue")
g.es("writing erroneous:",p_DOT_headString_PARENS_,color="blue")
# -- node putDescendentUnknownAttributes
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key",key,"in",p,color="blue")
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
# -- node write_Leo_file
# g.es_print('len',len(s),'putCount',self.putCount)
g.es_print('len',len_LP_s_RP_,'putCount',self_DOT_putCount)
g.es("exception writing:",fileName)
# -- node < < return if the .leo file is read-only > >
g.es("can not create: read only:",fileName,color="red")
# -- node < < create backup file > >
g.es("read only",color="red")
# -- node < < rename backupName to fileName > >
g.es("restoring",fileName,"from",backupName)
# -- node writeAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeDirtyAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeMissingAtFileNodes
g.es("auto-saving outline",color="blue")
# -- node writeOutlineOnly
g.es('done',color='blue')
# ---- @thin leoGlobals.py
g.es_print('','-------------------- @thin leoGlobals.py',color='red')
# -- node computeLoadDir
g.es("load dir:",loadDir,color="blue")
# -- node set_language
# g.es("ignoring:",g.get_line(s,i))
g.es("ignoring:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# -- node < < set theDict for @ directives > >
g.es("warning: conflicting values for",word,color="blue")
# -- node < < set theDict["root"] for noweb * chunks > >
# g.es('',g.angleBrackets("*") + "= requires @root in the headline")
g.es('',g_DOT_angleBrackets_LP__DQ___DQ__RP_ + "= requires @root in the headline")
# -- node g.scanAtEncodingDirective
g.es("invalid @encoding:",encoding,color="red")
# -- node g.scanAtLineendingDirective
g.es("invalid @lineending directive:",e,color="red")
# -- node g.scanAtPagewidthDirective
g.es("ignoring",s,color="red")
# -- node < < scan another @root option > >
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
# g.es("modes conflict in:",g.get_line(s,i))
g.es("modes conflict in:",g_DOT_get_line_LP_s_COMMA_i_RP_)
g.es("unknown option:",z_opt,"in",z_line)
# -- node g.scanAtTabwidthDirective
g.es("ignoring",s,color="red")
# -- node alert
g.es('',message)
# -- node es_dump
g.es_print('',title)
g.es_print('',aList)
# -- node es_error
g.es(s,color=color)
# -- node es_event_exception
g.es("exception handling ",eventName,"event")
g.es('',i)
# -- node es_exception_type
# g.es_print('','%s, %s' % (exctype.__name__, value),color=color)
g.es_print('','%s, %s' % (exctype_DOT___name__, value),color=color)
# -- node getLastTracebackFileAndLineNumber
# g.es_print('',repr(val))
g.es_print('',repr_LP_val_RP_)
# g.es_print('',repr(data))
g.es_print('',repr_LP_data_RP_)
# -- node Timing
# g.es('',"%s %6.3f" % (message,(time.clock()-start)))
###g.es('',"%s %6.3f" % (message,(time_DOT_clock_PARENS_-start)))
# -- node g.create_temp_file
###g.es('unexpected exception in g.create_temp_file',color='red')
# -- node g.is_sentinel
g.es("can't happen: is_sentinel",color="red")
# -- node g.makeAllNonExistentDirectories
g.es("created directory:",path)
g.es("exception creating directory:",path)
# -- node g.openLeoOrZipFile
g.es("can not open:",fileName,color="blue")
# -- node g.setGlobalOpenDir
# g.es('current directory:',g.app.globalOpenDir)
g.es('current directory:',g_DOT_app_DOT_globalOpenDir)
# -- node g.update_file_if_changed
g.es('','%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es('',file_name," may be read-only or in use")
# -- node g.utils_remove
g.es("exception removing:",fileName)
# -- node g.utils_rename
g.es('exception renaming',src,'to',dst,color='red')
# -- node g.utils_chmod
g.es("exception in os.chmod",fileName)
# -- node enable_gc_debug
g.es('can not import gc module',color='blue')
# -- node g.doHook
g.es_print(s,color="blue")
# -- node g.plugin_signon
# g.es('',"...%s.py v%s: %s" % (
#             m.__name__, m.__version__, g.plugin_date(m)))
g.es('',"...%s.py v%s: %s" % (
            m_DOT___name__, m_DOT___version__, g_DOT_plugin_date_LP_m_RP_))
# -- node mini test of es
g.es(s)
g.es_print(s)
# -- node es_print
# -- node @@test g.es_print
g.es_print('\ntest of es_print: Ă',color='red',newline=False)
g.es_print('after')
g.es_print('done')
# -- node es_trace
# -- node < < scan another @file option > >
g.es("using -asis option in:",h)
g.es("ignoring redundant -noref in:",h)
g.es("ignoring redundant -nosent in:",h)
g.es("using -thin option in:",h)
g.es("unknown option:",z_opt,"in",h)
# -- node scanError
g.es('',s)
# -- node skip_pp_if
g.es("#if and #else parts have different braces:",start_line)
g.es("no matching #endif:",start_line)
# -- node g.initScriptFind (set up dialog)
g.es("no Find script node",color="red")
# -- node g.handleScriptException
g.es("exception executing script",color='blue')
# -- node < < dump the lines near the error > >
g.es_print('',s)
g.es('',s,newline=False)
# -- node reportBadChars
g.es(s2,color='red')
g.es(s2,color='red')
# -- node g.executeScript
g.es("exception executing",name,color="red")
# -- node g.getScript
g.es_print("unexpected exception in g.getScript")
# -- node g.cantImport
g.es_print('',s,color="blue")
# -- node g.importFromPath
g.es_print("exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
                    (name),color='blue')
# -- node g.init_zodb
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')
# ---- @thin leoImport.py
g.es_print('','-------------------- @thin leoImport.py',color='red')
# -- node exportHeadlines
g.es("can not open",fileName,color="blue")
# -- node flattenOutline
g.es("can not open",fileName,color="blue")
# -- node outlineToWeb
g.es("can not open",fileName,color="blue")
# -- node < < Read file into s > >
g.es("can not open",fileName, color="blue")
# -- node < < set delims from the header line > >
g.es("invalid @+leo sentinel in",fileName)
# -- node < < Write s into newFileName > >
g.es("created:",newFileName)
g.es("exception creating:",newFileName)
# -- node < < open filename to f, or return > >
g.es("exception opening:",filename)
# -- node error
g.es('',s)
# -- node < < Read file into s > >
g.es("can not open", "%s%s" % (z,fileName),color='red')
# -- node readAtAutoNodes (importCommands) & helper
# g.es_print('ignoring',p.headString(),color='blue')
g.es_print('ignoring',p_DOT_headString_PARENS_,color='blue')
g.es(message,color='blue')
# -- node importFilesCommand
g.es("imported",fileName,color="blue")
# -- node importFlattenedOutline
g.es("not a valid MORE file",fileName)
# -- node < < Read the file into array > >
g.es("can not open",fileName, color="blue")
# -- node scanWebFile (handles limbo)
g.es("can not import",fileName, color="blue")
# -- node cstLookup
g.es('',"****** %s" % (target),"is also a prefix of",s)
g.es("replacing",target,"with",s)
# -- node scanPHPText
g.es_print('seems to be mixed HTML and PHP:',fileName)
# -- node compareHelper
# g.es_print('first mismatched line at line',str(i+1))
g.es_print('first mismatched line at line',str_LP_i_1_RP_)
g.es_print('original line: ',line1)
g.es_print('generated line:',line2)
g.es_print('missing lines')
# g.es_print('',repr(line))
g.es_print('',repr_LP_line_RP_)
# -- node checkLeadingWhitespace
# g.es_print('line:',repr(line),color='red')
g.es_print('line:',repr_LP_line_RP_,color='red')
# -- node reportMismatch
# -- node insertIgnoreDirective
g.es_print('inserting @ignore',color='blue')
# -- node error, oops, report and warning
g.es_print('',s,color='red')
g.es_print('error:',s,color='red')
g.es_print('warning:',s,color='red')
# ---- @thin leoKeys.py
g.es_print('','-------------------- @thin leoKeys.py',color='red')
# -- node showAutocompleter/CalltipsStatus
g.es(s,color='red')
g.es(s,color='red')
# -- node computeCompletionList
# g.es('',z,tabName=self.tabName)
g.es('',z,tabName=self_DOT_tabName)
# -- node info
g.es('no docstring for',word,color='blue')
g.es('',doc,tabName='Info')
g.es('no docstring for',word,color='blue')
# -- node scan
g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
# -- node scanOutline
g.es_print('scanning for auto-completer...')
g.es('','.',newline=False)
g.es_print('\nauto-completer scan complete',color='blue')
# -- node createClassObjectFromString
g.es_print('unexpected exception in',computeProxyObject)
# -- node forgivingParser
g.es_print('syntax error in class node: can not continue')
# g.es_print('syntax error: deleting',p.headString())
g.es_print('syntax error: deleting',p_DOT_headString_PARENS_)
# -- node bindKey
g.es_print('exception binding',shortcut,'to',commandName)
# -- node < < give warning and return if we try to bind to Enter or Leave > >
g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
# -- node < < remove previous conflicting definitions from bunchList > >
# g.es_print('redefining',z,'in',b2.pane,'to',commandName,'in',pane,color='red')
g.es_print('redefining',z,'in',b2_DOT_pane,'to',commandName,'in',pane,color='red')
# -- node k.initAbbrev
g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
# -- node k.makeMasterGuiBinding
# g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')
g.es_print('exception binding',bindStroke,'to',c_DOT_widget_name_LP_w_RP_,color='blue')
# -- node callStateFunction
# g.es_print('no state function for',k.state.kind,color='red')
g.es_print('no state function for',k_DOT_state_DOT_kind,color='red')
# -- node k.show/hide/toggleMinibuffer
g.es('minibuffer hidden',color='red')
g.es('',commandName,'is bound to:',shortcut)
# -- node printBindings & helper
g.es('no bindings')
g.es('','%s %s' % (sep, prefix),tabName=tabName)
g.es('','%s %s' % (sep, 'Plain Keys',),tabName=tabName)
# -- node printBindingsHelper
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName='Bindings')
# -- node printCommands
# g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-n1,s1,-(min_LP_12_COMMA_n2_RP_),s2,s3),tabName=tabName)
# -- node repeatComplexCommand & helper
g.es('no previous command',color='blue')
# -- node k.registerCommand
g.es_print('redefining',commandName, color='red')
# g.es_print('','@command: %s = %s' % (
#                 commandName,k.prettyPrintKey(stroke)),color='blue')
g.es_print('','@command: %s = %s' % (
                commandName,k_DOT_prettyPrintKey_LP_stroke_RP_),color='blue')
g.es_print('','@command: %s' % (commandName),color='blue')
# -- node createModeBindings
g.es_print('no such command:',commandName,'Referenced from',modeName)
# -- node modeHelpHelper
g.es('','%s mode\n\n' % modeName,tabName=tabName)
###g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
# -- node k.computeCompletionList
# g.es('','%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
# g.es('','%*s %*s %s' % (-(min_LP_20_COMMA_n1_RP_),s1,n2,s2,s3),tabName=tabName)
# -- node k.showFileNameTabList
g.es('',s,tabName=tabName)
# ---- @thin leoNodes.py
g.es_print('','-------------------- @thin leoNodes.py',color='red')
# -- node v.bodyString
g.es_print('',s,color="red")
# -- node v.headString & v.cleanHeadString
g.es_print('',s,color="red")
# -- node scanGnx
# g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
g.es("scanGnx: unexpected index type:",type_LP_s_RP_,'',s,color="red")
# ---- @thin leoPlugins.py
g.es_print('','-------------------- @thin leoPlugins.py',color='red')
# -- node loadHandlers & helper
# -- node loadOnePlugin
g.es_print('plugin',moduleName,'already loaded',color="blue")
g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
g.es('exception loading plugin',color='red')
g.es_print('can not load enabled plugin:',moduleName,color="red")
g.es_print('loaded plugin:',moduleName,color="blue")
# -- node printHandlers
g.es_print('handlers for',moduleName,'...')
g.es_print('all plugin handlers...')
g.es_print('','%25s %s' % (tag,key))
# -- node printPlugins
g.es_print('enabled plugins...')
g.es_print('',key)
# -- node registerExclusiveHandler
g.es("*** Two exclusive handlers for","'%s'" % (tag))
# ---- @thin leoPymacs.py
g.es_print('','-------------------- @thin leoPymacs.py',color='red')
# -- node open
g.es_print('','leoPymacs.open:','no file name')
g.es_print('','leoPymacs.open:',c)
g.es_print('','leoPymacs.open:','can not open',fileName)
# ---- @thin leoTangle.py
g.es_print('','-------------------- @thin leoTangle.py',color='red')
# -- node < < call tangle_done.run() or untangle_done.run() > >
g.es("can not execute","tangle_done.run()")
g.es("can not execute","tangle_done.run()")
# -- node initTangleCommand
g.es("tangling...")
# -- node initUntangleCommand
g.es("untangling...")
# -- node tangle
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
# -- node tangleAll
g.es("tangle complete")
# -- node tangleMarked
g.es("tangle complete")
# -- node untangle
g.es("untangle complete")
# -- node untangleAll
g.es("untangle complete")
# -- node untangleMarked
g.es("untangle complete")
# -- node untangleRoot (calls cleanup)
g.es('','@root ' + path)
# -- node < < return if @silent or unknown language > >
g.es("@comment disables untangle for",path, color="blue")
# g.es('','@%s' % (self.print_mode),"inhibits untangle for",path, color="blue")
g.es('','@%s' % (self_DOT_print_mode),"inhibits untangle for",path, color="blue")
# -- node < < Read the file into file_buf  > > in untangleRoot
g.es("error reading:",path)
# -- node tangle.put_all_roots
g.es("can not create temp file")
g.es("unchanged:",file_name)
# -- node st_check
# g.es('',' ' * 4,'warning:',lp,'',section.name,'',rp,'has been defined but not used.')
g.es('',' ' * 4,'warning:',lp,'',section_DOT_name,'',rp,'has been defined but not used.')
# -- node < <check for duplicate code definitions > >
g.es('warning: possible duplicate definition of:',s)
# -- node ust_warn_about_orphans
# g.es("warning:",'%s%s%s' % (lp,part.name,rp),"is not in the outline")
g.es("warning:",'%s%s%s' % (lp,part_DOT_name,rp),"is not in the outline")
# -- node update_def (pass 2)
# g.es("***Updating:",p.headString())
g.es("***Updating:",p_DOT_headString_PARENS_)
# -- node < < Test for @comment and @language > >
g.es("ignoring: @comment",z)
# -- node < < handle absolute @path > >
g.es("relative_path_base_directory:",base)
g.es("relative path in @path directive:",relative_path)
# -- node < < Test for @header and @noheader > >
g.es("conflicting @header and @noheader directives")
# -- node < < handle absolute path > >
g.es("relative_path_base_directory:",base)
g.es('',kind,"directory:",dir2)
# ---- @thin leoTest.py
g.es_print('','-------------------- @thin leoTest.py',color='red')
# -- node runTimerOnNode
# g.es_print("count:",count,"time/count:",ratio,'',p.headString())
g.es_print("count:",count,"time/count:",ratio,'',p_DOT_headString_PARENS_)
# -- node runTests
g.es('running',kind,'unit tests',color='blue')
g.es_print('no @test or @suite nodes in selected outline')
# -- node checkFileSyntax
g.es("syntax error in:",fileName,color="blue")
# -- node checkFileTabs
g.es_print("Token error in",fileName,color="blue")
g.es_print('',msg)
g.es_print("Indentation error in",fileName,"line",badline,color="blue")
g.es_print('',message)
g.es_print("offending line...")
g.es_print('',line)
# -- node importAllModulesInPath
g.es("path does not exist:",path)
# ---- @thin leoUndo.py
g.es_print('','-------------------- @thin leoUndo.py',color='red')
# -- node < < set newBead if we can't share the previous bead > >
g.es('exception in','setUndoRedoTypingParams',color='blue')
# -- node redoGroup
g.es("redo",count,"instances")
# -- node undoGroup
g.es("undo",count,"instances")
g.app.translateToUpperCase=False
#@nonl
#@-node:ekr.20080220082727:@scan_g.es_results
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose and not g.app.unitTesting:
        g.es_print("leoID=",g.app.leoID,spaces=False,color='red')
    # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
    g.app.leoID = g.app.leoID.replace('.','-')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose and not g.app.unitTesting:
            g.es("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId
        # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
        g.app.leoID = g.app.leoID.replace('.','-')
        return

except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
g.app.leoID = g.app.leoID.replace('.','-')

# g.trace(g.app.leoID)
g.es('leoID=',repr(g.app.leoID),spaces=False,color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                # Bug fix: 2008/3/15: periods in the id field of a gnx will corrupt the .leo file!
                g.app.leoID = g.app.leoID.replace('.','-')
                if verbose and not g.app.unitTesting:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                return
            elif verbose and not g.app.unitTesting:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es_print('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@+node:ekr.20070426092031:Consider another way to compute home directory
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4281562
By: ktenney

I don't know if this is a resolved issue, here's another approach,
looks like a good one.

email link
http://murl.se/24201

python.org os.path doc
http://murl.se/24202

>>> import os
>>> lin_key, win_key = "home", "Documents"
>>> homedir = os.path.expanduser('~')
>>> if os.name == 'nt': os_key = win_key
>>> if os.name == 'posix': os_key = lin_key
>>> print homedir.find(os_key) > -1
True

#@-node:ekr.20070426092031:Consider another way to compute home directory
#@+node:ekr.20070227094232:getLeoID
def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    << try to get leoID from sys.leoID >>
    if not g.app.leoID:
        << try to get leoID from "leoID.txt" >>
    if not g.app.leoID:
        << try to get leoID from os.getenv('USER') >>
    return g.app.leoID
#@+node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID=",g.app.leoID,spaces=False,color='red')
#@nonl
#@-node:ekr.20070227094232.1:<< try to get leoID from sys.leoID>>
#@+node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es('leoID=',g.app.leoID,' (in ',theDir,')',spaces=False,color="red")
                break
            elif verbose:
                g.es('empty ',tag,' (in ',theDir,')',spaces=False,color = "red")
        except IOError:
            g.app.leoID = None
        except Exception:
            g.app.leoID = None
            g.es('unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20070227094232.2:<< try to get leoID from "leoID.txt" >>
#@+node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'):",repr(theId),color='red')
        g.app.leoID = theId

except Exception:
    pass
#@-node:ekr.20070227094232.3:<< try to get leoID from os.getenv('USER') >>
#@-node:ekr.20070227094232:getLeoID
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es('',name,"not found in",configDir)
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es('',name,"not found in",configDir,"or",homeDir)
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leo.core.leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20080407090400.4:Found: homeDir
#@-node:ekr.20080407090400.3:Added install nodes re Leo's home directory
#@+node:ekr.20080318081653.1:Added support for @bool fixedWindow option
@nocolor

We should avoid conflicts here in the first place. We really need that
'toggle-fixed' thing (that would prevent writing window positions and node
expansion statuses to .leo file) I suggested a while back, to make collaboration
with .leo files possible...

@color
#@nonl
#@+node:ekr.20080412053100.3:Documentation
@nocolor

Leo suppresses marks, expansion state, orphan bits and current
position bits when writing fixed .leo files.  As a result, all nodes
will be collapsed and the root node will always be selected when Leo
opens a fixed .leo file.

When writing fixed .leo files, Leo writes fixed, immutable, reasonable
defaults for window size, position and body-outline ratio.
Specifically, width,height,left,top = 700,500,50,50 and the ratio is
0.5. These values are written so older versions of Leo can read fixed
files.

You make a file fixed by putting '@bool fixedWindow = True' in the
@settings tree of a particular .leo file.  The file will be fixed
after you save the file, reload the file, and save the file again.
Yes, this is clumsy, but it only has to be done once.  A toggle-fixed
file command doesn't seem that useful: using an @bool node is simple
and clear.

You can optionally specify the size and position on the screen of
fixed .leo files by putting an '@data fixedWindowPosition' node in the
@settings tree of myLeoSettings.leo or leoSettings.leo.  You should
**not** put such a node in the fixed .leo file itself--everyone who
opens the file would get that fixed position.

The body of the '@data fixedWindowPosition' node should contain
something like this:

# Must be four entries: width,height,left,top.
# Put this in myLeoSettings.leo, **not** in individual .leo files.

1200
800
50
50

Leo uses reasonable defaults for fixed .leo files if this node does
not exist, or contains something other than 4 numbers, one per line. 
#@nonl
#@-node:ekr.20080412053100.3:Documentation
#@+node:ekr.20060919145406:<< define sax classes >>
@others
#@nonl
#@+node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
class saxContentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that reads Leo files.'''

    @others
#@nonl
#@+node:ekr.20060919110638.20: __init__ & helpers
def __init__ (self,c,fileName,silent,inClipboard):

    self.c = c
    self.fileName = fileName
    self.silent = silent
    self.inClipboard = inClipboard

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    << define dispatch dict >>

    self.printElements = [] # 'all', 'v'

    # Global attributes of the .leo file...
    # self.body_outline_ratio = '0.5'
    self.global_window_position = {}
    self.encoding = 'utf-8' 

    # Semantics...
    self.content = None
    self.elementStack = []
    self.errors = 0
    self.tnxToListDict = {} # Keys are tnx's (strings), values are *lists* of saxNodeClass objects.
    self.level = 0
    self.node = None
    self.nodeList = [] # List of saxNodeClass objects with the present tnode.
    self.nodeStack = []
    self.rootNode = None # a sax node.
#@nonl
#@+node:ekr.20060919110638.21:<< define dispatch dict >>
# There is no need for an 'end' method if all info is carried in attributes.

self.dispatchDict = {
    'change_string':               (None,None),
    'find_panel_settings':         (None,None),
    'find_string':                 (None,None),
    'globals':                     (self.startGlobals,None),
    'global_log_window_position':  (None,None), # The position of the log window is no longer used.
    'global_window_position':      (self.startWinPos,None),
    'leo_file':                    (None,None),
    'leo_header':                  (self.startLeoHeader,None),
    'preferences':                 (None,None),
    't':                           (self.startTnode,self.endTnode),
    'tnodes':                      (None,None),
    'v':                           (self.startVnode,self.endVnode),
    'vh':                          (self.startVH,self.endVH),
    'vnodes':                      (self.startVnodes,None), # Causes window to appear.
}
#@nonl
#@-node:ekr.20060919110638.21:<< define dispatch dict >>
#@-node:ekr.20060919110638.20: __init__ & helpers
#@+node:ekr.20060919110638.29: Do nothing
def endElementNS(self,unused_name,unused_qname):
    g.trace(unused_name)

def endDocument(self):
    pass

def ignorableWhitespace(self,unused_whitespace):
    pass

def skippedEntity(self,name):
    g.trace(name)

def startElementNS(self,unused_name,unused_qname,unused_attrs):
    g.trace(unused_name)

def startDocument(self):
    pass
#@nonl
#@-node:ekr.20060919110638.29: Do nothing
#@+node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.23:attrsToList
def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.'''

    if 0: # check for non-unicode attributes.
        for name in attrs.getNames():
            val = attrs.getValue(name)
            if type(val) != type(u''):
                g.trace('Non-unicode attribute',name,val)

    # g.trace(g.listToString([repr(z) for z in attrs.getNames()]))

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
            for name in attrs.getNames()]
#@nonl
#@-node:ekr.20060919110638.23:attrsToList
#@+node:ekr.20060919110638.26:error
def error (self, message):

    print
    print
    print 'XML error: %s' % (message)
    print

    self.errors += 1
#@nonl
#@-node:ekr.20060919110638.26:error
#@+node:ekr.20060919110638.27:inElement
def inElement (self,name):

    return self.elementStack and name in self.elementStack
#@nonl
#@-node:ekr.20060919110638.27:inElement
#@+node:ekr.20060919110638.28:printStartElement
def printStartElement(self,name,attrs):

    indent = '\t' * self.level or ''

    if attrs.getLength() > 0:
        print '%s<%s %s>' % (
            indent,
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' ')),
    else:
        print '%s<%s>' % (
            indent,
            self.clean(name).strip()),

    if name.lower() in ['v','t','vnodes','tnodes',]:
        print
#@nonl
#@+node:ekr.20060919110638.24:attrsToString
def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
#@nonl
#@-node:ekr.20060919110638.24:attrsToString
#@+node:ekr.20060919110638.25:clean
def clean(self,s):

    return g.toEncodedString(s,"ascii")
#@nonl
#@-node:ekr.20060919110638.25:clean
#@-node:ekr.20060919110638.28:printStartElement
#@-node:ekr.20060919134313: Utils
#@+node:ekr.20060919110638.30:characters
def characters(self,content):

    if content and type(content) != type(u''):
        g.trace('Non-unicode content',repr(content))

    content = content.replace('\r','')
    if not content: return

    elementName = self.elementStack and self.elementStack[-1].lower() or '<no element name>'

    if elementName in ('t','vh'):
        # if elementName == 'vh': g.trace(elementName,repr(content))
        self.content.append(content)

    elif content.strip():
        print 'unexpected content:',elementName,repr(content)
#@nonl
#@-node:ekr.20060919110638.30:characters
#@+node:ekr.20060919110638.31:endElement & helpers
def endElement(self,name):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        indent = '\t' * (self.level-1) or ''
        print '%s</%s>' % (indent,self.clean(name).strip())

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown end element',name)
    else:
        junk,func = data
        if func:
            func()

    name2 = self.elementStack.pop()
    assert name == name2
#@nonl
#@+node:ekr.20060919110638.32:endTnode
def endTnode (self):

    for sax_node in self.nodeList:
        sax_node.bodyString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.32:endTnode
#@+node:ekr.20060919110638.33:endVnode
def endVnode (self):

    self.level -= 1
    self.node = self.nodeStack.pop()
#@nonl
#@-node:ekr.20060919110638.33:endVnode
#@+node:ekr.20060919110638.34:endVH
def endVH (self):

    if self.node:
        self.node.headString = ''.join(self.content)

    self.content = []
#@nonl
#@-node:ekr.20060919110638.34:endVH
#@-node:ekr.20060919110638.31:endElement & helpers
#@+node:ekr.20060919110638.45:getRootNode
def getRootNode (self):
    return self.rootNode
#@-node:ekr.20060919110638.45:getRootNode
#@+node:ekr.20061004054323:processingInstruction (stylesheet)
def processingInstruction (self,target,data):

    if target == 'xml-stylesheet':
        self.c.frame.stylesheet = data
        if False and not self.silent:
            g.es('','%s: %s' % (target,data),color='blue')
    else:
        g.trace(target,data)
#@nonl
#@-node:ekr.20061004054323:processingInstruction (stylesheet)
#@+node:ekr.20060919110638.35:startElement & helpers
def startElement(self,name,attrs):

    name = name.lower()

    if name in self.printElements or 'all' in self.printElements:
        self.printStartElement(name,attrs)

    self.elementStack.append(name)

    data = self.dispatchDict.get(name)

    if data is None:
        if 1: g.trace('unknown start element',name)
    else:
        func,junk = data
        if func:
            func(attrs)
#@nonl
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20060919110638.37:startGlobals
def startGlobals (self,attrs):

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val

        if name == 'body_outline_ratio':
            # self.body_outline_ratio = val
            if not self.inClipboard:
                self.c.ratio = val
            # g.trace(name,val)
        elif 0:
            g.trace(name,len(val))
#@nonl
#@-node:ekr.20060919110638.37:startGlobals
#@+node:ekr.20060919110638.38:startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getPositionAttributes(attrs)
#@nonl
#@-node:ekr.20060919110638.38:startWinPos
#@+node:ekr.20060919110638.39:startLeoHeader
def startLeoHeader (self,unused_attrs):

    self.tnxToListDict = {}
#@-node:ekr.20060919110638.39:startLeoHeader
#@+node:ekr.20060919110638.40:startVH
def startVH (self,unused_attrs):

    self.content = []
#@nonl
#@-node:ekr.20060919110638.40:startVH
#@+node:ekr.20060919112118:startVnodes
def startVnodes (self,unused_attrs):

    # __pychecker__ = '--no-argsused'

    if self.inClipboard:
        return # No need to do anything to the main window.

    c = self.c ; d = self.global_window_position

    w = d.get('width',700)
    h = d.get('height',500)
    x = d.get('left',50)
    y = d.get('top',50)
    # g.trace(d,w,h,x,y)

    # Redraw the window before writing into it.
    c.frame.setTopGeometry(w,h,x,y)
    c.frame.deiconify()
    c.frame.lift()
    c.frame.update()

    # Causes window to appear.
    # g.trace('ratio',c.frame.ratio,c.frame.secondary_ratio)
    c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
    if not self.silent and not g.unitTesting:
        g.es("reading:",self.fileName)
#@-node:ekr.20060919112118:startVnodes
#@+node:ekr.20060919110638.41:startTnode
def startTnode (self,attrs):

    if not self.inElement('tnodes'):
        self.error('<t> outside <tnodes>')

    self.content = []

    self.tnodeAttributes(attrs)
#@nonl
#@+node:ekr.20060919110638.42:tnodeAttributes
def tnodeAttributes (self,attrs):

    # The tnode must have a tx attribute to associate content with the proper node.

    node = self.node
    self.nodeList = []

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 'tx':
            self.nodeList = self.tnxToListDict.get(val,[])
            if not self.nodeList:
                self.error('Bad leo file: no node for <t tx=%s>' % (val))
        else:
            node.tnodeAttributes[name] = val

    if not self.nodeList:
        self.error('Bad leo file: no tx attribute for tnode')
#@nonl
#@-node:ekr.20060919110638.42:tnodeAttributes
#@-node:ekr.20060919110638.41:startTnode
#@+node:ekr.20060919110638.43:startVnode
def startVnode (self,attrs):

    if not self.inElement('vnodes'):
        self.error('<v> outside <vnodes>')

    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = saxNodeClass() # The dummy parent node.
        parent.headString = 'dummyNode'

    self.node = saxNodeClass()

    parent.children.append(self.node)
    self.vnodeAttributes(attrs)
    self.nodeStack.append(parent)

    return parent
#@nonl
#@+node:ekr.20060919110638.44:vnodeAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded and descendentTnodeUnknownAttributes.

def vnodeAttributes (self,attrs):

    node = self.node

    for bunch in self.attrsToList(attrs):
        name = bunch.name ; val = bunch.val
        if name == 't':
            aList = self.tnxToListDict.get(val,[])
            aList.append(self.node)
            self.tnxToListDict[val] = aList
            node.tnx = str(val) # nodeIndices.toString returns a string.
        else:
            node.attributes[name] = val
#@nonl
#@-node:ekr.20060919110638.44:vnodeAttributes
#@-node:ekr.20060919110638.43:startVnode
#@-node:ekr.20060919110638.35:startElement & helpers
#@-node:ekr.20060919110638.19:class saxContentHandler (XMLGenerator)
#@+node:ekr.20060919110638.15:class saxNodeClass
class saxNodeClass:

    '''A class representing one <v> element.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
#@nonl
#@+node:ekr.20060919110638.16: node.__init__
def __init__ (self):

    self.attributes = {}
    self.bodyString = ''
    self.headString = ''
    self.children = []
    self.tnodeAttributes = {}
    self.tnodeList = []
    self.tnx = None
#@nonl
#@-node:ekr.20060919110638.16: node.__init__
#@+node:ekr.20060919110638.17: node.__str__ & __repr__
def __str__ (self):

    return '<v: %s>' % self.headString

__repr__ = __str__
#@nonl
#@-node:ekr.20060919110638.17: node.__str__ & __repr__
#@+node:ekr.20060919110638.18:node.dump
def dump (self):

    print
    print 'node: tnx: %s len(body): %d %s' % (
        self.tnx,len(self.bodyString),self.headString)
    print 'children:',g.listToString(self.children)
    print 'attrs:',self.attributes.values()
#@nonl
#@-node:ekr.20060919110638.18:node.dump
#@-node:ekr.20060919110638.15:class saxNodeClass
#@-node:ekr.20060919145406:<< define sax classes >>
#@+node:ekr.20070626132332:es & minitest
def es(s,*args,**keys):

    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    # print 'es',repr(s)
    log = app.log
    if app.killed:
        return

    # Important: defining keyword arguments in addition to *args **does not work**.
    # See Section 5.3.4 (Calls) of the Python reference manual.
    # In other words, the following is about the best that can be done.
    color = keys.get('color')
    commas = keys.get('commas')
    commas = g.choose( 
        commas in (True,'True','true'),True,False)# default is False
    newline = keys.get('newline')
    newline = g.choose(
        newline in (False,'False','false'),False,True)# default is True
    spaces= keys.get('spaces')
    spaces = g.choose(
        spaces in (False,'False','false'),False,True)# default is True
    tabName = keys.get('tabName','Log')

        # Default goes to log pane *not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""):
        s = repr(s)
    s = g.translateArgs(s,args,commas,spaces)

    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
        else:
            app.logWaiting.append((s,color),)
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:es & minitest
#@+node:ekr.20041123092357:config.findSettingsPosition
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        #BJ munge will return None if a headstring is empty
        h = munge(p.headString()) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20080412053100.2:changed
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    if g.newDrawing:
        self.requestedFocusWidget = None
        c.requestRecolorFlag = False
        self.requestRedrawFlag = False
        self.requestRedrawScrollFlag = False
        self.requestedIconify = '' # 'iconify','deiconify'
        # g.es('Using new drawing code',color='red')

    # g.trace('Commands')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.chapterController = None
    self.frame = frame

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.hiddenRootNode.t.vnodeList = [self.hiddenRootNode]
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.nodeHistory = nodeHistory(c)

    self.contractVisitedNodes = c.config.getBool('contractVisitedNodes')
    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.fixed = c.config.getBool('fixedWindow',False)
        # New in Leo 4.5: True: Don't write window position, expansion states, marks, etc.
    self.fixedWindowPosition = c.config.getData('fixedWindowPosition')
    if self.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            self.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',repr(self.fixedWindowPosition),color='red')
    else:
        self.windowPosition = 500,700,50,50 # width,height,left,top.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo

    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20031218072017.3037:putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    c = self.c
    self.put("<globals")
    << put the body/outline ratio >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038:<< put the body/outline ratio >>
# Puts an innumerate number of digits

self.put(" body_outline_ratio=")

# New in Leo 4.5: support fixed .leo files.
self.put_in_dquotes(
    str(g.choose(c.fixed,0.5,c.frame.ratio)))
#@-node:ekr.20031218072017.3038:<< put the body/outline ratio >>
#@+node:ekr.20031218072017.3039:<< put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3039:<< put the position of this frame >>
#@+node:ekr.20031218072017.3040:<< put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@-node:ekr.20031218072017.3040:<< put the position of the log window >>
#@-node:ekr.20031218072017.3037:putGlobals
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    if isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto: forceWrite = False     # Never write non-ignored @auto trees.
    elif isThin: forceWrite = isOrphan  # Only write orphan @thin trees.
    else:        forceWrite = True      # Write all other @file trees.

    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.8.  Assign v.t.fileIndex here as needed.
if not v.t.fileIndex:
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)

if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"

    # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    # if not self.use_sax:
        # if p.equal(self.topPosition):     attr += "T" # was a bottleneck
        # if p.equal(self.currentPosition): attr += "V" # was a bottleneck

    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    if not c.fixed:
        d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for",p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.headString(),color="blue")
    p.clearOrphan()
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20060919110638.36:getPositionAttributes
def getPositionAttributes (self,attrs):

    c = self.c

    if c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}
    else:
        d = {}
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    return d
#@-node:ekr.20060919110638.36:getPositionAttributes
#@+node:ekr.20040629121554.3:c.signOnWithVersion
def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    if not g.unitTesting:
        g.es("Leo Log Window...",color=color)
        g.es(signon)
        g.es('',"python %s.%s.%s, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
        g.enl()
        if c.fixed:
            g.es_print('This is a fixed window',color='red')
#@-node:ekr.20040629121554.3:c.signOnWithVersion
#@+node:ekr.20080412172151.2:updateFixedStatus
def updateFixedStatus (self):

    c = self.c
    p = g.app.config.findSettingsPosition(c,'@bool fixedWindow')
    if p:
        import leo.core.leoConfig as leoConfig
        parser = leoConfig.settingsTreeParser(c)
        kind,name,val = parser.parseHeadline(p.headString())
        if val and val.lower() in ('true','1'):
            val = True
        else:
            val = False
        c.fixed = val

    # g.trace('c.fixed',c.fixed)
#@-node:ekr.20080412172151.2:updateFixedStatus
#@-node:ekr.20080412053100.2:changed
#@-node:ekr.20080318081653.1:Added support for @bool fixedWindow option
#@+node:ekr.20080517075806.1:Added new key-handling
This allows substantially simpler key bindings. Indeed, most per-pane bindings
have been eliminate.
#@nonl
#@+node:ekr.20080517075806.2:Vim notes
@nocolor

Other possible vim features:

- search-and-replace within the current selection,
- and to some extent macro recording and running.
- Support vim-specific features like '.', etc.
#@+node:ekr.20080517075806.3:Posting: New key handling
@nocolor

The "Huge Focus Aha", namely that focus never needs to be in the
outline pane, continues to clarify and guide my thinking:

1. There is no need for per-pane key bindings.  I'll be discussing
this in more detail as we go along.  This is itself a major
simplification.

2. Ville has discovered the heart of the matter: most modes should
continue until an unknown character is seen.  An **unknown character
for a mode** is a character for which no explicit binding has been
made for that mode.  Leo will enter a **main** (or default) mode when
the user types an unknown (unbound) character in a mode.

The main mode would be normal text-input mode for the emacs-like
bindings, and a "command" mode for vim-like bindings.  Leo already
allows the user to specify emacs-like or vim-like defaults via various
settings.  I forget the details, but they don't much matter in this
discussion.

There are a few complications with "stay in the mode until an unknown
character is seen".

A. Some modes, like the minibuffer, and vim input mode, will allow the
user to enter any unicode character.  Thus, we can't just list the
"known" bindings of a mode--there can be too many.  To handle this, we
need to create the distinction between **input modes** and **command
modes**.  Input modes continue until another mode is explicitly
requested.  Command modes continue until an unknown (unbound) key
sequence is seen.

B. Several modes, including the minibuffer and search modes, contain
implicit bindings for keys like <tab>, <return> and <backspace>.
Indeed, the user probably need not specify any bindings explicitly for
such modes.  This creates some interesting complications however.  Let
us distinguish between *text-editing* commands and *non-text-editing*
commands.  'beginning-of-line' is a text editing command; 'save-
outline' is not.  Commands such as sort-lines could be called text-
editing commands, but they make no sense in a single-line environment
such as the minibuffer or search/replace commands, so let us
tentatively call them non-text-editing commands, or rather **multi-
line-editing** commands.

As I write this, I realize that the distinction between text-editing
and non-text-editing commands implicitly assumes emacs-like *bindings*
for commands.  In the vim-like world of plain-key bindings, we could
imagine *temporarily* entering vim-command mode in the minibuffer, and
then *returning* to the minibuffer-insert-mode after the temporary vim-
command mode finished.  This could cause complications.  In general,
I'd rather stay away from a stack of modes, but only experimentation
will show what is needed.

C. Regardless of other details, some **basic editing commands/
bindings** surely must be supported in the minibuffer and search
commands:  cut, copy, paste, arrow-keys move the cursor, shift-arrow
keys extend the selection.  In emacs-like operation we can throw in
all text-editing bindings at essentially no cost.  In vim-like
operation, we can use the basic bindings, but more complex commands
would seem to require nested modes.

But the main point is that special-purpose modes will probably use
some reasonable, standard defaults based on settings for *other*
modes, plus some standard keys.  In other words, it may be possible to
dispense with explicit bindings for the minibuffer, etc.

That being so, we are left with a simple scheme:

1. Bindings apply **everywhere** in several senses.  They apply to all
panes, and bindings for text-editing commands apply in all text
widgets: the minibuffer, body pane, log pane, headlines, etc.

2. Binding unknown in a mode terminate the mode and return to the main
or default mode.

3. Non-text-editing commands, including multi-line-editing commands,
should terminate **single-line modes** such as minibuffer commands
unless a special case explicitly exists for them.

4. Bindings for **Leo-provided modes** will be created automatically
using the user's bindings for text-editing commands, plus special
characters like <tab>, <return> and <backspace>.  Leo provided modes
are the initial minibuffer mode and secondary minibuffer modes such
entering search patterns.

5. The only complication is possibly allowing vim-like command sub-
modes of single-line modes.

The code in k.masterKeyHandler is in the back of my mind as I write
this.  With luck, the new scheme will be considerably simpler than the
old, while being more flexible and more general.  Note that the way
bindings are actually specified is an entirely separate issue, which
is good because that logic is horrible.  Eliminating per-pane bindings
will help some, but not a lot.

We may want to allow the user to specify per-pane bindings as before,
but the bindings will be ignored.  But as I write this it seems like
this could cause a great deal of confusion.  Perhaps it will be better
to outlaw the old syntax entirely, or at least issue warnings that per-
pane bindings no longer have any effect.

This is all very preliminary.  I've written no code.  Your comments
are welcome now.
#@-node:ekr.20080517075806.3:Posting: New key handling
#@+node:ekr.20080517075806.4:Posting: More design notes
@nocolor

On May 7, 7:05 pm, "Edward K. Ream" <edream...@gmail.com> wrote:

> This post will be a "thinking out loud" discussion of the new design.

I've just spent some time drawing state diagrams that indicate transitions between various states.  It turned out to be more simple than I had feared.

> As I write this, I realize that the distinction between text-editing
> and non-text-editing commands implicitly assumes emacs-like *bindings*
> for commands.  

No.  The distinction has nothing to do with bindings, as my post earlier today shows.  In fact, after seeing the final state diagrams, my intention is to be able to support *both* emacs-like and vim-like bindings simultaneously.  Actually, Leo can already do this, or it could if @mode bindings actually worked :-)

The more useful distinction is between commands that change modes and commands that stay in the same mode.  This became clearer as I played with the diagrams.

Ok, let's see if I can summarize what the diagrams are trying to tell me without tying myself up in knots :-)

1. *All* modes are minibuffer modes.  That is, the present mode will always be indicated at the start of the minibuffer.  It would not be good to use the status area because the UNL plugin overwrites the status when changing nodes.

However, not all modes need actually *use* (alter) the minibuffer.  For example, a user-defined outline mode might provide bindings for just the arrow and shift arrow keys.  Nothing the user types would appear in the minibuffer during that mode.

2. @mode nodes define user modes.  These nodes can specify the "prompt" that will appear in the minibuffer while the node is active. For example:

@mode <mode name> @prompt = <prompt>

When a mode is active the minibuffer will contain as a **minibuffer prefix**:

<mode name> mode: <prompt>

As always, the prefix is protected: the user can not erase it by backspacing.

3. Binding are actually a completely separate topic from how Leo handles modes.  However, modes can create "virtual key sequences" that represent a command.  It would be extremely complex to generate those virtual key sequences in menus with the present code base--and probably for *any* version of Leo's config code.  To handle this, @item nodes in @settings trees could specify a "hint" that would look like a real menu shortcut.  Leo would completely ignore such hints: they would be only for cosmetic purposes.  Like this;

@item move-outline-left @hint = A-S-Left or [cmd]o,S-Left

The hint can be any string that makes sense to you.  In this case it signifies that there are two possible ways move an outline left: Alt-Shift-Left in any mode or type o followed by Shift-Left in command mode.

The advantage of this scheme is its simplicity and generality.  The disadvantage is that you, the user, must ensure that the hints make sense and are up-to-date.  I think it will turn out to be very handy.

4. With these preliminaries in place, the actual scheme for switching between modes is relatively straightforward:

A: The default (main) mode will be insert-mode for emacs-like operation and command-mode for vim-like operation.

B: In insert mode, edit-commands executed via menus or by key bindings will cause Leo to remain in insert mode.  All other commands transfer to other modes, with the default mode as the default.  So for emacs-like operation, control (focus) typically stays in the body pane, while for vim-like operation control typically stays in the minibuffer.

BTW, now that all modes can be considered minibuffer modes, we need to distinguish between modes that insert unbound keys (either in the present text pane or in the minibuffer) and those that don't.  For those modes that don't, any unbound key will transfer to the default mode.

C: In general (there may be smallish exceptions), a key stroke that would invoke an unknown command causes control to go to the default mode.

D: In user modes, all commands transfer to the default mode except for explicitly declared "stay-in-this-mode" commands.  This mechanism is already in place.

In short, key **bindings** no longer matter to k.masterKeyHandler.  All that matters is the command that is about to be executed.  This is a very nice simplification: all the old pane-specific logic should just go away.  Actually, it seems like an important Aha.

I now have hopes of putting this all in place in just a few days.

BTW, none of this is a "requirements specification".  That's not how I work :-)  What will emerge will be the result of playing with the code and seeing what works and what doesn't.

Edward
#@nonl
#@-node:ekr.20080517075806.4:Posting: More design notes
#@+node:ekr.20080517075806.5:Used by vim
@nocolor

Used by vim:

a/A (append after cursor)
c
d,dd,D (delete before cursor)
f/F/t/T
g,gf,g0,gg,ge,gE
h,j,k,l (motion commands)
i/I (insert before cursor, insert at indentation)
m,m',m` (marks)
n,N
o/O (open line) Why not just use <insert?>
r/R
x/X (delete after cursor)
y
u
v,V
w/W
ZZ,ZQ
.
:
;
+-
/ (patterns)
#@nonl
#@-node:ekr.20080517075806.5:Used by vim
#@+node:ekr.20080517075806.6:vim bindings: what I did
@nocolor

- Changed cycle-focus and cycle-all-focus commands.
- Removed Alt-T binding for focus-to-outline
- Paste in minibuffer (find/change) does not work.
  Added cut-text, copy-text, paste-text to list of single-line commands.  
- Bug: don't enter edit-headline in command mode.
- Bug: can't enter period in find.  Period is bound to auto-complete(!)
- Indicate input mode in mini-buffer.
- Ignore plain-key bindings in insert-mode.
- Enter outline mode after clone/copy-outline/Collapse all.
- Bound escape to set-command-mode.
- end-edit-headline should switch to body pane.
  Just set @bool stayInTreeAfterEditHeadline = False
- Enter command mode when editing headlines.
- Fix autocompletion.
- Don't allow unbound plain keys in command mode.
- State prompt (and Find prompt) in minibuffer is not protected.
- Tab completion wipes out full-command.
- Modes no longer put focus in minibuffer.
- Strip '-mode' from mode message in minibuffer.
- Show "In outline" in showStateAndMode.
- focus-to-body now enters default input state.
- End editing of headline leaves *body* in insert mode.
    - The actual bug was in k.setDefaultInputAction. It must use k.defaultUnboundKeyAction.
- Fixed bug: body pane changes color when headline mode changes.
- Python indentation now works.
- Ignore all unbound plain keys valid in command mode, except for plain auto-complete key.
- Insert mode does now persists in headline.
- Handled outline navigation.
- Don't honor command-mode keys if in tree.
- Reorganized and simplified leoSettings.leo.
- find-char should extend past line.
- Extended a, e commands: go further if at beginning/end of line.
- **Sometimes** the focus is both in the body pane and outline pane.
  For example, after save outline.
- Made legacy (insert mode) operation the default.
- All unit tests pass in legacy mode.
- Moving outlines with alt-shift-arrow keys messed up state reports.
- Autocompletion doesn't restore 'insert' mode when 'command' mode is the default.
- Control-g doesn't restore default input state, or doesn't recolor the body.
- Body pane is yellow initially, and prompt is "In Tree", but focus is in body!
- Initial body pane color should be yellow if outline has focus initially.
- Make sure minibuffer keeps its blue color.
- add empty bindings for clean-recent-files and sort-recent-files.
- Dot in insert mode when there are no autocompletions to suggest goes to command mode.
- Typing . at the start of a line with auto-completer enabled hangs leo(!)
  This happens in the trunk too.
- Disabled failed unit tests when command-mode is the default.
#@nonl
#@-node:ekr.20080517075806.6:vim bindings: what I did
#@-node:ekr.20080517075806.2:Vim notes
#@-node:ekr.20080517075806.1:Added new key-handling
#@+node:ekr.20080517075806.7:New drawing/focus code
#@+node:ekr.20080517075806.9:Notes
@nocolor

c.redraw_now is a bit of a problem.  Sometimes it can be replaced by c.redraw, sometimes not. I have been super conservative: I've left all calls to c.redraw_now alone, and added calls to c.outerUpdate as needed.

Later, when preliminary testing is complete, c.redraw_now() can call c.outerUpdate automatically.

c.bind(w,a,b) can call g.app.gui.bind(w,a,b) to avoid a gui-related case statement.

@color
#@nonl
#@+node:ekr.20080517075806.8:What I did
What I did:

- Created new version of all c.Drawing methods when g.newDrawing is True.
- Call outerUpdate from event handlers.
- Call outerUpdate after calling k.masterKeyHandlerHelper.
- Created new versions of leoBody.color methods.
- Created and test c.bind.
- Reviewed all uses of c.redraw_now(): added calls to c.outerUpdate where needed.
- Removed new wrappers from k.masterX.
- There is a slight wiggle when opening files.  It happens with the old code.
- Add c.bind2 with 3 args.
- Added call to c.outerUpdate to g.app.closeLeoWindow.
- Fixed major bug: c.redraw and c.redraw_now must request a redraw.

Changed x.bind to c.bind or c.bind2 in the following plugins:

EditAttributes.py
UASearch.py
URLloader.py
UniversalScrolling.py
fastGotoNode.py
ironPythonGui.py
mod_scripting.py
nav_buttons.py
newButtons.py
nodebar.py
pie_menus.py
plugins_menu.py
scheduler.py
searchbox.py
toolbar.py
xcc_nodes.py
#@nonl
#@-node:ekr.20080517075806.8:What I did
#@+node:ekr.20080517075806.10:Design for simplified drawing & focus
@nocolor

- c.outerUpdate actually updates everything, using c.requestedRedraw,
  c.requestedWidget, c.requestedMinibufferPrompt. c.outerUpdate may be called
  anytime to force an immediate update. The master command handler calls
  outerUpdate, as do all event handlers that make any requests.

- g.newDrawing selects between old and new code. When g.newDrawing is False,
  c.outerUpdate does nothing. When g.newDrawing is True, many of Leo's drawing
  methods simply make requests:

    - c.beginUpdate does nothing.
    - c.endUpdate sets c.requestRedrawFlag to request a redraw.
    - c.xWantsFocus set c.requestedFocusWidget.
    - c.k.showStateAndFocus sets c.requestedMinibufferPrompt.
    - c.selectPosition sets c.requestedPosition.
    - c.recolor() sets c.frame.requestRecolorFlag.

This design might substantially simplify some very complex code. My intention is
to make *no* changes to the code base except for calls to c.outerUpdate. Thus,
it will be easy to see what has changed. The experiment can be done in the
key-handling branch.

This is a higly speculative project.  Previous attempts have failed...
#@-node:ekr.20080517075806.10:Design for simplified drawing & focus
#@-node:ekr.20080517075806.9:Notes
#@+node:ekr.20080517075806.12:Menus (tkBody) (May cause problems)
def bind (self,*args,**keys):

    c = self.c
    return self.bodyCtrl.bind(*args,**keys)
#@-node:ekr.20080517075806.12:Menus (tkBody) (May cause problems)
#@+node:ekr.20080517075806.13:Projects
#@+node:ekr.20080517075806.14:Classified commands
#@-node:ekr.20080517075806.14:Classified commands
#@+node:ekr.20080517075806.15:@strings  [ignore,insert, overwrite] top_level_unbound_key_action = insert
@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

ignore:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.
#@nonl
#@-node:ekr.20080517075806.15:@strings  [ignore,insert, overwrite] top_level_unbound_key_action = insert
#@+node:ekr.20080517075806.16:Modes no longer put focus in minibuffer
#@-node:ekr.20080517075806.16:Modes no longer put focus in minibuffer
#@+node:ekr.20080517075806.17:Reset input state in end-edit-headline
#@-node:ekr.20080517075806.17:Reset input state in end-edit-headline
#@+node:ekr.20080517075806.18:Don't honor command-mode keys if not in text widget
#@-node:ekr.20080517075806.18:Don't honor command-mode keys if not in text widget
#@+node:ekr.20080517075806.20:Make sure keyboard-quit enters default mode, except during auto-completion
#@-node:ekr.20080517075806.20:Make sure keyboard-quit enters default mode, except during auto-completion
#@+node:ekr.20080517075806.22:Munged mode names to create mode prompt
@nocolor

In @mode aString, everything before the first :: is the mode name, and everything after is the prompt that appears in the minibuffer.  If there is no ::, the prompt is the same as the mode name.
#@nonl
#@-node:ekr.20080517075806.22:Munged mode names to create mode prompt
#@+node:ekr.20080517075806.23:Fixed an unusual headline click problem
@

This happens when focus is in the minibuffer and the user clicks a headline.

The fix was to add a "don't color" arg to showStateAndMode.

I also changed treeWantsFocus to treeWantsFocusNow in OnActivateHeadline.
#@nonl
#@-node:ekr.20080517075806.23:Fixed an unusual headline click problem
#@-node:ekr.20080517075806.13:Projects
#@-node:ekr.20080517075806.7:New drawing/focus code
#@+node:ekr.20080517075806.24:Improved end of calltips
# Added ')' at end.
#@nonl
#@-node:ekr.20080517075806.24:Improved end of calltips
#@+node:ekr.20080517075806.19:Find character crosses lines
#@-node:ekr.20080517075806.19:Find character crosses lines
#@+node:ekr.20080520090822.1:Added os.curdir to sys.path if possible
# This is necessary to simulate operation as a package.
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:
    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

# Add the current directory to sys.path *before* importing g.
# This will fail if the current directory contains unicode characters...
path = os.getcwd()
if path not in sys.path:
    # print 'appending %s to sys.path' % path
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

# Set leoGlobals.g, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@-node:ekr.20080520090822.1:Added os.curdir to sys.path if possible
#@+node:ekr.20080521132317.1:Added support for single-config option
# This code appears to have been reverted in such a way that it never got pushed to launchpad.
#@nonl
#@+node:ekr.20031218072017.1934:run
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    # __pychecker__ = '--no-argsused' # keywords not used.

    import pdb ; pdb = pdb.set_trace

    << import leoGlobals and leoApp >>
    if not jyLeo and not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath(g)
    script,windowFlag = scanOptions(g)
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    if not fileName:
        fileName = getFileName()

    << import other early files >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName,relativeFileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leo.core.leoSwingGui as leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    if g.app.oneConfigFilename: g.es_print('--one-config option in effect',color='red')
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    # Respect c's focus wishes if posssible.
    w = g.app.gui.get_focus(c)
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)
    c.outerUpdate()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:
    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

# Add the current directory to sys.path *before* importing g.
# This will fail if the current directory contains unicode characters...
path = os.getcwd()
if path not in sys.path:
    # print 'appending %s to sys.path' % path
    sys.path.append(path)

# Import leoGlobals, but do NOT set g.
import leo.core.leoGlobals as leoGlobals

# Set leoGlobals.g, rather than in leoGlobals.py.
leoGlobals.g = leoGlobals

import leo.core.leoApp as leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import other early files>>
import leo.core.leoNodes as leoNodes
import leo.core.leoConfig as leoConfig

# There is a circular dependency between leoCommands and leoEditCommands.
import leo.core.leoCommands as leoCommands

# try:
    # import leo.core.leoNodes as leoNodes
# except ImportError:
    # print "Error importing leoNodes.py"
    # import traceback ; traceback.print_exc()

# try:
    # import leo.core.leoConfig as leoConfig
# except ImportError:
    # print "Error importing leoConfig.py"
    # import traceback ; traceback.print_exc()
#@-node:ekr.20041219072416.1:<< import other early files>>
#@-node:ekr.20031218072017.1934:run
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions(g):

    '''Handle all options and remove them from sys.argv.'''

    import optparse

    parser = optparse.OptionParser()
    parser.add_option('--one-config',dest="one_config_path")
    parser.add_option('--silent',action="store_false",dest="silent")
    parser.add_option('--script',dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # --one-config
    path = options.one_config_path
    if path:
        path = g.os_path_abspath(g.os_path_join(os.getcwd(),path))
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid option: file not found:',s,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag

#@-node:ekr.20080521132317.2:scanOptions
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # g.trace(g.app.oneConfigFilename)
    if g.app.oneConfigFilename:
        table = ((g.app.oneConfigFilename,False),)
    else:
        table = (
            (self.globalConfigFile,False),
            (self.homeFile,False),
            (localConfigFile,False),
            (self.myGlobalConfigFile,False),
            (self.myHomeConfigFile,False),
            (self.machineConfigFile,False),
            (myLocalConfigFile,False),
            (fileName,True),
        )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        path = g.os_path_abspath(g.os_path_normpath(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@-node:ekr.20080521132317.1:Added support for single-config option
#@+node:ekr.20080531075119.8:Finished Tracer class
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            # g.trace('@auto',p.headString(),'name',p.atAutoNodeName())
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20041005105605.21:read (atFile)
# The caller must enclose this code in beginUpdate/endUpdate.
# Reads @thin, @file and @noref trees.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading:",root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        << advise user to delete all unvisited nodes >>
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.headString(),color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

#@-node:ekr.20071105164407:<< advise user to delete all unvisited nodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read (atFile)
#@+node:ekr.20080531075119.1:class Tracer & g.startTracer
class Tracer:

    '''A "debugger" that computes a call graph.

    To trace a function and its callers, put the following at the function's start:

    g.startTracer()
    '''

	@others

def startTracer():

    import sys
    t = g.Tracer()
    sys.settrace(t.tracer)
    return t
#@+node:ekr.20080531075119.2: __init__
def __init__(self):

    self.callDict = {}
        # Keys are function names.
        # Values are the number of times the function was called by the caller.
    self.calledDict = {}
        # Keys are function names.
        # Values are the total number of times the function was called.

    self.count = 0
    self.inited = False
    self.limit = 2 # 0: no limit, otherwise, limit trace to n entries deep.
    self.stack = []
    self.trace = False
    self.verbose = False # True: print returns as well as calls.
#@-node:ekr.20080531075119.2: __init__
#@+node:ekr.20080531075119.3:computeName
def computeName (self,frame):

    import inspect

    if not frame: return ''

    code = frame.f_code ; result = []

    module = inspect.getmodule(code)
    if module:
        module_name = module.__name__
        if module_name == 'leo.core.leoGlobals':
            result.append('g')
        else:
            tag = 'leo.core.'
            if module_name.startswith(tag):
                module_name = module_name[len(tag):]
            result.append(module_name)

    try:
        # This can fail during startup.
        self_obj = frame.f_locals.get('self')
        if self.obj: result.append(self_obj.__class__.__name__)
    except Exception:
        pass

    result.append(code.co_name)

    return '.'.join(result)
#@-node:ekr.20080531075119.3:computeName
#@+node:ekr.20080531075119.4:report
def report (self):

    if 0:
        print ; print 'stack'
        for z in self.stack:
            print z

    print ; print 'callDict...'

    # print g.dictToString(self.callDict)
    keys = self.callDict.keys()
    keys.sort()
    for key in keys:
        # Print the calling function.
        print '%d' % (self.calledDict.get(key,0)),key
        # Print the called functions.
        d = self.callDict.get(key)
        keys2 = d.keys()
        keys2.sort()
        for key2 in keys2:
            print '%8d' % (d.get(key2)),key2
#@-node:ekr.20080531075119.4:report
#@+node:ekr.20080531075119.5:stop
def stop (self):

    sys.settrace(None)
    self.report()
#@-node:ekr.20080531075119.5:stop
#@+node:ekr.20080531075119.6:tracer
def tracer (self, frame, event, arg):

    '''A function to be passed to sys.settrace.'''

    n = len(self.stack)
    if event == 'return': n = max(0,n-1)
    pad = '.' * n

    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) < self.limit):
            g.trace('%scall' % (pad),name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    elif event == 'return':
        if self.stack:
            name = self.stack.pop()
            if self.trace and self.verbose and (self.limit == 0 or len(self.stack) < self.limit):
                g.trace('%sret ' % (pad),name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        else:
            self.stop()
            return None
    else:
        return self.tracer
#@-node:ekr.20080531075119.6:tracer
#@+node:ekr.20080531075119.7:updateStats
def updateStats (self,name):

    if not self.stack:
        return

    caller = self.stack[-1]
    d = self.callDict.get(caller,{})
        # d is a dict reprenting the called functions.
        # Keys are called functions, values are counts.
    d[name] = 1 + d.get(name,0)
    self.callDict[caller] = d

    # Update the total counts.
    self.calledDict[name] = 1 + self.calledDict.get(name,0)
#@-node:ekr.20080531075119.7:updateStats
#@-node:ekr.20080531075119.1:class Tracer & g.startTracer
#@-node:ekr.20080531075119.8:Finished Tracer class
#@+node:ekr.20080527084425.4:Rewrote option-parsing code using optparse
#@+node:ekr.20080521132317.2:scanOptions
def scanOptions(g):

    '''Handle all options and remove them from sys.argv.'''

    import optparse

    parser = optparse.OptionParser()
    parser.add_option('--one-config',dest="one_config_path")
    parser.add_option('--silent',action="store_false",dest="silent")
    parser.add_option('--script',dest="script")
    parser.add_option('--script-window',dest="script_window")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # --one-config
    path = options.one_config_path
    if path:
        path = g.os_path_abspath(g.os_path_join(os.getcwd(),path))
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid option: file not found:',s,color='red')

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent

    # Compute the return values.
    windowFlag = script and script_path_w
    return script, windowFlag

#@-node:ekr.20080521132317.2:scanOptions
#@-node:ekr.20080527084425.4:Rewrote option-parsing code using optparse
#@+node:ekr.20080602172531.3:Added @bool cleo_color_ignore = True
This determines whether cleo colors @ignore headlines. The default is True.
#@nonl
#@-node:ekr.20080602172531.3:Added @bool cleo_color_ignore = True
#@-node:ekr.20080408060320.783:Features
#@+node:ekr.20080529054218.2:Benchmarked the read code
To do:

- Use cProfile.
- Sort first by module, then by time (**not** cumulative)
#@nonl
#@+node:ekr.20031218072017.2607:profile_leo
@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g

    name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    # name = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','leoProfile.txt'))

    profile.run('leo.run()',name)

    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)
#@-node:ekr.20031218072017.2607:profile_leo
#@+node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20051104075904.3:isSuiteNode and isTestNode
def isSuiteNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@suite")

def isTestNode (p):
    h = p.headString().lower()
    return g.match_word(h,0,"@test")

# def isTestCaseNode (p):
    # h = p.headString().lower()
    # return g.match_word(h,0,"@testcase") or g.match_word(h,0,"@test-case")
#@-node:ekr.20051104075904.3:isSuiteNode and isTestNode
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    if all:
        p = c.rootPosition()
    else:
        p = c.currentPosition()
    p1 = p.copy()

    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        if all: last = None
        else:   last = p.nodeAfterTree()
        while p and p != last:
            h = p.headString()
            if g.match_word(h,0,'@ignore'):
                p.moveToNodeAfterTree()
            elif isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
                p.moveToThreadNext()
            elif isSuiteNode(p): # @suite
                # g.trace(p.headString())
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
                p.moveToThreadNext()
            else:
                p.moveToThreadNext()

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    # __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # To do: restore the outline.
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # import leo.core.leoGlobals as g

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!

    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    # import leo.core.leoGlobals as g
    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20051104075904.14:runProfileOnNode
# A utility for use by script buttons.

def runProfileOnNode (p,outputPath=None):

    s = p.bodyString().rstrip() + '\n'

    if outputPath is None:
        # outputPath = g.os_path_abspath(
            # g.os_path_join(
                # g.app.loadDir,'..','test','profileStats'))
        outputPath = name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"

    profile.run(s,outputPath)

    if 1:
        stats = pstats.Stats(outputPath)
        stats.strip_dirs()
        stats.sort_stats('cum','file','name')
        stats.print_stats()
#@-node:ekr.20051104075904.14:runProfileOnNode
#@+node:ekr.20051104075904.15:runTimerOnNode
# A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'

    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p and p.copy()}

    # This looks like the best we can do.
    setup = 'import leo.core.leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        ratio = "%f" % (float(result)/float(count))
        g.es_print("count:",count,"time/count:",ratio,'',p.headString())
    except:
        t.print_exc()
#@-node:ekr.20051104075904.15:runTimerOnNode
#@-node:ekr.20051104075904.2:Support @profile, @suite, @test, @timer
#@+node:ekr.20080529114024.1:Stats
@killcolor

C:\leo.repo\trunk>python
Python 2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)] on win32

         881734 function calls (875681 primitive calls) in 17.168 CPU seconds

   Ordered by: file name, call count, internal time, function name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

      412    0.001    0.000    0.001    0.000 cp1252.py:14(decode)
       14    0.000    0.000    0.000    0.000 cp1252.py:11(encode)
        3    0.000    0.000    0.000    0.000 cp437.py:11(encode)
        1    0.004    0.004    0.004    0.004 dis.py:1(<module>)


        1    0.004    0.004    0.004    0.004 expat.py:1(<module>)
     4254    0.014    0.000    0.122    0.000 expatreader.py:300(start_element)
     4254    0.006    0.000    0.051    0.000 expatreader.py:303(end_element)
        8    0.000    0.000    0.310    0.039 expatreader.py:196(feed)
        4    0.000    0.000    0.000    0.000 expatreader.py:244(reset)
        4    0.000    0.000    0.000    0.000 expatreader.py:223(_reset_cont_handler)
        2    0.000    0.000    0.000    0.000 expatreader.py:213(close)
        2    0.000    0.000    0.310    0.155 expatreader.py:100(parse)
        2    0.000    0.000    0.000    0.000 expatreader.py:87(__init__)
        2    0.000    0.000    0.000    0.000 expatreader.py:404(create_parser)
        2    0.000    0.000    0.000    0.000 expatreader.py:115(setContentHandler)
        2    0.000    0.000    0.000    0.000 expatreader.py:109(prepareParser)
        2    0.000    0.000    0.000    0.000 expatreader.py:54(__init__)
        2    0.000    0.000    0.000    0.000 expatreader.py:132(setFeature)
        1    0.008    0.008    0.013    0.013 expatreader.py:4(<module>)
        1    0.000    0.000    0.000    0.000 expatreader.py:84(ExpatParser)
        1    0.000    0.000    0.000    0.000 expatreader.py:48(ExpatLocator)

    14209    0.015    0.000    0.094    0.000 pyexpat.c:479(CharacterData)
     4254    0.005    0.000    0.127    0.000 pyexpat.c:604(StartElement)
     4254    0.005    0.000    0.056    0.000 pyexpat.c:656(EndElement)
        2    0.000    0.000    0.000    0.000 pyexpat.c:662(ProcessingInstruction)
        1    0.000    0.000    0.000    0.000 python.py:5(<module>)
      204    0.002    0.000    0.145    0.001 re.py:219(_compile)
      117    0.000    0.000    0.001    0.000 re.py:126(match)
       84    0.000    0.000    0.143    0.002 re.py:178(compile)
       11    0.000    0.000    0.000    0.000 re.py:196(escape)
        3    0.000    0.000    0.001    0.000 re.py:131(search)

     1686    0.001    0.000    0.001    0.000 sre_compile.py:24(_identityfunction)
   892/81    0.014    0.000    0.040    0.000 sre_compile.py:38(_compile)
      310    0.001    0.000    0.001    0.000 sre_compile.py:360(_simple)
      301    0.013    0.000    0.022    0.000 sre_compile.py:213(_optimize_charset)
      301    0.002    0.000    0.025    0.000 sre_compile.py:184(_compile_charset)
      162    0.000    0.000    0.000    0.000 sre_compile.py:480(isstring)
       88    0.005    0.000    0.005    0.000 sre_compile.py:264(_mk_bitmap)
       81    0.001    0.000    0.013    0.000 sre_compile.py:367(_compile_info)
       81    0.001    0.000    0.143    0.002 sre_compile.py:501(compile)
       81    0.000    0.000    0.053    0.001 sre_compile.py:486(_code)
       16    0.000    0.000    0.000    0.000 sre_compile.py:57(fixup)
        1    0.002    0.002    0.003    0.003 sre_compile.py:307(_optimize_unicode)
    11989    0.025    0.000    0.033    0.000 sre_parse.py:188(__next)
    10954    0.012    0.000    0.042    0.000 sre_parse.py:207(get)
     3665    0.003    0.000    0.006    0.000 sre_parse.py:201(match)
     3176    0.002    0.000    0.002    0.000 sre_parse.py:136(__getitem__)
     1553    0.001    0.000    0.002    0.000 sre_parse.py:132(__len__)
     1212    0.001    0.000    0.002    0.000 sre_parse.py:144(append)
 1129/415    0.006    0.000    0.008    0.000 sre_parse.py:146(getwidth)
      892    0.001    0.000    0.001    0.000 sre_parse.py:96(__init__)
   499/84    0.025    0.000    0.087    0.001 sre_parse.py:385(_parse)
   375/81    0.004    0.000    0.087    0.001 sre_parse.py:307(_parse_sub)
      310    0.001    0.000    0.001    0.000 sre_parse.py:140(__getslice__)
      310    0.000    0.000    0.000    0.000 sre_parse.py:138(__setitem__)
      231    0.000    0.000    0.000    0.000 sre_parse.py:216(isident)
      225    0.001    0.000    0.001    0.000 sre_parse.py:231(_class_escape)
      198    0.001    0.000    0.001    0.000 sre_parse.py:263(_escape)
      143    0.000    0.000    0.000    0.000 sre_parse.py:78(opengroup)
      143    0.000    0.000    0.000    0.000 sre_parse.py:89(closegroup)
       81    0.001    0.000    0.089    0.001 sre_parse.py:669(parse)
       81    0.000    0.000    0.000    0.000 sre_parse.py:184(__init__)
       81    0.000    0.000    0.000    0.000 sre_parse.py:73(__init__)
       38    0.000    0.000    0.000    0.000 sre_parse.py:222(isname)
        6    0.000    0.000    0.000    0.000 sre_parse.py:211(tell)
        2    0.000    0.000    0.000    0.000 sre_parse.py:219(isdigit)

        5    0.000    0.000    0.000    0.000 stat.py:29(S_IFMT)
        3    0.000    0.000    0.000    0.000 stat.py:45(S_ISDIR)
        2    0.000    0.000    0.000    0.000 stat.py:54(S_ISREG)

        1    0.006    0.006    0.007    0.007 statemachine.py:105(<module>)
        1    0.000    0.000    0.000    0.000 statemachine.py:115(StateMachine)
        1    0.000    0.000    0.000    0.000 statemachine.py:1041(ViewList)
        1    0.000    0.000    0.000    0.000 statemachine.py:867(StateWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:489(State)
        1    0.000    0.000    0.000    0.000 statemachine.py:1297(StringList)
        1    0.000    0.000    0.000    0.000 statemachine.py:761(StateMachineWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:1008(_SearchOverride)
        1    0.000    0.000    0.000    0.000 statemachine.py:1427(StateMachineError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1437(TransitionCorrection)
        1    0.000    0.000    0.000    0.000 statemachine.py:1036(SearchStateMachineWS)
        1    0.000    0.000    0.000    0.000 statemachine.py:1433(TransitionMethodNotFound)
        1    0.000    0.000    0.000    0.000 statemachine.py:1428(UnknownStateError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1031(SearchStateMachine)
        1    0.000    0.000    0.000    0.000 statemachine.py:1429(DuplicateStateError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1434(UnexpectedIndentationError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1431(DuplicateTransitionError)
        1    0.000    0.000    0.000    0.000 statemachine.py:1446(StateCorrection)
        1    0.000    0.000    0.000    0.000 statemachine.py:1432(TransitionPatternNotFound)
        1    0.000    0.000    0.000    0.000 statemachine.py:1430(UnknownTransitionError)

        7    0.000    0.000    0.000    0.000 states.py:132(__init__)
      5/1    0.000    0.000    0.007    0.007 states.py:416(build_regexp)
        1    0.017    0.017    0.122    0.122 states.py:101(<module>)
        1    0.000    0.000    0.033    0.033 states.py:985(Body)
        1    0.000    0.000    0.044    0.044 states.py:439(Inliner)
        1    0.000    0.000    0.000    0.000 states.py:2794(Line)
        1    0.000    0.000    0.000    0.000 states.py:2318(RFC2822Body)
        1    0.000    0.000    0.000    0.000 states.py:2583(Text)
        1    0.000    0.000    0.000    0.000 states.py:201(RSTState)
        1    0.000    0.000    0.001    0.001 states.py:2557(SubstitutionDef)
        1    0.000    0.000    0.000    0.000 states.py:2914(QuotedLiteralBlock)
        1    0.000    0.000    0.000    0.000 states.py:2364(SpecializedBody)
        1    0.000    0.000    0.000    0.000 states.py:2754(SpecializedText)
        1    0.000    0.000    0.000    0.000 states.py:2483(RFC2822List)
        1    0.000    0.000    0.000    0.000 states.py:2777(Definition)
        1    0.000    0.000    0.000    0.000 states.py:136(RSTStateMachine)
        1    0.000    0.000    0.000    0.000 states.py:128(Struct)
        1    0.000    0.000    0.000    0.000 states.py:2536(Explicit)
        1    0.000    0.000    0.000    0.000 states.py:2520(LineBlock)
        1    0.000    0.000    0.000    0.000 states.py:2456(FieldList)
        1    0.000    0.000    0.000    0.000 states.py:175(NestedStateMachine)
        1    0.000    0.000    0.000    0.000 states.py:2408(BulletList)
        1    0.000    0.000    0.000    0.000 states.py:2432(EnumeratedList)
        1    0.000    0.000    0.000    0.000 states.py:124(ParserError)
        1    0.000    0.000    0.000    0.000 states.py:2468(OptionList)
        1    0.000    0.000    0.000    0.000 states.py:122(UnknownInterpretedRoleError)
        1    0.000    0.000    0.000    0.000 states.py:2500(ExtensionOptions)
        1    0.000    0.000    0.000    0.000 states.py:2423(DefinitionList)
        1    0.000    0.000    0.000    0.000 states.py:121(MarkupError)
        1    0.000    0.000    0.000    0.000 states.py:123(InterpretedRoleNotImplementedError)
        1    0.000    0.000    0.000    0.000 states.py:125(MarkupMismatch)
    18311    0.024    0.000    0.024    0.000 string.py:349(find)
       16    0.000    0.000    0.000    0.000 string.py:509(replace)
        6    0.000    0.000    0.000    0.000 string.py:390(atoi)
        1    0.000    0.000    0.000    0.000 string.py:279(split)
        1    0.000    0.000    0.000    0.000 string.py:218(lower)

     4254    0.002    0.000    0.002    0.000 xmlreader.py:278(__init__)
     2845    0.002    0.000    0.002    0.000 xmlreader.py:290(getValue)
     2803    0.003    0.000    0.005    0.000 xmlreader.py:306(getNames)
        6    0.000    0.000    0.000    0.000 xmlreader.py:253(getByteStream)
        4    0.000    0.000    0.000    0.000 xmlreader.py:203(__init__)
        4    0.000    0.000    0.000    0.000 xmlreader.py:236(getEncoding)
        2    0.000    0.000    0.310    0.155 xmlreader.py:115(parse)
        2    0.000    0.000    0.000    0.000 xmlreader.py:24(__init__)
        2    0.000    0.000    0.000    0.000 xmlreader.py:111(__init__)
        2    0.000    0.000    0.000    0.000 xmlreader.py:38(setContentHandler)
        2    0.000    0.000    0.000    0.000 xmlreader.py:240(setByteStream)
        2    0.000    0.000    0.000    0.000 xmlreader.py:222(getSystemId)
        1    0.002    0.002    0.003    0.003 xmlreader.py:2(<module>)
        1    0.000    0.000    0.000    0.000 xmlreader.py:11(XMLReader)
        1    0.000    0.000    0.000    0.000 xmlreader.py:276(AttributesImpl)
        1    0.000    0.000    0.000    0.000 xmlreader.py:341(AttributesNSImpl)
        1    0.000    0.000    0.000    0.000 xmlreader.py:187(InputSource)
        1    0.000    0.000    0.000    0.000 xmlreader.py:91(IncrementalParser)
        1    0.000    0.000    0.000    0.000 xmlreader.py:163(Locator)
        2    0.000    0.000    0.000    0.000 zipfile.py:128(_EndRecData)
        2    0.000    0.000    0.001    0.001 zipfile.py:82(is_zipfile)

83742/83321    0.029    0.000    0.030    0.000 {len}
    55075    0.058    0.000    0.058    0.000 {method 'replace' of 'unicode' objects}
    52474    0.023    0.000    0.023    0.000 {method 'append' of 'list' objects}
    50753    0.029    0.000    0.029    0.000 {method 'get' of 'dict' objects}
    31516    0.011    0.000    0.011    0.000 {method 'isalnum' of 'unicode' objects}
    29332    0.016    0.000    0.016    0.000 {method 'lower' of 'unicode' objects}
    19837    0.013    0.000    0.013    0.000 {method 'replace' of 'str' objects}
    15341    0.005    0.000    0.005    0.000 {method 'isalnum' of 'str' objects}
     9902    0.007    0.000    0.007    0.000 {method 'lower' of 'str' objects}
     8813    0.013    0.000    0.013    0.000 {method 'join' of 'str' objects}
     7762    0.004    0.000    0.004    0.000 {method 'strip' of 'unicode' objects}
     6700    0.007    0.000    0.008    0.000 {method 'update' of 'dict' objects}
     6630    0.003    0.000    0.003    0.000 {method 'pop' of 'list' objects}
     6371    0.007    0.000    0.007    0.000 {method 'startswith' of 'unicode' objects}
     6315    0.003    0.000    0.003    0.000 {method 'strip' of 'str' objects}
     5914    0.004    0.000    0.004    0.000 {method 'keys' of 'dict' objects}
     5592    0.005    0.000    0.005    0.000 {method 'find' of 'unicode' objects}
3888/3778    0.185    0.000    0.189    0.000 {built-in method call}
     3855    0.003    0.000    0.003    0.000 {method 'endswith' of 'unicode' objects}
     3282    0.008    0.000    0.008    0.000 {method 'split' of 'unicode' objects}
     2787    0.003    0.000    0.003    0.000 {method 'lstrip' of 'unicode' objects}
     2769    0.001    0.000    0.001    0.000 {callable}
     2756    0.004    0.000    0.004    0.000 {repr}
     2743    0.001    0.000    0.001    0.000 {id}
     2541    0.007    0.000    0.007    0.000 {built-in method createcommand}
     2515    0.008    0.000    0.008    0.000 {built-in method deletecommand}
     2346    0.005    0.000    0.005    0.000 {nt._getfullpathname}
     2012    0.003    0.000    0.003    0.000 {hasattr}
     1865    0.001    0.000    0.001    0.000 {min}
     1729    0.001    0.000    0.001    0.000 {ord}
     1704    0.002    0.000    0.002    0.000 {method 'has_key' of 'dict' objects}
     1693    0.001    0.000    0.001    0.000 {method 'startswith' of 'str' objects}
     1243    0.001    0.000    0.001    0.000 {method 'items' of 'dict' objects}
     1110    0.001    0.000    0.001    0.000 {method 'capitalize' of 'str' objects}
      765    0.001    0.000    0.001    0.000 {method 'rfind' of 'unicode' objects}
      761    0.001    0.000    0.001    0.000 {_tkinter._flatten}
      727    0.001    0.000    0.001    0.000 {method 'find' of 'str' objects}
      597    0.000    0.000    0.000    0.000 {setattr}
      528    0.000    0.000    0.000    0.000 {method 'endswith' of 'str' objects}
      512    0.000    0.000    0.000    0.000 {chr}
      487    0.000    0.000    0.000    0.000 {max}
      447    0.001    0.000    0.001    0.000 {built-in method match}
      431    0.021    0.000    0.021    0.000 {nt.stat}
      412    0.001    0.000    0.001    0.000 {_codecs.charmap_decode}
      394    0.001    0.000    0.001    0.000 {method 'setdefault' of 'dict' objects}
      365    0.000    0.000    0.000    0.000 {isinstance}
  272/169    0.001    0.000    0.109    0.001 {apply}
      198    0.000    0.000    0.000    0.000 {getattr}
      197    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}
      194    0.000    0.000    0.000    0.000 {range}
      186    0.000    0.000    0.000    0.000 {method 'isdigit' of 'unicode' objects}
      181    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}
      173    0.000    0.000    0.000    0.000 {method 'rstrip' of 'unicode' objects}
      172    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}
      127    0.018    0.000    0.085    0.001 {__import__}
      124    0.000    0.000    0.000    0.000 {method 'read' of 'cStringIO.StringI' objects}
      109    0.000    0.000    0.000    0.000 {method 'upper' of 'str' objects}
       87    0.000    0.000    0.000    0.000 {method 'upper' of 'unicode' objects}
       81    0.000    0.000    0.000    0.000 {_sre.compile}
       72    0.000    0.000    0.000    0.000 {built-in method getboolean}
       70    0.000    0.000    0.000    0.000 {method 'isdigit' of 'str' objects}
       69    0.000    0.000    0.000    0.000 {method 'isalpha' of 'unicode' objects}
       66    0.000    0.000    0.000    0.000 {built-in method splitlist}
       66    0.000    0.000    0.000    0.000 {method 'isupper' of 'unicode' objects}
       65    0.000    0.000    0.000    0.000 {_codecs.utf_8_decode}
       60    0.000    0.000    0.000    0.000 {method 'lstrip' of 'str' objects}
       60    0.000    0.000    0.000    0.000 {method 'rstrip' of 'str' objects}
       57    0.000    0.000    0.001    0.000 {method 'encode' of 'unicode' objects}
       49    0.000    0.000    0.000    0.000 {method 'reverse' of 'list' objects}
       48    0.000    0.000    0.000    0.000 {method 'islower' of 'unicode' objects}
       41    0.001    0.000    0.001    0.000 {method 'splitlines' of 'unicode' objects}
       37    0.000    0.000    0.000    0.000 {method 'split' of 'str' objects}
       32    0.000    0.000    0.000    0.000 {method 'index' of 'list' objects}
       31    0.000    0.000    0.000    0.000 {cStringIO.StringIO}
       29    0.000    0.000    0.000    0.000 {binascii.unhexlify}
       29    0.000    0.000    0.000    0.000 {_sre.getlower}
       24    0.000    0.000    0.026    0.001 {map}
       19    0.002    0.000    0.002    0.000 {method 'close' of 'file' objects}
       19    0.000    0.000    0.000    0.000 {built-in method globalsetvar}
       18    0.000    0.000    0.000    0.000 {built-in method globalunsetvar}
       18    0.000    0.000    0.000    0.000 {method 'insert' of 'list' objects}
       17    0.000    0.000    0.000    0.000 {_codecs.charmap_encode}
       16    0.001    0.000    0.001    0.000 {method 'clear' of 'dict' objects}
       15    0.017    0.001    0.017    0.001 {imp.find_module}
       15    0.009    0.001    0.359    0.024 {imp.load_module}
       14    0.000    0.000    0.000    0.000 {locals}
       13    0.000    0.000    0.000    0.000 {method 'sort' of 'list' objects}
       13    0.000    0.000    0.000    0.000 {_codecs.lookup}
       10    0.001    0.000    0.001    0.000 {method 'read' of 'file' objects}
        9    0.000    0.000    0.000    0.000 {built-in method search}
        8    0.032    0.004    0.309    0.039 {built-in method Parse}
        7    0.000    0.000    0.000    0.000 {abs}
        6    0.000    0.000    0.000    0.000 {method 'count' of 'str' objects}
        5    0.001    0.000    0.001    0.000 {open}
        5    0.000    0.000    0.000    0.000 {method 'rfind' of 'str' objects}
        5    0.000    0.000    0.000    0.000 {method 'splitlines' of 'str' objects}
        4    0.000    0.000    0.000    0.000 {method 'seek' of 'file' objects}
        4    0.000    0.000    0.000    0.000 {thread.allocate_lock}
        4    0.000    0.000    0.000    0.000 {built-in method getvar}
        4    0.000    0.000    0.000    0.000 {method 'copy' of 'dict' objects}
        4    0.000    0.000    0.000    0.000 {built-in method globalgetvar}
        4    0.000    0.000    0.000    0.000 {built-in method SetParamEntityParsing}
        4    0.000    0.000    0.000    0.000 {globals}
        3    0.001    0.000    0.001    0.000 {nt.listdir}
        3    0.001    0.000    0.001    0.000 {method 'readlines' of 'file' objects}
        3    0.000    0.000    0.001    0.000 {filter}
        3    0.000    0.000    0.000    0.000 {eval}
        3    0.000    0.000    0.000    0.000 {vars}
        3    0.000    0.000    0.000    0.000 {method 'join' of 'unicode' objects}
        2    0.000    0.000    0.000    0.000 {dir}
        2    0.000    0.000    0.000    0.000 {nt.access}
        2    0.000    0.000    0.000    0.000 {_weakref.proxy}
        2    0.000    0.000    0.000    0.000 {method 'tell' of 'file' objects}
        2    0.000    0.000    0.000    0.000 {method 'capitalize' of 'unicode' objects}
        2    0.000    0.000    0.000    0.000 {built-in method acquire}
        2    0.000    0.000    0.000    0.000 {thread.get_ident}
        2    0.000    0.000    0.000    0.000 {sys.getdefaultencoding}
        2    0.000    0.000    0.000    0.000 {built-in method release}

        1   14.431   14.431   14.504   14.504 {built-in method mainloop}
        1    0.042    0.042    0.042    0.042 {_tkinter.create}
        1    0.002    0.002    0.002    0.002 {_ctypes.LoadLibrary}
        1    0.001    0.001    0.001    0.001 {execfile}
        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}
        1    0.000    0.000    0.000    0.000 {method 'readline' of 'file' objects}
        1    0.000    0.000    0.000    0.000 {method 'write' of 'file' objects}
        1    0.000    0.000    0.000    0.000 {time.sleep}
        1    0.000    0.000    0.000    0.000 {strop.maketrans}
        1    0.000    0.000    0.000    0.000 {_locale._getdefaultlocale}
        1    0.000    0.000    0.000    0.000 {time.strftime}
        1    0.000    0.000    0.000    0.000 {time.localtime}
        1    0.000    0.000    0.000    0.000 {sys.getwindowsversion}
        1    0.000    0.000    0.000    0.000 {method 'tolist' of 'array.array' objects}
        1    0.000    0.000    0.000    0.000 {nt.getcwd}
        1    0.000    0.000    0.000    0.000 {built-in method __new__ of type object at 0x1E1E6DD0}
        1    0.000    0.000    0.000    0.000 {built-in method quit}
        1    0.000    0.000    0.000    0.000 {method 'tostring' of 'array.array' objects}
        1    0.000    0.000    0.000    0.000 {method 'translate' of 'str' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        1    0.000    0.000    0.000    0.000 {imp.get_magic}
#@-node:ekr.20080529114024.1:Stats
#@+node:ekr.20080529114024.3:Stats (.py files)
@killcolor

         10085874 function calls (10077839 primitive calls) in 31.652 CPU seconds

   Ordered by: file name, call count, internal time, function name
   List reduced from 2528 to 363 due to restriction <'leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   111237    0.279    0.000    0.963    0.000 leoAtFile.py:1808(readLine)
   111118    0.545    0.000    3.134    0.000 leoAtFile.py:1511(sentinelKind4)
    96055    0.261    0.000    0.589    0.000 leoAtFile.py:806(readNormalLine)
    15063    0.085    0.000    0.347    0.000 leoAtFile.py:1557(skipSentinelStart4)
     6272    0.010    0.000    0.013    0.000 leoAtFile.py:1499(popSentinelStack)
     5859    0.134    0.000    0.588    0.000 leoAtFile.py:634(createThinChild4)
     5859    0.087    0.000    0.743    0.000 leoAtFile.py:915(readStartNode)
     5859    0.084    0.000    0.165    0.000 leoAtFile.py:1079(readEndNode)
       43    0.531    0.012    6.564    0.153 leoAtFile.py:744(scanText4)
       43    0.292    0.007   13.668    0.318 leoAtFile.py:439(read)

negligible
      845    0.006    0.000    0.013    0.000 leoAtFile.py:1413(readNonl)
      665    0.004    0.000    0.017    0.000 leoAtFile.py:1452(readRef)
      664    0.002    0.000    0.005    0.000 leoAtFile.py:1400(readNl)
      287    0.002    0.000    0.006    0.000 leoAtFile.py:1322(readDirective)
      221    0.001    0.000    0.004    0.000 leoAtFile.py:999(readStartOthers)
      221    0.000    0.000    0.001    0.000 leoAtFile.py:1172(readEndOthers)
      188    0.002    0.000    0.004    0.000 leoAtFile.py:1182(readLastDocLine)
      188    0.001    0.000    0.003    0.000 leoAtFile.py:860(readStartAt)
      188    0.001    0.000    0.005    0.000 leoAtFile.py:1029(readEndAt)
       62    0.000    0.000    0.001    0.000 leoAtFile.py:3454(os)
       45    0.003    0.000    0.029    0.001 leoAtFile.py:3880(scanAllDirectives)
       45    0.000    0.000    0.001    0.000 leoAtFile.py:180(initCommonIvars)
       43    0.038    0.001    0.251    0.006 leoAtFile.py:1632(copyAllTempBodyStringsToTnodes)
       43    0.013    0.000    0.013    0.000 leoAtFile.py:422(openForRead)
       43    0.002    0.000    0.023    0.001 leoAtFile.py:4084(scanDefaultDirectory)
       43    0.001    0.000    0.003    0.000 leoAtFile.py:1677(parseLeoSentinel)
       43    0.001    0.000    6.572    0.153 leoAtFile.py:580(readOpenFile)
       43    0.001    0.000    0.024    0.001 leoAtFile.py:242(initReadIvars)
       43    0.000    0.000    0.006    0.000 leoAtFile.py:1817(scanHeader)
       43    0.000    0.000    0.018    0.000 leoAtFile.py:393(openFileForReading)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1582(completeFirstDirectives)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1610(completeLastDirectives)
       43    0.000    0.000    0.001    0.000 leoAtFile.py:1052(readEndLeo)
       27    0.000    0.000    0.000    0.000 leoAtFile.py:3440(onl)
       25    0.000    0.000    0.000    0.000 leoAtFile.py:3661(putIndent)
       17    0.000    0.000    0.001    0.000 leoAtFile.py:2831(putCodeLine)
       17    0.000    0.000    0.000    0.000 leoAtFile.py:3347(directiveKind4)
       17    0.000    0.000    0.000    0.000 leoAtFile.py:3392(findSectionName)
       14    0.000    0.000    0.000    0.000 leoAtFile.py:1474(readVerbatim)
       14    0.000    0.000    0.000    0.000 leoAtFile.py:1872(skipIndent)
       12    0.000    0.000    0.001    0.000 leoAtFile.py:906(readStartMiddle)
       12    0.000    0.000    0.000    0.000 leoAtFile.py:1070(readEndMiddle)
       10    0.000    0.000    0.000    0.000 leoAtFile.py:3292(putSentinel)
        5    0.000    0.000    0.000    0.000 leoAtFile.py:127(__init__)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:842(readStartAll)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:3163(nodeSentinelText)
        4    0.000    0.000    0.000    0.000 leoAtFile.py:1019(readEndAll)
        2    0.000    0.000    0.002    0.001 leoAtFile.py:2561(putBody)
        2    0.000    0.000    0.002    0.001 leoAtFile.py:289(initWriteIvars)
        2    0.000    0.000    0.003    0.001 leoAtFile.py:2533(writeOpenFile)
        2    0.000    0.000    0.006    0.003 leoAtFile.py:2394(writeFromString)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:2014(openFileForWriting)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:4173(cleanLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:1891(closeWriteFile)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3259(putOpenNodeSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3499(putAtLastLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3239(putOpenLeoSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3227(putCloseNodeSentinel)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3479(putAtFirstLines)
        2    0.000    0.000    0.000    0.000 leoAtFile.py:3675(putInitialComment)
        1    0.012    0.012   13.944   13.944 leoAtFile.py:502(readAll)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:33(atFile)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:7(<module>)
        1    0.000    0.000    0.000    0.000 leoAtFile.py:1240(readAfterRef)

All negligible

    22805    0.090    0.000    0.134    0.000 leoFileCommands.py:222(characters)
     5122    0.021    0.000    0.167    0.000 leoFileCommands.py:303(startElement)
     5122    0.021    0.000    0.056    0.000 leoFileCommands.py:241(endElement)
     3344    0.028    0.000    0.045    0.000 leoFileCommands.py:142(attrsToList)
     3337    0.006    0.000    0.006    0.000 leoFileCommands.py:173(inElement)
     1753    0.006    0.000    0.006    0.000 leoFileCommands.py:488(__init__)
     1749    0.017    0.000    0.069    0.000 leoFileCommands.py:436(startVnode)
     1749    0.012    0.000    0.041    0.000 leoFileCommands.py:459(vnodeAttributes)
     1749    0.010    0.000    0.012    0.000 leoFileCommands.py:278(endVH)
     1749    0.003    0.000    0.004    0.000 leoFileCommands.py:271(endVnode)
     1749    0.001    0.000    0.001    0.000 leoFileCommands.py:370(startVH)
     1710    0.004    0.000    0.048    0.000 leoFileCommands.py:892(canonicalTnodeIndex)
     1703    0.028    0.000    0.166    0.000 leoFileCommands.py:1037(createSaxVnode)
     1703    0.012    0.000    0.019    0.000 leoFileCommands.py:1092(handleVnodeSaxAttributes)
     1703    0.002    0.000    0.003    0.000 leoFileCommands.py:1073(handleTnodeSaxAttributes)
   1678/4    0.010    0.000    0.199    0.050 leoFileCommands.py:1003(createSaxChildren)
     1678    0.004    0.000    0.011    0.000 leoFileCommands.py:1149(_linkParentAndChildren)
  1674/29    0.004    0.000    0.198    0.007 leoFileCommands.py:1027(createSaxVnodeTree)
     1588    0.007    0.000    0.026    0.000 leoFileCommands.py:414(tnodeAttributes)
     1588    0.005    0.000    0.010    0.000 leoFileCommands.py:262(endTnode)
     1588    0.004    0.000    0.033    0.000 leoFileCommands.py:404(startTnode)
       35    0.000    0.000    0.002    0.000 leoFileCommands.py:1178(getSaxUa)
       12    0.000    0.000    0.000    0.000 leoFileCommands.py:909(getDescendentAttributes)
        8    0.002    0.000    0.002    0.000 leoFileCommands.py:940(initReadIvars)
        5    0.000    0.000    0.000    0.000 leoFileCommands.py:543(initIvars)
        5    0.000    0.000    0.000    0.000 leoFileCommands.py:529(__init__)
        4    0.015    0.004    0.323    0.081 leoFileCommands.py:761(initAllParents)
        4    0.004    0.001    0.072    0.018 leoFileCommands.py:1274(resolveTnodeLists)
        4    0.000    0.000   15.661    3.915 leoFileCommands.py:686(getLeoFile)
        4    0.000    0.000    0.688    0.172 leoFileCommands.py:1255(readSaxFile)
        4    0.000    0.000    0.490    0.122 leoFileCommands.py:1219(parse_leo_file)
        4    0.000    0.000    0.033    0.008 leoFileCommands.py:376(startVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:67(__init__)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:322(getPositionAttributes)
        4    0.000    0.000   15.661    3.915 leoFileCommands.py:824(open)
        4    0.000    0.000    0.001    0.000 leoFileCommands.py:1295(setPositionsFromVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:344(startGlobals)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:292(processingInstruction)
        4    0.000    0.000    0.199    0.050 leoFileCommands.py:990(createSaxVnodes)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:359(startWinPos)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:365(startLeoHeader)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:288(getRootNode)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:124(endDocument)
        4    0.000    0.000    0.000    0.000 leoFileCommands.py:136(startDocument)
        2    0.000    0.000    0.000    0.000 leoFileCommands.py:1309(archivedPositionToPosition)
        1    0.020    0.020    0.245    0.245 leoFileCommands.py:949(restoreDescendentAttributes)
        1    0.012    0.012    0.066    0.066 leoFileCommands.py:9(<module>)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:525(baseFileCommands)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:61(saxContentHandler)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:480(saxNodeClass)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:43(BadLeoFile)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:50(invalidPaste)
        1    0.000    0.000    0.000    0.000 leoFileCommands.py:2303(fileCommands)

   979398    0.728    0.000    0.728    0.000 leoGlobals.py:3520(is_ws)
   283766    0.585    0.000    1.047    0.000 leoGlobals.py:3531(match)
   185704    0.386    0.000    0.409    0.000 leoGlobals.py:4074(toUnicode)
   162977    0.996    0.000    1.779    0.000 leoGlobals.py:3734(skip_ws)
   111237    0.217    0.000    0.402    0.000 leoGlobals.py:2009(readlineForceUnixNewline)
    94250    0.251    0.000    0.251    0.000 leoGlobals.py:5569(removeLeadingWhitespace)
    89406    0.088    0.000    0.124    0.000 leoGlobals.py:3921(isWordChar)
    26522    0.026    0.000    0.026    0.000 leoGlobals.py:3996(isUnicode)

Negligible

    25877    0.055    0.000    0.088    0.000 leoGlobals.py:3725(skip_to_char)
    19384    0.053    0.000    0.103    0.000 leoGlobals.py:2992(toUnicodeFileEncoding)
    15700    0.037    0.000    0.063    0.000 leoGlobals.py:3550(match_word)
    15333    0.007    0.000    0.007    0.000 leoGlobals.py:2594(choose)
    14256    0.075    0.000    0.179    0.000 leoGlobals.py:3577(skip_c_id)
    11417    0.012    0.000    0.045    0.000 leoGlobals.py:2195(clearAllIvars)
     6721    0.011    0.000    0.018    0.000 leoGlobals.py:4384(__init__)
     6028    0.012    0.000    0.024    0.000 leoGlobals.py:5159(stripBrackets)
     5859    0.022    0.000    0.024    0.000 leoGlobals.py:5642(skip_leading_ws_with_indent)
     4844    0.019    0.000    0.222    0.000 leoGlobals.py:2807(os_path_abspath)
     3813    0.008    0.000    0.014    0.000 leoGlobals.py:3603(skip_line)
     2570    0.010    0.000    0.089    0.000 leoGlobals.py:2955(os_path_normpath)
     1946    0.021    0.000    0.050    0.000 leoGlobals.py:3585(skip_id)
      506    0.002    0.000    0.014    0.000 leoGlobals.py:2820(os_path_basename)
      473    0.002    0.000    0.011    0.000 leoGlobals.py:2980(os_path_splitext)
      448    0.004    0.000    0.015    0.000 leoGlobals.py:2891(os_path_join)
      275    0.008    0.000    0.020    0.000 leoGlobals.py:462(get_directives_dict)
      184    0.001    0.000    0.002    0.000 leoGlobals.py:2864(os_path_isabs)
      181    0.002    0.000    1.364    0.008 leoGlobals.py:2540(doHook)
      156    0.005    0.000    0.020    0.000 leoGlobals.py:3501(is_special)
      139    0.000    0.000    0.000    0.000 leoGlobals.py:3494(is_nl)
      123    0.000    0.000    0.002    0.000 leoGlobals.py:4048(toEncodedString)
      113    0.000    0.000    0.006    0.000 leoGlobals.py:2846(os_path_exists)
      106    0.001    0.000    0.001    0.000 leoGlobals.py:838(getOutputNewline)
      100    0.001    0.000    0.003    0.000 leoGlobals.py:2833(os_path_dirname)
       94    0.001    0.000    0.002    0.000 leoGlobals.py:1773(getBaseDirectory)
       83    0.000    0.000    0.000    0.000 leoGlobals.py:4118(convertPythonIndexToRowCol)
       76    0.001    0.000    0.001    0.000 leoGlobals.py:3628(skip_long)
       73    0.000    0.000    0.002    0.000 leoGlobals.py:2968(os_path_split)
       71    0.000    0.000    0.003    0.000 leoGlobals.py:4931(computeWindowTitle)
       69    0.001    0.000    0.006    0.000 leoGlobals.py:2742(translateArgs)
       67    0.000    0.000    0.006    0.000 leoGlobals.py:2768(translateString)
       66    0.003    0.000    0.130    0.002 leoGlobals.py:2616(es)
       64    0.000    0.000    0.001    0.000 leoGlobals.py:3750(splitLines)
       62    0.000    0.000    0.000    0.000 leoGlobals.py:5023(write)
       57    0.000    0.000    0.031    0.001 leoGlobals.py:2609(enl)
       55    0.000    0.000    0.031    0.001 leoGlobals.py:2603(ecnls)
       55    0.000    0.000    0.031    0.001 leoGlobals.py:2600(ecnl)
       53    0.001    0.000    0.002    0.000 leoGlobals.py:326(set_delims_from_string)
       53    0.000    0.000    0.002    0.000 leoGlobals.py:311(set_delims_from_language)
       46    0.000    0.000    0.001    0.000 leoGlobals.py:2050(shortFileName)
       38    0.000    0.000    0.001    0.000 leoGlobals.py:563(scanAtPagewidthDirective)
       38    0.000    0.000    0.001    0.000 leoGlobals.py:622(scanAtTabwidthDirective)
       20    0.001    0.000    0.001    0.000 leoGlobals.py:4001(isValidEncoding)
       19    0.000    0.000    0.000    0.000 leoGlobals.py:4137(convertRowColToPythonIndex)
       17    0.001    0.000    0.031    0.002 leoGlobals.py:5233(importModule)
       17    0.000    0.000    0.073    0.004 leoGlobals.py:5255(importExtension)
       14    0.000    0.000    0.002    0.000 leoGlobals.py:2489(idleTimeHookHandler)
       13    0.000    0.000    0.337    0.026 leoGlobals.py:5406(importFromPath)
       12    0.000    0.000    0.000    0.000 leoGlobals.py:4229(CheckVersionToInt)
       11    0.001    0.000    0.009    0.001 leoGlobals.py:2573(plugin_signon)
        6    0.000    0.000    0.002    0.000 leoGlobals.py:669(scanDirectives)
        4    0.001    0.000    0.006    0.001 leoGlobals.py:1981(openLeoOrZipFile)
        4    0.000    0.000    0.000    0.000 leoGlobals.py:4974(__init__)
        3    0.002    0.001    0.003    0.001 leoGlobals.py:2692(es_print)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:291(startupEncoding)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:2873(os_path_isdir)
        3    0.000    0.000    0.000    0.000 leoGlobals.py:5048(funcToMethod)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4204(CheckVersion)
        2    0.000    0.000    0.006    0.003 leoGlobals.py:5054(getScript)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5585(removeExtraLws)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:247(computeMachineName)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:1902(munge)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5529(get_leading_ws)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5518(computeWidth)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:5004(get)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:3763(joinLines)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4999(flush)
        2    0.000    0.000    0.000    0.000 leoGlobals.py:4992(close)
        1    0.000    0.000   16.606   16.606 leoGlobals.py:1894(openWithFileName)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:208(computeLoadDir)
        1    0.000    0.000    0.001    0.001 leoGlobals.py:265(computeStandardDirectories)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:140(computeGlobalConfigDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:164(computeHomeDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:192(computeLeoDir)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1574(init_trace)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1556(get_Sherlock_args)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:2467(enableIdleTimeHook)
        1    0.000    0.000    0.000    0.000 leoGlobals.py:1542(init_sherlock)


  1117866    0.908    0.000    0.908    0.000 leoNodes.py:1069(__nonzero__)
   768290    0.663    0.000    0.663    0.000 leoNodes.py:1692(<lambda>)
   396157    0.682    0.000    0.682    0.000 leoNodes.py:2721(_parentVnode)
   223158    0.737    0.000    1.212    0.000 leoNodes.py:1276(hasNext)
   194215    0.768    0.000    7.557    0.000 leoNodes.py:1707(next)
   194143    2.396    0.000    6.314    0.000 leoNodes.py:1722(moveToThreadNextUnique)
   172954    0.739    0.000    1.085    0.000 leoNodes.py:2425(moveToNext)
   155157    0.136    0.000    0.136    0.000 leoNodes.py:1773(<lambda>)
    50509    0.137    0.000    0.160    0.000 leoNodes.py:2473(moveToParent)
    50075    0.240    0.000    0.259    0.000 leoNodes.py:2376(moveToFirstChild)
    26496    0.019    0.000    0.019    0.000 leoNodes.py:852(areEqual)
    25341    0.109    0.000    0.421    0.000 leoNodes.py:2502(moveToThreadNext)
    11920    0.053    0.000    0.279    0.000 leoNodes.py:1662(next)
    11871    0.061    0.000    0.294    0.000 leoNodes.py:1806(next)
     9243    0.109    0.000    0.274    0.000 leoNodes.py:892(scanGnx)

    20184    0.068    0.000    0.106    0.000 leoNodes.py:564(headString)
    17200    0.020    0.000    0.020    0.000 leoNodes.py:588(isDirty)
    16140    0.105    0.000    0.124    0.000 leoNodes.py:812(_computeParentsOfChildren)
    13814    0.022    0.000    0.093    0.000 leoNodes.py:1183(headString)
    12820    0.009    0.000    0.009    0.000 leoNodes.py:1777(<lambda>)
    12132    0.022    0.000    0.022    0.000 leoNodes.py:1030(isEqual)
    11763    0.015    0.000    0.015    0.000 leoNodes.py:213(setVisited)
     7293    0.024    0.000    0.024    0.000 leoNodes.py:260(__init__)
     7177    0.056    0.000    0.114    0.000 leoNodes.py:58(__init__)
     7174    0.011    0.000    0.020    0.000 leoNodes.py:1192(isDirty)
     6338    0.020    0.000    0.032    0.000 leoNodes.py:491(bodyString)
     6338    0.010    0.000    0.041    0.000 leoNodes.py:1179(bodyString)
     5985    0.006    0.000    0.006    0.000 leoNodes.py:598(isMarked)
     5961    0.009    0.000    0.014    0.000 leoNodes.py:1194(isMarked)
     5871    0.005    0.000    0.005    0.000 leoNodes.py:115(hasBody)
     5843    0.005    0.000    0.005    0.000 leoNodes.py:135(isVisited)
     5653    0.006    0.000    0.006    0.000 leoNodes.py:662(clearOrphan)
     5582    0.020    0.000    0.109    0.000 leoNodes.py:792(_linkAsNthChild)
     5582    0.008    0.000    0.011    0.000 leoNodes.py:538(numberOfChildren)
     5001    0.010    0.000    0.014    0.000 leoNodes.py:748(setBodyString)
     1702    0.003    0.000    0.003    0.000 leoNodes.py:1012(__cmp__)
     1094    0.003    0.000    0.003    0.000 leoNodes.py:989(__init__)
     1059    0.005    0.000    0.007    0.000 leoNodes.py:1104(copy)
      672    0.003    0.000    0.017    0.000 leoNodes.py:342(findAtFileName)
      397    0.002    0.000    0.003    0.000 leoNodes.py:2024(next)
      301    0.001    0.000    0.006    0.000 leoNodes.py:2444(moveToNodeAfterTree)
      257    0.000    0.000    0.000    0.000 leoNodes.py:100(bodyString)
      202    0.001    0.000    0.006    0.000 leoNodes.py:1240(getNodeAfterTree)
      175    0.000    0.000    0.008    0.000 leoNodes.py:362(anyAtFileNodeName)
      156    0.000    0.000    0.005    0.000 leoNodes.py:447(isAtThinFileNode)
      156    0.000    0.000    0.021    0.000 leoNodes.py:456(isAtIgnoreNode)
      156    0.000    0.000    0.021    0.000 leoNodes.py:1163(isAtIgnoreNode)
      156    0.000    0.000    0.006    0.000 leoNodes.py:1168(isAtThinFileNode)
      156    0.000    0.000    0.005    0.000 leoNodes.py:403(atThinFileNodeName)
      136    0.001    0.000    0.006    0.000 leoNodes.py:1786(__init__)
      136    0.000    0.000    0.000    0.000 leoNodes.py:1801(__iter__)
      133    0.001    0.000    0.006    0.000 leoNodes.py:1827(self_and_subtree_iter)
      131    0.000    0.000    0.007    0.000 leoNodes.py:1146(anyAtFileNodeName)
      116    0.000    0.000    0.001    0.000 leoNodes.py:2007(__init__)
      116    0.000    0.000    0.000    0.000 leoNodes.py:2019(__iter__)
      115    0.000    0.000    0.002    0.000 leoNodes.py:435(isAtFileNode)
      115    0.000    0.000    0.002    0.000 leoNodes.py:1162(isAtFileNode)
      115    0.000    0.000    0.002    0.000 leoNodes.py:387(atFileNodeName)
      113    0.001    0.000    0.002    0.000 leoNodes.py:2045(self_and_parents_iter)
      113    0.000    0.000    0.002    0.000 leoNodes.py:432(isAtAutoNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:441(isAtRawFileNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:1161(isAtAutoNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:1166(isAtRawFileNode)
      113    0.000    0.000    0.002    0.000 leoNodes.py:380(atAutoNodeName)
      113    0.000    0.000    0.002    0.000 leoNodes.py:395(atRawFileNodeName)
       95    0.001    0.000    0.001    0.000 leoNodes.py:1130(key)
       72    0.001    0.000    0.001    0.000 leoNodes.py:1692(__init__)
       72    0.000    0.000    0.000    0.000 leoNodes.py:1702(__iter__)
       58    0.000    0.000    0.000    0.000 leoNodes.py:1217(hasChildren)
       57    0.000    0.000    0.000    0.000 leoNodes.py:1287(hasParent)
       52    0.000    0.000    0.000    0.000 leoNodes.py:1272(hasBack)
       47    0.000    0.000    0.000    0.000 leoNodes.py:667(clearVisited)
       45    0.001    0.000    0.005    0.000 leoNodes.py:1455(clearVisitedInTree)
       45    0.000    0.000    0.002    0.000 leoNodes.py:421(isAnyAtFileNode)
       45    0.000    0.000    0.000    0.000 leoNodes.py:1401(clearVisited)
       45    0.000    0.000    0.000    0.000 leoNodes.py:1193(isExpanded)
       45    0.000    0.000    0.000    0.000 leoNodes.py:593(isExpanded)
       44    0.000    0.000    0.000    0.000 leoNodes.py:2357(moveToBack)
       43    0.000    0.000    0.000    0.000 leoNodes.py:1771(unique_tnodes_iter)
       43    0.000    0.000    0.000    0.000 leoNodes.py:1471(clearDirty)
       43    0.000    0.000    0.000    0.000 leoNodes.py:645(clearDirty)
       43    0.000    0.000    0.002    0.000 leoNodes.py:1159(isAnyAtFileNode)
       25    0.000    0.000    0.000    0.000 leoNodes.py:1943(<lambda>)
       24    0.000    0.000    0.000    0.000 leoNodes.py:767(computeIcon)
       24    0.000    0.000    0.000    0.000 leoNodes.py:1239(getNext)
       24    0.000    0.000    0.000    0.000 leoNodes.py:583(isCloned)
       11    0.000    0.000    0.000    0.000 leoNodes.py:752(setHeadString)
       10    0.000    0.000    0.000    0.000 leoNodes.py:678(expand)
        9    0.000    0.000    0.000    0.000 leoNodes.py:2076(next)
        8    0.000    0.000    0.000    0.000 leoNodes.py:1861(next)
        6    0.000    0.000    0.000    0.000 leoNodes.py:1873(moveToThreadNextUnique)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2056(__init__)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2092(siblings_iter)
        6    0.000    0.000    0.000    0.000 leoNodes.py:2071(__iter__)
        6    0.000    0.000    0.000    0.000 leoNodes.py:1939(<lambda>)
        5    0.000    0.000    0.000    0.000 leoNodes.py:1775(unique_vnodes_iter)
        5    0.000    0.000    0.000    0.000 leoNodes.py:1404(expand)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1440(initHeadString)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1649(__init__)
        4    0.000    0.000    0.000    0.000 leoNodes.py:736(setVisited)
        4    0.000    0.000    0.000    0.000 leoNodes.py:125(isDirty)
        4    0.000    0.000    0.000    0.000 leoNodes.py:1657(__iter__)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2525(moveToVisBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2689(_linkAsRoot)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1247(getVisBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1823(subtree_iter)
        3    0.000    0.000    0.000    0.000 leoNodes.py:2041(parents_iter)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1234(getBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:1291(hasThreadBack)
        3    0.000    0.000    0.000    0.000 leoNodes.py:717(initMarkedBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1461(clearAllVisitedInTree)
        2    0.000    0.000    0.000    0.000 leoNodes.py:2564(moveToVisNext)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1354(isVisible)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1838(__init__)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1248(getVisNext)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1934(subtree_with_unique_tnodes_iter)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1403(contract)
        2    0.000    0.000    0.000    0.000 leoNodes.py:672(contract)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1400(clearOrphan)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1413(setVisited)
        2    0.000    0.000    0.000    0.000 leoNodes.py:193(clearVisited)
        2    0.000    0.000    0.000    0.000 leoNodes.py:198(clearWriteBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:218(setWriteBit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:2531(checkLimit)
        2    0.000    0.000    0.000    0.000 leoNodes.py:1855(__iter__)
        1    0.000    0.000    0.001    0.001 leoNodes.py:9(<module>)
        1    0.000    0.000    0.000    0.000 leoNodes.py:46(tnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:985(basePosition)
        1    0.000    0.000    0.000    0.000 leoNodes.py:234(vnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1477(findAllPotentiallyDirtyNodes)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1520(setAllAncestorAtFileNodesDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2753(_unlink)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2665(_linkAsNthChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1547(setDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2208(insertAsNthChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2284(moveToRoot)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1295(hasThreadNext)
        1    0.000    0.000    0.000    0.000 leoNodes.py:919(setTimestamp)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2196(insertAsLastChild)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1242(getParent)
        1    0.000    0.000    0.000    0.000 leoNodes.py:840(__init__)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2487(moveToThreadBack)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2607(_adjustPositionBeforeUnlink)
        1    0.000    0.000    0.000    0.000 leoNodes.py:834(nodeIndices)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1341(isCloned)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1780(subtree_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1686(unique_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1224(numberOfChildren)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1832(subtree_unique_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:874(getNewIndex)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1643(iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:1959(children_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2001(parents_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2050(siblings_iter_class)
        1    0.000    0.000    0.000    0.000 leoNodes.py:203(setDirty)
        1    0.000    0.000    0.000    0.000 leoNodes.py:43(baseTnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:231(baseVnode)
        1    0.000    0.000    0.000    0.000 leoNodes.py:171(setFileIndex)
        1    0.000    0.000    0.000    0.000 leoNodes.py:2798(position)
#@-node:ekr.20080529114024.3:Stats (.py files)
#@-node:ekr.20080529054218.2:Benchmarked the read code
#@-node:ekr.20080408060320.4:4.5 b1
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
