#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20100118163110.6256:Leo 4.7 rc1 projects
#@+node:ekr.20100119024225.6107:Fixed colorizer bug affecting per-language @font settings
@nocolor-node

It looks like you should be able to put the following in an
@font node, and get restructured text bold to appear in bold onscreen:

rest_keyword2_font_size = 16
rest_keyword2_font_family = Bitstream Charter
rest_keyword2_font_slant = roman
rest_keyword2_font_weight = bold

However nothing happens when I do this. The python examples in the
test.leo file work fine for me, so I'm not sure what's gone wrong.

I think that the following should also work, but it's also currently
not doing anything for me:

@color rest_keyword2_color = black

==================

Rev 2706 fixes a significant colorizer bug that caused your problem.
Previously, the colorizer inited the so-called configuration tags only
once, which is wrong. These tags are what the @font settings specify.
Now, the colorizer inits the tags when the language changes when
switching nodes.  Usually the language doesn't change, so the new code
will be approximately as fast as the old. 
#@-node:ekr.20100119024225.6107:Fixed colorizer bug affecting per-language @font settings
#@+node:ekr.20100119024225.6108:support extend-mode for several commands
'backward-find-character'
'find-character'
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20090530181848.6034:pages & helper
def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
#@+node:ekr.20090530181848.6035:movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    c = self.c ; w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind=g.choose(kind=='forward','page-down','page-up'),
            extend=extend,linesPerPage=linesPerPage)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = g.choose(kind=='back',
            max(0,row-linesPerPage),
            min(row+linesPerPage,len(lines)-1))
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@-node:ekr.20090530181848.6035:movePageHelper
#@-node:ekr.20090530181848.6034:pages & helper
#@-node:ekr.20100119024225.6108:support extend-mode for several commands
#@+node:ekr.20100119024225.6106:Fixed qttab problem
@nocolor-node

On Mon, Jan 18, 2010 at 9:25 PM, tfer <tfetherston@aol.com> wrote:

cmd.exe /k C:\PyDev\leo-editor\trunk\launchLeo.py --gui=qttabs -- ipython

1) (??) the button removal menu just flash on right mouse click, disappears immediately.

2) Leo opens up the workbook, I open a new doc in a tab, 'untitled', save it,
   get saved ... in log, however, tab title does not change unless I close and
   reload it.
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.currentPosition()
    w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs (commands)
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        g.trace(fileName)
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        if g.app.qt_use_tabs and hasattr(c.frame,'top'):
            c.frame.top.master.setTabName(c,c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
#@-node:ekr.20031218072017.2835:saveAs (commands)
#@-node:ekr.20100119024225.6106:Fixed qttab problem
#@+node:ekr.20100115091643.6249:<alt-x> select-all crashes python when focus is in headline
@
The problem occurs because the QtGui.QLineEdit object goes away
when the minibuffer gets focus and the QTreeWidget loses focus.

The fix: add a 'permanent' ivar to leoQtTextWidgets, and set
this ivar to False for headline widgets.
#@nonl
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):

    trace = True and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20100115091643.6249:<alt-x> select-all crashes python when focus is in headline
#@+node:ekr.20080412053100.1:Allow saving .leo files with undefined-sections
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/db797dd1d4dddffb

1) Create an @thin file based outline.
2) In the @thin file, create an unreferenced section (something like a
  header <<This Section Is Bogus>>).
3) Now, File->Exit
4) A dialog box pops up
  (Save changes to leo_file.leo before quitting? Yes/No/Cancel)
5) Click "Yes"
6) In the log pane, you will see: "undefined section" and "saved: leo_file.leo"
  and in the console window, you see "undefined section: ..."

The point is that I can't kill Leo if I keep saying "Yes" to the
"Save change before quitting" dialog. This is definitely not the
intended behavior. The correct behavior would be to save the file,
give me the warning about the undefined section, and exit.

EKR: The fix was simple: write_leo_file ignores the status returned from
c.atFileCommands.writeAll.

Note that Leo writes the write error to the console as well as the log pane,
so this should be safe enough.
#@nonl
#@+node:ekr.20031218072017.3692:promptForSave (leoFrame)
def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # g.pr(answer)
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            << Put up a file save dialog to set mFileName >>
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@+node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
# Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
#@-node:ekr.20031218072017.3693:<< Put up a file save dialog to set mFileName >>
#@-node:ekr.20031218072017.3692:promptForSave (leoFrame)
#@+node:ekr.20031218072017.1720:save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)

    if ok is None:
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = c.checkFileTimeStamp(fileName)
        if ok:
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            self.putSavedMessage(fileName)
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@-node:ekr.20031218072017.1720:save (fileCommands)
#@+node:ekr.20031218072017.3046:write_Leo_file & helpers
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    if self.checkOutlineBeforeSave and not self.checkOutline():
        return False
    if not outlineOnlyFlag or toOPML:
        g.app.config.writeRecentFilesFile(c)
        self.writeAllAtFileNodesHelper() # Ignore any errors.
    if self.isReadOnly(fileName):
        return False
    try:
        self.putCount = 0 ; self.toString = toString
        if toString:
            ok = self.writeToStringHelper(fileName)
        else:
            ok = self.writeToFileHelper(fileName,toOPML)
    finally:
        self.outputFile = None
        self.toString = False
    return ok

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20100119145629.6109:checkOutline
def checkOutline (self):

    c = self.c

    g.trace('@bool check_outline_before_save = True',color='blue')

    errors = c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    ok = errors == 0
    if not ok:
        g.es_print('outline not written',color='red')

    return ok
#@-node:ekr.20100119145629.6109:checkOutline
#@+node:ekr.20040324080359.1:isReadOnly
def isReadOnly (self,fileName):

    # self.read_only is not valid for Save As and Save To commands.

    if g.os_path_exists(fileName):
        try:
            if not os.access(fileName,os.W_OK):
                g.es("can not write: read only:",fileName,color="red")
                return True
        except Exception:
            pass # os.access() may not exist on all platforms.

    return False
#@-node:ekr.20040324080359.1:isReadOnly
#@+node:ekr.20100119145629.6114:writeAllAtFileNodesHelper
def writeAllAtFileNodesHelper (self):

    '''Write all @file nodes and set orphan bits.
    '''

    c = self.c

    try:
        # 2010/01/19: Do *not* signal failure here.
        # This allows Leo to quit properly.
        c.atFileCommands.writeAll()
        return True
    except Exception:
        g.es_error("exception writing derived files")
        g.es_exception()
        return False
#@-node:ekr.20100119145629.6114:writeAllAtFileNodesHelper
#@+node:ekr.20100119145629.6111:writeToFileHelper & helpers
def writeToFileHelper (self,fileName,toOPML):

    c = self.c ; toZip = c.isZipped
    ok,backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName,theActualFile = self.createActualFile(fileName,toOPML,toZip)
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.

    try:
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName,'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName,backupName,theActualFile)
        return False
#@+node:ekr.20100119145629.6106:createActualFile
def createActualFile (self,fileName,toOPML,toZip):

    c = self.c

    if toOPML and not self.mFileName.endswith('opml'):
        fileName = self.mFileName + '.opml'

    if toZip:
        self.toString = True
        theActualFile = None
    else:
        mode = g.choose(g.isPython3,'w','wb')
        try:
            theActualFile = open(fileName,mode)
        except IOError:
            theActualFile = None

    return fileName,theActualFile
#@-node:ekr.20100119145629.6106:createActualFile
#@+node:ekr.20031218072017.3047:createBackupFile
def createBackupFile (self,fileName):

    '''rename fileName to fileName.bak if fileName exists.
    '''

    c = self.c
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"

    if g.os_path_exists(backupName):
        g.utils_remove(backupName)

    ok = g.utils_rename(c,fileName,backupName)

    if not ok and self.read_only:
        g.es("read only",color="red")

    return ok,backupName
#@-node:ekr.20031218072017.3047:createBackupFile
#@+node:ekr.20100119145629.6108:handleWriteLeoFileException
def handleWriteLeoFileException(self,fileName,backupName,theActualFile):

    c = self.c

    g.es("exception writing:",fileName)
    g.es_exception(full=True)

    if theActualFile:
        theActualFile.close()

    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName,'')

    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring",fileName,"from",backupName)
        g.utils_rename(c,backupName,fileName)
    else:
        g.es_print('does not exist!',backupName)

#@-node:ekr.20100119145629.6108:handleWriteLeoFileException
#@-node:ekr.20100119145629.6111:writeToFileHelper & helpers
#@+node:ekr.20100119145629.6110:writeToStringHelper
def writeToStringHelper (self,fileName):

    try:
        self.mFileName = fileName
        self.outputFile = StringIO()
        self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s
        return True
    except Exception:
        g.es("exception writing:",fileName)
        g.es_exception(full=True)
        g.app.write_Leo_file_string = ''
        return False
#@-node:ekr.20100119145629.6110:writeToStringHelper
#@+node:ekr.20070412095520:writeZipFile
def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
#@-node:ekr.20070412095520:writeZipFile
#@-node:ekr.20031218072017.3046:write_Leo_file & helpers
#@-node:ekr.20080412053100.1:Allow saving .leo files with undefined-sections
#@+node:ekr.20100119175348.6127:Refactored write_Leo_file
#@+node:ekr.20031218072017.3046:write_Leo_file & helpers
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    if self.checkOutlineBeforeSave and not self.checkOutline():
        return False
    if not outlineOnlyFlag or toOPML:
        g.app.config.writeRecentFilesFile(c)
        self.writeAllAtFileNodesHelper() # Ignore any errors.
    if self.isReadOnly(fileName):
        return False
    try:
        self.putCount = 0 ; self.toString = toString
        if toString:
            ok = self.writeToStringHelper(fileName)
        else:
            ok = self.writeToFileHelper(fileName,toOPML)
    finally:
        self.outputFile = None
        self.toString = False
    return ok

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20100119145629.6109:checkOutline
def checkOutline (self):

    c = self.c

    g.trace('@bool check_outline_before_save = True',color='blue')

    errors = c.checkOutline(event=None,verbose=True,unittest=False,full=True)
    ok = errors == 0
    if not ok:
        g.es_print('outline not written',color='red')

    return ok
#@-node:ekr.20100119145629.6109:checkOutline
#@+node:ekr.20040324080359.1:isReadOnly
def isReadOnly (self,fileName):

    # self.read_only is not valid for Save As and Save To commands.

    if g.os_path_exists(fileName):
        try:
            if not os.access(fileName,os.W_OK):
                g.es("can not write: read only:",fileName,color="red")
                return True
        except Exception:
            pass # os.access() may not exist on all platforms.

    return False
#@-node:ekr.20040324080359.1:isReadOnly
#@+node:ekr.20100119145629.6114:writeAllAtFileNodesHelper
def writeAllAtFileNodesHelper (self):

    '''Write all @file nodes and set orphan bits.
    '''

    c = self.c

    try:
        # 2010/01/19: Do *not* signal failure here.
        # This allows Leo to quit properly.
        c.atFileCommands.writeAll()
        return True
    except Exception:
        g.es_error("exception writing derived files")
        g.es_exception()
        return False
#@-node:ekr.20100119145629.6114:writeAllAtFileNodesHelper
#@+node:ekr.20100119145629.6111:writeToFileHelper & helpers
def writeToFileHelper (self,fileName,toOPML):

    c = self.c ; toZip = c.isZipped
    ok,backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName,theActualFile = self.createActualFile(fileName,toOPML,toZip)
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.

    try:
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName,'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName,backupName,theActualFile)
        return False
#@+node:ekr.20100119145629.6106:createActualFile
def createActualFile (self,fileName,toOPML,toZip):

    c = self.c

    if toOPML and not self.mFileName.endswith('opml'):
        fileName = self.mFileName + '.opml'

    if toZip:
        self.toString = True
        theActualFile = None
    else:
        mode = g.choose(g.isPython3,'w','wb')
        try:
            theActualFile = open(fileName,mode)
        except IOError:
            theActualFile = None

    return fileName,theActualFile
#@-node:ekr.20100119145629.6106:createActualFile
#@+node:ekr.20031218072017.3047:createBackupFile
def createBackupFile (self,fileName):

    '''rename fileName to fileName.bak if fileName exists.
    '''

    c = self.c
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"

    if g.os_path_exists(backupName):
        g.utils_remove(backupName)

    ok = g.utils_rename(c,fileName,backupName)

    if not ok and self.read_only:
        g.es("read only",color="red")

    return ok,backupName
#@-node:ekr.20031218072017.3047:createBackupFile
#@+node:ekr.20100119145629.6108:handleWriteLeoFileException
def handleWriteLeoFileException(self,fileName,backupName,theActualFile):

    c = self.c

    g.es("exception writing:",fileName)
    g.es_exception(full=True)

    if theActualFile:
        theActualFile.close()

    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName,'')

    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring",fileName,"from",backupName)
        g.utils_rename(c,backupName,fileName)
    else:
        g.es_print('does not exist!',backupName)

#@-node:ekr.20100119145629.6108:handleWriteLeoFileException
#@-node:ekr.20100119145629.6111:writeToFileHelper & helpers
#@+node:ekr.20100119145629.6110:writeToStringHelper
def writeToStringHelper (self,fileName):

    try:
        self.mFileName = fileName
        self.outputFile = StringIO()
        self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s
        return True
    except Exception:
        g.es("exception writing:",fileName)
        g.es_exception(full=True)
        g.app.write_Leo_file_string = ''
        return False
#@-node:ekr.20100119145629.6110:writeToStringHelper
#@+node:ekr.20070412095520:writeZipFile
def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
#@-node:ekr.20070412095520:writeZipFile
#@-node:ekr.20031218072017.3046:write_Leo_file & helpers
#@-node:ekr.20100119175348.6127:Refactored write_Leo_file
#@+node:ekr.20100119175348.6128:Fixed print-bindings crasher w/ leo3k
@nocolor-node

https://bugs.launchpad.net/bugs/509888

When I select 'Help' 'Print Bindings' I receive this error message:
exception executing command
Traceback (most recent call last):
 File "C:\Python31\Lib\site-packages\leo-editor\leo\core\leoCommands.py", line 386, in doCommand
   val = command(event)
 File "C:\Python31\Lib\site-packages\leo-editor\leo\core\leoKeys.py", line 2924, in printBindings
   self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
 File "C:\Python31\Lib\site-packages\leo-editor\leo\core\leoKeys.py", line 2947, in printBindingsHelper
   data.sort(lambda x,y: cmp(x[1],y[1]))
TypeError: must use keyword argument for key function
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        if g.isPython3:
            data.sort(key=lambda x: x[1]) # key is a function used to extract args.
        else:
            data.sort(lambda x,y: cmp(x[1],y[1])) # the function is a comparison.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20100119175348.6128:Fixed print-bindings crasher w/ leo3k
#@-node:ekr.20100118163110.6256:Leo 4.7 rc1 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
