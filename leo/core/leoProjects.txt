#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @file leoProjects.txt
#@+all
#@+node:ekr.20101127152442.5916: ** Testing
#@+node:ekr.20101115092550.5825: *3* Pylint reports
@killcolor

Wrong:
************* Module leo.core.leoFileCommands
E1120:833:baseFileCommands.getDiff: No value passed for parameter 'b' in function call
E1101:1048:baseFileCommands.cleanSaxInputString: Class 'str' has no 'maketrans' member
#@+node:ekr.20101115092550.5826: *4* Minor plugins
************* Module leo.plugins.groupOperations
W0601:190:initImages: Global variable 'groupOpPI' undefined at the module level
W0601:191:initImages: Global variable 'bullseyePI' undefined at the module level
W0601:192:initImages: Global variable 'copyPI' undefined at the module level
W0601:193:initImages: Global variable 'clonePI' undefined at the module level
W0601:194:initImages: Global variable 'movePI' undefined at the module level
W0601:195:initImages: Global variable 'move_arrowPI' undefined at the module level
W0601:196:initImages: Global variable 'copy_arrowPI' undefined at the module level
W0601:197:initImages: Global variable 'clone_arrowPI' undefined at the module level
W0601:198:initImages: Global variable 'markSpotPI' undefined at the module level
W0601:199:initImages: Global variable 'markForPI' undefined at the module level
W0601:200:initImages: Global variable 'operateOnMarkedPI' undefined at the module level
W0601:201:initImages: Global variable 'clearMarksPI' undefined at the module level
W0601:202:initImages: Global variable 'transferFromPI' undefined at the module level
W0611: 33: Unused import copy
W0611: 34: Unused import base64

************* Module leo.plugins.leoupdate
W0105: 59: String statement has no effect
W0601: 85:onCreate: Global variable 'thePluginController' undefined at the module level
W0601: 92:topLevelMenu: Global variable 'thePluginController' undefined at the module level
E1101:132:LeoUpdater.showManagerDialog.HandlerDialog.initLocalCollection: Instance of 'HandlerDialog' has no 'c' member
E1101:150:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:151:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:155:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:159:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:160:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:162:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:163:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
W0611: 28: Unused import glob
W0611: 27: Unused import sys
W0611: 26: Unused import re

************* Module leo.plugins.mod_labels
W0311:113: Bad indentation. Found 3 spaces, expected 4
W0311:114: Bad indentation. Found 6 spaces, expected 8
W0311:121: Bad indentation. Found 6 spaces, expected 8
W0311:123: Bad indentation. Found 3 spaces, expected 4
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 6 spaces, expected 8
W0311:130: Bad indentation. Found 6 spaces, expected 8
W0311:135: Bad indentation. Found 6 spaces, expected 8
W0311:137: Bad indentation. Found 3 spaces, expected 4
W0311:138: Bad indentation. Found 6 spaces, expected 8
W0311:201: Bad indentation. Found 20 spaces, expected 16
W0311:202: Bad indentation. Found 20 spaces, expected 16
W0311:203: Bad indentation. Found 20 spaces, expected 16
W0311:204: Bad indentation. Found 28 spaces, expected 20
W0311:205: Bad indentation. Found 20 spaces, expected 16
W0311:207: Bad indentation. Found 20 spaces, expected 16
W0311:221: Bad indentation. Found 20 spaces, expected 16
W0311:223: Bad indentation. Found 20 spaces, expected 16
W0311:231: Bad indentation. Found 20 spaces, expected 16
E1123:537:labelsController.label_to_subnode: Passing unexpected keyword argument 'p' in function call
E1120:537:labelsController.label_to_subnode: No value passed for parameter 'v' in function call
E1101:566:labelsController.subnode_to_label: Instance of 'labelsController' has no 'get_labellist_for_node' member
E0602:574:labelsController.subnode_to_label: Undefined variable 'v'
E0602:600:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:601:labelsController.subnode_to_label: Undefined variable 'v'
E0602:601:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:606:labelsController.subnode_to_label: Undefined variable 'v'
E1120:618:labelsController.subnodes_to_label: No value passed for parameter 'title' in function call
E0602:668:labelsController.subnodes_to_labels: Undefined variable 'v'
W0611: 37: Unused import leoAtFile
W0611: 38: Unused import leoCommands
W0611: 48: Unused import os
('EKR: exit status', 6)
('*****', 'c:\\leo.repo\\trunk\\leo\\plugins\\mod_read_dir_outline.py', '')
************* Module leo.plugins.mod_read_dir_outline
E1103:105:controller.readDir: Instance of 'unitTestGui' has no 'runOpenDirectoryDialog' member (but some types could notbe inferred)
E1103:105:controller.readDir: Instance of 'nullGui' has no 'runOpenDirectoryDialog' member (but some types could not beinferred)

************* Module leo.plugins.multifile
E1103:131:insertDirectoryString: Instance of 'unitTestGui' has no 'runOpenDirectoryDialog' member (but some types could not be inferred)
E1103:131:insertDirectoryString: Instance of 'nullGui' has no 'runOpenDirectoryDialog' member (but some types could not be inferred)

************* Module leo.plugins.newButtons
E1101:246:UIHelperClass.addWidgets: Instance of 'FlatOptionMenu' has no 'pack' member
E1111:359:HelperForm.formCommit: Assigning to function call which doesn't return

************* Module leo.plugins.nodeActions
W0312:252: Found indentation with tabs instead of spaces
W0312:253: Found indentation with tabs instead of spaces
W0312:254: Found indentation with tabs instead of spaces
W0312:255: Found indentation with tabs instead of spaces
W0312:256: Found indentation with tabs instead of spaces
W0312:257: Found indentation with tabs instead of spaces
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:270: Bad indentation. Found 3 spaces, expected 4
W0311:272: Bad indentation. Found 3 spaces, expected 4
W0311:273: Bad indentation. Found 6 spaces, expected 8
W0311:276: Bad indentation. Found 3 spaces, expected 4
W0311:277: Bad indentation. Found 3 spaces, expected 4
W0311:278: Bad indentation. Found 6 spaces, expected 8
W0311:281: Bad indentation. Found 3 spaces, expected 4
W0311:282: Bad indentation. Found 3 spaces, expected 4
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:285: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:293: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 12 spaces, expected 16
W0311:297: Bad indentation. Found 9 spaces, expected 12
W0311:298: Bad indentation. Found 12 spaces, expected 16
W0311:300: Bad indentation. Found 9 spaces, expected 12
W0311:301: Bad indentation. Found 9 spaces, expected 12
W0311:302: Bad indentation. Found 12 spaces, expected 16
W0311:305: Bad indentation. Found 9 spaces, expected 12
W0311:306: Bad indentation. Found 9 spaces, expected 12
W0311:307: Bad indentation. Found 12 spaces, expected 16
W0311:308: Bad indentation. Found 9 spaces, expected 12
W0311:309: Bad indentation. Found 12 spaces, expected 16
W0311:311: Bad indentation. Found 9 spaces, expected 12
W0311:312: Bad indentation. Found 9 spaces, expected 12
W0311:313: Bad indentation. Found 9 spaces, expected 12
W0311:314: Bad indentation. Found 12 spaces, expected 16
W0311:316: Bad indentation. Found 9 spaces, expected 12
W0311:317: Bad indentation. Found 9 spaces, expected 12
W0311:318: Bad indentation. Found 12 spaces, expected 16
W0311:322: Bad indentation. Found 9 spaces, expected 12
W0311:326: Bad indentation. Found 9 spaces, expected 12
W0311:327: Bad indentation. Found 9 spaces, expected 12
W0311:328: Bad indentation. Found 9 spaces, expected 12
W0311:330: Bad indentation. Found 12 spaces, expected 16
W0311:331: Bad indentation. Found 12 spaces, expected 16
W0311:332: Bad indentation. Found 15 spaces, expected 20
W0311:334: Bad indentation. Found 15 spaces, expected 20
W0311:335: Bad indentation. Found 15 spaces, expected 20
W0311:336: Bad indentation. Found 18 spaces, expected 24
W0311:340: Bad indentation. Found 9 spaces, expected 12
W0311:341: Bad indentation. Found 12 spaces, expected 16
W0311:342: Bad indentation. Found 9 spaces, expected 12
W0311:343: Bad indentation. Found 12 spaces, expected 16
W0311:344: Bad indentation. Found 9 spaces, expected 12
W0311:345: Bad indentation. Found 12 spaces, expected 16
W0311:346: Bad indentation. Found 15 spaces, expected 20
W0311:347: Bad indentation. Found 12 spaces, expected 16
W0311:348: Bad indentation. Found 15 spaces, expected 20
W0311:351: Bad indentation. Found 12 spaces, expected 16
W0311:352: Bad indentation. Found 15 spaces, expected 20
W0311:354: Bad indentation. Found 18 spaces, expected 24
W0311:355: Bad indentation. Found 18 spaces, expected 24
W0311:356: Bad indentation. Found 18 spaces, expected 24
W0311:357: Bad indentation. Found 18 spaces, expected 24
W0311:358: Bad indentation. Found 21 spaces, expected 28
W0311:360: Bad indentation. Found 12 spaces, expected 16
W0311:362: Bad indentation. Found 12 spaces, expected 16
W0311:364: Bad indentation. Found 12 spaces, expected 16
W0311:365: Bad indentation. Found 15 spaces, expected 20
W0311:366: Bad indentation. Found 9 spaces, expected 12
W0311:367: Bad indentation. Found 12 spaces, expected 16
W0311:368: Bad indentation. Found 15 spaces, expected 20
W0311:371: Bad indentation. Found 6 spaces, expected 8
W0311:373: Bad indentation. Found 9 spaces, expected 12
W0311:374: Bad indentation. Found 12 spaces, expected 16
W0311:375: Bad indentation. Found 9 spaces, expected 12
W0311:376: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 9 spaces, expected 12
W0311:379: Bad indentation. Found 12 spaces, expected 16
W0311:380: Bad indentation. Found 9 spaces, expected 12
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 9 spaces, expected 12
W0311:384: Bad indentation. Found 12 spaces, expected 16
W0311:385: Bad indentation. Found 9 spaces, expected 12
W0311:386: Bad indentation. Found 3 spaces, expected 4
W0311:388: Bad indentation. Found 6 spaces, expected 8
W0311:389: Bad indentation. Found 9 spaces, expected 12
W0311:390: Bad indentation. Found 6 spaces, expected 8
W0311:394: Bad indentation. Found 3 spaces, expected 4
W0311:395: Bad indentation. Found 3 spaces, expected 4
W0311:396: Bad indentation. Found 7 spaces, expected 8
W0311:397: Bad indentation. Found 7 spaces, expected 8
W0311:398: Bad indentation. Found 7 spaces, expected 8
W0311:399: Bad indentation. Found 7 spaces, expected 8
W0311:401: Bad indentation. Found 7 spaces, expected 8
W0311:402: Bad indentation. Found 11 spaces, expected 12
W0311:403: Bad indentation. Found 11 spaces, expected 12
W0311:404: Bad indentation. Found 7 spaces, expected 8
W0311:405: Bad indentation. Found 11 spaces, expected 12
W0311:411: Bad indentation. Found 11 spaces, expected 12
W0311:413: Bad indentation. Found 11 spaces, expected 12
W0311:414: Bad indentation. Found 15 spaces, expected 16
W0311:415: Bad indentation. Found 15 spaces, expected 16
W0311:416: Bad indentation. Found 7 spaces, expected 8
W0311:418: Bad indentation. Found 11 spaces, expected 12
W0311:419: Bad indentation. Found 15 spaces, expected 16
W0311:420: Bad indentation. Found 15 spaces, expected 16
W0311:421: Bad indentation. Found 11 spaces, expected 12
W0311:422: Bad indentation. Found 11 spaces, expected 12
W0311:424: Bad indentation. Found 7 spaces, expected 8

************* Module leo.plugins.pie_menus
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E0602:134:PieMenu.construct: Undefined variable 'l1'
E0602:138:PieMenu.construct: Undefined variable 'l1'
E0602:142:PieMenu.construct: Undefined variable 'l1'
E0602:147:PieMenu.construct: Undefined variable 'l1'
E0602:151:PieMenu.construct: Undefined variable 'l1'
E0602:166:PieMenu.construct: Undefined variable 'l1'
E0602:179:PieMenu.construct: Undefined variable 'l3'
E0602:185:PieMenu.construct: Undefined variable 'l3'
E0602:192:PieMenu.construct: Undefined variable 'l3'
E0602:200:PieMenu.construct: Undefined variable 'l2'
E0602:206:PieMenu.construct: Undefined variable 'l2'
E0602:212:PieMenu.construct: Undefined variable 'l2'
E0602:219:PieMenu.construct: Undefined variable 'l2'
E0602:225:PieMenu.construct: Undefined variable 'l2'
E0602:233:PieMenu.construct: Undefined variable 'l4'
E0602:239:PieMenu.construct: Undefined variable 'l4'
E0602:246:PieMenu.construct: Undefined variable 'l4'
E0602:254:PieMenu.construct: Undefined variable 'l5'
E0602:262:PieMenu.construct: Undefined variable 'l6'
E0602:270:PieMenu.construct: Undefined variable 'l7'
E0602:276:PieMenu.construct: Undefined variable 'l7'
E0602:282:PieMenu.construct: Undefined variable 'l7'
E1101:381:PieMenu.clean: Instance of 'PieMenu' has no 'l1' member
E1101:382:PieMenu.clean: Instance of 'PieMenu' has no 'l2' member
E1101:383:PieMenu.clean: Instance of 'PieMenu' has no 'l3' member
E1101:384:PieMenu.clean: Instance of 'PieMenu' has no 'l4' member
E1101:385:PieMenu.clean: Instance of 'PieMenu' has no 'l5' member
E1101:386:PieMenu.clean: Instance of 'PieMenu' has no 'l6' member
E1101:387:PieMenu.clean: Instance of 'PieMenu' has no 'l7' member
E1101:433:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:434:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:435:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:436:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:437:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:438:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:439:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member
E1101:440:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:441:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:442:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:443:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:444:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:445:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:446:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member

************* Module leo.plugins.read_only_nodes
E0611: 73: No name 'parse' in module 'urllib'
E0602:188:FTPurl.read: Undefined variable 'sys'
E0602:222:FTPurl.write: Undefined variable 'sys'
E0213:226:FTPurl.seek: Method should have "self" as first argument
E0602:227:FTPurl.seek: Undefined variable 'self'
E0211:229:FTPurl.flush: Method has no argument
E0602:243:FTPurl.dir: Undefined variable 'sys'
W0601:277:enable_body: Global variable 'insertOnTime' undefined at the module level
W0601:277:enable_body: Global variable 'insertOffTime' undefined at the module level
W0601:287:disable_body: Global variable 'insertOnTime' undefined at the module level
W0601:287:disable_body: Global variable 'insertOffTime' undefined at the module level

************* Module leo.plugins.rClick
W0511:611: TODO:
E1101:938:pluginController.getButtonHandlers: Instance of 'pluginController' has no 'button_handlers' member
E1101:1567:pluginController.findButtonCommandClass.doCommand: Instance of 'findButtonCommandClass' has no 'data' member
W0611:640: Unused import ImageTk
W0611:639: Unused import Image

************* Module leo.plugins.searchbar
W0107: 89:onPreCreate: Unnecessary pass statement
E1101:162:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'bg' member
E1101:168:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'labelText' member
E1101:170:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'command' member
E1101:225:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:230:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:252:SearchbarEntryWidget.onTextChanged: Instance of 'SearchbarEntryWidget' has no 'slave' member
E1101:261:SearchbarEntryWidget.onRightClick: Instance of 'SearchbarEntryWidget' has no 'entry_menu' member
E1101:267:SearchbarEntryWidget.onReturn: Instance of 'SearchbarEntryWidget' has no 'command' member
W0107:403:pluginController.toggleSearchbarCommandClass.doCommand: Unnecessary pass statement
W0611: 27: Unused import leoPlugins
W0611: 30: Unused import sys
W0611: 38: Unused import ImageTk
W0611: 37: Unused import Image
W0611: 29: Unused import re
W0611: 31: Unused import os

************* Module leo.plugins.searchbox
E1101:241:QuickFind.__init__: Class 'leoTkinterFrame' has no 'leoTkTextWidget' member
E1103:276:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)
E1103:278:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'toGuiIndex' member (but some types could not be inferred)
E1103:279:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)

************* Module leo.plugins.templates
W0601: 95:initImages: Global variable 'templatePI' undefined at the module level
W0601: 96:initImages: Global variable 'tempwizPI' undefined at the module level
E0602:205:getTemplateDialog: Undefined variable 'bs'
E0602:206:getTemplateDialog: Undefined variable 'hs'

************* Module leo.plugins.toolbar
W0511:725: FIXME:
W0511:805: TODO: not ready yet
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
W0221:467:ToolbarTkinterFrame.addIconWidget: Arguments number differs from overridden method
W0221:475:ToolbarTkinterFrame.clearIconBar: Arguments number differs from overridden method
E1101:479:ToolbarTkinterFrame.clearIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:481:ToolbarTkinterFrame.createIconBar: Arguments number differs from overridden method
E1101:495:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:501:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:504:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:516:ToolbarTkinterFrame.hideIconBar: Arguments number differs from overridden method
E1101:520:ToolbarTkinterFrame.hideIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some
types could not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but som
e types could not be inferred)
E1101:556:ToolbarTkinterFrame.getToolbarFrame: Instance of 'ToolbarTkinterFrame' has no 'toolBar' member
E1101:619:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:624:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:834:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:839:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:971:ToolbarIconButton.setCommand: Instance of 'ToolbarIconButton' has no 'config' member
E1101:1007:ToolbarScriptButton.__init__.<lambda>: Instance of 'ToolbarScriptButton' has no 'invoke' member
W0221:1229:ToolbarScriptingController.executeScriptFromButton: Arguments number differs from overridden method
W0221:1314:ToolbarScriptingController.createScriptButtonIconButton: Arguments number differs from overridden method
E1103:1336:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure'
 member (but some types could not be inferred)
W0221:1338:ToolbarScriptingController.addScriptButtonCommand: Arguments number differs from overridden method
W0221:1816:ToolbarTkIconBarClass.addWidget: Arguments number differs from overridden method
W0221:1992:ToolbarTkIconBarClass.pack: Arguments number differs from overridden method

************* Module leo.plugins.xcc_nodes
W0312:233: Found indentation with tabs instead of spaces
W0312:403: Found indentation with tabs instead of spaces
W0312:405: Found indentation with tabs instead of spaces
W0312:406: Found indentation with tabs instead of spaces
W0312:407: Found indentation with tabs instead of spaces
W0312:409: Found indentation with tabs instead of spaces
W0312:410: Found indentation with tabs instead of spaces
W0312:414: Found indentation with tabs instead of spaces
W0312:415: Found indentation with tabs instead of spaces
W0312:420: Found indentation with tabs instead of spaces
W0312:421: Found indentation with tabs instead of spaces
W0312:422: Found indentation with tabs instead of spaces
W0312:466: Found indentation with tabs instead of spaces
W0312:468: Found indentation with tabs instead of spaces
W0312:470: Found indentation with tabs instead of spaces
W0312:471: Found indentation with tabs instead of spaces
W0312:472: Found indentation with tabs instead of spaces
W0312:475: Found indentation with tabs instead of spaces
W0312:476: Found indentation with tabs instead of spaces
W0312:491: Found indentation with tabs instead of spaces
W0312:492: Found indentation with tabs instead of spaces
W0312:493: Found indentation with tabs instead of spaces
W0312:495: Found indentation with tabs instead of spaces
W0312:496: Found indentation with tabs instead of spaces
W0312:500: Found indentation with tabs instead of spaces
W0312:501: Found indentation with tabs instead of spaces
W0312:502: Found indentation with tabs instead of spaces
W0312:503: Found indentation with tabs instead of spaces
W0312:504: Found indentation with tabs instead of spaces
W0312:505: Found indentation with tabs instead of spaces
W0312:509: Found indentation with tabs instead of spaces
W0312:510: Found indentation with tabs instead of spaces
W0312:511: Found indentation with tabs instead of spaces
W0312:512: Found indentation with tabs instead of spaces
W0312:514: Found indentation with tabs instead of spaces
W0312:518: Found indentation with tabs instead of spaces
W0312:522: Found indentation with tabs instead of spaces
W0312:523: Found indentation with tabs instead of spaces
W0312:524: Found indentation with tabs instead of spaces
W0312:525: Found indentation with tabs instead of spaces
W0312:529: Found indentation with tabs instead of spaces
W0312:530: Found indentation with tabs instead of spaces
W0312:533: Found indentation with tabs instead of spaces
W0312:534: Found indentation with tabs instead of spaces
W0312:535: Found indentation with tabs instead of spaces
W0312:536: Found indentation with tabs instead of spaces
W0312:537: Found indentation with tabs instead of spaces
W0312:539: Found indentation with tabs instead of spaces
W0312:553: Found indentation with tabs instead of spaces
W0312:554: Found indentation with tabs instead of spaces
W0511:169: XXX to XxxClass.
W0511:518: TODO: ","Add import code in ImportFiles function!")
W0511:3339: TODO: Support precompiled header auto creation/inclusion."""
W0511:3660: TODO: send a WATCHTASK if breaked
E0602:336:OnStart2: Undefined variable 'XCC_INITED'
E0602:338:OnStart2: Undefined variable 'InitXcc'
E1101:415:linPause: Module 'os' has no 'kill' member
E0601:420:AddText: Using variable 'c' before assignment
E0602:421:AddText: Undefined variable 'LeoBody'
E0602:422:AddText: Undefined variable 'LeoBody'
E0602:471:DecompressIcon: Undefined variable 'Excetion'
E0602:472:DecompressIcon: Undefined variable 'Traceback'
E0602:533:ReplaceVars: Undefined variable 'NAME'
E0602:534:ReplaceVars: Undefined variable 'EXT'
E0602:535:ReplaceVars: Undefined variable 'ABS_PATH'
E0602:536:ReplaceVars: Undefined variable 'REL_PATH'
E0602:537:ReplaceVars: Undefined variable 'SRC_EXT'
E1121:674:controllerClass.onIdle: Too many positional arguments for function call
E1121:727:controllerClass.onQuit: Too many positional arguments for function call
E0211:813:controllerClass.UpdateProcess: Method has no argument
E0601:815:controllerClass.UpdateProcess: Using variable 'cc' before assignment
E0602:817:controllerClass.UpdateProcess: Undefined variable 'self'
E0211:992:controllerClass.sGetExecInfo: Method has no argument
E0602:994:controllerClass.sGetExecInfo: Undefined variable 'self'
E0602:1020:controllerClass.sGoToError: Undefined variable 'CPL'
E1101:1178:controllerClass.sSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1178:controllerClass.sSetText: Undefined variable 'SELECTED_NODE'
E1101:1184:controllerClass.sAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1184:controllerClass.sAddText: Undefined variable 'SELECTED_NODE'
E1120:1249:controllerClass.aStop: No value passed for parameter 'pid' in function call
E0602:1265:controllerClass.aStepIn: Undefined variable 'DBG'
E0602:1280:controllerClass.aStepOver: Undefined variable 'DBG'
E0602:1295:controllerClass.aStepOut: Undefined variable 'DBG'
E1120:1308:controllerClass.aPause: No value passed for parameter 'pid' in function call
E1101:1342:controllerClass.aSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1342:controllerClass.aSetText: Undefined variable 'ACTIVE_NODE'
E1101:1348:controllerClass.aAddText: Instance of 'controllerClass' has no 'ACTIVE_NOD' member
E1101:1349:controllerClass.aAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1352:controllerClass.aAddText: Undefined variable 'LeoBodyText'
E1101:1379:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessClass' member
E1101:1386:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1401:controllerClass.CplCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E0602:1440:controllerClass.CplCmd: Undefined variable 'CPL'
E1101:1457:controllerClass.Debug: Instance of 'controllerClass' has no 'GetDebugInfo' member
E1101:1466:controllerClass.Debug: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1473:controllerClass.DbgCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E1121:1483:controllerClass.Execute: Too many positional arguments for function call
E1101:1495:controllerClass.Execute: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1507:controllerClass.CplStart: Instance of 'controllerClass' has no 'VProcessList' member
E1101:1587:controllerClass.DbgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1607:controllerClass.DbgStart: Undefined variable 'DBG'
E0602:1614:controllerClass.DbgStart: Undefined variable 'DBG'
E0213:1616:controllerClass.DbgOut: Method should have "self" as first argument
E0602:1620:controllerClass.DbgOut: Undefined variable 'self'
E0602:1625:controllerClass.DbgOut: Undefined variable 'OutBuff'
E1101:1704:controllerClass.ProgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1719:controllerClass.ProgOut: Undefined variable 'ExtractLines'
E0602:1719:controllerClass.ProgOut: Undefined variable 'OutBuff'
E0602:1736:controllerClass.ProgErr: Undefined variable 'ExtractLines'
E0602:1736:controllerClass.ProgErr: Undefined variable 'ErrBuff'
E0602:1772:DBGTASK.__init__: Undefined variable 'DBG_SD'
E0602:1774:DBGTASK.__init__: Undefined variable 'DBG_SD'
E1101:1780:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1781:DBGTASK.Send: Instance of 'DBGTASK' has no 'aWrite' member
E1101:1781:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1782:DBGTASK.Send: Instance of 'DBGTASK' has no 'DBG_SD' member
E0602:1858:BREAKTASK.__init__: Undefined variable 'aGet'
E0602:1860:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1862:BREAKTASK.__init__: Undefined variable 'Waning'
E0602:1867:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1881:BREAKTASK.Send: Undefined variable 'NAME'
E0602:1882:BREAKTASK.Send: Undefined variable 'aWrite'
E0602:1884:BREAKTASK.Send: Undefined variable 'DBG_SD'
E0602:1885:BREAKTASK.Send: Undefined variable 'DBG_RD'
E0602:1897:BREAKTASK.Receive: Undefined variable 'aAddText'
E0602:1949:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1951:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1955:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1956:WATCHTASK.__init__: Undefined variable 'ccWatcher'
E0602:1959:WATCHTASK.__init__: Undefined variable 'DBG_SD'
W0601:1969:WATCHTASK.Cancel: Global variable 'WATCH_TASK' undefined at the module level
E0602:1970:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1971:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1972:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1973:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1974:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1975:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1977:WATCHTASK.Cancel: Undefined variable 'Watcher'
E0602:1983:WATCHTASK.Send: Undefined variable 'Watcher'
E0602:1985:WATCHTASK.Send: Undefined variable 'aWrite'
E0602:1985:WATCHTASK.Send: Undefined variable 'DBG'
E0602:1986:WATCHTASK.Send: Undefined variable 'DBG_SD'
E0602:1987:WATCHTASK.Send: Undefined variable 'DBG_RD'
E0602:1988:WATCHTASK.Send: Undefined variable 'PROMPT_RD'
E0602:1993:WATCHTASK.Receive: Undefined variable 'DBG_PROMPT'
W0601:1997:WATCHTASK.OnPrompt: Global variable 'WATCH_TASK' undefined at the module level
E0602:1999:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2005:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2010:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2011:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2014:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2015:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2017:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2020:WATCHTASK.OnPrompt: Undefined variable 'DBG_SD'
E0602:2022:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2025:WATCHTASK.OnPrompt: Undefined variable 'PROMPT_RD'
E0602:2026:WATCHTASK.OnPrompt: Undefined variable 'DBG_RD'
E0602:2101:BREAKIDTASK.Send: Undefined variable 'aWrite'
E0602:2102:BREAKIDTASK.Send: Undefined variable 'DBG_SD'
E0602:2103:BREAKIDTASK.Send: Undefined variable 'DBG_RD'
E0602:2554:ConfigClass.CplPageClass.Browse: Undefined variable 'e'
E0602:2694:ConfigClass.DbgPageClass.Browse: Undefined variable 'e'
E0602:3535:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3536:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3541:ToolbarClass.SyncDisplayToError: Undefined variable 'INSERT'
E0602:3554:ToolbarClass.SyncDisplayToError: Undefined variable 'c'
W0601:3558:ToolbarClass.SetError: Global variable 'PARSE_ERROR' undefined at the module level
W0601:3558:ToolbarClass.SetError: Global variable 'PARSE_ERROR_NODE' undefined at the module level
E0602:3590:ToolbarClass.Refresh: Undefined variable 'ACTIVE_NODE'
E0602:3610:WatcherClass.__init__: Undefined variable 'c'
E0602:3631:WatcherClass.__init__: Undefined variable 'c'
E0602:3632:WatcherClass.__init__: Undefined variable 'c'
E0602:3633:WatcherClass.__init__: Undefined variable 'c'
E0602:3634:WatcherClass.__init__: Undefined variable 'c'
E0602:3684:WatcherClass.OnDelete: Undefined variable 'sGet'
W0221:3796:BreakbarClass.yview: Arguments number differs from overridden method
E0602:3846:BreakbarClass.OnCut: Undefined variable 'LeoFrame'
E0602:3850:BreakbarClass.OnPaste: Undefined variable 'LeoFrame'
E1101:3855:BreakbarClass.OnRightClick: Instance of 'BreakbarClass' has no 'c' member
E0602:3856:BreakbarClass.OnRightClick: Undefined variable 'Menu'
E0602:3873:BreakbarClass.OnLeftClick: Undefined variable 'cGet'
E0602:3875:BreakbarClass.OnLeftClick: Undefined variable 'CHILD_NODE'
E0602:3888:BreakbarClass.OnLeftClick: Undefined variable 'SEL'
E0602:3892:BreakbarClass.AddNodeBreak: Undefined variable 'cGet'
E0602:3895:BreakbarClass.DeleteNodeBreak: Undefined variable 'cGet'
E0602:3900:BreakbarClass.ClearNodeBreaks: Undefined variable 'cSet'
E0602:4010:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_EXT'
E0602:4010:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_LINE'
E0602:4016:BreakbarClass.AddBreak: Undefined variable 'sGet'
E0602:4057:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cGet'
E0602:4061:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_EXT'
E0602:4061:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_LINE'
E1101:4063:BreakbarClass.DeleteNodeBreaks: Instance of 'BreakbarClass' has no 'DeleteDbgBreaks' member
E0602:4065:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cSelect'
E0602:4357:CppParserClass.FUNCRULE.DeclareFunc: Undefined variable 'ToolBar'
E0602:4375:CppParserClass.FUNCRULE.DefineFunc: Undefined variable 'ToolBar'
E0602:4513:CppParserClass.CLASSRULE.OnMatch: Undefined variable 'ToolBar'
E1101:4703:CppParserClass.Docum: Instance of 'CppParserClass' has no 'CURRENT_DOC_LINE' member
E0602:4727:CppParserClass.SetRealBodyDestination: Undefined variable 'EXT'
E1101:4796:CppParserClass.CppParse: Instance of 'CppParserClass' has no 'cc' member
E1102:4823:CppParserClass.CppParse: self.OnStart is not callable
E0602:4830:CppParserClass.CppParse: Undefined variable 'NAME'
E1102:4836:CppParserClass.CppParse: self.OnEnd is not callable
E1101:4849:CppParserClass.ParseNode: Instance of 'CppParserClass' has no 'cc' member
E0602:4939:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4940:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4940:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4942:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4945:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4946:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4950:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4951:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4956:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4956:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4957:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4957:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4958:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4961:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4962:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:5008:BreakFinderClass.__init__: Undefined variable 'controllerSELECTED_NODE'
E0602:5008:BreakFinderClass.__init__: Undefined variable 'controllerEXT'
E0602:5024:BreakFinderClass.OnFindStart: Undefined variable 'sSet'
E0602:5025:BreakFinderClass.OnFindStart: Undefined variable 'sGet'
E0602:5031:BreakFinderClass.OnFindEnd: Undefined variable 'sSet'
E0602:5050:BreakFinderClass.BreakDef: Undefined variable 'SRC_EXT'
W0611:206: Unused import tkSimpleDialog
W0611:207: Unused import base64
W0611:203: Unused import beep

************* Module leo.plugins.active_path
W0108:124:attachToCommander.<lambda>: Lambda may not be necessary
E1101:399:openDir: Generator 'walk' has no 'next' member

************* Module leo.plugins.attrib_edit
W0311:816: Bad indentation. Found 3 spaces, expected 4
W0311:819: Bad indentation. Found 3 spaces, expected 4
W0311:822: Bad indentation. Found 3 spaces, expected 4
W0311:825: Bad indentation. Found 3 spaces, expected 4
W0311:828: Bad indentation. Found 3 spaces, expected 4
W0511:289: FIXME type_ = {True: '_view', False: '_edit'}[readonly]
W0511:304: FIXME self.attrPaths.add(tuple(ns))
E1101:665:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'recSearch' member
E1101:669:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
E1101:671:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
W0611:118: Unused import os
W0611:114: Unused import re

************* Module leo.plugins.backlink
W0511: 23: TODO
E1101:145:backlinkTkUI.updateTkTab: Instance of 'backlinkTkUI' has no 'c' member
E1101:150:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:161:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:169:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnode' member
E1101:170:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnodePosition' member
E1101:171:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:179:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:186:backlinkTkUI.updateTkTabInt.delLink: Instance of 'backlinkTkUI' has no 'deleteLink' member
W0101:787:backlinkController.vnodePosition: Unreachable code
E1101:790:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:791:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:805:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member

************* Module leo.plugins.codewisecompleter
E1111:244:codewise_lookup: Assigning to function call which doesn't return
E0602:283:codewise_suggest: Undefined variable 'txt'
W0611: 34: Unused import os

************* Module leo.plugins.cursesGui
W0311: 84: Bad indentation. Found 2 spaces, expected 4
W0311: 85: Bad indentation. Found 4 spaces, expected 8
W0311: 87: Bad indentation. Found 2 spaces, expected 4
W0311: 92: Bad indentation. Found 2 spaces, expected 4
W0311: 93: Bad indentation. Found 4 spaces, expected 8
W0311: 95: Bad indentation. Found 4 spaces, expected 8
W0311: 96: Bad indentation. Found 4 spaces, expected 8
W0311: 99: Bad indentation. Found 2 spaces, expected 4
W0311:103: Bad indentation. Found 6 spaces, expected 8
W0311:105: Bad indentation. Found 2 spaces, expected 4
W0311:106: Bad indentation. Found 4 spaces, expected 8
W0311:107: Bad indentation. Found 4 spaces, expected 8
W0311:108: Bad indentation. Found 4 spaces, expected 8
W0311:110: Bad indentation. Found 2 spaces, expected 4
W0311:111: Bad indentation. Found 4 spaces, expected 8
W0311:114: Bad indentation. Found 2 spaces, expected 4
W0311:115: Bad indentation. Found 4 spaces, expected 8
W0311:117: Bad indentation. Found 2 spaces, expected 4
W0311:118: Bad indentation. Found 4 spaces, expected 8
W0311:120: Bad indentation. Found 2 spaces, expected 4
W0311:122: Bad indentation. Found 6 spaces, expected 8
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 2 spaces, expected 4
W0311:127: Bad indentation. Found 4 spaces, expected 8
W0311:129: Bad indentation. Found 2 spaces, expected 4
W0311:130: Bad indentation. Found 4 spaces, expected 8
W0311:132: Bad indentation. Found 2 spaces, expected 4
W0311:133: Bad indentation. Found 4 spaces, expected 8
W0311:135: Bad indentation. Found 4 spaces, expected 8
W0311:137: Bad indentation. Found 4 spaces, expected 8
W0311:138: Bad indentation. Found 4 spaces, expected 8
W0311:140: Bad indentation. Found 4 spaces, expected 8
W0311:142: Bad indentation. Found 4 spaces, expected 8
W0311:143: Bad indentation. Found 6 spaces, expected 12
W0311:144: Bad indentation. Found 4 spaces, expected 8
W0311:146: Bad indentation. Found 2 spaces, expected 4
W0311:147: Bad indentation. Found 4 spaces, expected 8
W0311:149: Bad indentation. Found 2 spaces, expected 4
W0311:150: Bad indentation. Found 4 spaces, expected 8
W0311:152: Bad indentation. Found 2 spaces, expected 4
W0311:153: Bad indentation. Found 4 spaces, expected 8
W0311:155: Bad indentation. Found 4 spaces, expected 8
W0311:156: Bad indentation. Found 4 spaces, expected 8
W0311:158: Bad indentation. Found 4 spaces, expected 8
W0311:161: Bad indentation. Found 6 spaces, expected 12
W0311:162: Bad indentation. Found 8 spaces, expected 16
W0311:163: Bad indentation. Found 6 spaces, expected 12
W0311:164: Bad indentation. Found 6 spaces, expected 12
W0311:167: Bad indentation. Found 6 spaces, expected 12
W0311:169: Bad indentation. Found 6 spaces, expected 12
W0311:170: Bad indentation. Found 8 spaces, expected 16
W0311:171: Bad indentation. Found 6 spaces, expected 12
W0311:172: Bad indentation. Found 10 spaces, expected 16
W0311:174: Bad indentation. Found 2 spaces, expected 4
W0311:176: Bad indentation. Found 4 spaces, expected 8
W0311:177: Bad indentation. Found 6 spaces, expected 12
W0311:178: Bad indentation. Found 4 spaces, expected 8
W0311:179: Bad indentation. Found 6 spaces, expected 12
W0311:180: Bad indentation. Found 4 spaces, expected 8
W0311:181: Bad indentation. Found 6 spaces, expected 12
W0311:182: Bad indentation. Found 4 spaces, expected 8
W0311:183: Bad indentation. Found 6 spaces, expected 12
W0311:184: Bad indentation. Found 8 spaces, expected 16
W0311:185: Bad indentation. Found 6 spaces, expected 12
W0311:186: Bad indentation. Found 6 spaces, expected 12
W0311:187: Bad indentation. Found 8 spaces, expected 16
W0311:188: Bad indentation. Found 6 spaces, expected 12
W0311:189: Bad indentation. Found 8 spaces, expected 16
W0311:190: Bad indentation. Found 6 spaces, expected 12
W0311:191: Bad indentation. Found 8 spaces, expected 16
W0311:192: Bad indentation. Found 4 spaces, expected 8
W0311:193: Bad indentation. Found 6 spaces, expected 12
W0311:194: Bad indentation. Found 4 spaces, expected 8
W0311:195: Bad indentation. Found 6 spaces, expected 12
W0311:197: Bad indentation. Found 2 spaces, expected 4
W0311:198: Bad indentation. Found 4 spaces, expected 8
W0311:199: Bad indentation. Found 6 spaces, expected 12
W0311:200: Bad indentation. Found 4 spaces, expected 8
W0311:206: Bad indentation. Found 2 spaces, expected 4
W0311:208: Bad indentation. Found 4 spaces, expected 8
W0311:210: Bad indentation. Found 4 spaces, expected 8
W0311:213: Bad indentation. Found 2 spaces, expected 4
W0311:215: Bad indentation. Found 4 spaces, expected 8
W0311:217: Bad indentation. Found 4 spaces, expected 8
W0311:218: Bad indentation. Found 4 spaces, expected 8
W0311:219: Bad indentation. Found 4 spaces, expected 8
W0311:221: Bad indentation. Found 4 spaces, expected 8
W0311:222: Bad indentation. Found 4 spaces, expected 8
W0311:223: Bad indentation. Found 4 spaces, expected 8
W0311:236: Bad indentation. Found 2 spaces, expected 4
W0311:237: Bad indentation. Found 2 spaces, expected 4
W0311:239: Bad indentation. Found 2 spaces, expected 4
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 2 spaces, expected 4
W0311:243: Bad indentation. Found 4 spaces, expected 8
W0311:245: Bad indentation. Found 4 spaces, expected 8
W0311:246: Bad indentation. Found 4 spaces, expected 8
W0311:247: Bad indentation. Found 4 spaces, expected 8
W0311:248: Bad indentation. Found 4 spaces, expected 8
W0311:250: Bad indentation. Found 4 spaces, expected 8
W0311:251: Bad indentation. Found 6 spaces, expected 12
W0311:253: Bad indentation. Found 4 spaces, expected 8
W0311:254: Bad indentation. Found 4 spaces, expected 8
W0311:257: Bad indentation. Found 4 spaces, expected 8
W0311:260: Bad indentation. Found 4 spaces, expected 8
W0311:262: Bad indentation. Found 2 spaces, expected 4
W0311:264: Bad indentation. Found 2 spaces, expected 4
W0311:265: Bad indentation. Found 4 spaces, expected 8
W0311:267: Bad indentation. Found 2 spaces, expected 4
W0311:268: Bad indentation. Found 4 spaces, expected 8
W0311:270: Bad indentation. Found 2 spaces, expected 4
W0311:271: Bad indentation. Found 4 spaces, expected 8
W0311:273: Bad indentation. Found 4 spaces, expected 8
W0311:274: Bad indentation. Found 4 spaces, expected 8
W0311:276: Bad indentation. Found 4 spaces, expected 8
W0311:277: Bad indentation. Found 4 spaces, expected 8
W0311:279: Bad indentation. Found 4 spaces, expected 8
W0311:280: Bad indentation. Found 8 spaces, expected 12
W0311:281: Bad indentation. Found 12 spaces, expected 16
W0311:282: Bad indentation. Found 12 spaces, expected 16
W0311:283: Bad indentation. Found 12 spaces, expected 16
W0311:284: Bad indentation. Found 12 spaces, expected 16
W0311:285: Bad indentation. Found 12 spaces, expected 16
W0311:291: Bad indentation. Found 4 spaces, expected 8
W0311:292: Bad indentation. Found 4 spaces, expected 8
W0311:293: Bad indentation. Found 4 spaces, expected 8
W0311:295: Bad indentation. Found 4 spaces, expected 8
W0311:296: Bad indentation. Found 4 spaces, expected 8
W0311:298: Bad indentation. Found 2 spaces, expected 4
W0311:299: Bad indentation. Found 2 spaces, expected 4
W0311:305: Bad indentation. Found 2 spaces, expected 4
W0311:306: Bad indentation. Found 4 spaces, expected 8
W0311:308: Bad indentation. Found 4 spaces, expected 8
W0311:310: Bad indentation. Found 4 spaces, expected 8
W0311:311: Bad indentation. Found 4 spaces, expected 8
W0311:314: Bad indentation. Found 2 spaces, expected 4
W0311:317: Bad indentation. Found 4 spaces, expected 8
W0311:321: Bad indentation. Found 2 spaces, expected 4
W0311:322: Bad indentation. Found 2 spaces, expected 4
W0311:324: Bad indentation. Found 2 spaces, expected 4
W0311:326: Bad indentation. Found 4 spaces, expected 8
W0311:327: Bad indentation. Found 4 spaces, expected 8
W0311:328: Bad indentation. Found 4 spaces, expected 8
W0311:329: Bad indentation. Found 4 spaces, expected 8
W0311:333: Bad indentation. Found 2 spaces, expected 4
W0311:338: Bad indentation. Found 2 spaces, expected 4
W0311:339: Bad indentation. Found 4 spaces, expected 8
W0311:340: Bad indentation. Found 4 spaces, expected 8
W0311:341: Bad indentation. Found 4 spaces, expected 8
W0311:343: Bad indentation. Found 2 spaces, expected 4
W0311:344: Bad indentation. Found 4 spaces, expected 8
W0311:345: Bad indentation. Found 4 spaces, expected 8
W0311:346: Bad indentation. Found 6 spaces, expected 12
W0311:347: Bad indentation. Found 4 spaces, expected 8
W0311:353: Bad indentation. Found 2 spaces, expected 4
W0311:354: Bad indentation. Found 4 spaces, expected 8
W0311:355: Bad indentation. Found 4 spaces, expected 8
W0311:356: Bad indentation. Found 4 spaces, expected 8
W0311:357: Bad indentation. Found 4 spaces, expected 8
W0311:359: Bad indentation. Found 2 spaces, expected 4
W0311:360: Bad indentation. Found 4 spaces, expected 8
W0311:366: Bad indentation. Found 2 spaces, expected 4
W0311:367: Bad indentation. Found 4 spaces, expected 8
W0311:374: Bad indentation. Found 2 spaces, expected 4
W0311:377: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 6 spaces, expected 8
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 2 spaces, expected 4
W0311:385: Bad indentation. Found 4 spaces, expected 8
W0311:387: Bad indentation. Found 4 spaces, expected 8
W0311:389: Bad indentation. Found 4 spaces, expected 8
W0311:391: Bad indentation. Found 2 spaces, expected 4
W0311:393: Bad indentation. Found 4 spaces, expected 8
W0311:398: Bad indentation. Found 4 spaces, expected 8
W0311:399: Bad indentation. Found 4 spaces, expected 8
W0311:400: Bad indentation. Found 4 spaces, expected 8
W0311:402: Bad indentation. Found 2 spaces, expected 4
W0311:406: Bad indentation. Found 4 spaces, expected 8
W0311:407: Bad indentation. Found 8 spaces, expected 12
W0311:408: Bad indentation. Found 4 spaces, expected 8
W0311:412: Bad indentation. Found 2 spaces, expected 4
W0311:417: Bad indentation. Found 4 spaces, expected 8
W0311:421: Bad indentation. Found 4 spaces, expected 8
W0311:422: Bad indentation. Found 6 spaces, expected 12
W0311:424: Bad indentation. Found 4 spaces, expected 8
W0311:425: Bad indentation. Found 4 spaces, expected 8
W0311:426: Bad indentation. Found 4 spaces, expected 8
W0311:427: Bad indentation. Found 4 spaces, expected 8
W0311:430: Bad indentation. Found 4 spaces, expected 8
W0311:431: Bad indentation. Found 4 spaces, expected 8
W0311:433: Bad indentation. Found 2 spaces, expected 4
W0311:434: Bad indentation. Found 4 spaces, expected 8
W0311:436: Bad indentation. Found 2 spaces, expected 4
W0311:438: Bad indentation. Found 4 spaces, expected 8
W0311:440: Bad indentation. Found 2 spaces, expected 4
W0311:441: Bad indentation. Found 4 spaces, expected 8
W0311:443: Bad indentation. Found 4 spaces, expected 8
W0311:444: Bad indentation. Found 6 spaces, expected 12
W0311:446: Bad indentation. Found 6 spaces, expected 12
W0311:447: Bad indentation. Found 8 spaces, expected 16
W0311:448: Bad indentation. Found 6 spaces, expected 12
W0311:450: Bad indentation. Found 6 spaces, expected 12
W0311:451: Bad indentation. Found 6 spaces, expected 12
W0311:452: Bad indentation. Found 6 spaces, expected 12
W0311:454: Bad indentation. Found 6 spaces, expected 12
W0311:455: Bad indentation. Found 8 spaces, expected 16
W0311:456: Bad indentation. Found 6 spaces, expected 12
W0311:458: Bad indentation. Found 8 spaces, expected 16
W0311:459: Bad indentation. Found 8 spaces, expected 16
W0311:460: Bad indentation. Found 10 spaces, expected 20
W0311:461: Bad indentation. Found 14 spaces, expected 24
W0311:462: Bad indentation. Found 8 spaces, expected 16
W0311:464: Bad indentation. Found 6 spaces, expected 12
W0311:465: Bad indentation. Found 8 spaces, expected 16
W0311:466: Bad indentation. Found 6 spaces, expected 12
W0311:467: Bad indentation. Found 8 spaces, expected 16
W0311:469: Bad indentation. Found 6 spaces, expected 12
W0311:470: Bad indentation. Found 6 spaces, expected 12
W0311:471: Bad indentation. Found 8 spaces, expected 16
W0311:472: Bad indentation. Found 8 spaces, expected 16
W0311:473: Bad indentation. Found 6 spaces, expected 12
W0311:474: Bad indentation. Found 8 spaces, expected 16
W0311:475: Bad indentation. Found 6 spaces, expected 12
W0311:476: Bad indentation. Found 8 spaces, expected 16
W0311:483: Bad indentation. Found 2 spaces, expected 4
W0311:484: Bad indentation. Found 4 spaces, expected 8
W0311:486: Bad indentation. Found 2 spaces, expected 4
W0311:487: Bad indentation. Found 4 spaces, expected 8
W0311:489: Bad indentation. Found 2 spaces, expected 4
W0311:490: Bad indentation. Found 4 spaces, expected 8
W0311:493: Bad indentation. Found 2 spaces, expected 4
W0311:494: Bad indentation. Found 2 spaces, expected 4
W0311:496: Bad indentation. Found 2 spaces, expected 4
W0311:504: Bad indentation. Found 2 spaces, expected 4
W0311:505: Bad indentation. Found 4 spaces, expected 8
W0311:507: Bad indentation. Found 2 spaces, expected 4
W0311:508: Bad indentation. Found 4 spaces, expected 8
W0311:510: Bad indentation. Found 2 spaces, expected 4
W0311:511: Bad indentation. Found 4 spaces, expected 8
W0311:512: Bad indentation. Found 6 spaces, expected 12
W0311:514: Bad indentation. Found 2 spaces, expected 4
W0311:515: Bad indentation. Found 4 spaces, expected 8
W0311:517: Bad indentation. Found 2 spaces, expected 4
W0311:518: Bad indentation. Found 4 spaces, expected 8
W0311:519: Bad indentation. Found 6 spaces, expected 12
W0311:522: Bad indentation. Found 2 spaces, expected 4
W0311:524: Bad indentation. Found 4 spaces, expected 8
W0311:526: Bad indentation. Found 4 spaces, expected 8
W0311:528: Bad indentation. Found 2 spaces, expected 4
W0311:531: Bad indentation. Found 4 spaces, expected 8
W0311:532: Bad indentation. Found 4 spaces, expected 8
W0311:534: Bad indentation. Found 4 spaces, expected 8
W0311:538: Bad indentation. Found 4 spaces, expected 8
W0311:541: Bad indentation. Found 2 spaces, expected 4
W0311:542: Bad indentation. Found 4 spaces, expected 8
W0311:544: Bad indentation. Found 2 spaces, expected 4
W0311:545: Bad indentation. Found 4 spaces, expected 8
W0311:547: Bad indentation. Found 2 spaces, expected 4
W0311:550: Bad indentation. Found 4 spaces, expected 8
W0311:551: Bad indentation. Found 4 spaces, expected 8
W0311:553: Bad indentation. Found 2 spaces, expected 4
W0311:555: Bad indentation. Found 4 spaces, expected 8
W0311:557: Bad indentation. Found 6 spaces, expected 12
W0311:558: Bad indentation. Found 8 spaces, expected 16
W0311:559: Bad indentation. Found 6 spaces, expected 12
W0311:560: Bad indentation. Found 8 spaces, expected 16
W0311:562: Bad indentation. Found 6 spaces, expected 12
W0311:568: Bad indentation. Found 6 spaces, expected 12
W0311:570: Bad indentation. Found 6 spaces, expected 12
W0311:571: Bad indentation. Found 8 spaces, expected 16
W0511: 21: TODO >>
W0511: 22: TODO >>
W0511: 43: TODO >>
W0511: 97: TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
W0511:319: TODO Tkinter onBodyChanged undo call and many others. =(
W0511:529: TODO Much more here: there's four hooks and all sorts of other things called in the TK version.
W0221:267:textFrame.setTopGeometry: Arguments number differs from overridden method
W0221:391:textLeoMenu.new_menu: Arguments number differs from overridden method
W0221:412:textLeoMenu.add_command: Arguments number differs from overridden method
W0221:436:textLeoMenu.delete_range: Arguments number differs from overridden method
W0221:514:textTree.redraw: Arguments number differs from overridden method
W0221:517:textTree.redraw_now: Arguments number differs from overridden method
W0221:541:textTree.editLabel: Arguments number differs from overridden method

************* Module leo.plugins.dtest
W0611: 32: Unused import leoPlugins

************* Module leo.plugins.leo_interface
W0311: 42: Bad indentation. Found 3 spaces, expected 4
W0311: 43: Bad indentation. Found 6 spaces, expected 8
W0311: 45: Bad indentation. Found 3 spaces, expected 4
W0311: 46: Bad indentation. Found 6 spaces, expected 8
W0311: 52: Bad indentation. Found 3 spaces, expected 4
W0311: 59: Bad indentation. Found 3 spaces, expected 4
W0311: 60: Bad indentation. Found 7 spaces, expected 8
W0311: 62: Bad indentation. Found 3 spaces, expected 4
W0311: 63: Bad indentation. Found 7 spaces, expected 8
W0311: 64: Bad indentation. Found 7 spaces, expected 8
W0311: 66: Bad indentation. Found 3 spaces, expected 4
W0311: 67: Bad indentation. Found 7 spaces, expected 8
W0311: 69: Bad indentation. Found 3 spaces, expected 4
W0311: 70: Bad indentation. Found 7 spaces, expected 8
W0311: 71: Bad indentation. Found 11 spaces, expected 12
W0311: 73: Bad indentation. Found 3 spaces, expected 4
W0311: 74: Bad indentation. Found 7 spaces, expected 8
W0311: 75: Bad indentation. Found 7 spaces, expected 8
W0311: 76: Bad indentation. Found 11 spaces, expected 12
W0311: 77: Bad indentation. Found 7 spaces, expected 8
W0311: 78: Bad indentation. Found 7 spaces, expected 8
W0311: 80: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 7 spaces, expected 8
W0311: 82: Bad indentation. Found 7 spaces, expected 8
W0311: 83: Bad indentation. Found 7 spaces, expected 8
W0311: 84: Bad indentation. Found 7 spaces, expected 8
W0311: 85: Bad indentation. Found 7 spaces, expected 8
W0311: 86: Bad indentation. Found 11 spaces, expected 12
W0311: 87: Bad indentation. Found 7 spaces, expected 8
W0311: 88: Bad indentation. Found 7 spaces, expected 8
W0311: 89: Bad indentation. Found 11 spaces, expected 12
W0311: 90: Bad indentation. Found 7 spaces, expected 8
W0311: 91: Bad indentation. Found 7 spaces, expected 8
W0311: 92: Bad indentation. Found 7 spaces, expected 8
W0311: 93: Bad indentation. Found 11 spaces, expected 12
W0311: 95: Bad indentation. Found 3 spaces, expected 4
W0311: 96: Bad indentation. Found 7 spaces, expected 8
W0311: 97: Bad indentation. Found 7 spaces, expected 8
W0311: 98: Bad indentation. Found 7 spaces, expected 8
W0311: 99: Bad indentation. Found 7 spaces, expected 8
W0311:100: Bad indentation. Found 7 spaces, expected 8
W0311:101: Bad indentation. Found 11 spaces, expected 12
W0311:102: Bad indentation. Found 7 spaces, expected 8
W0311:104: Bad indentation. Found 3 spaces, expected 4
W0311:105: Bad indentation. Found 5 spaces, expected 8
W0311:109: Bad indentation. Found 3 spaces, expected 4
W0311:115: Bad indentation. Found 3 spaces, expected 4
W0311:116: Bad indentation. Found 6 spaces, expected 8
W0311:118: Bad indentation. Found 3 spaces, expected 4
W0311:119: Bad indentation. Found 6 spaces, expected 8
W0311:121: Bad indentation. Found 3 spaces, expected 4
W0311:122: Bad indentation. Found 7 spaces, expected 8
W0311:124: Bad indentation. Found 3 spaces, expected 4
W0311:125: Bad indentation. Found 7 spaces, expected 8
W0311:126: Bad indentation. Found 7 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 7 spaces, expected 8
W0311:130: Bad indentation. Found 7 spaces, expected 8
W0311:131: Bad indentation. Found 7 spaces, expected 8
W0311:132: Bad indentation. Found 7 spaces, expected 8
W0311:134: Bad indentation. Found 3 spaces, expected 4
W0311:135: Bad indentation. Found 7 spaces, expected 8
W0311:138: Bad indentation. Found 7 spaces, expected 8
W0311:143: Bad indentation. Found 7 spaces, expected 8
W0311:144: Bad indentation. Found 7 spaces, expected 8
W0311:145: Bad indentation. Found 7 spaces, expected 8
W0311:146: Bad indentation. Found 10 spaces, expected 12
W0311:147: Bad indentation. Found 10 spaces, expected 12
W0311:148: Bad indentation. Found 7 spaces, expected 8
W0311:149: Bad indentation. Found 7 spaces, expected 8
W0311:151: Bad indentation. Found 3 spaces, expected 4
W0311:152: Bad indentation. Found 7 spaces, expected 8
W0311:153: Bad indentation. Found 11 spaces, expected 12
W0311:155: Bad indentation. Found 3 spaces, expected 4
W0311:156: Bad indentation. Found 6 spaces, expected 8
W0311:157: Bad indentation. Found 9 spaces, expected 12
W0311:158: Bad indentation. Found 9 spaces, expected 12
W0311:159: Bad indentation. Found 9 spaces, expected 12
W0311:160: Bad indentation. Found 6 spaces, expected 8
W0311:161: Bad indentation. Found 9 spaces, expected 12
W0311:163: Bad indentation. Found 3 spaces, expected 4
W0311:164: Bad indentation. Found 7 spaces, expected 8
W0311:170: Bad indentation. Found 3 spaces, expected 4
W0311:171: Bad indentation. Found 7 spaces, expected 8
W0311:173: Bad indentation. Found 3 spaces, expected 4
W0311:174: Bad indentation. Found 7 spaces, expected 8
W0311:176: Bad indentation. Found 3 spaces, expected 4
W0311:177: Bad indentation. Found 7 spaces, expected 8
W0311:179: Bad indentation. Found 3 spaces, expected 4
W0311:180: Bad indentation. Found 7 spaces, expected 8
W0311:184: Bad indentation. Found 3 spaces, expected 4
W0311:194: Bad indentation. Found 3 spaces, expected 4
W0311:195: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 3 spaces, expected 4
W0311:200: Bad indentation. Found 7 spaces, expected 8
W0311:201: Bad indentation. Found 7 spaces, expected 8
W0311:202: Bad indentation. Found 7 spaces, expected 8
W0311:203: Bad indentation. Found 7 spaces, expected 8
W0311:204: Bad indentation. Found 7 spaces, expected 8
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 3 spaces, expected 4
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 7 spaces, expected 8
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:216: Bad indentation. Found 3 spaces, expected 4
W0311:217: Bad indentation. Found 7 spaces, expected 8
W0311:219: Bad indentation. Found 3 spaces, expected 4
W0311:220: Bad indentation. Found 6 spaces, expected 8
W0311:221: Bad indentation. Found 6 spaces, expected 8
W0311:222: Bad indentation. Found 9 spaces, expected 12
W0311:227: Bad indentation. Found 9 spaces, expected 12
W0311:228: Bad indentation. Found 9 spaces, expected 12
W0311:229: Bad indentation. Found 12 spaces, expected 16
W0311:230: Bad indentation. Found 12 spaces, expected 16
W0311:231: Bad indentation. Found 12 spaces, expected 16
W0311:232: Bad indentation. Found 12 spaces, expected 16
W0311:233: Bad indentation. Found 15 spaces, expected 20
W0311:234: Bad indentation. Found 12 spaces, expected 16
W0311:235: Bad indentation. Found 12 spaces, expected 16
W0311:236: Bad indentation. Found 9 spaces, expected 12
W0311:237: Bad indentation. Found 9 spaces, expected 12
W0311:238: Bad indentation. Found 9 spaces, expected 12
W0311:239: Bad indentation. Found 9 spaces, expected 12
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:241: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 9 spaces, expected 12
W0311:243: Bad indentation. Found 9 spaces, expected 12
W0311:245: Bad indentation. Found 3 spaces, expected 4
W0311:246: Bad indentation. Found 6 spaces, expected 8
W0311:247: Bad indentation. Found 6 spaces, expected 8
W0311:248: Bad indentation. Found 9 spaces, expected 12
W0311:250: Bad indentation. Found 3 spaces, expected 4
W0311:251: Bad indentation. Found 7 spaces, expected 8
W0311:253: Bad indentation. Found 3 spaces, expected 4
W0311:254: Bad indentation. Found 7 spaces, expected 8
W0311:256: Bad indentation. Found 3 spaces, expected 4
W0311:257: Bad indentation. Found 7 spaces, expected 8
W0311:259: Bad indentation. Found 3 spaces, expected 4
W0311:260: Bad indentation. Found 7 spaces, expected 8
W0311:263: Bad indentation. Found 3 spaces, expected 4
W0311:264: Bad indentation. Found 7 spaces, expected 8
W0311:266: Bad indentation. Found 3 spaces, expected 4
W0311:267: Bad indentation. Found 6 spaces, expected 8
W0311:271: Bad indentation. Found 3 spaces, expected 4
W0311:286: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 3 spaces, expected 4
W0311:291: Bad indentation. Found 6 spaces, expected 8
W0311:296: Bad indentation. Found 3 spaces, expected 4
W0311:297: Bad indentation. Found 6 spaces, expected 8
W0601:146:leo_file.gen1: Global variable 'vnode_count' undefined at the module level
W0601:157:leo_file.gen_vnodes: Global variable 'allvnodes' undefined at the module level
W0601:157:leo_file.gen_vnodes: Global variable 'vnode_stack' undefined at the module level
W0105:226:leo_node.gen_vnodes: String statement has no effect
W0601:236:leo_node.gen_vnodes: Global variable 'vnode_count' undefined at the module level

************* Module leo.plugins.leo_pdf
E0602:322:Bunch.__setitem__: Undefined variable 'operator'
E0602:326:Bunch.__getitem__: Undefined variable 'operator'
W0105:344:Writer: String statement has no effect
W0105:372:Writer: String statement has no effect

************* Module leo.plugins.leoOPML
E1101:211:opmlFileCommandsClass.putOPMLHeader: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_globals_attributes' member
E1101:245:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_details' member
E1101:261:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_body_text' member
E1101:262:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_use_outline_elements' member
E1101:334:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_write_ua_attributes' member
E1101:336:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_expand_ua_dictionary' member
E1101:338:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_skip_ua_dictionary_blanks' member
E1101:430:opmlController.createVnode: Module 'leo.core.leoNodes' has no 'tnode' member
E1101:434:opmlController.createVnode: Instance of 'vnode' has no 't' member
W0221:778:contentHandler.ignorableWhitespace: Arguments number differs from overridden method

************* Module leo.plugins.leoremote
W0611: 41: Unused import sys

************* Module leo.plugins.lineNumbers
E1121: 51:init.putLineNumberDirective: Too many positional arguments for function call

************* Module leo.plugins.macros
E1103:135:paramClass.parameterize: Instance of 'unitTestGui' has no 'getInsertPoint' member (but some types could not be inferred)
E1103:135:paramClass.parameterize: Instance of 'nullGui' has no 'getInsertPoint' member (but some types could not be inferred)

************* Module leo.plugins.mod_autosave
W0311: 86: Bad indentation. Found 9 spaces, expected 8
W0611: 25: Unused import os

************* Module leo.plugins.mod_leo2ascd
E1120:143:GetAscFilename: No value passed for parameter 'vnode' in function call
E1120:358:WriteTreeOfCurrentNode: No value passed for parameter 'vnode' in function call
E1120:373:WriteAll: No value passed for parameter 'vnode' in function call
E1120:433: No value passed for parameter 'c' in function call

************* Module leo.plugins.mod_speedups
W0611: 27: Unused import leoPlugins
W0611: 46: Unused import leo

************* Module leo.plugins.nav_buttons
W0311:319: Bad indentation. Found 11 spaces, expected 12

************* Module leo.plugins.nodeActions
W0312:252: Found indentation with tabs instead of spaces
W0312:253: Found indentation with tabs instead of spaces
W0312:254: Found indentation with tabs instead of spaces
W0312:255: Found indentation with tabs instead of spaces
W0312:256: Found indentation with tabs instead of spaces
W0312:257: Found indentation with tabs instead of spaces
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:270: Bad indentation. Found 3 spaces, expected 4
W0311:272: Bad indentation. Found 3 spaces, expected 4
W0311:273: Bad indentation. Found 6 spaces, expected 8
W0311:276: Bad indentation. Found 3 spaces, expected 4
W0311:277: Bad indentation. Found 3 spaces, expected 4
W0311:278: Bad indentation. Found 6 spaces, expected 8
W0311:281: Bad indentation. Found 3 spaces, expected 4
W0311:282: Bad indentation. Found 3 spaces, expected 4
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:285: Bad indentation. Found 3 spaces, expected 4
W0311:287: Bad indentation. Found 6 spaces, expected 8
W0311:288: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:293: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 12 spaces, expected 16
W0311:297: Bad indentation. Found 9 spaces, expected 12
W0311:298: Bad indentation. Found 12 spaces, expected 16
W0311:300: Bad indentation. Found 9 spaces, expected 12
W0311:301: Bad indentation. Found 9 spaces, expected 12
W0311:302: Bad indentation. Found 12 spaces, expected 16
W0311:305: Bad indentation. Found 9 spaces, expected 12
W0311:306: Bad indentation. Found 9 spaces, expected 12
W0311:307: Bad indentation. Found 12 spaces, expected 16
W0311:308: Bad indentation. Found 9 spaces, expected 12
W0311:309: Bad indentation. Found 12 spaces, expected 16
W0311:311: Bad indentation. Found 9 spaces, expected 12
W0311:312: Bad indentation. Found 9 spaces, expected 12
W0311:313: Bad indentation. Found 9 spaces, expected 12
W0311:314: Bad indentation. Found 12 spaces, expected 16
W0311:316: Bad indentation. Found 9 spaces, expected 12
W0311:317: Bad indentation. Found 9 spaces, expected 12
W0311:318: Bad indentation. Found 12 spaces, expected 16
W0311:322: Bad indentation. Found 9 spaces, expected 12
W0311:326: Bad indentation. Found 9 spaces, expected 12
W0311:327: Bad indentation. Found 9 spaces, expected 12
W0311:328: Bad indentation. Found 9 spaces, expected 12
W0311:330: Bad indentation. Found 12 spaces, expected 16
W0311:331: Bad indentation. Found 12 spaces, expected 16
W0311:332: Bad indentation. Found 15 spaces, expected 20
W0311:334: Bad indentation. Found 15 spaces, expected 20
W0311:335: Bad indentation. Found 15 spaces, expected 20
W0311:336: Bad indentation. Found 18 spaces, expected 24
W0311:340: Bad indentation. Found 9 spaces, expected 12
W0311:341: Bad indentation. Found 12 spaces, expected 16
W0311:342: Bad indentation. Found 9 spaces, expected 12
W0311:343: Bad indentation. Found 12 spaces, expected 16
W0311:344: Bad indentation. Found 9 spaces, expected 12
W0311:345: Bad indentation. Found 12 spaces, expected 16
W0311:346: Bad indentation. Found 15 spaces, expected 20
W0311:347: Bad indentation. Found 12 spaces, expected 16
W0311:348: Bad indentation. Found 15 spaces, expected 20
W0311:351: Bad indentation. Found 12 spaces, expected 16
W0311:352: Bad indentation. Found 15 spaces, expected 20
W0311:354: Bad indentation. Found 18 spaces, expected 24
W0311:355: Bad indentation. Found 18 spaces, expected 24
W0311:356: Bad indentation. Found 18 spaces, expected 24
W0311:357: Bad indentation. Found 18 spaces, expected 24
W0311:358: Bad indentation. Found 21 spaces, expected 28
W0311:360: Bad indentation. Found 12 spaces, expected 16
W0311:362: Bad indentation. Found 12 spaces, expected 16
W0311:364: Bad indentation. Found 12 spaces, expected 16
W0311:365: Bad indentation. Found 15 spaces, expected 20
W0311:366: Bad indentation. Found 9 spaces, expected 12
W0311:367: Bad indentation. Found 12 spaces, expected 16
W0311:368: Bad indentation. Found 15 spaces, expected 20
W0311:371: Bad indentation. Found 6 spaces, expected 8
W0311:373: Bad indentation. Found 9 spaces, expected 12
W0311:374: Bad indentation. Found 12 spaces, expected 16
W0311:375: Bad indentation. Found 9 spaces, expected 12
W0311:376: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 9 spaces, expected 12
W0311:379: Bad indentation. Found 12 spaces, expected 16
W0311:380: Bad indentation. Found 9 spaces, expected 12
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 9 spaces, expected 12
W0311:384: Bad indentation. Found 12 spaces, expected 16
W0311:385: Bad indentation. Found 9 spaces, expected 12
W0311:386: Bad indentation. Found 3 spaces, expected 4
W0311:388: Bad indentation. Found 6 spaces, expected 8
W0311:389: Bad indentation. Found 9 spaces, expected 12
W0311:390: Bad indentation. Found 6 spaces, expected 8
W0311:394: Bad indentation. Found 3 spaces, expected 4
W0311:395: Bad indentation. Found 3 spaces, expected 4
W0311:396: Bad indentation. Found 7 spaces, expected 8
W0311:397: Bad indentation. Found 7 spaces, expected 8
W0311:398: Bad indentation. Found 7 spaces, expected 8
W0311:399: Bad indentation. Found 7 spaces, expected 8
W0311:401: Bad indentation. Found 7 spaces, expected 8
W0311:402: Bad indentation. Found 11 spaces, expected 12
W0311:403: Bad indentation. Found 11 spaces, expected 12
W0311:404: Bad indentation. Found 7 spaces, expected 8
W0311:405: Bad indentation. Found 11 spaces, expected 12
W0311:411: Bad indentation. Found 11 spaces, expected 12
W0311:413: Bad indentation. Found 11 spaces, expected 12
W0311:414: Bad indentation. Found 15 spaces, expected 16
W0311:415: Bad indentation. Found 15 spaces, expected 16
W0311:416: Bad indentation. Found 7 spaces, expected 8
W0311:418: Bad indentation. Found 11 spaces, expected 12
W0311:419: Bad indentation. Found 15 spaces, expected 16
W0311:420: Bad indentation. Found 15 spaces, expected 16
W0311:421: Bad indentation. Found 11 spaces, expected 12
W0311:422: Bad indentation. Found 11 spaces, expected 12
W0311:424: Bad indentation. Found 7 spaces, expected 8

************* Module leo.plugins.nodebar
W0601:179:initImages: Global variable 'clonePI' undefined at the module level
W0601:180:initImages: Global variable 'copyPI' undefined at the module level
W0601:181:initImages: Global variable 'cutPI' undefined at the module level
W0601:182:initImages: Global variable 'dehoistPI' undefined at the module level
W0601:183:initImages: Global variable 'deletePI' undefined at the module level
W0601:184:initImages: Global variable 'demotePI' undefined at the module level
W0601:185:initImages: Global variable 'hoistPI' undefined at the module level
W0601:186:initImages: Global variable 'insertPI' undefined at the module level
W0601:187:initImages: Global variable 'movedownPI' undefined at the module level
W0601:188:initImages: Global variable 'moveleftPI' undefined at the module level
W0601:189:initImages: Global variable 'moverightPI' undefined at the module level
W0601:190:initImages: Global variable 'moveupPI' undefined at the module level
W0601:191:initImages: Global variable 'nodedownPI' undefined at the module level
W0601:192:initImages: Global variable 'nodeleftPI' undefined at the module level
W0601:193:initImages: Global variable 'noderightPI' undefined at the module level
W0601:194:initImages: Global variable 'nodeupPI' undefined at the module level
W0601:195:initImages: Global variable 'pastePI' undefined at the module level
W0601:196:initImages: Global variable 'pasteclonePI' undefined at the module level
W0601:197:initImages: Global variable 'promotePI' undefined at the module level
W0601:198:initImages: Global variable 'questionPI' undefined at the module level
W0601:199:initImages: Global variable 'sortchildrenPI' undefined at the module level
W0601:200:initImages: Global variable 'sortsiblingsPI' undefined at the module level
W0611: 26: Unused import weakref

************* Module leo.plugins.pretty_print
W0233: 54:myPrettyPrinter.__init__: __init__ method from a non direct base class 'myPrettyPrinter' is called
E0602: 64:myPrettyPrinter.putNormalToken: Undefined variable 'token'
E0602:190:myPrettyPrinter.doOp: Undefined variable 'keyword'
E0602:225:myPrettyPrinter.doOp: Undefined variable 'string'
E0602:225:myPrettyPrinter.doOp: Undefined variable 'string'

************* Module leo.plugins.quickMove
W0311:219: Bad indentation. Found 16 spaces, expected 12
W0311:224: Bad indentation. Found 16 spaces, expected 12
W0611:105: Unused import types

************* Module leo.plugins.quicksearch
W0301:222: Unnecessary semicolon
W0301:240: Unnecessary semicolon
W0604: 73: Using the global statement at the module level
W0611: 42: Unused import QListWidget

************* Module leo.plugins.rClickBasePluginClasses
E1101:134:pluginCommandClass.preDoCommand: Instance of 'pluginCommandClass' has no 'doCommand' member
E1101:260:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandList' member
E1101:267:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:272:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:310:basePluginController.getCommandList: Instance of 'basePluginController' has no 'commandList' member
E1101:318:basePluginController.setDefaultContextMenus: Instance of 'basePluginController' has no 'defaultContextMenus' member

************* Module leo.plugins.run_nodes
E1120:211:OnQuit: No value passed for parameter 'c' in function call

************* Module leo.plugins.rst3
E1120:264:runUnitTests: No value passed for parameter 'headline' in function call
E1120:1018:rstClass.initOptionsFromSettings: No value passed for parameter 'tag' in function call

************* Module leo.plugins.scrolledmessage
W0311:402: Bad indentation. Found 12 spaces, expected 8
W0311:403: Bad indentation. Found 12 spaces, expected 8
E1101:284:ScrolledMessageDialog.doActionOutlineShow: Instance of 'ScrolledMessageDialog' has no 'name' member
W0107:309:ScrolledMessageDialog.doActionAbout: Unnecessary pass statement
E1101:526:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:527:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:533:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'title' member
E0211:537:ScrolledMessageDialog.afterDrawHandler: Method has no argument
E0602:607:ScrolledMessageController.afterRedrawHandler: Undefined variable 'dialogs'
E1120:608:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'tag' in function call
E1120:608:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'keywords' in function call
W0611: 86: Unused import inspect

************* Module leo.plugins.todo
E0102:258:todoController.addPopupMenu.func: function already defined line 249
E0213:305:todoController.redrawer: Method should have "self" as first argument
E1102:310:todoController.redrawer.new: fn is not callable
E0213:320:todoController.projectChanger: Method should have "self" as first argument
E1102:323:todoController.projectChanger.new: fn is not callable

************* Module leo.external.ipy_leo
W0601: 30:init_ipython: Global variable 'ip' undefined at the module level
W0107: 90:es: Unnecessary pass statement
W0108:231:LeoNode.<lambda>: Lambda may not be necessary
W1001:398:LeoWorkbook: Use of "property" on an old style class
E1101:438:workbook_complete: Function 'dispatch' has no 'when_type' member
E1101:438:workbook_complete: Function 'complete_object' has no 'when_type' member
E1101:589:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
W0601:749:lleo_f: Global variable '_request_immediate_connect' undefined at the module level

************* Module leo.external.lproto
E1101:137:LProtoClient.__init__: Module 'socket' has no 'AF_UNIX' member

************* Module leo.plugins.toolbar
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types coul
d not be inferred)
E1103:463:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types co
uld not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some
types could not be inferred)
E1103:538:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but som
e types could not be inferred)
E1103:1336:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure'
 member (but some types could not be inferred)
#@+node:ekr.20101028131948.5858: *3* Pylint errors for minor plugins
@killcolor

************* Module leo.plugins.geotag
E1101: 64:geotag_Controller.__del__: Instance of 'geotag_Controller' has no 'handlers' member


************* Module leo.plugins.graphed
W0511:366: FIXME
W0511:377: FIXME no handlers?


************* Module leo.plugins.groupOperations
E0602: 77:init: Undefined variable 'sets'
W0601:192:initImages: Global variable 'groupOpPI' undefined at the module level
W0601:193:initImages: Global variable 'bullseyePI' undefined at the module level
W0601:194:initImages: Global variable 'copyPI' undefined at the module level
W0601:195:initImages: Global variable 'clonePI' undefined at the module level
W0601:196:initImages: Global variable 'movePI' undefined at the module level
W0601:197:initImages: Global variable 'move_arrowPI' undefined at the module level
W0601:198:initImages: Global variable 'copy_arrowPI' undefined at the module level
W0601:199:initImages: Global variable 'clone_arrowPI' undefined at the module level
W0601:200:initImages: Global variable 'markSpotPI' undefined at the module level
W0601:201:initImages: Global variable 'markForPI' undefined at the module level
W0601:202:initImages: Global variable 'operateOnMarkedPI' undefined at the module level
W0601:203:initImages: Global variable 'clearMarksPI' undefined at the module level
W0601:204:initImages: Global variable 'transferFromPI' undefined at the module level
W0611: 31: Unused import copy
W0611: 32: Unused import base64


************* Module leo.plugins.leoupdate
W0105: 61: String statement has no effect
E0602: 72:init: Undefined variable 'sets'
W0601: 96:onCreate: Global variable 'thePluginController' undefined at the module level
W0601:103:topLevelMenu: Global variable 'thePluginController' undefined at the module level
E1101:143:LeoUpdater.showManagerDialog.HandlerDialog.initLocalCollection: Instance of 'HandlerDialog' has no 'c' member
E1101:161:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:162:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:166:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
E1101:170:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:171:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'plugin_list' member
E1101:173:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'remote_plugin_list' member
E1101:174:LeoUpdater.showManagerDialog.HandlerDialog.installPlugin: Instance of 'HandlerDialog' has no 'messagebar' member
W0611: 30: Unused import glob
W0611: 29: Unused import sys
W0611: 28: Unused import re


************* Module leo.plugins.mod_labels
W0311:118: Bad indentation. Found 3 spaces, expected 4
W0311:119: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 6 spaces, expected 8
W0311:128: Bad indentation. Found 3 spaces, expected 4
W0311:129: Bad indentation. Found 6 spaces, expected 8
W0311:133: Bad indentation. Found 3 spaces, expected 4
W0311:134: Bad indentation. Found 6 spaces, expected 8
W0311:135: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 6 spaces, expected 8
W0311:142: Bad indentation. Found 3 spaces, expected 4
W0311:143: Bad indentation. Found 6 spaces, expected 8
W0311:206: Bad indentation. Found 20 spaces, expected 16
W0311:207: Bad indentation. Found 20 spaces, expected 16
W0311:208: Bad indentation. Found 20 spaces, expected 16
W0311:209: Bad indentation. Found 28 spaces, expected 20
W0311:210: Bad indentation. Found 20 spaces, expected 16
W0311:212: Bad indentation. Found 20 spaces, expected 16
W0311:226: Bad indentation. Found 20 spaces, expected 16
W0311:228: Bad indentation. Found 20 spaces, expected 16
W0311:236: Bad indentation. Found 20 spaces, expected 16
E1123:542:labelsController.label_to_subnode: Passing unexpected keyword argument 'p' in function call
E1120:542:labelsController.label_to_subnode: No value passed for parameter 'v' in function call
E1101:571:labelsController.subnode_to_label: Instance of 'labelsController' has no 'get_labellist_for_node' member
E0602:579:labelsController.subnode_to_label: Undefined variable 'v'
E0602:605:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:606:labelsController.subnode_to_label: Undefined variable 'v'
E0602:606:labelsController.subnode_to_label: Undefined variable 'labels'
E0602:611:labelsController.subnode_to_label: Undefined variable 'v'
E1120:623:labelsController.subnodes_to_label: No value passed for parameter 'title' in function call
E0602:673:labelsController.subnodes_to_labels: Undefined variable 'v'
W0611: 39: Unused import leoAtFile
W0611: 40: Unused import leoCommands
W0611: 53: Unused import os


************* Module leo.plugins.newButtons
E1101:249:UIHelperClass.addWidgets: Instance of 'FlatOptionMenu' has no 'pack' member
E1111:362:HelperForm.formCommit: Assigning to function call which doesn't return


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.pie_menus
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E1101:104:PieMenu.drawString: Instance of 'PieMenu' has no 'l4' member
E0602:134:PieMenu.construct: Undefined variable 'l1'
E0602:138:PieMenu.construct: Undefined variable 'l1'
E0602:142:PieMenu.construct: Undefined variable 'l1'
E0602:147:PieMenu.construct: Undefined variable 'l1'
E0602:151:PieMenu.construct: Undefined variable 'l1'
E0602:166:PieMenu.construct: Undefined variable 'l1'
E0602:179:PieMenu.construct: Undefined variable 'l3'
E0602:185:PieMenu.construct: Undefined variable 'l3'
E0602:192:PieMenu.construct: Undefined variable 'l3'
E0602:200:PieMenu.construct: Undefined variable 'l2'
E0602:206:PieMenu.construct: Undefined variable 'l2'
E0602:212:PieMenu.construct: Undefined variable 'l2'
E0602:219:PieMenu.construct: Undefined variable 'l2'
E0602:225:PieMenu.construct: Undefined variable 'l2'
E0602:233:PieMenu.construct: Undefined variable 'l4'
E0602:239:PieMenu.construct: Undefined variable 'l4'
E0602:246:PieMenu.construct: Undefined variable 'l4'
E0602:254:PieMenu.construct: Undefined variable 'l5'
E0602:262:PieMenu.construct: Undefined variable 'l6'
E0602:270:PieMenu.construct: Undefined variable 'l7'
E0602:276:PieMenu.construct: Undefined variable 'l7'
E0602:282:PieMenu.construct: Undefined variable 'l7'
E1101:381:PieMenu.clean: Instance of 'PieMenu' has no 'l1' member
E1101:382:PieMenu.clean: Instance of 'PieMenu' has no 'l2' member
E1101:383:PieMenu.clean: Instance of 'PieMenu' has no 'l3' member
E1101:384:PieMenu.clean: Instance of 'PieMenu' has no 'l4' member
E1101:385:PieMenu.clean: Instance of 'PieMenu' has no 'l5' member
E1101:386:PieMenu.clean: Instance of 'PieMenu' has no 'l6' member
E1101:387:PieMenu.clean: Instance of 'PieMenu' has no 'l7' member
E1101:433:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:434:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:435:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:436:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:437:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:438:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:439:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member
E1101:440:PieMenu.draw: Instance of 'PieMenu' has no 'l1' member
E1101:441:PieMenu.draw: Instance of 'PieMenu' has no 'l3' member
E1101:442:PieMenu.draw: Instance of 'PieMenu' has no 'l2' member
E1101:443:PieMenu.draw: Instance of 'PieMenu' has no 'l4' member
E1101:444:PieMenu.draw: Instance of 'PieMenu' has no 'l5' member
E1101:445:PieMenu.draw: Instance of 'PieMenu' has no 'l6' member
E1101:446:PieMenu.draw: Instance of 'PieMenu' has no 'l7' member


************* Module leo.plugins.read_only_nodes
E0611: 73: No name 'parse' in module 'urllib'
E0602:201:FTPurl.read: Undefined variable 'sys'
E0602:235:FTPurl.write: Undefined variable 'sys'
E0213:239:FTPurl.seek: Method should have "self" as first argument
E0602:240:FTPurl.seek: Undefined variable 'self'
E0211:242:FTPurl.flush: Method has no argument
E0602:256:FTPurl.dir: Undefined variable 'sys'
W0601:290:enable_body: Global variable 'insertOnTime' undefined at the module level
W0601:290:enable_body: Global variable 'insertOffTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOnTime' undefined at the module level
W0601:300:disable_body: Global variable 'insertOffTime' undefined at the module level


************* Module leo.plugins.rClick
W0511:633: TODO:
E1101:958:pluginController.getButtonHandlers: Instance of 'pluginController' has no 'button_handlers' member
E1101:1587:pluginController.findButtonCommandClass.doCommand: Instance of 'findButtonCommandClass' has no 'data' member
W0611:662: Unused import ImageTk
W0611:661: Unused import Image


************* Module leo.plugins.searchbar
W0311:100: Bad indentation. Found 9 spaces, expected 8
W0107:125:onPreCreate: Unnecessary pass statement
E1101:205:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'bg' member
E1101:211:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'labelText' member
E1101:213:SearchbarEntryWidget.__init__: Instance of 'SearchbarEntryWidget' has no 'command' member
E1103:216:SearchbarEntryWidget.__init__: Instance of 'stringTextWidget' has no 'pack' member (but some types could not be inferred)
E1101:270:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:275:SearchbarEntryWidget.detachWidget: Instance of 'SearchbarEntryWidget' has no 'leoIconBar' member
E1101:299:SearchbarEntryWidget.onTextChanged: Instance of 'SearchbarEntryWidget' has no 'slave' member
E1101:309:SearchbarEntryWidget.onRightClick: Instance of 'SearchbarEntryWidget' has no 'entry_menu' member
E1101:316:SearchbarEntryWidget.onReturn: Instance of 'SearchbarEntryWidget' has no 'command' member
W0107:460:pluginController.toggleSearchbarCommandClass.doCommand: Unnecessary pass statement
W0611: 48: Unused import sys
W0611: 56: Unused import ImageTk
W0611: 55: Unused import Image
W0611: 47: Unused import re
W0611: 49: Unused import os


************* Module leo.plugins.searchbox
E1101:245:QuickFind.__init__: Class 'leoTkinterFrame' has no 'leoTkTextWidget' member
E1103:280:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)
E1103:282:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'toGuiIndex' member (but some types could not be inferred)
E1103:283:QuickFind.init_s_ctrl: Instance of 'searchWidget' has no 'mark_set' member (but some types could not be inferred)


************* Module leo.plugins.templates
W0601:100:initImages: Global variable 'templatePI' undefined at the module level
W0601:101:initImages: Global variable 'tempwizPI' undefined at the module level
E0602:210:getTemplateDialog: Undefined variable 'bs'
E0602:211:getTemplateDialog: Undefined variable 'hs'


************* Module leo.plugins.toolbar
W0511:749: FIXME:
W0511:829: TODO: not ready yet
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
W0221:491:ToolbarTkinterFrame.addIconWidget: Arguments number differs from overridden method
W0221:499:ToolbarTkinterFrame.clearIconBar: Arguments number differs from overridden method
E1101:503:ToolbarTkinterFrame.clearIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:505:ToolbarTkinterFrame.createIconBar: Arguments number differs from overridden method
E1101:519:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:525:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1101:528:ToolbarTkinterFrame.createIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
W0221:540:ToolbarTkinterFrame.hideIconBar: Arguments number differs from overridden method
E1101:544:ToolbarTkinterFrame.hideIconBar: Instance of 'ToolbarTkinterFrame' has no 'iconBars' member
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1101:580:ToolbarTkinterFrame.getToolbarFrame: Instance of 'ToolbarTkinterFrame' has no 'toolBar' member
E1101:643:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:648:ToolbarIconWidgetFrame.detachWidget: Instance of 'ToolbarIconWidgetFrame' has no 'leoIconBar' member
E1101:858:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:863:ToolbarIconButton.detachWidget: Instance of 'ToolbarIconButton' has no 'leoIconBar' member
E1101:995:ToolbarIconButton.setCommand: Instance of 'ToolbarIconButton' has no 'config' member
E1101:1031:ToolbarScriptButton.__init__.<lambda>: Instance of 'ToolbarScriptButton' has no 'invoke' member
W0221:1253:ToolbarScriptingController.executeScriptFromButton: Arguments number differs from overridden method
W0221:1338:ToolbarScriptingController.createScriptButtonIconButton: Arguments number differs from overridden method
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)
W0221:1362:ToolbarScriptingController.addScriptButtonCommand: Arguments number differs from overridden method
W0221:1840:ToolbarTkIconBarClass.addWidget: Arguments number differs from overridden method
W0221:2016:ToolbarTkIconBarClass.pack: Arguments number differs from overridden method


============ xcc
W0312:233: Found indentation with tabs instead of spaces
W0312:406: Found indentation with tabs instead of spaces
W0312:408: Found indentation with tabs instead of spaces
W0312:409: Found indentation with tabs instead of spaces
W0312:410: Found indentation with tabs instead of spaces
W0312:412: Found indentation with tabs instead of spaces
W0312:413: Found indentation with tabs instead of spaces
W0312:417: Found indentation with tabs instead of spaces
W0312:418: Found indentation with tabs instead of spaces
W0312:423: Found indentation with tabs instead of spaces
W0312:424: Found indentation with tabs instead of spaces
W0312:425: Found indentation with tabs instead of spaces
W0312:469: Found indentation with tabs instead of spaces
W0312:471: Found indentation with tabs instead of spaces
W0312:473: Found indentation with tabs instead of spaces
W0312:474: Found indentation with tabs instead of spaces
W0312:475: Found indentation with tabs instead of spaces
W0312:478: Found indentation with tabs instead of spaces
W0312:479: Found indentation with tabs instead of spaces
W0312:494: Found indentation with tabs instead of spaces
W0312:495: Found indentation with tabs instead of spaces
W0312:496: Found indentation with tabs instead of spaces
W0312:498: Found indentation with tabs instead of spaces
W0312:499: Found indentation with tabs instead of spaces
W0312:503: Found indentation with tabs instead of spaces
W0312:504: Found indentation with tabs instead of spaces
W0312:505: Found indentation with tabs instead of spaces
W0312:506: Found indentation with tabs instead of spaces
W0312:507: Found indentation with tabs instead of spaces
W0312:508: Found indentation with tabs instead of spaces
W0312:512: Found indentation with tabs instead of spaces
W0312:513: Found indentation with tabs instead of spaces
W0312:514: Found indentation with tabs instead of spaces
W0312:515: Found indentation with tabs instead of spaces
W0312:517: Found indentation with tabs instead of spaces
W0312:521: Found indentation with tabs instead of spaces
W0312:525: Found indentation with tabs instead of spaces
W0312:526: Found indentation with tabs instead of spaces
W0312:527: Found indentation with tabs instead of spaces
W0312:528: Found indentation with tabs instead of spaces
W0312:532: Found indentation with tabs instead of spaces
W0312:533: Found indentation with tabs instead of spaces
W0312:536: Found indentation with tabs instead of spaces
W0312:537: Found indentation with tabs instead of spaces
W0312:538: Found indentation with tabs instead of spaces
W0312:539: Found indentation with tabs instead of spaces
W0312:540: Found indentation with tabs instead of spaces
W0312:542: Found indentation with tabs instead of spaces
W0312:556: Found indentation with tabs instead of spaces
W0312:557: Found indentation with tabs instead of spaces
W0511:169: XXX to XxxClass.
W0511:521: TODO: ","Add import code in ImportFiles function!")
W0511:3342: TODO: Support precompiled header auto creation/inclusion."""
W0511:3663: TODO: send a WATCHTASK if breaked
E0602:339:OnStart2: Undefined variable 'XCC_INITED'
E0602:341:OnStart2: Undefined variable 'InitXcc'
E1101:418:linPause: Module 'os' has no 'kill' member
E0601:423:AddText: Using variable 'c' before assignment
E0602:424:AddText: Undefined variable 'LeoBody'
E0602:425:AddText: Undefined variable 'LeoBody'
E0602:474:DecompressIcon: Undefined variable 'Excetion'
E0602:475:DecompressIcon: Undefined variable 'Traceback'
E0602:536:ReplaceVars: Undefined variable 'NAME'
E0602:537:ReplaceVars: Undefined variable 'EXT'
E0602:538:ReplaceVars: Undefined variable 'ABS_PATH'
E0602:539:ReplaceVars: Undefined variable 'REL_PATH'
E0602:540:ReplaceVars: Undefined variable 'SRC_EXT'
E1121:677:controllerClass.onIdle: Too many positional arguments for function call
E1121:730:controllerClass.onQuit: Too many positional arguments for function call
E0211:816:controllerClass.UpdateProcess: Method has no argument
E0601:818:controllerClass.UpdateProcess: Using variable 'cc' before assignment
E0602:820:controllerClass.UpdateProcess: Undefined variable 'self'
E0211:995:controllerClass.sGetExecInfo: Method has no argument
E0602:997:controllerClass.sGetExecInfo: Undefined variable 'self'
E0602:1023:controllerClass.sGoToError: Undefined variable 'CPL'
E1101:1181:controllerClass.sSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1181:controllerClass.sSetText: Undefined variable 'SELECTED_NODE'
E1101:1187:controllerClass.sAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1187:controllerClass.sAddText: Undefined variable 'SELECTED_NODE'
E1120:1252:controllerClass.aStop: No value passed for parameter 'pid' in function call
E0602:1268:controllerClass.aStepIn: Undefined variable 'DBG'
E0602:1283:controllerClass.aStepOver: Undefined variable 'DBG'
E0602:1298:controllerClass.aStepOut: Undefined variable 'DBG'
E1120:1311:controllerClass.aPause: No value passed for parameter 'pid' in function call
E1101:1345:controllerClass.aSetText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1345:controllerClass.aSetText: Undefined variable 'ACTIVE_NODE'
E1101:1351:controllerClass.aAddText: Instance of 'controllerClass' has no 'ACTIVE_NOD' member
E1101:1352:controllerClass.aAddText: Instance of 'controllerClass' has no 'setBodyText' member
E0602:1355:controllerClass.aAddText: Undefined variable 'LeoBodyText'
E1101:1382:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessClass' member
E1101:1389:controllerClass.Compile: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1404:controllerClass.CplCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E0602:1443:controllerClass.CplCmd: Undefined variable 'CPL'
E1101:1460:controllerClass.Debug: Instance of 'controllerClass' has no 'GetDebugInfo' member
E1101:1469:controllerClass.Debug: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1476:controllerClass.DbgCmd: Instance of 'controllerClass' has no 'ReplaceVars' member
E1121:1486:controllerClass.Execute: Too many positional arguments for function call
E1101:1498:controllerClass.Execute: Instance of 'controllerClass' has no 'ProcessList' member
E1101:1510:controllerClass.CplStart: Instance of 'controllerClass' has no 'VProcessList' member
E1101:1590:controllerClass.DbgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1610:controllerClass.DbgStart: Undefined variable 'DBG'
E0602:1617:controllerClass.DbgStart: Undefined variable 'DBG'
E0213:1619:controllerClass.DbgOut: Method should have "self" as first argument
E0602:1623:controllerClass.DbgOut: Undefined variable 'self'
E0602:1628:controllerClass.DbgOut: Undefined variable 'OutBuff'
E1101:1707:controllerClass.ProgStart: Instance of 'controllerClass' has no 'ProcessList' member
E0602:1722:controllerClass.ProgOut: Undefined variable 'ExtractLines'
E0602:1722:controllerClass.ProgOut: Undefined variable 'OutBuff'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ExtractLines'
E0602:1739:controllerClass.ProgErr: Undefined variable 'ErrBuff'
E0602:1775:DBGTASK.__init__: Undefined variable 'DBG_SD'
E0602:1777:DBGTASK.__init__: Undefined variable 'DBG_SD'
E1101:1783:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'aWrite' member
E1101:1784:DBGTASK.Send: Instance of 'DBGTASK' has no 'Command' member
E1101:1785:DBGTASK.Send: Instance of 'DBGTASK' has no 'DBG_SD' member
E0602:1861:BREAKTASK.__init__: Undefined variable 'aGet'
E0602:1863:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1865:BREAKTASK.__init__: Undefined variable 'Waning'
E0602:1870:BREAKTASK.__init__: Undefined variable 'DBG'
E0602:1884:BREAKTASK.Send: Undefined variable 'NAME'
E0602:1885:BREAKTASK.Send: Undefined variable 'aWrite'
E0602:1887:BREAKTASK.Send: Undefined variable 'DBG_SD'
E0602:1888:BREAKTASK.Send: Undefined variable 'DBG_RD'
E0602:1900:BREAKTASK.Receive: Undefined variable 'aAddText'
E0602:1952:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1954:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1958:WATCHTASK.__init__: Undefined variable 'cc'
E0602:1959:WATCHTASK.__init__: Undefined variable 'ccWatcher'
E0602:1962:WATCHTASK.__init__: Undefined variable 'DBG_SD'
W0601:1972:WATCHTASK.Cancel: Global variable 'WATCH_TASK' undefined at the module level
E0602:1973:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1974:WATCHTASK.Cancel: Undefined variable 'DBG_SD'
E0602:1975:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1976:WATCHTASK.Cancel: Undefined variable 'DBG_RD'
E0602:1977:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1978:WATCHTASK.Cancel: Undefined variable 'PROMPT_RD'
E0602:1980:WATCHTASK.Cancel: Undefined variable 'Watcher'
E0602:1986:WATCHTASK.Send: Undefined variable 'Watcher'
E0602:1988:WATCHTASK.Send: Undefined variable 'aWrite'
E0602:1988:WATCHTASK.Send: Undefined variable 'DBG'
E0602:1989:WATCHTASK.Send: Undefined variable 'DBG_SD'
E0602:1990:WATCHTASK.Send: Undefined variable 'DBG_RD'
E0602:1991:WATCHTASK.Send: Undefined variable 'PROMPT_RD'
E0602:1996:WATCHTASK.Receive: Undefined variable 'DBG_PROMPT'
W0601:2000:WATCHTASK.OnPrompt: Global variable 'WATCH_TASK' undefined at the module level
E0602:2002:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2008:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2013:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2014:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2017:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2018:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2020:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2023:WATCHTASK.OnPrompt: Undefined variable 'DBG_SD'
E0602:2025:WATCHTASK.OnPrompt: Undefined variable 'Watcher'
E0602:2028:WATCHTASK.OnPrompt: Undefined variable 'PROMPT_RD'
E0602:2029:WATCHTASK.OnPrompt: Undefined variable 'DBG_RD'
E0602:2104:BREAKIDTASK.Send: Undefined variable 'aWrite'
E0602:2105:BREAKIDTASK.Send: Undefined variable 'DBG_SD'
E0602:2106:BREAKIDTASK.Send: Undefined variable 'DBG_RD'
E0602:2557:ConfigClass.CplPageClass.Browse: Undefined variable 'e'
E0602:2697:ConfigClass.DbgPageClass.Browse: Undefined variable 'e'
E0602:3538:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3539:ToolbarClass.SyncDisplayToError: Undefined variable 'BreakBar'
E0602:3544:ToolbarClass.SyncDisplayToError: Undefined variable 'INSERT'
E0602:3557:ToolbarClass.SyncDisplayToError: Undefined variable 'c'
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR' undefined at the module level
W0601:3561:ToolbarClass.SetError: Global variable 'PARSE_ERROR_NODE' undefined at the module level
E0602:3593:ToolbarClass.Refresh: Undefined variable 'ACTIVE_NODE'
E0602:3613:WatcherClass.__init__: Undefined variable 'c'
E0602:3634:WatcherClass.__init__: Undefined variable 'c'
E0602:3635:WatcherClass.__init__: Undefined variable 'c'
E0602:3636:WatcherClass.__init__: Undefined variable 'c'
E0602:3637:WatcherClass.__init__: Undefined variable 'c'
E0602:3687:WatcherClass.OnDelete: Undefined variable 'sGet'
W0221:3799:BreakbarClass.yview: Arguments number differs from overridden method
E0602:3849:BreakbarClass.OnCut: Undefined variable 'LeoFrame'
E0602:3853:BreakbarClass.OnPaste: Undefined variable 'LeoFrame'
E1101:3858:BreakbarClass.OnRightClick: Instance of 'BreakbarClass' has no 'c' member
E0602:3859:BreakbarClass.OnRightClick: Undefined variable 'Menu'
E0602:3876:BreakbarClass.OnLeftClick: Undefined variable 'cGet'
E0602:3878:BreakbarClass.OnLeftClick: Undefined variable 'CHILD_NODE'
E0602:3891:BreakbarClass.OnLeftClick: Undefined variable 'SEL'
E0602:3895:BreakbarClass.AddNodeBreak: Undefined variable 'cGet'
E0602:3898:BreakbarClass.DeleteNodeBreak: Undefined variable 'cGet'
E0602:3903:BreakbarClass.ClearNodeBreaks: Undefined variable 'cSet'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_EXT'
E0602:4013:BreakbarClass.BreaksFromTags: Undefined variable 'CHILD_LINE'
E0602:4019:BreakbarClass.AddBreak: Undefined variable 'sGet'
E0602:4060:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cGet'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_EXT'
E0602:4064:BreakbarClass.DeleteNodeBreaks: Undefined variable 'CHILD_LINE'
E1101:4066:BreakbarClass.DeleteNodeBreaks: Instance of 'BreakbarClass' has no 'DeleteDbgBreaks' member
E0602:4068:BreakbarClass.DeleteNodeBreaks: Undefined variable 'cSelect'
E0602:4360:CppParserClass.FUNCRULE.DeclareFunc: Undefined variable 'ToolBar'
E0602:4378:CppParserClass.FUNCRULE.DefineFunc: Undefined variable 'ToolBar'
E0602:4516:CppParserClass.CLASSRULE.OnMatch: Undefined variable 'ToolBar'
E1101:4706:CppParserClass.Docum: Instance of 'CppParserClass' has no 'CURRENT_DOC_LINE' member
E0602:4730:CppParserClass.SetRealBodyDestination: Undefined variable 'EXT'
E1101:4799:CppParserClass.CppParse: Instance of 'CppParserClass' has no 'cc' member
E1102:4826:CppParserClass.CppParse: self.OnStart is not callable
E0602:4833:CppParserClass.CppParse: Undefined variable 'NAME'
E1102:4839:CppParserClass.CppParse: self.OnEnd is not callable
E1101:4852:CppParserClass.ParseNode: Instance of 'CppParserClass' has no 'cc' member
E0602:4942:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'REL_PATH'
E0602:4943:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4945:WriterClass.OnWriteStart: Undefined variable 'NAME'
E0602:4948:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4949:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4953:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4954:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4959:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:4960:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4961:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4964:WriterClass.OnWriteStart: Undefined variable 'EXT'
E0602:4965:WriterClass.OnWriteStart: Undefined variable 'sAddText'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerSELECTED_NODE'
E0602:5011:BreakFinderClass.__init__: Undefined variable 'controllerEXT'
E0602:5027:BreakFinderClass.OnFindStart: Undefined variable 'sSet'
E0602:5028:BreakFinderClass.OnFindStart: Undefined variable 'sGet'
E0602:5034:BreakFinderClass.OnFindEnd: Undefined variable 'sSet'
E0602:5053:BreakFinderClass.BreakDef: Undefined variable 'SRC_EXT'
W0611:206: Unused import tkSimpleDialog
W0611:207: Unused import base64
W0611:203: Unused import beep


************* Module leo.plugins.active_path
W0108:122:attachToCommander.<lambda>: Lambda may not be necessary
E1101:397:openDir: Generator 'walk' has no 'next' member


************* Module leo.plugins.attrib_edit
W0311:817: Bad indentation. Found 3 spaces, expected 4
W0311:820: Bad indentation. Found 3 spaces, expected 4
W0311:823: Bad indentation. Found 3 spaces, expected 4
W0311:826: Bad indentation. Found 3 spaces, expected 4
W0311:829: Bad indentation. Found 3 spaces, expected 4
W0511:290: FIXME type_ = {True: '_view', False: '_edit'}[readonly]
W0511:305: FIXME self.attrPaths.add(tuple(ns))
E1101:666:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'recSearch' member
E1101:670:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
E1101:672:attrib_edit_Controller.JUNKrecSearch: Instance of 'attrib_edit_Controller' has no 'typeMap' member
W0611:119: Unused import os
W0611:116: Unused import re


************* Module leo.plugins.backlink
W0511: 21: TODO
E1101:143:backlinkTkUI.updateTkTab: Instance of 'backlinkTkUI' has no 'c' member
E1101:148:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:159:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:167:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnode' member
E1101:168:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'vnodePosition' member
E1101:169:backlinkTkUI.updateTkTabInt: Instance of 'backlinkTkUI' has no 'c' member
E1123:177:backlinkTkUI.updateTkTabInt: Passing unexpected keyword argument 'optional' in function call
E1101:184:backlinkTkUI.updateTkTabInt.delLink: Instance of 'backlinkTkUI' has no 'deleteLink' member
E1103:647:backlinkController.showMenu: Instance of 'unitTestGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:647:backlinkController.showMenu: Instance of 'nullGui' has no 'killPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'unitTestGui' has no 'postPopupMenu' member (but some types could not be inferred)
E1103:709:backlinkController.showMenu: Instance of 'nullGui' has no 'postPopupMenu' member (but some types could not be inferred)
W0101:785:backlinkController.vnodePosition: Unreachable code
E1101:788:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:789:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member
E1101:803:backlinkController.vnodePosition: Instance of 'backlinkController' has no 'positions' member


************* Module leo.plugins.cursesGui
W0311: 84: Bad indentation. Found 2 spaces, expected 4
W0311: 85: Bad indentation. Found 4 spaces, expected 8
W0311: 87: Bad indentation. Found 2 spaces, expected 4
W0311: 92: Bad indentation. Found 2 spaces, expected 4
W0311: 93: Bad indentation. Found 4 spaces, expected 8
W0311: 95: Bad indentation. Found 4 spaces, expected 8
W0311: 96: Bad indentation. Found 4 spaces, expected 8
W0311: 99: Bad indentation. Found 2 spaces, expected 4
W0311:103: Bad indentation. Found 6 spaces, expected 8
W0311:105: Bad indentation. Found 2 spaces, expected 4
W0311:106: Bad indentation. Found 4 spaces, expected 8
W0311:107: Bad indentation. Found 4 spaces, expected 8
W0311:108: Bad indentation. Found 4 spaces, expected 8
W0311:110: Bad indentation. Found 2 spaces, expected 4
W0311:111: Bad indentation. Found 4 spaces, expected 8
W0311:114: Bad indentation. Found 2 spaces, expected 4
W0311:115: Bad indentation. Found 4 spaces, expected 8
W0311:117: Bad indentation. Found 2 spaces, expected 4
W0311:118: Bad indentation. Found 4 spaces, expected 8
W0311:120: Bad indentation. Found 2 spaces, expected 4
W0311:122: Bad indentation. Found 6 spaces, expected 8
W0311:124: Bad indentation. Found 6 spaces, expected 8
W0311:126: Bad indentation. Found 2 spaces, expected 4
W0311:127: Bad indentation. Found 4 spaces, expected 8
W0311:129: Bad indentation. Found 2 spaces, expected 4
W0311:130: Bad indentation. Found 4 spaces, expected 8
W0311:132: Bad indentation. Found 2 spaces, expected 4
W0311:133: Bad indentation. Found 4 spaces, expected 8
W0311:135: Bad indentation. Found 4 spaces, expected 8
W0311:137: Bad indentation. Found 4 spaces, expected 8
W0311:138: Bad indentation. Found 4 spaces, expected 8
W0311:140: Bad indentation. Found 4 spaces, expected 8
W0311:142: Bad indentation. Found 4 spaces, expected 8
W0311:143: Bad indentation. Found 6 spaces, expected 12
W0311:144: Bad indentation. Found 4 spaces, expected 8
W0311:146: Bad indentation. Found 2 spaces, expected 4
W0311:147: Bad indentation. Found 4 spaces, expected 8
W0311:149: Bad indentation. Found 2 spaces, expected 4
W0311:150: Bad indentation. Found 4 spaces, expected 8
W0311:152: Bad indentation. Found 2 spaces, expected 4
W0311:153: Bad indentation. Found 4 spaces, expected 8
W0311:155: Bad indentation. Found 4 spaces, expected 8
W0311:156: Bad indentation. Found 4 spaces, expected 8
W0311:158: Bad indentation. Found 4 spaces, expected 8
W0311:161: Bad indentation. Found 6 spaces, expected 12
W0311:162: Bad indentation. Found 8 spaces, expected 16
W0311:163: Bad indentation. Found 6 spaces, expected 12
W0311:164: Bad indentation. Found 6 spaces, expected 12
W0311:167: Bad indentation. Found 6 spaces, expected 12
W0311:169: Bad indentation. Found 6 spaces, expected 12
W0311:170: Bad indentation. Found 8 spaces, expected 16
W0311:171: Bad indentation. Found 6 spaces, expected 12
W0311:172: Bad indentation. Found 10 spaces, expected 16
W0311:174: Bad indentation. Found 2 spaces, expected 4
W0311:176: Bad indentation. Found 4 spaces, expected 8
W0311:177: Bad indentation. Found 6 spaces, expected 12
W0311:178: Bad indentation. Found 4 spaces, expected 8
W0311:179: Bad indentation. Found 6 spaces, expected 12
W0311:180: Bad indentation. Found 4 spaces, expected 8
W0311:181: Bad indentation. Found 6 spaces, expected 12
W0311:182: Bad indentation. Found 4 spaces, expected 8
W0311:183: Bad indentation. Found 6 spaces, expected 12
W0311:184: Bad indentation. Found 8 spaces, expected 16
W0311:185: Bad indentation. Found 6 spaces, expected 12
W0311:186: Bad indentation. Found 6 spaces, expected 12
W0311:187: Bad indentation. Found 8 spaces, expected 16
W0311:188: Bad indentation. Found 6 spaces, expected 12
W0311:189: Bad indentation. Found 8 spaces, expected 16
W0311:190: Bad indentation. Found 6 spaces, expected 12
W0311:191: Bad indentation. Found 8 spaces, expected 16
W0311:192: Bad indentation. Found 4 spaces, expected 8
W0311:193: Bad indentation. Found 6 spaces, expected 12
W0311:194: Bad indentation. Found 4 spaces, expected 8
W0311:195: Bad indentation. Found 6 spaces, expected 12
W0311:197: Bad indentation. Found 2 spaces, expected 4
W0311:198: Bad indentation. Found 4 spaces, expected 8
W0311:199: Bad indentation. Found 6 spaces, expected 12
W0311:200: Bad indentation. Found 4 spaces, expected 8
W0311:206: Bad indentation. Found 2 spaces, expected 4
W0311:208: Bad indentation. Found 4 spaces, expected 8
W0311:210: Bad indentation. Found 4 spaces, expected 8
W0311:213: Bad indentation. Found 2 spaces, expected 4
W0311:215: Bad indentation. Found 4 spaces, expected 8
W0311:217: Bad indentation. Found 4 spaces, expected 8
W0311:218: Bad indentation. Found 4 spaces, expected 8
W0311:219: Bad indentation. Found 4 spaces, expected 8
W0311:221: Bad indentation. Found 4 spaces, expected 8
W0311:222: Bad indentation. Found 4 spaces, expected 8
W0311:223: Bad indentation. Found 4 spaces, expected 8
W0311:236: Bad indentation. Found 2 spaces, expected 4
W0311:237: Bad indentation. Found 2 spaces, expected 4
W0311:239: Bad indentation. Found 2 spaces, expected 4
W0311:240: Bad indentation. Found 6 spaces, expected 8
W0311:242: Bad indentation. Found 2 spaces, expected 4
W0311:243: Bad indentation. Found 4 spaces, expected 8
W0311:245: Bad indentation. Found 4 spaces, expected 8
W0311:246: Bad indentation. Found 4 spaces, expected 8
W0311:247: Bad indentation. Found 4 spaces, expected 8
W0311:248: Bad indentation. Found 4 spaces, expected 8
W0311:250: Bad indentation. Found 4 spaces, expected 8
W0311:251: Bad indentation. Found 6 spaces, expected 12
W0311:253: Bad indentation. Found 4 spaces, expected 8
W0311:254: Bad indentation. Found 4 spaces, expected 8
W0311:257: Bad indentation. Found 4 spaces, expected 8
W0311:260: Bad indentation. Found 4 spaces, expected 8
W0311:262: Bad indentation. Found 2 spaces, expected 4
W0311:264: Bad indentation. Found 2 spaces, expected 4
W0311:265: Bad indentation. Found 4 spaces, expected 8
W0311:267: Bad indentation. Found 2 spaces, expected 4
W0311:268: Bad indentation. Found 4 spaces, expected 8
W0311:270: Bad indentation. Found 2 spaces, expected 4
W0311:271: Bad indentation. Found 4 spaces, expected 8
W0311:273: Bad indentation. Found 4 spaces, expected 8
W0311:274: Bad indentation. Found 4 spaces, expected 8
W0311:276: Bad indentation. Found 4 spaces, expected 8
W0311:277: Bad indentation. Found 4 spaces, expected 8
W0311:279: Bad indentation. Found 4 spaces, expected 8
W0311:280: Bad indentation. Found 8 spaces, expected 12
W0311:281: Bad indentation. Found 12 spaces, expected 16
W0311:282: Bad indentation. Found 12 spaces, expected 16
W0311:283: Bad indentation. Found 12 spaces, expected 16
W0311:284: Bad indentation. Found 12 spaces, expected 16
W0311:285: Bad indentation. Found 12 spaces, expected 16
W0311:291: Bad indentation. Found 4 spaces, expected 8
W0311:292: Bad indentation. Found 4 spaces, expected 8
W0311:293: Bad indentation. Found 4 spaces, expected 8
W0311:295: Bad indentation. Found 4 spaces, expected 8
W0311:296: Bad indentation. Found 4 spaces, expected 8
W0311:298: Bad indentation. Found 2 spaces, expected 4
W0311:299: Bad indentation. Found 2 spaces, expected 4
W0311:305: Bad indentation. Found 2 spaces, expected 4
W0311:306: Bad indentation. Found 4 spaces, expected 8
W0311:308: Bad indentation. Found 4 spaces, expected 8
W0311:310: Bad indentation. Found 4 spaces, expected 8
W0311:311: Bad indentation. Found 4 spaces, expected 8
W0311:314: Bad indentation. Found 2 spaces, expected 4
W0311:317: Bad indentation. Found 4 spaces, expected 8
W0311:321: Bad indentation. Found 2 spaces, expected 4
W0311:322: Bad indentation. Found 2 spaces, expected 4
W0311:324: Bad indentation. Found 2 spaces, expected 4
W0311:326: Bad indentation. Found 4 spaces, expected 8
W0311:327: Bad indentation. Found 4 spaces, expected 8
W0311:328: Bad indentation. Found 4 spaces, expected 8
W0311:329: Bad indentation. Found 4 spaces, expected 8
W0311:333: Bad indentation. Found 2 spaces, expected 4
W0311:338: Bad indentation. Found 2 spaces, expected 4
W0311:339: Bad indentation. Found 4 spaces, expected 8
W0311:340: Bad indentation. Found 4 spaces, expected 8
W0311:341: Bad indentation. Found 4 spaces, expected 8
W0311:343: Bad indentation. Found 2 spaces, expected 4
W0311:344: Bad indentation. Found 4 spaces, expected 8
W0311:345: Bad indentation. Found 4 spaces, expected 8
W0311:346: Bad indentation. Found 6 spaces, expected 12
W0311:347: Bad indentation. Found 4 spaces, expected 8
W0311:353: Bad indentation. Found 2 spaces, expected 4
W0311:354: Bad indentation. Found 4 spaces, expected 8
W0311:355: Bad indentation. Found 4 spaces, expected 8
W0311:356: Bad indentation. Found 4 spaces, expected 8
W0311:357: Bad indentation. Found 4 spaces, expected 8
W0311:359: Bad indentation. Found 2 spaces, expected 4
W0311:360: Bad indentation. Found 4 spaces, expected 8
W0311:366: Bad indentation. Found 2 spaces, expected 4
W0311:367: Bad indentation. Found 4 spaces, expected 8
W0311:374: Bad indentation. Found 2 spaces, expected 4
W0311:377: Bad indentation. Found 6 spaces, expected 8
W0311:378: Bad indentation. Found 6 spaces, expected 8
W0311:381: Bad indentation. Found 6 spaces, expected 8
W0311:383: Bad indentation. Found 2 spaces, expected 4
W0311:385: Bad indentation. Found 4 spaces, expected 8
W0311:387: Bad indentation. Found 4 spaces, expected 8
W0311:389: Bad indentation. Found 4 spaces, expected 8
W0311:391: Bad indentation. Found 2 spaces, expected 4
W0311:393: Bad indentation. Found 4 spaces, expected 8
W0311:398: Bad indentation. Found 4 spaces, expected 8
W0311:399: Bad indentation. Found 4 spaces, expected 8
W0311:400: Bad indentation. Found 4 spaces, expected 8
W0311:402: Bad indentation. Found 2 spaces, expected 4
W0311:406: Bad indentation. Found 4 spaces, expected 8
W0311:407: Bad indentation. Found 8 spaces, expected 12
W0311:408: Bad indentation. Found 4 spaces, expected 8
W0311:412: Bad indentation. Found 2 spaces, expected 4
W0311:417: Bad indentation. Found 4 spaces, expected 8
W0311:421: Bad indentation. Found 4 spaces, expected 8
W0311:422: Bad indentation. Found 6 spaces, expected 12
W0311:424: Bad indentation. Found 4 spaces, expected 8
W0311:425: Bad indentation. Found 4 spaces, expected 8
W0311:426: Bad indentation. Found 4 spaces, expected 8
W0311:427: Bad indentation. Found 4 spaces, expected 8
W0311:430: Bad indentation. Found 4 spaces, expected 8
W0311:431: Bad indentation. Found 4 spaces, expected 8
W0311:433: Bad indentation. Found 2 spaces, expected 4
W0311:434: Bad indentation. Found 4 spaces, expected 8
W0311:436: Bad indentation. Found 2 spaces, expected 4
W0311:438: Bad indentation. Found 4 spaces, expected 8
W0311:440: Bad indentation. Found 2 spaces, expected 4
W0311:441: Bad indentation. Found 4 spaces, expected 8
W0311:443: Bad indentation. Found 4 spaces, expected 8
W0311:444: Bad indentation. Found 6 spaces, expected 12
W0311:446: Bad indentation. Found 6 spaces, expected 12
W0311:447: Bad indentation. Found 8 spaces, expected 16
W0311:448: Bad indentation. Found 6 spaces, expected 12
W0311:450: Bad indentation. Found 6 spaces, expected 12
W0311:451: Bad indentation. Found 6 spaces, expected 12
W0311:452: Bad indentation. Found 6 spaces, expected 12
W0311:454: Bad indentation. Found 6 spaces, expected 12
W0311:455: Bad indentation. Found 8 spaces, expected 16
W0311:456: Bad indentation. Found 6 spaces, expected 12
W0311:458: Bad indentation. Found 8 spaces, expected 16
W0311:459: Bad indentation. Found 8 spaces, expected 16
W0311:460: Bad indentation. Found 10 spaces, expected 20
W0311:461: Bad indentation. Found 14 spaces, expected 24
W0311:462: Bad indentation. Found 8 spaces, expected 16
W0311:464: Bad indentation. Found 6 spaces, expected 12
W0311:465: Bad indentation. Found 8 spaces, expected 16
W0311:466: Bad indentation. Found 6 spaces, expected 12
W0311:467: Bad indentation. Found 8 spaces, expected 16
W0311:469: Bad indentation. Found 6 spaces, expected 12
W0311:470: Bad indentation. Found 6 spaces, expected 12
W0311:471: Bad indentation. Found 8 spaces, expected 16
W0311:472: Bad indentation. Found 8 spaces, expected 16
W0311:473: Bad indentation. Found 6 spaces, expected 12
W0311:474: Bad indentation. Found 8 spaces, expected 16
W0311:475: Bad indentation. Found 6 spaces, expected 12
W0311:476: Bad indentation. Found 8 spaces, expected 16
W0311:483: Bad indentation. Found 2 spaces, expected 4
W0311:484: Bad indentation. Found 4 spaces, expected 8
W0311:486: Bad indentation. Found 2 spaces, expected 4
W0311:487: Bad indentation. Found 4 spaces, expected 8
W0311:489: Bad indentation. Found 2 spaces, expected 4
W0311:490: Bad indentation. Found 4 spaces, expected 8
W0311:493: Bad indentation. Found 2 spaces, expected 4
W0311:494: Bad indentation. Found 2 spaces, expected 4
W0311:496: Bad indentation. Found 2 spaces, expected 4
W0311:504: Bad indentation. Found 2 spaces, expected 4
W0311:505: Bad indentation. Found 4 spaces, expected 8
W0311:507: Bad indentation. Found 2 spaces, expected 4
W0311:508: Bad indentation. Found 4 spaces, expected 8
W0311:510: Bad indentation. Found 2 spaces, expected 4
W0311:511: Bad indentation. Found 4 spaces, expected 8
W0311:512: Bad indentation. Found 6 spaces, expected 12
W0311:514: Bad indentation. Found 2 spaces, expected 4
W0311:515: Bad indentation. Found 4 spaces, expected 8
W0311:517: Bad indentation. Found 2 spaces, expected 4
W0311:518: Bad indentation. Found 4 spaces, expected 8
W0311:519: Bad indentation. Found 6 spaces, expected 12
W0311:522: Bad indentation. Found 2 spaces, expected 4
W0311:524: Bad indentation. Found 4 spaces, expected 8
W0311:526: Bad indentation. Found 4 spaces, expected 8
W0311:528: Bad indentation. Found 2 spaces, expected 4
W0311:531: Bad indentation. Found 4 spaces, expected 8
W0311:532: Bad indentation. Found 4 spaces, expected 8
W0311:534: Bad indentation. Found 4 spaces, expected 8
W0311:538: Bad indentation. Found 4 spaces, expected 8
W0311:541: Bad indentation. Found 2 spaces, expected 4
W0311:542: Bad indentation. Found 4 spaces, expected 8
W0311:544: Bad indentation. Found 2 spaces, expected 4
W0311:545: Bad indentation. Found 4 spaces, expected 8
W0311:547: Bad indentation. Found 2 spaces, expected 4
W0311:550: Bad indentation. Found 4 spaces, expected 8
W0311:551: Bad indentation. Found 4 spaces, expected 8
W0311:553: Bad indentation. Found 2 spaces, expected 4
W0311:555: Bad indentation. Found 4 spaces, expected 8
W0311:557: Bad indentation. Found 6 spaces, expected 12
W0311:558: Bad indentation. Found 8 spaces, expected 16
W0311:559: Bad indentation. Found 6 spaces, expected 12
W0311:560: Bad indentation. Found 8 spaces, expected 16
W0311:562: Bad indentation. Found 6 spaces, expected 12
W0311:568: Bad indentation. Found 6 spaces, expected 12
W0311:570: Bad indentation. Found 6 spaces, expected 12
W0311:571: Bad indentation. Found 8 spaces, expected 16
W0511: 21: TODO >>
W0511: 22: TODO >>
W0511: 43: TODO >>
W0511: 97: TODO leoTkinterFrame finishCreate g.app.windowList.append(f) - use that?
W0511:319: TODO Tkinter onBodyChanged undo call and many others. =(
W0511:529: TODO Much more here: there's four hooks and all sorts of other things called in the TK version. 
W0221:267:textFrame.setTopGeometry: Arguments number differs from overridden method
W0221:391:textLeoMenu.new_menu: Arguments number differs from overridden method
W0221:412:textLeoMenu.add_command: Arguments number differs from overridden method
W0221:436:textLeoMenu.delete_range: Arguments number differs from overridden method
W0221:514:textTree.redraw: Arguments number differs from overridden method
W0221:517:textTree.redraw_now: Arguments number differs from overridden method
W0221:541:textTree.editLabel: Arguments number differs from overridden method


************* Module leo.plugins.dtest
W0611: 30: Unused import leoPlugins


************* Module leo.plugins.leo_interface
W0311: 42: Bad indentation. Found 3 spaces, expected 4
W0311: 43: Bad indentation. Found 6 spaces, expected 8
W0311: 47: Bad indentation. Found 3 spaces, expected 4
W0311: 48: Bad indentation. Found 6 spaces, expected 8
W0311: 59: Bad indentation. Found 3 spaces, expected 4
W0311: 66: Bad indentation. Found 3 spaces, expected 4
W0311: 67: Bad indentation. Found 7 spaces, expected 8
W0311: 70: Bad indentation. Found 3 spaces, expected 4
W0311: 71: Bad indentation. Found 7 spaces, expected 8
W0311: 72: Bad indentation. Found 7 spaces, expected 8
W0311: 75: Bad indentation. Found 3 spaces, expected 4
W0311: 76: Bad indentation. Found 7 spaces, expected 8
W0311: 79: Bad indentation. Found 3 spaces, expected 4
W0311: 80: Bad indentation. Found 7 spaces, expected 8
W0311: 81: Bad indentation. Found 11 spaces, expected 12
W0311: 84: Bad indentation. Found 3 spaces, expected 4
W0311: 85: Bad indentation. Found 7 spaces, expected 8
W0311: 86: Bad indentation. Found 7 spaces, expected 8
W0311: 87: Bad indentation. Found 11 spaces, expected 12
W0311: 88: Bad indentation. Found 7 spaces, expected 8
W0311: 89: Bad indentation. Found 7 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 7 spaces, expected 8
W0311: 94: Bad indentation. Found 7 spaces, expected 8
W0311: 95: Bad indentation. Found 7 spaces, expected 8
W0311: 96: Bad indentation. Found 7 spaces, expected 8
W0311: 97: Bad indentation. Found 7 spaces, expected 8
W0311: 98: Bad indentation. Found 11 spaces, expected 12
W0311: 99: Bad indentation. Found 7 spaces, expected 8
W0311:100: Bad indentation. Found 7 spaces, expected 8
W0311:101: Bad indentation. Found 11 spaces, expected 12
W0311:102: Bad indentation. Found 7 spaces, expected 8
W0311:103: Bad indentation. Found 7 spaces, expected 8
W0311:104: Bad indentation. Found 7 spaces, expected 8
W0311:105: Bad indentation. Found 11 spaces, expected 12
W0311:108: Bad indentation. Found 3 spaces, expected 4
W0311:109: Bad indentation. Found 7 spaces, expected 8
W0311:110: Bad indentation. Found 7 spaces, expected 8
W0311:111: Bad indentation. Found 7 spaces, expected 8
W0311:112: Bad indentation. Found 7 spaces, expected 8
W0311:113: Bad indentation. Found 7 spaces, expected 8
W0311:114: Bad indentation. Found 11 spaces, expected 12
W0311:115: Bad indentation. Found 7 spaces, expected 8
W0311:120: Bad indentation. Found 3 spaces, expected 4
W0311:121: Bad indentation. Found 5 spaces, expected 8
W0311:130: Bad indentation. Found 3 spaces, expected 4
W0311:135: Bad indentation. Found 3 spaces, expected 4
W0311:136: Bad indentation. Found 6 spaces, expected 8
W0311:140: Bad indentation. Found 3 spaces, expected 4
W0311:141: Bad indentation. Found 6 spaces, expected 8
W0311:145: Bad indentation. Found 3 spaces, expected 4
W0311:146: Bad indentation. Found 7 spaces, expected 8
W0311:149: Bad indentation. Found 3 spaces, expected 4
W0311:150: Bad indentation. Found 7 spaces, expected 8
W0311:151: Bad indentation. Found 7 spaces, expected 8
W0311:154: Bad indentation. Found 3 spaces, expected 4
W0311:155: Bad indentation. Found 7 spaces, expected 8
W0311:156: Bad indentation. Found 7 spaces, expected 8
W0311:157: Bad indentation. Found 7 spaces, expected 8
W0311:158: Bad indentation. Found 7 spaces, expected 8
W0311:161: Bad indentation. Found 3 spaces, expected 4
W0311:162: Bad indentation. Found 7 spaces, expected 8
W0311:165: Bad indentation. Found 7 spaces, expected 8
W0311:170: Bad indentation. Found 7 spaces, expected 8
W0311:171: Bad indentation. Found 7 spaces, expected 8
W0311:172: Bad indentation. Found 7 spaces, expected 8
W0311:173: Bad indentation. Found 10 spaces, expected 12
W0311:174: Bad indentation. Found 10 spaces, expected 12
W0311:175: Bad indentation. Found 7 spaces, expected 8
W0311:176: Bad indentation. Found 7 spaces, expected 8
W0311:179: Bad indentation. Found 3 spaces, expected 4
W0311:180: Bad indentation. Found 7 spaces, expected 8
W0311:181: Bad indentation. Found 11 spaces, expected 12
W0311:184: Bad indentation. Found 3 spaces, expected 4
W0311:185: Bad indentation. Found 6 spaces, expected 8
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 9 spaces, expected 12
W0311:188: Bad indentation. Found 9 spaces, expected 12
W0311:189: Bad indentation. Found 6 spaces, expected 8
W0311:190: Bad indentation. Found 9 spaces, expected 12
W0311:194: Bad indentation. Found 3 spaces, expected 4
W0311:195: Bad indentation. Found 7 spaces, expected 8
W0311:202: Bad indentation. Found 3 spaces, expected 4
W0311:203: Bad indentation. Found 7 spaces, expected 8
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 3 spaces, expected 4
W0311:211: Bad indentation. Found 7 spaces, expected 8
W0311:214: Bad indentation. Found 3 spaces, expected 4
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:224: Bad indentation. Found 3 spaces, expected 4
W0311:233: Bad indentation. Found 3 spaces, expected 4
W0311:234: Bad indentation. Found 3 spaces, expected 4
W0311:237: Bad indentation. Found 3 spaces, expected 4
W0311:238: Bad indentation. Found 7 spaces, expected 8
W0311:239: Bad indentation. Found 7 spaces, expected 8
W0311:240: Bad indentation. Found 7 spaces, expected 8
W0311:241: Bad indentation. Found 7 spaces, expected 8
W0311:242: Bad indentation. Found 7 spaces, expected 8
W0311:245: Bad indentation. Found 3 spaces, expected 4
W0311:246: Bad indentation. Found 7 spaces, expected 8
W0311:249: Bad indentation. Found 3 spaces, expected 4
W0311:250: Bad indentation. Found 7 spaces, expected 8
W0311:253: Bad indentation. Found 7 spaces, expected 8
W0311:254: Bad indentation. Found 11 spaces, expected 12
W0311:257: Bad indentation. Found 3 spaces, expected 4
W0311:258: Bad indentation. Found 7 spaces, expected 8
W0311:261: Bad indentation. Found 3 spaces, expected 4
W0311:262: Bad indentation. Found 6 spaces, expected 8
W0311:263: Bad indentation. Found 6 spaces, expected 8
W0311:264: Bad indentation. Found 9 spaces, expected 12
W0311:269: Bad indentation. Found 9 spaces, expected 12
W0311:270: Bad indentation. Found 9 spaces, expected 12
W0311:271: Bad indentation. Found 12 spaces, expected 16
W0311:272: Bad indentation. Found 12 spaces, expected 16
W0311:273: Bad indentation. Found 12 spaces, expected 16
W0311:274: Bad indentation. Found 12 spaces, expected 16
W0311:275: Bad indentation. Found 15 spaces, expected 20
W0311:276: Bad indentation. Found 12 spaces, expected 16
W0311:277: Bad indentation. Found 12 spaces, expected 16
W0311:278: Bad indentation. Found 9 spaces, expected 12
W0311:279: Bad indentation. Found 9 spaces, expected 12
W0311:280: Bad indentation. Found 9 spaces, expected 12
W0311:281: Bad indentation. Found 9 spaces, expected 12
W0311:282: Bad indentation. Found 6 spaces, expected 8
W0311:283: Bad indentation. Found 6 spaces, expected 8
W0311:284: Bad indentation. Found 9 spaces, expected 12
W0311:285: Bad indentation. Found 9 spaces, expected 12
W0311:288: Bad indentation. Found 3 spaces, expected 4
W0311:289: Bad indentation. Found 6 spaces, expected 8
W0311:290: Bad indentation. Found 6 spaces, expected 8
W0311:291: Bad indentation. Found 9 spaces, expected 12
W0311:294: Bad indentation. Found 3 spaces, expected 4
W0311:295: Bad indentation. Found 7 spaces, expected 8
W0311:298: Bad indentation. Found 3 spaces, expected 4
W0311:299: Bad indentation. Found 7 spaces, expected 8
W0311:302: Bad indentation. Found 3 spaces, expected 4
W0311:303: Bad indentation. Found 7 spaces, expected 8
W0311:306: Bad indentation. Found 3 spaces, expected 4
W0311:307: Bad indentation. Found 7 spaces, expected 8
W0311:311: Bad indentation. Found 3 spaces, expected 4
W0311:312: Bad indentation. Found 7 spaces, expected 8
W0311:315: Bad indentation. Found 3 spaces, expected 4
W0311:316: Bad indentation. Found 6 spaces, expected 8
W0311:322: Bad indentation. Found 3 spaces, expected 4
W0311:336: Bad indentation. Found 3 spaces, expected 4
W0311:337: Bad indentation. Found 6 spaces, expected 8
W0311:338: Bad indentation. Found 6 spaces, expected 8
W0311:342: Bad indentation. Found 3 spaces, expected 4
W0311:343: Bad indentation. Found 6 spaces, expected 8
W0311:350: Bad indentation. Found 3 spaces, expected 4
W0311:351: Bad indentation. Found 6 spaces, expected 8
W0601:173:leo_file.gen1: Global variable 'vnode_count' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'allvnodes' undefined at the module level
W0601:186:leo_file.gen_vnodes: Global variable 'vnode_stack' undefined at the module level
W0105:268:leo_node.gen_vnodes: String statement has no effect
W0601:278:leo_node.gen_vnodes: Global variable 'vnode_count' undefined at the module level


************* Module leo.plugins.leo_pdf
E0602:322:Bunch.__setitem__: Undefined variable 'operator'
E0602:326:Bunch.__getitem__: Undefined variable 'operator'
W0105:344:Writer: String statement has no effect
W0105:372:Writer: String statement has no effect


************* Module leo.plugins.leoOPML
E1101:241:opmlFileCommandsClass.putOPMLHeader: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_globals_attributes' member
E1101:278:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_leo_details' member
E1101:294:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_write_body_text' member
E1101:295:opmlFileCommandsClass.putOPMLNode: Instance of 'opmlFileCommandsClass' has no 'opml_use_outline_elements' member
E1101:373:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_write_ua_attributes' member
E1101:375:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_expand_ua_dictionary' member
E1101:377:opmlFileCommandsClass.uAAttributes: Instance of 'opmlFileCommandsClass' has no 'opml_skip_ua_dictionary_blanks' member
E1101:485:opmlController.createVnode: Module 'leo.core.leoNodes' has no 'tnode' member
E1101:489:opmlController.createVnode: Instance of 'vnode' has no 't' member
W0221:887:contentHandler.ignorableWhitespace: Arguments number differs from overridden method


************* Module leo.plugins.leoremote
W0611: 45: Unused import sys


************* Module leo.plugins.lineNumbers
E1121: 48:init.putLineNumberDirective: Too many positional arguments for function call


************* Module leo.plugins.macros
This is a real error.
E1103:130:paramClass.parameterize: Instance of 'unitTestGui' has no 'getInsertPoint' member (but some types could not be inferred)
E1103:130:paramClass.parameterize: Instance of 'nullGui' has no 'getInsertPoint' member (but some types could not be inferred)


************* Module leo.plugins.mod_autosave
W0311: 85: Bad indentation. Found 9 spaces, expected 8
W0611: 24: Unused import os


************* Module leo.plugins.mod_leo2ascd
E1120:133:GetAscFilename: No value passed for parameter 'vnode' in function call
E1120:353:WriteTreeOfCurrentNode: No value passed for parameter 'vnode' in function call
E1120:368:WriteAll: No value passed for parameter 'vnode' in function call
E1120:427: No value passed for parameter 'c' in function call


************* Module leo.plugins.mod_speedups
W0611: 30: Unused import leoPlugins
W0611: 52: Unused import leo


************* Module leo.plugins.nav_buttons
W0311:347: Bad indentation. Found 11 spaces, expected 12


************* Module leo.plugins.nodeActions
W0312: 63: Found indentation with tabs instead of spaces
W0312: 64: Found indentation with tabs instead of spaces
W0312: 65: Found indentation with tabs instead of spaces
W0312: 66: Found indentation with tabs instead of spaces
W0312: 67: Found indentation with tabs instead of spaces
W0312: 68: Found indentation with tabs instead of spaces
W0311: 72: Bad indentation. Found 3 spaces, expected 4
W0311: 81: Bad indentation. Found 3 spaces, expected 4
W0311: 83: Bad indentation. Found 3 spaces, expected 4
W0311: 84: Bad indentation. Found 6 spaces, expected 8
W0311: 87: Bad indentation. Found 3 spaces, expected 4
W0311: 88: Bad indentation. Found 3 spaces, expected 4
W0311: 89: Bad indentation. Found 6 spaces, expected 8
W0311: 92: Bad indentation. Found 3 spaces, expected 4
W0311: 93: Bad indentation. Found 3 spaces, expected 4
W0311: 94: Bad indentation. Found 6 spaces, expected 8
W0311: 96: Bad indentation. Found 3 spaces, expected 4
W0311: 98: Bad indentation. Found 6 spaces, expected 8
W0311: 99: Bad indentation. Found 6 spaces, expected 8
W0311:101: Bad indentation. Found 6 spaces, expected 8
W0311:104: Bad indentation. Found 9 spaces, expected 12
W0311:105: Bad indentation. Found 12 spaces, expected 16
W0311:108: Bad indentation. Found 9 spaces, expected 12
W0311:109: Bad indentation. Found 12 spaces, expected 16
W0311:111: Bad indentation. Found 9 spaces, expected 12
W0311:112: Bad indentation. Found 9 spaces, expected 12
W0311:113: Bad indentation. Found 12 spaces, expected 16
W0311:116: Bad indentation. Found 9 spaces, expected 12
W0311:117: Bad indentation. Found 9 spaces, expected 12
W0311:118: Bad indentation. Found 12 spaces, expected 16
W0311:119: Bad indentation. Found 9 spaces, expected 12
W0311:120: Bad indentation. Found 12 spaces, expected 16
W0311:122: Bad indentation. Found 9 spaces, expected 12
W0311:123: Bad indentation. Found 9 spaces, expected 12
W0311:124: Bad indentation. Found 9 spaces, expected 12
W0311:125: Bad indentation. Found 12 spaces, expected 16
W0311:127: Bad indentation. Found 9 spaces, expected 12
W0311:128: Bad indentation. Found 9 spaces, expected 12
W0311:129: Bad indentation. Found 12 spaces, expected 16
W0311:133: Bad indentation. Found 9 spaces, expected 12
W0311:137: Bad indentation. Found 9 spaces, expected 12
W0311:138: Bad indentation. Found 9 spaces, expected 12
W0311:139: Bad indentation. Found 9 spaces, expected 12
W0311:141: Bad indentation. Found 12 spaces, expected 16
W0311:142: Bad indentation. Found 12 spaces, expected 16
W0311:143: Bad indentation. Found 15 spaces, expected 20
W0311:145: Bad indentation. Found 15 spaces, expected 20
W0311:146: Bad indentation. Found 15 spaces, expected 20
W0311:147: Bad indentation. Found 18 spaces, expected 24
W0311:151: Bad indentation. Found 9 spaces, expected 12
W0311:152: Bad indentation. Found 12 spaces, expected 16
W0311:153: Bad indentation. Found 9 spaces, expected 12
W0311:154: Bad indentation. Found 12 spaces, expected 16
W0311:155: Bad indentation. Found 9 spaces, expected 12
W0311:156: Bad indentation. Found 12 spaces, expected 16
W0311:157: Bad indentation. Found 15 spaces, expected 20
W0311:158: Bad indentation. Found 12 spaces, expected 16
W0311:159: Bad indentation. Found 15 spaces, expected 20
W0311:162: Bad indentation. Found 12 spaces, expected 16
W0311:163: Bad indentation. Found 15 spaces, expected 20
W0311:165: Bad indentation. Found 18 spaces, expected 24
W0311:166: Bad indentation. Found 18 spaces, expected 24
W0311:167: Bad indentation. Found 18 spaces, expected 24
W0311:168: Bad indentation. Found 18 spaces, expected 24
W0311:169: Bad indentation. Found 21 spaces, expected 28
W0311:171: Bad indentation. Found 12 spaces, expected 16
W0311:173: Bad indentation. Found 12 spaces, expected 16
W0311:175: Bad indentation. Found 12 spaces, expected 16
W0311:176: Bad indentation. Found 15 spaces, expected 20
W0311:177: Bad indentation. Found 9 spaces, expected 12
W0311:178: Bad indentation. Found 12 spaces, expected 16
W0311:179: Bad indentation. Found 15 spaces, expected 20
W0311:182: Bad indentation. Found 6 spaces, expected 8
W0311:184: Bad indentation. Found 9 spaces, expected 12
W0311:185: Bad indentation. Found 12 spaces, expected 16
W0311:186: Bad indentation. Found 9 spaces, expected 12
W0311:187: Bad indentation. Found 6 spaces, expected 8
W0311:189: Bad indentation. Found 9 spaces, expected 12
W0311:190: Bad indentation. Found 12 spaces, expected 16
W0311:191: Bad indentation. Found 9 spaces, expected 12
W0311:192: Bad indentation. Found 6 spaces, expected 8
W0311:194: Bad indentation. Found 9 spaces, expected 12
W0311:195: Bad indentation. Found 12 spaces, expected 16
W0311:196: Bad indentation. Found 9 spaces, expected 12
W0311:197: Bad indentation. Found 3 spaces, expected 4
W0311:199: Bad indentation. Found 6 spaces, expected 8
W0311:200: Bad indentation. Found 9 spaces, expected 12
W0311:201: Bad indentation. Found 6 spaces, expected 8
W0311:205: Bad indentation. Found 3 spaces, expected 4
W0311:206: Bad indentation. Found 3 spaces, expected 4
W0311:207: Bad indentation. Found 7 spaces, expected 8
W0311:208: Bad indentation. Found 7 spaces, expected 8
W0311:209: Bad indentation. Found 7 spaces, expected 8
W0311:210: Bad indentation. Found 7 spaces, expected 8
W0311:212: Bad indentation. Found 7 spaces, expected 8
W0311:213: Bad indentation. Found 11 spaces, expected 12
W0311:214: Bad indentation. Found 11 spaces, expected 12
W0311:215: Bad indentation. Found 7 spaces, expected 8
W0311:216: Bad indentation. Found 11 spaces, expected 12
W0311:222: Bad indentation. Found 11 spaces, expected 12
W0311:224: Bad indentation. Found 11 spaces, expected 12
W0311:225: Bad indentation. Found 15 spaces, expected 16
W0311:226: Bad indentation. Found 15 spaces, expected 16
W0311:227: Bad indentation. Found 7 spaces, expected 8
W0311:229: Bad indentation. Found 11 spaces, expected 12
W0311:230: Bad indentation. Found 15 spaces, expected 16
W0311:231: Bad indentation. Found 15 spaces, expected 16
W0311:232: Bad indentation. Found 11 spaces, expected 12
W0311:233: Bad indentation. Found 11 spaces, expected 12
W0311:235: Bad indentation. Found 7 spaces, expected 8


************* Module leo.plugins.nodebar
W0601:183:initImages: Global variable 'clonePI' undefined at the module level
W0601:184:initImages: Global variable 'copyPI' undefined at the module level
W0601:185:initImages: Global variable 'cutPI' undefined at the module level
W0601:186:initImages: Global variable 'dehoistPI' undefined at the module level
W0601:187:initImages: Global variable 'deletePI' undefined at the module level
W0601:188:initImages: Global variable 'demotePI' undefined at the module level
W0601:189:initImages: Global variable 'hoistPI' undefined at the module level
W0601:190:initImages: Global variable 'insertPI' undefined at the module level
W0601:191:initImages: Global variable 'movedownPI' undefined at the module level
W0601:192:initImages: Global variable 'moveleftPI' undefined at the module level
W0601:193:initImages: Global variable 'moverightPI' undefined at the module level
W0601:194:initImages: Global variable 'moveupPI' undefined at the module level
W0601:195:initImages: Global variable 'nodedownPI' undefined at the module level
W0601:196:initImages: Global variable 'nodeleftPI' undefined at the module level
W0601:197:initImages: Global variable 'noderightPI' undefined at the module level
W0601:198:initImages: Global variable 'nodeupPI' undefined at the module level
W0601:199:initImages: Global variable 'pastePI' undefined at the module level
W0601:200:initImages: Global variable 'pasteclonePI' undefined at the module level
W0601:201:initImages: Global variable 'promotePI' undefined at the module level
W0601:202:initImages: Global variable 'questionPI' undefined at the module level
W0601:203:initImages: Global variable 'sortchildrenPI' undefined at the module level
W0601:204:initImages: Global variable 'sortsiblingsPI' undefined at the module level
W0611: 21: Unused import weakref


************* Module leo.plugins.pretty_print
W0233: 52:myPrettyPrinter.__init__: __init__ method from a non direct base class 'myPrettyPrinter' is called
E0602: 62:myPrettyPrinter.putNormalToken: Undefined variable 'token'
E0602:188:myPrettyPrinter.doOp: Undefined variable 'keyword'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'
E0602:223:myPrettyPrinter.doOp: Undefined variable 'string'


************* Module leo.plugins.quickMove
W0311:220: Bad indentation. Found 16 spaces, expected 12
W0311:225: Bad indentation. Found 16 spaces, expected 12
E1101:220:quickMove.__init__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E1101:225:quickMove.__del__: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
W0611:106: Unused import types


************* Module leo.plugins.quicksearch
W0301:222: Unnecessary semicolon
W0301:240: Unnecessary semicolon
W0604: 73: Using the global statement at the module level
W0611: 42: Unused import QListWidget


************* Module leo.plugins.rClickBasePluginClasses
E1101:134:pluginCommandClass.preDoCommand: Instance of 'pluginCommandClass' has no 'doCommand' member
E1101:260:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandList' member
E1101:267:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:272:basePluginController.getPublicCommands: Instance of 'basePluginController' has no 'commandPrefix' member
E1101:310:basePluginController.getCommandList: Instance of 'basePluginController' has no 'commandList' member
E1101:318:basePluginController.setDefaultContextMenus: Instance of 'basePluginController' has no 'defaultContextMenus' member


************* Module leo.plugins.run_nodes
E1120:210:OnQuit: No value passed for parameter 'c' in function call


************* Module leo.plugins.rst3
E1120:263:runUnitTests: No value passed for parameter 'headline' in function call
E1120:1017:rstClass.initOptionsFromSettings: No value passed for parameter 'tag' in function call


************* Module leo.plugins.scrolledmessage
W0311:407: Bad indentation. Found 12 spaces, expected 8
W0311:408: Bad indentation. Found 12 spaces, expected 8
W0311:410: Bad indentation. Found 12 spaces, expected 8
W0311:411: Bad indentation. Found 12 spaces, expected 8
E1101:289:ScrolledMessageDialog.doActionOutlineShow: Instance of 'ScrolledMessageDialog' has no 'name' member
W0107:314:ScrolledMessageDialog.doActionAbout: Unnecessary pass statement
E1101:318:ScrolledMessageDialog.doActionRST3: Instance of 'LeoApp' has no 'pluginsController' member
E1101:532:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:533:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'label' member
E1101:539:ScrolledMessageDialog.updateDialog: Instance of 'ScrolledMessageDialog' has no 'title' member
E0211:543:ScrolledMessageDialog.afterDrawHandler: Method has no argument
E0602:613:ScrolledMessageController.afterRedrawHandler: Undefined variable 'dialogs'
E1120:614:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'tag' in function call
E1120:614:ScrolledMessageController.afterRedrawHandler: No value passed for parameter 'keywords' in function call
W0611: 91: Unused import inspect


************* Module leo.plugins.todo
E1101: 58:init: Module 'leo.core.leoGlobals' has no 'tree_popup_handlers' member
E0102:260:todoController.addPopupMenu.func: function already defined line 251
E0213:307:todoController.redrawer: Method should have "self" as first argument
E1102:312:todoController.redrawer.new: fn is not callable
E0213:322:todoController.projectChanger: Method should have "self" as first argument
E1102:325:todoController.projectChanger.new: fn is not callable

************* Module leo.plugins.toolbar
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'tkIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:487:ToolbarTkinterFrame.getIconButton: Instance of 'nullIconBarClass' has no 'getButton' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'tkIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:562:ToolbarTkinterFrame.getIconWidgetFrame: Instance of 'nullIconBarClass' has no 'getWidgetFrame' member (but some types could not be inferred)
E1103:1360:ToolbarScriptingController.createScriptButtonIconButton: Instance of 'ToolbarScriptButton' has no 'configure' member (but some types could not be inferred)


************* Module leo.external.ipy_leo
W0601: 30:init_ipython: Global variable 'ip' undefined at the module level
W0107: 90:es: Unnecessary pass statement
W0108:231:LeoNode.<lambda>: Lambda may not be necessary
W1001:398:LeoWorkbook: Use of "property" on an old style class
E1101:438:workbook_complete: Function 'dispatch' has no 'when_type' member
E1101:438:workbook_complete: Function 'complete_object' has no 'when_type' member
E1101:589:edit_macro: Function 'edit_object_in_leo' has no 'when_type' member
W0601:749:lleo_f: Global variable '_request_immediate_connect' undefined at the module level


************* Module leo.external.lproto
E1101:137:LProtoClient.__init__: Module 'socket' has no 'AF_UNIX' member
#@+node:ekr.20100907092144.5901: *3* Unit tests
# These are intended to be temporary tests,
# to be copied eventually to unitTest.leo
#@+node:ekr.20100907115157.5905: *4* @ignore
#@+node:ekr.20100208095423.5940: *5* @test leoCache
import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()
#@+node:ekr.20100906165118.5915: *5* @test leoInkCommands
ic = c.inkscapeCommands
screenshot = r'c:\leo.repo\inkcall\some_screen_shot.png'
template_fn = r'c:\leo.repo\inkcall\template.svg'
png_fn = r'c:\leo.repo\inkcall\output.png'
svg_fn = r'c:\leo.repo\inkcall\temp.svg'
callouts = [
        "This goes here",
        "These are those, but slightly longer",
        "Then you pull this, but this text needs to be longer for testing",]
ic.run(
    screenshot,
    callouts=callouts,
    numbers=[2,4,17],
    edit_flag = True, # True: call inkscape to edit the working file.
    png_fn=png_fn, # Optional: Name of output png file.
    svg_fn=svg_fn, # Optional: Name of working svg file.
    template_fn=template_fn, # Optional: Name of template svg file.
)
#@+node:ekr.20101127152442.5917: ** 4.9 a1
#@+node:ekr.20101218101041.8570: *3* Bugs
#@+node:ekr.20101218101041.5922: *4* Fixed bug 682561: pyenchant install problem
#@+node:ekr.20101218101041.5923: *5* Report
@nocolor-node

Traceback (most recent call last):
File "/usr/lib/pymodules/python2.6/leo/core/leoEditCommands.py", line 8574, in __init__
self.d = enchant.DictWithPWL(language,fn)
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 708, in __init__
self.pwl = self._broker.request_pwl_dict(pwl)
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 276, in request_pwl_dict
self._raise_error(eStr % (pwl,))
File "/usr/lib/pymodules/python2.6/enchant/__init__.py", line 216, in _raise_error
raise eclass(err)
Error: Couldn't open personal wordlist '/usr/share/pyshared/leo/plugins/spellpyx.txt'
not a valid dictionary file /usr/share/pyshared/leo/plugins/spellpyx.txt
#@+node:ekr.20100904095239.5916: *5*  __init__ (EnchantClass)
def __init__ (self,c):

    """Ctor for the EnchantClass class."""

    self.c = c
    language = g.toUnicode(c.config.getString('enchant_language'))

    # Set the base language
    if language and not enchant.dict_exists(language):
        g.es_print('Invalid language code for Enchant',
            repr(language),color='blue')
        g.es('Using "en_US" instead')
        language = 'en_US'

    # Compute fn, the full path to the local dictionary.
    fn = g.os_path_finalize(
        c.config.getString('enchant_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if fn and g.os_path_exists(fn):
        # Merge the local and global dictionaries.
        try:
            self.d = enchant.DictWithPWL(language,fn)
        except Exception:
            g.es_exception()
            g.es_print('not a valid dictionary file',fn,color='red')
            self.d = enchant.Dict(language) 
    else:
        self.d = enchant.Dict(language) 
#@+node:ekr.20101218103123.5936: *4* Investigated bug 689314: @path does not create folder
@nocolor-node

This appears to be invalid.
#@+node:ekr.20101218103123.5937: *5* Report
@nocolor-node

Steps to reproduce it:

0) Make sure that there is no directory named 'test' in your home directory.
1) Create new .leo file with File>New and save it as test.leo
2) Create '@path test' headline.
3) Create '@thin file.txt' headline as a child of the @path headline
4) Save
Log window content for step 4:

created: /home/username/file.txt
saved: test.leo

suppose that file.txt should be found in ~/test/ but it is really in ~.

5) Quit leo and open test.leo again
Log window content:

reading: /home/username/test.leo
can not open: '@file /home/username/test/file.txt'

6) Create directory test/ in your home directory (in file manager)
7) Edit '@thin file.txt' content and save all.
Log window content:

created: /home/ss/test/file.txt
saved: test.leo

I think that in the case of directory absence the @path directive should either
create it or raise an error message but should not create the file silently. I
would prefer the first way.
#@+node:ekr.20080827175609.39: *5* c.scanAllDirectives
def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    trace = False and not g.unitTesting
    c = self ; p = p or c.p

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    d = {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }

    if trace: g.trace(lang_dict.get('language'),g.callers())

    return d
#@+node:ekr.20080828103146.15: *5* c.scanAtPathDirectives
def scanAtPathDirectives(self,aList):

    '''Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.'''

    trace = False and not g.unitTesting
    verbose = True

    c = self
    c.scanAtPathDirectivesCount += 1 # An important statistic.
    if trace and verbose: g.trace('**entry',g.callers(4))

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose:
        g.trace('base   ',base)
        g.trace('loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if trace and path:
            g.trace('**** d',d)
            g.trace('**** @path path',path)
        if path is not None: # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                paths.append(path)
            # We will silently ignore empty @path directives.

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose:
        g.printList(paths,tag='c.scanAtPathDirectives: raw paths')

    path = c.os_path_finalize_join(*paths)

    if trace and verbose: g.trace('joined path:',path)
    if trace: g.trace('returns',path)

    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
#@+node:ekr.20080923070954.4: *5* at.scanAllDirectives
def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
    createPath=True,
    issuePathWarning=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    trace = False and not g.unitTesting
    at = self ; c = self.c
    g.app.atPathInBodyWarning = None
    << set ivars >>
    lang_dict = {'language':at.language,'delims':delims,}
    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    if issuePathWarning and g.app.atPathInBodyWarning:
        g.es('warning: ignoring @path directive in',
            g.app.atPathInBodyWarning,color='red')

    # Post process.
    lang_dict   = d.get('lang-dict')
    delims      = lang_dict.get('delims')
    lineending  = d.get('lineending')

    at.encoding             = d.get('encoding')
    at.explicitLineEnding   = bool(lineending)
    at.language             = lang_dict.get('language')
    at.output_newline       = lineending or g.getOutputNewline(c=c)
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        << set comment strings from delims >>

    # For unit testing.
    d = {
        "all"       : all,
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
    if trace: g.trace(d)
    return d
#@+node:ekr.20080923070954.14: *6* << Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@+node:ekr.20080923070954.13: *6* << Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@+node:ekr.20041005105605.144: *5* at.write & helper
def write (self,root,
    kind = '@unknown', # Should not happen.
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):
    """Write a 4.x derived file.
    root is the position of an @<file> node"""

    trace = False and not g.unitTesting
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    # "look ahead" computation of eventual fileName.
    eventualFileName = c.os_path_finalize_join(
        at.default_directory,at.targetFileName)
    exists = g.os_path_exists(eventualFileName)

    if trace:
        g.trace('default_dir',
            g.os_path_exists(at.default_directory),
            at.default_directory)
        g.trace('eventual_fn',exists,eventualFileName)

    if not scriptWrite and not toString:
        # 2010/7/28: The read logic now sets the at_read bit for @nosent nodes,
        # so we can just use promptForDangerousWrite.
        if not hasattr(root.v,'at_read') and exists:
            # Prompt if writing a new @file or @thin node would
            # overwrite an existing file.
            ok = self.promptForDangerousWrite(eventualFileName,kind)
            if ok:
                root.v.at_read = True # Create the attribute for all clones.
            else:
                g.es("not written:",eventualFileName)
                << set dirty and orphan bits >> # 2010/10/21.
                return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        assert root==at.root,'write'
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            if hasattr(self.root.v,'tnodeList'):
                delattr(self.root.v,'tnodeList')
            root.v._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors > 0 or root.isOrphan():
                << set dirty and orphan bits >>
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.

    except Exception:
        if hasattr(self.root.v,'tnodeList'):
            delattr(self.root.v,'tnodeList')
        if toString:
            at.exception("exception preprocessing script")
            root.v._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145: *6* << set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
    if not at.targetFileName:
        # We have an @file node.
        at.targetFileName = root.atFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@+node:ekr.20041005105605.146: *6* << set dirty and orphan bits >>
# Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

#@+node:ekr.20041005105605.15: *5* at.initWriteIvars
def initWriteIvars(self,root,targetFileName,
    atAuto=False,atEdit=False,atShadow=False,
    nosentinels=False,thinFile=False,
    scriptWrite=False,toString=False,
    forcePythonSentinels=None,
):
    at = self ; c = at.c

    assert root
    self.initCommonIvars()

    at.atAuto = atAuto
    at.atEdit = atEdit
    at.atShadow = atShadow
    # at.default_directory: set by scanAllDirectives()
    at.docKind = None
    if forcePythonSentinels:
        at.endSentinelComment = None
    # else: at.endSentinelComment set by initCommonIvars.
    # at.encoding: set by scanAllDirectives() below.
    # at.explicitLineEnding # True: an @lineending directive specifies the ending.
        # Set by scanAllDirectives() below.
    at.fileChangedFlag = False # True: the file has actually been updated.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force_newlines_in_at_nosent_bodies')
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite
    # at.language:      set by scanAllDirectives() below.
    # at.outputFile:    set below.
    # at.outputNewline: set below.
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        at.startSentinelComment = "#"
    # else:                 set by initCommonIvars.
    # at.stringOutput:      set below.
    # at.outputFileName:    set below.
    # at.output_newline:    set by scanAllDirectives() below.
    # at.page_width:        set by scanAllDirectives() below.
    at.sentinels = not nosentinels
    at.shortFileName = ""   # For messages.
    at.root = root
    # at.tab_width:         set by scanAllDirectives() below.
    at.targetFileName = targetFileName
        # Must be None for @shadow.
    at.thinFile = thinFile
    at.toString = toString
    at.writeVersion5 = at.new_write and not atShadow

    at.scanAllDirectives(root,
        scripting=scriptWrite,
        forcePythonSentinels=forcePythonSentinels,
        issuePathWarning=True)
    # Sets the following ivars:
        # at.default_directory
        # at.encoding
        # at.explicitLineEnding
        # at.language
        # at.output_newline
        # at.page_width
        # at.tab_width

    if toString:
        at.outputFile = g.fileLikeObject()
        if g.app.unitTesting:
            at.output_newline = '\n'
        # else: at.output_newline set in initCommonIvars.
        at.stringOutput = ""
        at.outputFileName = "<string-file>"
    else:
        at.outputFile = None # The temporary output file.
        # at.outputNewline set in initCommonIvars.
        at.stringOutput = None
        at.outputFileName = g.u('')

    # Init all other ivars even if there is an error.
    if not at.errors and at.root:
        if hasattr(at.root.v,'tnodeList'):
            delattr(at.root.v,'tnodeList')
        at.root.v._p_changed = True
#@+node:ekr.20110117113521.6105: *4* Fixed unit tests
@nocolor-node

Support @nonl in headlines in compareOutlines. This is another test of reformat
paragraph. And this is some.
#@+node:ekr.20110117145531.6151: *4* Don't change user's lines!
#@+node:ekr.20041005105605.161: *5* at.putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    trace = False and not g.unitTesting
    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.setVisited()
    if trace: g.trace('visit',p.h)
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if not at.thinFile:
        p.v.setWriteBit() # Mark the vnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    at.raw = False # 2007/07/04: Bug fix exposed by new sentinels.
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert next_i > i,'putBody'
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()

    if not trailingNewlineFlag:
        if at.writeVersion5:
            if at.sentinels:
                pass # Never write @nonl
            elif at.atAuto and not at.atEdit:
                at.onl() # 2010/08/01: bug fix: ensure newline here.
        else:
            if at.sentinels:
                at.putSentinel("@nonl")
            elif at.atAuto and not at.atEdit:
                # Ensure all @auto nodes end in a newline!
                at.onl()
#@+node:ekr.20041005105605.162: *6* << Make sure all lines end in a newline >>
@ If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@+node:ekr.20041005105605.163: *6* << handle line at s[i] >> (putBody)
if trace: g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert not at.pending,'putBody at.pending'
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    at.putSentinel("@verbatim")
    at.putIndent(at.indent)
    i = next_i
    next_i = g.skip_line(s,i)
    at.os(s[i:next_i])
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert 0,'putBody: unknown directive'
#@+node:ekr.20041005105605.174: *5* putCodeLine (leoAtFile)
def putCodeLine (self,s,i):

    '''Put a normal code line.'''

    trace = False and not g.unitTesting
    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')

    j = g.skip_line(s,i)
    line = s[i:j]

    if trace: g.trace(self.atShadow,repr(line))

    # Don't put any whitespace in otherwise blank lines.
    if len(line) > 1: # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent,line)

        if line[-1:]=='\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    else:
        g.trace('Can not happen: completely empty line')

#@+node:ekr.20101218103123.5938: *4* Fix bug 690260: g.es sends to wrong tabbed pane
#@+node:ekr.20101218103123.5939: *5* Report
@nocolor-node

I start Leo with 3 filenames, they open in tabs.
I execute a g.es() in the leftmost file tab, it writes to the
log pane for the file with it's tab on the right.

update:

Doesn't happen via ctl-b, does happen if the g.es() is in a @button.
Kent Tenney wrote on 2010-12-14: 	#2

upupdate:

doing a ctl-b in the left pane corrects it, after that the @button g.es()
targets the correct pane.
#@+node:ekr.20110120193351.5982: *4* Fixed goto-global-line problems
# The key was not to keep track of skipped lines.
# That is, we use a simpler invariant.
#@+node:ekr.20100216141722.5620: *5* class gotoLineNumber and helpers (commands)
class goToLineNumber:

    '''A class implementing goto-global-line.'''

    @others
#@+node:ekr.20100216141722.5621: *6*  __init__ (gotoLineNumber)
def __init__ (self,c):

    # g.trace('(c.gotoLineNumber)')
    self.c = c
    self.p = c.p.copy()
    self.isAtAuto = False
#@+node:ekr.20100216141722.5622: *6* go
def go (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self.c
    if n < 0: return

    if scriptData:
        fileName,lines,p,root = self.setup_script(scriptData)
    else:
        if not p: p = c.p
        fileName,lines,n,root = self.setup_file(n,p)

    self.isAtAuto = root and root.isAtAutoNode()
    isRaw = not root or (
        root.isAtEditNode() or root.isAtAsisFileNode() or
        root.isAtAutoNode() or root.isAtNoSentFileNode())
    ignoreSentinels = root and root.isAtNoSentFileNode()
    if not root:
        if scriptData:  root = p.copy()
        else:           root = c.p

    if isRaw:
        p,n2,found = self.countLines(root,n)
        n2 += 1 # Convert to one-based.
    else:
        vnodeName,gnx,n2,delim = self.findVnode(root,lines,n,ignoreSentinels)
        p,found = self.findGnx(delim,root,gnx,vnodeName)

    self.showResults(found,p or root,n,n2,lines)
    return found
#@+node:ekr.20100216141722.5623: *6* countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n (one based).
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False and not g.unitTesting
    c = self.c
    
    # if trace and not g.unitTesting and sys.platform.startswith('win'): os.system('cls')

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624: *7* countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n (zero-based).
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0
        # The index of the line being scanning in this node.
    effective_lines = 0
        # The number of "counted" lines including the present line i.
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n is alway the target line.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %3s effective %3s %s' % (
            i,effective_lines,line.rstrip()))
        if line.strip().startswith('@'):
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        if effective_lines2 > new_n:
                            if trace: g.trace(
                                '***oops! effective_lines2: %s, new_n: %s' % (
                                effective_lines2,new_n))
                            if g.unitTesting: assert False
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        else:
            # Bug fix 2011/01/21: use effective_lines, not i, in this comparison.
            # The line is now known to be effective.
            if effective_lines == n:
                if trace: g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
                return p,i,-1,True # effective_lines doesn't matter.
            else:
                effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@+node:ekr.20100216141722.5625: *7* countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*10,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            if trace: g.trace('Found! i2: %s %s' % (i2,child.h))
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            if effective_lines2 > new_n:
                if trace: g.trace(
                    '*** oops! effective_lines2: %s, new_n: %s n: %s %s' % (
                        effective_lines2,new_n,n,p.h))
                if g.unitTesting: assert False
            # i2 is not used
            effective_lines += effective_lines2
    
    if trace: g.trace('Not found. effective_lines: %s %s' % (
        effective_lines,p.h))
    return p,-1,effective_lines,False # i does not matter.
#@+node:ekr.20100216141722.5626: *6* findGnx
def findGnx (self,delim,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    trace = False and not g.unitTesting

    if delim and gnx:
        gnx = g.app.nodeIndices.scanGnx(gnx,0)
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(),True

        if trace: g.trace('not found! %s, %s' % (gnx,repr(vnodeName)))
        return None,False
    else:
        return root,False
#@+node:ekr.20100216141722.5627: *6* findRoot
def findRoot (self,p):

    '''Find the closest ancestor @<file> node, except @all nodes.

    return root, fileName.'''

    c = self.c ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions():
        if p.v == p1.v and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@+node:ekr.20100216141722.5628: *6* findVnode & helpers
def findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    trace = False and not g.unitTesting
    c = self.c
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    delim,readVersion5,thinFile = self.setDelimFromLines(lines)
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    nodeLine,offset = self.findNodeSentinel(delim,lines,n)
    if nodeLine == -1:
        if n < len(lines):
            # The line precedes the first @+node sentinel
            g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeLine]
    gnx,vnodeName = self.getNodeLineInfo(readVersion5,s,thinFile)
    if delim and vnodeName:
        if trace: g.trace('offset: %s, vnodeName: %s' % (offset,vnodeName))
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20100216141722.5629: *7* findNodeSentinel & helper
def findNodeSentinel(self,delim,lines,n):

    '''
    Scan backwards from the line n, looking for an @-body line. When found,
    get the vnode's name from that line and set p to the indicated vnode. This
    will fail if vnode names have been changed, and that can't be helped.

    We compute the offset of the requested line **within the found node**.
    '''

    c = self.c
    offset = 0 # This is essentially the Tk line number.
    nodeSentinelLine = -1
    line = n - 1 # Start with the requested line.
    while len(lines) > line >= 0 and nodeSentinelLine == -1:
        progress = line
        s = lines[line]
        i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            line,nodeSentinelLine,offset = self.handleDelim(
                delim,s,i,line,lines,n,offset)
        else:
            line -= 1
        assert nodeSentinelLine > -1 or line < progress
    return nodeSentinelLine,offset
#@+node:ekr.20100216141722.5630: *8* handleDelim
def handleDelim (self,delim,s,i,line,lines,n,offset):

    '''Handle the delim while scanning backward.'''

    trace = False and not g.unitTesting
    c = self.c
    if line == n:
        g.es("line",str(n),"is a sentinel line")
    i += len(delim)
    nodeSentinelLine = -1

    # This code works for both old and new sentinels.
    if g.match(s,i,"-node"):
        # The end of a nested section.
        old_line = line
        line = self.skipToMatchingNodeSentinel(lines,line,delim)
        assert line < old_line
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"+node"):
        if trace: g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"<<") or g.match(s,i,"@first"):
        line -= 1
    else:
        line -= 1
        nodeSentinelLine = -1
    return line,nodeSentinelLine,offset
#@+node:ekr.20100216141722.5631: *7* getNodeLineInfo & helper
def getNodeLineInfo (self,readVersion5,s,thinFile):

    i = 0 ; gnx = None ; vnodeName = None

    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:   gnx = s[i:j]
            else:       i = len(s) # Force an error.
        else:
            i = len(s) # Force an error.

    # old sentinels: vnode name is everything following the first or second':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
        if readVersion5: # new sentinels: remove level stars.
            vnodeName = self.removeLevelStars(vnodeName)
    else:
        vnodeName = None
        g.es_print("bad @+node sentinel",color='red')

    return gnx,vnodeName
#@+node:ekr.20100728074713.5843: *8* removeLevelStars
def removeLevelStars (self,s):

    i = g.skip_ws(s,0)

    # Remove leading stars.
    while i < len(s) and s[i] == '*':
        i += 1
    # Remove optional level number.
    while i < len(s) and s[i].isdigit():
        i += 1
    # Remove trailing stars.
    while i < len(s) and s[i] == '*':
        i += 1
    # Remove one blank.
    if i < len(s) and s[i] == ' ':
        i += 1

    return s[i:]
#@+node:ekr.20100216141722.5632: *7* setDelimFromLines
def setDelimFromLines (self,lines):

    c = self.c ; at = c.atFileCommands

    # Find the @+leo line.
    i = 0 
    while i < len(lines) and lines[i].find("@+leo")==-1:
        i += 1
    leoLine = i # Index of the line containing the leo sentinel

    # Set delim and thinFile from the @+leo line.
    delim,thinFile = None,False

    if leoLine < len(lines):
        s = lines[leoLine]
        valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
        readVersion5 = at.readVersion5

        # New in Leo 4.5.1: only support 4.x files.
        if valid and newDerivedFile:
            delim = start + '@'
    else:
        readVersion5 = False

    return delim,readVersion5,thinFile
#@+node:ekr.20100216141722.5633: *7* skipToMatchingNodeSentinel (no longer used)
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@+node:ekr.20100216141722.5634: *6* getFileLines (leoEditCommands)
def getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self.c
    isAtEdit = root.isAtEditNode()
    isAtNoSent = root.isAtNoSentFileNode()

    if isAtNoSent or isAtEdit:
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        kind = g.choose(isAtNoSent,'@nosent','@edit')
        at.write(root,kind=kind,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        path = g.scanAllAtPathDirectives(c,root)
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = self.openFile(fileName)

    return lines
#@+node:ekr.20100216141722.5635: *6* openFile (gotoLineNumber)
def openFile (self,filename):
    """
    Open a file and check if a shadow file exists.
    Construct a line mapping. This ivar is empty if no shadow file exists.
    Otherwise it contains a mapping, shadow file number -> real file number.
    """

    c = self.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@+node:ekr.20100216141722.5636: *6* setup_file
def setup_file (self,n,p):

    '''Return (lines,n) where:

    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    '''

    c = self.c ; x = c.shadowController

    root,fileName = self.findRoot(p)

    if root and fileName:
        c.shadowController.line_mapping = [] # Set by open.
        lines = self.getFileLines(root,fileName)
            # This will set x.line_mapping for @shadow files.
        if len(x.line_mapping) > n:
            n = x.line_mapping[n]
    else:
        if not g.unitTesting:
            g.es("no ancestor @<file node>: using script line numbers",
                color="blue")
        lines = g.getScript(c,p,useSelectedText=False)
        lines = g.splitLines(lines)

    return fileName,lines,n,root
#@+node:ekr.20100216141722.5637: *6* setup_script
def setup_script (self,scriptData):

    c = self.c

    p = scriptData.get('p')
    root,fileName = self.findRoot(p)
    lines = scriptData.get('lines')

    return fileName,lines,p,root
#@+node:ekr.20100216141722.5638: *6* showResults
def showResults(self,found,p,n,n2,lines):

    trace = False and not g.unitTesting
    c = self.c ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    if trace:
        i,j = g.getLine(s,ins)
        g.trace('found: %5s %2s %2s %15s %s' % (
            found,n,n2,p.h,repr(s[i:j])))  

    w.setInsertPoint(ins)
    c.bodyWantsFocus()
    w.seeInsertPoint()
#@+node:ekr.20100216141722.5623: *5* countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n (one based).
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False and not g.unitTesting
    c = self.c
    
    # if trace and not g.unitTesting and sys.platform.startswith('win'): os.system('cls')

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624: *6* countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n (zero-based).
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0
        # The index of the line being scanning in this node.
    effective_lines = 0
        # The number of "counted" lines including the present line i.
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n is alway the target line.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %3s effective %3s %s' % (
            i,effective_lines,line.rstrip()))
        if line.strip().startswith('@'):
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        if effective_lines2 > new_n:
                            if trace: g.trace(
                                '***oops! effective_lines2: %s, new_n: %s' % (
                                effective_lines2,new_n))
                            if g.unitTesting: assert False
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        else:
            # Bug fix 2011/01/21: use effective_lines, not i, in this comparison.
            # The line is now known to be effective.
            if effective_lines == n:
                if trace: g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
                return p,i,-1,True # effective_lines doesn't matter.
            else:
                effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@+node:ekr.20100216141722.5625: *6* countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*10,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            if trace: g.trace('Found! i2: %s %s' % (i2,child.h))
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            if effective_lines2 > new_n:
                if trace: g.trace(
                    '*** oops! effective_lines2: %s, new_n: %s n: %s %s' % (
                        effective_lines2,new_n,n,p.h))
                if g.unitTesting: assert False
            # i2 is not used
            effective_lines += effective_lines2
    
    if trace: g.trace('Not found. effective_lines: %s %s' % (
        effective_lines,p.h))
    return p,-1,effective_lines,False # i does not matter.
#@+node:ekr.20110124055400.12600: *4* Postions of non-tabbed windows are not restored
#@+node:ekr.20060919110638.36: *5* getWindowPositionAttributes
def getWindowPositionAttributes (self,attrs):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(c.mFileName)

    d = {}

    if g.enableDB and c.mFileName:
        d = c.cacher.getCachedWindowPositionDict(c.mFileName)

    if not d and c.fixed and c.fixedWindowPosition:
        width,height,left,top = c.fixedWindowPosition
        d = {'top':top,'left':left,'width':width,'height':height}

    if not d:
        for bunch in self.attrsToList(attrs):
            name = bunch.name ; val = bunch.val
            if name in ('top','left','width','height'):
                try:
                    d[name] = int(val)
                except ValueError:
                    d[name] = 100 # A reasonable default.
            else:
                g.trace(name,len(val))

    # if trace: g.trace(d)
    return d
#@+node:ekr.20100208082353.5922: *5* getCachedWindowPositionDict
def getCachedWindowPositionDict (self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        g.internalError('no commander')
        return {}

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)
    data = self.db.get('window_position_%s' % (key))

    if data:
        top,left,height,width = data
        top,left,height,width = int(top),int(left),int(height),int(width)
        d = {'top':top,'left':left,'height':height,'width':width}
    else:
        d = {}

    if trace: g.trace(fn,key,data)
    return d
#@+node:ekr.20060919110638.38: *5* startWinPos
def startWinPos (self,attrs):

    self.global_window_position = self.getWindowPositionAttributes(attrs)
#@+node:ekr.20110127085519.15074: *4* Fixed TL's Ctrl+U crash
@nocolor-node

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 1937, in makeMasterGuiBinding
    c.bind(w,bindStroke,masterBindKeyCallback)
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 6123, in bind
    w.bind(pattern,bindCallback,*args,**keys)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 985, in bind
    return self._bind(('bind', self._w), sequence, func, add)
  File "c:\python26\lib\lib-tk\Tkinter.py", line 940, in _bind
    self.tk.call(what + (sequence, cmd))
TclError: bad event type or keysym "Key+U"
#@+node:ekr.20061031131434.103: *5* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@+node:ekr.20110127085519.15075: *5* dump k.bindingsDict
aList = list(c.k.bindingsDict.keys())
aList.sort()
for z in aList: print(z)
#@+node:ekr.20061031131434.191: *5* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False,trace=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    # g.trace('*'*10,s,g.callers())
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06
    # g.trace(stroke,s)
    return g.choose(brief,s,'<%s>' % s)
#@+node:ekr.20061031131434.89: *5* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *6* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *6* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20110222090020.6060: *4* Fixed Python 3.2 ua problems
#@+node:ekr.20060919110638.7: *5* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
#@+node:ekr.20060919110638.8: *6* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
#@+node:ekr.20061004053644: *6* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
#@+node:EKR.20040627114602: *5* getDescendentUnknownAttributes
# Pre Leo 4.5 Only @thin vnodes had the descendentTnodeUnknownAttributes field.
# New in Leo 4.5: @thin & @shadow vnodes have descendentVnodeUnknownAttributes field.

def getDescendentUnknownAttributes (self,s,v=None):

    '''Unhexlify and unpickle t/v.descendentUnknownAttribute field.'''

    try:
        # Changed in version 3.2: Accept only bytestring or bytearray objects as input.
        s = g.toEncodedString(s) # 2011/02/22
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except:
        g.es_exception()
        g.trace('Can not unpickle',type(s),v and v.h,s[:40])
        return None
#@+node:ekr.20061003093021: *5* getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None


    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
#@+node:ekr.20110225061928.15452: *4* Fixed bug in p._adjustPostionBeforeUnlink and simplified code
#@+node:ekr.20110225061928.15456: *5*  Changed
#@+node:ekr.20040803140033.2: *6* c.rootPosition
def rootPosition(self):

    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """

    c = self

    # 2011/02/25: Compute the position directly.
    if c.hiddenRootNode.children:
        v = c.hiddenRootNode.children[0]
        return leoNodes.position(v,childIndex=0,stack=None)
    else:
        return c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
#@+node:ekr.20040803140033.1: *6* c.setCurrentPosition
_currentCount = 0

def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController

    if trace:
        c._currentCount += 1
        g.trace(c._currentCount,p)
        
    # Always recompute the root position.
    c.setRootPosition()

    if p and not c.positionExists(p): # 2011/02/25:
        g.internalError('Invalid position',p)
        c._currentPosition = c._rootPosition = c.rootPosition()
        if g.unitTesting: assert False,p
        return

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p == c._currentPosition:
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@+node:ekr.20040803140033.3: *6* c.setRootPosition
def setRootPosition(self,unused_p=None):

    """Set c._rootPosition."""

    c = self
    
    # 2011/02/25: There is no need to make a copy of the position.
    c._rootPosition = c.rootPosition()
    
    # Important: p.equal requires c._rootPosition to be non-None.
    # c.rootPosition() returns c.nullPosition() instead of None.
    assert c._rootPosition is not None
#@+node:ekr.20080427062528.4: *6* p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink (self,p2):

    '''Adjust position p before unlinking p2.'''

    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.

    trace = False and not g.unitTesting
    p = self ; sib = p.copy()

    if trace:
        g.trace('entry')
        g.trace('p ',p)
        g.trace('p2',p2)
        g.trace('p.stack',p.stack)

    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            if trace: g.trace('***new index: %s\n%s' % (
                p.h,p.stack))
            return

    # Adjust p's stack.
    stack = [] ; changed = False ; i = 0
    while i < len(p.stack):
        v,childIndex = p.stack[i]
        p3 = position(v=v,childIndex=childIndex,stack=stack[:i])
        while p3:
            if p2 == p3:
                # 2011/02/25: compare full positions, not just vnodes.
                # A match with the to-be-moved node.
                stack.append((v,childIndex-1),)
                changed = True
                break # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v,childIndex),)
        i += 1

    if changed:
        if trace: g.trace('***new stack: %s\n%s' % (
            p.h,stack))
        p.stack = stack
#@+node:ekr.20060920203352: *6* p.findRootPosition
def findRootPosition (self):
    
    # 2011/02/25: always use c.rootPosition
    p = self
    c = p.v.context
    return c.rootPosition()
#@+node:ekr.20110225061928.15450: *4* Fixed crash in archivedPositionToPosition

c:\leo.repo\trunk>python3 launchLeo.py --gui=qt leo\test\test.leo --gui=qttabs --no-cache
@nocolor-node


c:\leo.repo\trunk>c:\python32\python.exe launchLeo.py --gui=qt leo\test\test.leo --gui=qttabs --no-cache
*** isPython3: True
scanOptions: disabling caching
Traceback (most recent call last):
  File "launchLeo.py", line 8, in <module>
    leo.core.runLeo.run()
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 121, in run
    files,options = doPrePluginsInit(fileName,pymacs)
  File "c:\leo.repo\trunk\leo\core\runLeo.py", line 163, in doPrePluginsInit
    g.app.config.readSettingsFiles(fn,verbose)
  File "c:\leo.repo\trunk\leo\core\leoConfig.py", line 1876, in readSettingsFiles
    c = self.openSettingsFile(path)
  File "c:\leo.repo\trunk\leo\core\leoConfig.py", line 1963, in openSettingsFile
    theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 882, in open
    silent=silent)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 743, in getLeoFile
    self.setPositionsFromVnodes()
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 1400, in setPositionsFromVnodes
    current = self.archivedPositionToPosition(str_pos)
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 1407, in archivedPositionToPosition
    aList = s.split(',')
TypeError: Type str doesn't support the buffer API

c:\leo.repo\trunk>
#@+node:ekr.20061006104837.1: *5* archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
#@+node:ekr.20110227071546.15477: *4* Fixed top-level uA's
# There was a misspelling of 'unknownAttributes' in putVnode.
#@+node:ekr.20110227071546.15478: *5* Report
@nocolor-node

The uA for the first top level node in the outline is cleared on save
and by some copy paste op.s etc.

Easiest way to observe effect is to do Cmds -> Icons -> Insert-Icon and
make several copies, incl. on positioned at the top of the outline.
Depending on the order of copy paste you may have already seen the icon
disappear, if not Ctrl-S save and it will vanish.  I don't think it's
icon related though, I think uA is being cleared on this node.
#@+node:ekr.20040324080819.1: *5* putLeoFile & helpers
def putLeoFile (self):

    self.updateFixedStatus()
    self.putProlog()
    self.putHeader()
    self.putGlobals()
    self.putPrefs()
    self.putFindSettings()
    #start = g.getTime()
    self.putVnodes()
    #start = g.printDiffTime("vnodes ",start)
    self.putTnodes()
    #start = g.printDiffTime("tnodes ",start)
    self.putPostlog()
#@+node:ekr.20031218072017.3035: *6* putFindSettings
def putFindSettings (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<find_panel_settings/>")
    self.put_nl()
#@+node:ekr.20031218072017.3037: *6* putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.mFileName
    if use_db:
        if trace: g.trace(c.mFileName)
        c.cacher.setCachedGlobalsElement(c.mFileName)

    # Always put positions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038: *7* << put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@+node:ekr.20031218072017.3039: *7* << put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3040: *7* << put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3041: *6* putHeader
def putHeader (self):

    tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

    if 1: # For compatibility with versions before Leo 4.5.
        self.put("<leo_header")
        self.put(" file_format=") ; self.put_in_dquotes("2")
        self.put(" tnodes=") ; self.put_in_dquotes(str(tnodes))
        self.put(" max_tnode_index=") ; self.put_in_dquotes(str(0))
        self.put(" clone_windows=") ; self.put_in_dquotes(str(clone_windows))
        self.put("/>") ; self.put_nl()

    else:
        self.put('<leo_header file_format="2"/>\n')
#@+node:ekr.20031218072017.3042: *6* putPostlog
def putPostlog (self):

    self.put("</leo_file>") ; self.put_nl()
#@+node:ekr.20031218072017.2066: *6* putPrefs
def putPrefs (self):

    # New in 4.3:  These settings never get written to the .leo file.
    self.put("<preferences/>")
    self.put_nl()
#@+node:ekr.20031218072017.1246: *6* putProlog
def putProlog (self):

    c = self.c

    self.putXMLLine()

    if c.config.stylesheet or c.frame.stylesheet:
        self.putStyleSheetLine()

    self.put("<leo_file>") ; self.put_nl()
#@+node:ekr.20031218072017.1248: *6* putStyleSheetLine
def putStyleSheetLine (self):

    c = self.c

    # The stylesheet in the .leo file takes precedence over the default stylesheet.
    self.put("<?xml-stylesheet ")
    self.put(c.frame.stylesheet or c.config.stylesheet)
    self.put("?>")
    self.put_nl()
#@+node:ekr.20031218072017.1577: *6* putTnode
def putTnode (self,v):

    # Call put just once.
    gnx = g.app.nodeIndices.toString(v.fileIndex)
    ua = hasattr(v,'unknownAttributes') and self.putUnknownAttributes(v) or ''
    b = v.b
    if b:
        body = xml.sax.saxutils.escape(b)
    else:
        body = ''

    self.put('<t tx="%s"%s>%s</t>\n' % (gnx,ua,body))
#@+node:ekr.20031218072017.1575: *6* putTnodes
def putTnodes (self):

    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("<tnodes>\n")
    << write only those tnodes that were referenced >>
    self.put("</tnodes>\n")
#@+node:ekr.20031218072017.1576: *7* << write only those tnodes that were referenced >>
if self.usingClipboard: # write the current tree.
    theIter = c.p.self_and_subtree()
else: # write everything
    theIter = c.all_unique_positions()

# Populate tnodes
tnodes = {}
nodeIndices = g.app.nodeIndices
for p in theIter:
    # Make *sure* the file index has the proper form.
    # g.trace(p.v.fileIndex)
    try:
        theId,t,n = p.v.fileIndex
    except ValueError:
        try:
            theId,t,n = p.v.fileIndex,''
        except Exception:
            raise BadLeoFile('bad p.v.fileIndex' % repr(p.v.fileIndex))

    if n is None:
        n = g.u('0')
    elif g.isPython3:
        n = str(n)
    else:
        n = unicode(n)
    index = theId,t,n
    tnodes[index] = p.v

# Put all tnodes in index order.
for index in sorted(tnodes):
    # g.trace(index)
    v = tnodes.get(index)
    if v:
        # Write only those tnodes whose vnodes were written.
        if v.isWriteBit():
            self.putTnode(v)
    else:
        g.trace('can not happen: no vnode for',repr(index))
        # This prevents the file from being written.
        raise BadLeoFile('no vnode for %s' % repr(index))
#@+node:ekr.20031218072017.1863: *6* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *7* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *7* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *7* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *7* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20031218072017.1579: *6* putVnodes
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>\n")

    # Make only one copy for all calls.
    self.currentPosition = c.p 
    self.rootPosition    = c.rootPosition()
    # self.topPosition     = c.topPosition()
    self.vnodesDict = {}

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("</vnodes>\n")
#@+node:ekr.20031218072017.1247: *6* putXMLLine
def putXMLLine (self):

    '''Put the **properly encoded** <?xml> element.'''

    # Use self.leo_file_encoding encoding.
    self.put('%s"%s"%s\n' % (
        g.app.prolog_prefix_string,
        self.leo_file_encoding,
        g.app.prolog_postfix_string))
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # 2010/09/02: @edit nodes must not have children.
        # If they do, the entire tree is written to the outline.
    isFile   = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin   = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    # 2010/10/22: force writes of orphan @edit, @auto and @shadow trees.
    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = isOrphan  # Force write of orphan @auto trees.
    elif isEdit:   forceWrite = isOrphan  # Force write of orphan @edit trees.
    elif isFile:   forceWrite = isOrphan  # Force write of orphan @file trees.
    elif isShadow: forceWrite = isOrphan  # Force write of @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Force write of  orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren() and c.putBitsFlag:
        attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = v.u
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    v.u = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20110228083015.14114: *4* fixed bug in g.printGcAll
@nocolor-node

ERROR: runTest (leo.core.leoTest.generalTestCase)
@test g.printGcAll

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoTest.py", line 177, in runTest
    exec(script,d)
  File "<string>", line 3, in <module>
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 2798, in printGcAll
    d[t] = d.get(t,0) + 1
TypeError: unhashable type: 'ProxyType'
#@+node:ekr.20110228083015.14113: *4* mod_autosave plugin does not register redundant idle-time handlers
@nocolor-node

while I was experimenting with registering handler for "idle" events,
I have noticed
that there were about 40 registered handlers for "idle" event. What
was most interesting is the fact that those handlers were all about
the same function onIdle in mod_autosave plugin. At first I thought
that handler is registering itself over and over, but when I looked in
the source I couldn't find anything suspicious.

So I made small script to print number of registered handlers and
manually executed it from time to time to see when it increases.

g.es(len(g.app.pluginsController.getHandlersForOneTag("idle")))

Finally, I realized that every time when I invoke unit test command Alt
+5, number of registered handlers increased.

From the above it is obvious that I have enabled plugin mod_autosave.
From the Log
Leo Log Window
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.6, qt version 4.7.0
linux2

#@+node:ekr.20110227200312.15373: *4* Fixed bug 568452 re local @settings
@nocolor-node

file local @settings ignored if file opened from command line with absolute path

Report:
    
Given

  LEOPATH=/home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk
  HOME=/tmp python $LEOPATH/launchLeo.py foo/bar.leo

@settings in bar.leo are honored., but with

  HOME=/tmp python $LEOPATH/launchLeo.py /home/tbrown/Desktop/leotest/foo/bar.leo

(i.e. absolute path to same file), they're ignored.

(LEOPATH has nothing to do with anything here, just trying to make the example more clear)
#@+node:ekr.20041120064303: *5* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose or trace
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *6* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *6* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),table)
    return table
#@+node:ekr.20041117085625: *6* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20101125041212.5846: *4* Fixed bug: ignore f-keys in find/replace patterns
#@+node:ekr.20060125093807: *5* searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@+node:ekr.20060210173041: *5* stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@+node:ekr.20061031131434.128: *5* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129: *6* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@+node:ekr.20101218103123.5932: *3* Docs
#@+node:ekr.20101214101416.5950: *4* Creating minimal outlines
#@+node:ekr.20101214101416.5951: *5* script
import leo.core.leoGui as leoGui
nullGui = leoGui.nullGui("nullGui")
c2,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,gui=nullGui)
c2.frame.createFirstTreeNode()
for p in c2.all_positions():
    g.es(p.h)
#@+node:ekr.20031218072017.1623: *5* c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)
    g.doHook("new",old_c=self,c=c,new_c=c)
    g.app.unlockLog()

    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.redraw()
    return c # For unit test.
#@+node:ekr.20031218072017.2188: *5* app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,
        relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c)
            # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
#@+node:ekr.20031218072017.2189: *6* << compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@+node:ekr.20110111100539.9727: *4* Docs fixes
@nocolor-node

(Fixed) Using ZODB with Leo — Leo v4.8 documentation
http://diigo.com/0dw79

(Fixed) Embedding Leo with the leoBridge module — Leo v4.8 documentation
http://diigo.com/0dw77
#@+node:ekr.20101218103123.5931: *3* Features
#@+node:ekr.20101127152442.5915: *4* Improved handling of @url nodes
@nocolor-node

The new rule is simple: if the body text contains any text the first line of the
body text is taken to be the url. There is no longer any need to put '--' in the
headline.

More importantly, you can put anything you like in the body text following the
first line. Other url's, notes, even .. graphics:: directives for the
viewrendered plugin.

These improvements allow Leo to be what it should have been a long time ago: the
world's best organizer of url's. My typical usage is::

    @url fizbatz: short description of fizbatz (headline)
    http://fizbatz.org (body text)
    @language rest
    Why I care about fizbatz.
#@+node:ekr.20031218072017.2312: *5* tree.OnIconDoubleClick (@url) & helper
# Several plugins handle url's, especially UNL.py.

def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b.strip():
            lines = p.b.split('\n',1)
            url = lines and lines[0].strip() or ''
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())

        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url, c=c, p=p)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@+node:ekr.20110119063247.6086: *4* Improved clean-all-lines command
@nocolor-node

It is now much faster and has better feedback.
#@+node:ekr.20060415112257: *5* cleanLines
def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20070325094935: *5* cleanAllLines
def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.p ; u = c.undoer
    w = c.frame.body.bodyCtrl
    if not w: return

    tag = 'clean-all-lines'
    u.beforeChangeGroup(c.p,tag)
    n = 0
    # g.es('cleaning',c.p.h)
    for p in c.p.self_and_subtree():
        lines = []
        for s in g.splitLines(p.b):
            if s.strip():
                lines.append(s)
            else:
                # Ensures a trailing newline.
                lines.append('\n')
        s2 = ''.join(lines)
        if s2 != p.b:
            print(p.h)
            bunch = u.beforeChangeNodeContents(p,oldBody=p.b,oldHead=p.h)
            p.b = s2
            p.v.setDirty()
            n += 1
            u.afterChangeNodeContents(p,tag,bunch)

    u.afterChangeGroup(c.p,tag)
    c.redraw_after_icons_changed()
    g.es('cleaned %s nodes' % n)
#@+node:ekr.20110120114224.12563: *4* The first loaded file sets tabbed gui size
#@+node:ekr.20110122083721.12582: *5* Reading...
#@+node:ekr.20090519143741.5917: *6* doPostPluginsInit & helpers (runLeo.py)
def doPostPluginsInit(args,files,options):

    '''Return True if the frame was created properly.'''

    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,c1,fileName = None,None,None
    for fileName in files:
        c,frame = createFrame(fileName,options)
        if frame:
            if not c1: c1 = c
        else:
            g.trace('createFrame failed',repr(fileName))
            return False
          
    # Put the focus in the first-opened file.  
    if not c:
        c,frame = createFrame(None,options)
        c1 = c
        if c and frame:
            fileName = c.fileName()
        else:
            g.trace('createFrame failed 2')
            return False
            
    # For qttabs gui, select the first-loaded tab.
    if hasattr(g.app.gui,'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory,'setTabForCommander'):
            c = c1
            factory.setTabForCommander(c)

    # Do the final inits.
    c.setLog() # 2010/10/20
    g.app.logInited = True # 2010/10/20
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)

    screenshot_fn = options.get('screenshot_fn')
    if screenshot_fn:
        make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.

    return True
#@+node:ekr.20031218072017.1624: *7* createFrame & helpers (runLeo.py)
def createFrame (fileName,options):

    """Create a LeoFrame during Leo's startup process."""
    
    # g.trace('(runLeo.py)',fileName)

    script = options.get('script')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        c2 = frame.c
        select = options.get('select')
        windowSize = options.get('windowSize')
        if select: doSelect(c2,select)
        if windowSize: doWindowSize(c2,windowSize)
        if ok: return c2,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        initEditCommanders=True)

    if not script:
        g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20100913171604.5888: *8* doSelect
def doSelect (c,s):

    '''Select the node with key s.'''

    p = findNode(c,s)

    if p:
        c.selectPosition(p)
    else:
        g.es_print('--select: not found:',s)
#@+node:ekr.20100913171604.5885: *8* doWindowSize
def doWindowSize (c,windowSize):

    w = c.frame.top

    try:
        h,w2 = windowSize.split('x')
        h,w2 = int(h.strip()),int(w2.strip())
        w.resize(w2,h) # 2010/10/08.
        c.k.simulateCommand('equal-sized-panes')
        c.redraw()
        w.repaint() # Essential
    except Exception:
        print('doWindowSize:unexpected exception')
        g.es_exception()
#@+node:ekr.20100913171604.5889: *8* findNode
def findNode (c,s):

    s = s.strip()

    # First, assume s is a gnx.
    for p in c.all_unique_positions():
        if p.gnx.strip() == s:
            return p

    for p in c.all_unique_positions():
        # g.trace(p.h.strip())
        if p.h.strip() == s:
            return p

    return None
#@+node:ekr.20080921060401.5: *7* finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
#@+node:ekr.20080921060401.6: *7* initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@+node:ekr.20100914142850.5894: *7* make_screen_shot
def make_screen_shot(fn):

    '''Create a screenshot of the present Leo outline and save it to path.'''

    # g.trace('runLeo.py',fn)

    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20040411081633: *7* startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@+node:ekr.20110122083721.12583: *5* Writing...
#@+node:ekr.20031218072017.3037: *6* putGlobals
# Changed for Leo 4.0.

def putGlobals (self):

    trace = False and not g.unitTesting
    c = self.c

    use_db = g.enableDB and c.mFileName
    if use_db:
        if trace: g.trace(c.mFileName)
        c.cacher.setCachedGlobalsElement(c.mFileName)

    # Always put positions, to trigger sax methods.
    self.put("<globals")
    << put the body/outline ratios >>
    self.put(">") ; self.put_nl()
    << put the position of this frame >>
    << put the position of the log window >>
    self.put("</globals>") ; self.put_nl()
#@+node:ekr.20031218072017.3038: *7* << put the body/outline ratios >>
self.put(" body_outline_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.ratio)))

self.put(" body_secondary_ratio=")
self.put_in_dquotes(g.choose(c.fixed or use_db,"0.5","%1.2f" % (
    c.frame.secondary_ratio)))

if trace: g.trace('fixed or use_db',c.fixed or use_db,
    '%1.2f %1.2f' % (c.frame.ratio,c.frame.secondary_ratio))
#@+node:ekr.20031218072017.3039: *7* << put the position of this frame >>
# New in Leo 4.5: support fixed .leo files.

if c.fixed or use_db:
    width,height,left,top = 700,500,50,50
        # Put fixed, immutable, reasonable defaults.
        # Leo 4.5 and later will ignore these when reading.
        # These should be reasonable defaults so that the
        # file will be opened properly by older versions
        # of Leo that do not support fixed .leo files.
else:
    width,height,left,top = c.frame.get_window_info()

# g.trace(width,height,left,top)

self.put_tab()
self.put("<global_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20031218072017.3040: *7* << put the position of the log window >>
top = left = height = width = 0 # no longer used

self.put_tab()
self.put("<global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(str(top))
self.put(" left=") ; self.put_in_dquotes(str(left))
self.put(" height=") ; self.put_in_dquotes(str(height))
self.put(" width=") ; self.put_in_dquotes(str(width))
self.put("/>") ; self.put_nl()
#@+node:ekr.20100208082353.5929: *6* setCachedGlobalsElement
def setCachedGlobalsElement(self,fn):

    trace = False and not g.unitTesting
    c = self.c

    if not c:
        return g.internalError('no commander')

    globals_tag = g.choose(g.isPython3,'leo3k.globals','leo2k.globals')
    key = self.fileKey(fn,globals_tag)

    if trace: g.trace(c.mFileName,key,g.callers(5))

    self.db['body_outline_ratio_%s' % key] = str(c.frame.ratio)
    self.db['body_secondary_ratio_%s' % key] = str(c.frame.secondary_ratio)
    if trace: g.trace('ratios: %1.2f %1.2f' % (
        c.frame.ratio,c.frame.secondary_ratio))

    width,height,left,top = c.frame.get_window_info()

    self.db['window_position_%s' % key] = (
        str(top),str(left),str(height),str(width))
    if trace:
        g.trace('top',top,'left',left,'height',height,'width',width)
#@+node:ekr.20110210081557.15387: *4* Show sources in print-bindings
#@+node:ekr.20061031131434.88: *5* Binding (keyHandler)
#@+node:ekr.20061031131434.89: *6* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *7* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *7* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.93: *6* bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):

    k = self
    d =  k.masterBindingsDict.get(pane,{})

    stroke = g.stripBrackets(stroke)

    # if commandName == 'full-command':
        # g.trace('%-4s %-18s %-40s %s' % (
            # pane,repr(stroke),commandName,func and func.__name__),g.callers())

    # New in Leo 4.4.1: Allow redefintions.
    d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
    k.masterBindingsDict [pane] = d
#@+node:ekr.20061031131434.94: *6* bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@+node:ekr.20061031131434.95: *6* checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@+node:ekr.20070218130238: *6* dumpMasterBindingsDict
def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            b = d2.get(key2)
            g.pr('%20s %s' % (key2,b.commandName))
#@+node:ekr.20061031131434.96: *6* k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,'Alt+Key-4' in d)

    for stroke in d:
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20061031131434.97: *6* k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
#@+node:ekr.20061031131434.98: *6* k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.99: *6* k.initAbbrev
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
#@+node:ekr.20061031131434.100: *6* addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d:

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace(f.__name__,key)
#@+node:ekr.20061031131434.101: *6* initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@+node:ekr.20061031131434.102: *6* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *7* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20061031131434.103: *6* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@+node:ekr.20110210081557.15393: *5* Printing...
#@+node:ekr.20070418073400: *6* g.app.config.printSettings
def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in self.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    g.es('',''.join(result),tabName='Settings')
#@+node:ekr.20061031131434.119: *6* k.printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[S] leoSettings.leo
[ ] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode
'''
    legend = g.adjustTripleString(legend,c.tab_width)

    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            s4 = b.get('_hash','<no hash>')
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120: *7* printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.

    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3,s4 in data:
            
            # 2011/02/10: Print the source of the binding: s4 is the _hash.
            s4 = s4.lower()
            if s4.endswith('myleosettings.leo'):
                letter = 'M'
            elif s4.endswith('leosettings.leo'):
                letter = 'S'
            elif s4.endswith('.leo'):
                letter = 'F'
            elif s4.find('mode') != -1:
                letter = '@' # the full mode.
            else:
                letter = ' '
            
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%s %*s %*s %s\n' % (letter,-n1,s1,-(min(12,n2)),s2,s3))
#@+node:ekr.20110210081557.15392: *5* Reading settings
#@+node:ekr.20041119203941.3: *6* class settingsTreeParser (parserBaseClass)
class settingsTreeParser (parserBaseClass):

    '''A class that inits settings found in an @settings tree.

    Used by read settings logic.'''

    @others
#@+node:ekr.20041119204103: *7* ctor
def __init__ (self,c,localFlag=True):

    # Init the base class.
    parserBaseClass.__init__(self,c,localFlag)
#@+node:ekr.20041119204714: *7* visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.h)

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.h)
    kind = munge(kind)

    if g.isPython3:
        isNone = val in ('None','none','',None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','',None)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    # elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
    elif kind in self.basic_types and isNone:
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p,kind,name,val)
            except Exception:
                g.es_exception()
        else:
            g.pr("*** no handler",kind)

    return None
#@+node:ekr.20041120064303: *6* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose or trace
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *7* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *7* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),table)
    return table
#@+node:ekr.20041117085625: *7* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *7* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20041117083857.1: *6* g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    trace = False and not g.unitTesting
    if trace: g.trace('localFlag: %5s %s' % (localFlag, c and c.shortFileName()))

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
#@+node:ekr.20041120105609: *6* doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    verbose = False
    theHash = d.get('_hash')
    theHash = g.choose(theHash,g.shortFileName(theHash),'<no hash>')
    if trace: g.trace('localFlag: %s d._hash: %s %s' % (
        self.localFlag,theHash,c.shortFileName()))
    munge = k.shortcutFromSetting
    if s is None: s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                bunch._hash = theHash # 2011/02/10
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace and verbose: g.trace('****** killing binding:',
                            bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace and verbose: g.trace('%6s %20s %s' % (
                            bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    # if name in ('full-command'):
                        # g.trace('id(self.shortcutsDict)',id(d),bunchList)
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@+node:ekr.20110210081557.15394: *5* Remembering the source of bindings
#@+node:ekr.20041120105609: *6* doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    c = self.c ; d = self.shortcutsDict ; k = c.k
    trace = False or c.config.getBool('trace_bindings_verbose')
    verbose = False
    theHash = d.get('_hash')
    theHash = g.choose(theHash,g.shortFileName(theHash),'<no hash>')
    if trace: g.trace('localFlag: %s d._hash: %s %s' % (
        self.localFlag,theHash,c.shortFileName()))
    munge = k.shortcutFromSetting
    if s is None: s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                bunch._hash = theHash # 2011/02/10
                if bunch.val not in (None,'none','None'):
                    # A regular shortcut.
                    bunchList = d.get(name,[])
                    if bunch.pane in ('kill','Kill'):
                        if trace and verbose: g.trace('****** killing binding:',
                            bunch.val,'to',name)
                        bunchList = [z for z in bunchList
                            if munge(z.val) != munge(bunch.val)]
                        # g.trace(bunchList)
                    else:
                        if trace and verbose: g.trace('%6s %20s %s' % (
                            bunch.pane,bunch.val,name))
                        bunchList.append(bunch)
                    d [name] = bunchList
                    # if name in ('full-command'):
                        # g.trace('id(self.shortcutsDict)',id(d),bunchList)
                    self.set(p,"shortcut",name,bunchList)
                    self.setShortcut(name,bunchList)
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20041119204700.1: *6* traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {'_hash': c.hash()} # 2011/02/10
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.h)
            # if p.h == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.h,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@+node:ekr.20060102103625.1: *6* doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    c = self.c ; k = c.k ; name1 = name

    # g.trace('%20s' % (name),c.fileName())
    modeName = self.computeModeName(name)

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {'_hash':modeName,} # 2011/02/10

    s = p.b
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,name1,d)
#@+node:ekr.20110210081557.15395: *5* Calls to k.bindKey
# Added _hash keyword arg to bindKey.
#@+node:ekr.20061031131434.89: *6* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *7* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *7* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.131: *6* k.registerCommand
def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    # if commandName == 'full-command': g.trace(commandName,func.__name__)
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    if trace: g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName,g.callers(4))
        ok = k.bindKey (pane,stroke,func,commandName,_hash='register-command') # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif trace and verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20061031131434.102: *6* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *7* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20110227200312.15374: *4* Open leoSettings.leo only once
#@+node:ekr.20090519143741.5915: *5* doPrePluginsInit & helpers
def doPrePluginsInit(fileName,pymacs):

    ''' Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    options = scanOptions()

    # Post-process the options.
    fileName2 = options.get('fileName')
    if fileName2: fileName = fileName2

    if pymacs:
        options['script'] = script = None
        options['windowFlag'] = False
    else:
        script = options.get('script')
    verbose = script is None

    # Init the app.
    initApp(verbose)
    files = getFiles(fileName2)
    reportDirectories(verbose)

    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(None,verbose)
    for fn in files:
        g.app.config.readSettingsFiles(fn,verbose)

    if not files and not script:
        # This must be done *after* the standard settings have been read.
        fn = getDefaultFile()
        if fn:
            files = [fn]
            g.app.config.readSettingsFiles(fn,verbose=True)

    g.app.setGlobalDb()
    createGui(pymacs,options)

    # if no gui specified on command line, and qt not installed
    # set options['gui'] to 'tk' to match reality
    if g.app.guiArgName == 'tk':
        options['gui'] = 'tk'

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    versionFlag = options.get('versionFlag')
    if versionFlag:
        print(g.app.signon)
    if versionFlag or not g.app.gui:
        options['exit'] = True

    return files,options
#@+node:ekr.20100914142850.5892: *6* createGui & helper
def createGui(pymacs,options):

    gui = options.get('gui')
    windowFlag = options.get('windowFlag')
    script = options.get('script')

    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)

#@+node:ekr.20080921060401.4: *6* createSpecialGui
def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
#@+node:ekr.20070306085724: *6* adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
#@+node:ekr.20041124083125: *6* completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName
#@+node:ekr.20101021101942.6010: *6* getDefaultFile
def getDefaultFile ():

    # Get the name of the workbook.
    fn = g.app.config.getString(c=None,setting='default_leo_file')
    fn = g.os_path_finalize(fn)
    if not fn: return

    # g.trace(g.os_path_exists(fn),fn)

    if g.os_path_exists(fn):
        return fn
    elif g.os_path_isabs(fn):
        # Create the file.
        g.es_print('Using default leo file name:\n%s' % (fn),color='red')
        return fn
    else:
        # It's too risky to open a default file if it is relative.
        return None
#@+node:ekr.20101020125657.5976: *6* getFiles
def getFiles(fileName):

    files = []
    if fileName:
        files.append(fileName)

    for arg in sys.argv[1:]:
        if not arg.startswith('-'):
            files.append(arg)

    files = [completeFileName(z) for z in files]
    return files
#@+node:ekr.20080921091311.2: *6* initApp
def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.pluginsController.finishCreate() # 2010/09/09
#@+node:ekr.20041130093254: *6* reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@+node:ekr.20091007103358.6061: *6* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    add = parser.add_option
    add('-c', '--config', dest="one_config_path",
        help = 'use a single configuration file')
    add('--debug',        action="store_true",dest="debug",
        help = 'enable debugging support')
    add('-f', '--file',   dest="fileName",
        help = 'load a file at startup')
    add('--gui',
        help = 'gui to use (qt/tk/qttabs)')
    add('--minimized',    action="store_true",
        help = 'start minimized (Qt only)')
    add('--maximized',    action="store_true",
        help = 'start maximized (Qt only)')
    add('--fullscreen',   action="store_true",
        help = 'start fullscreen (Qt only)')
    add('--ipython',      action="store_true",dest="use_ipython",
        help = 'enable ipython support')
    add('--no-cache',     action="store_true",dest='no_cache',
        help = 'disable reading of cached files')
    add('--silent',       action="store_true",dest="silent",
        help = 'disable all log messages')
    add('--screen-shot',  dest='screenshot_fn',
        help = 'take a screen shot and then exit')
    add('--script',       dest="script",
        help = 'execute a script and then exit')
    add('--script-window',dest="script_window",
        help = 'open a window for scripts')
    add('--select',       dest='select',
        help='headline or gnx of node to select')
    add('--version',      action="store_true",dest="version",
        help='print version number and exit')
    add('--window-size',  dest='window_size',
        help='initial window size in height x width format')

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions:',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        print('scanOptions: *** debug mode on')

    # -f or --file
    fileName = options.fileName
    if fileName:
        fileName = fileName.strip('"')
        if trace: print('scanOptions:',fileName)

    # --gui
    gui = options.gui

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
            g.app.qt_use_tabs = False
        else:
            print('scanOptions: unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
            g.app.qt_use_tabs = True
    else:
        gui = g.app.guiArgName = 'qt'
        g.app.qt_use_tabs = True

    assert gui == g.app.guiArgName

    # --minimized
    # --maximized
    # --fullscreen
    g.app.start_minimized = options.minimized
    g.app.start_maximized = options.maximized
    g.app.start_fullscreen = options.fullscreen

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        print('scanOptions: disabling caching')
        g.enableDB = False

    # --screen-shot=fn
    screenshot_fn = options.screenshot_fn
    if screenshot_fn:
        screenshot_fn = screenshot_fn.strip('"')
        if trace: print('scanOptions: screenshot_fn',screenshot_fn)

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
        # print('script_name',repr(script_name))
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --select
    select = options.select
    if select:
        select = select.strip('"')
        if trace: print('scanOptions: select',repr(select))

    # --silent
    g.app.silentMode = options.silent
    # print('scanOptions: silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # --window-size
    windowSize = options.window_size
    if windowSize:
        if trace: print('windowSize',repr(windowSize))
        try:
            h,w = windowSize.split('x')
        except ValueError:
            windowSize = None
            g.trace('bad --window-size:',size)

    # Compute the return values.
    windowFlag = script and script_path_w
    return {
        'fileName':fileName,
        'gui':gui,
        'screenshot_fn':screenshot_fn,
        'script':script,
        'select':select,
        'version':versionFlag,
        'windowFlag':windowFlag,
        'windowSize':windowSize,
    }
#@+node:ekr.20041120064303: *5* readSettingsFiles & helpers (g.app.config)
def readSettingsFiles (self,fileName,verbose=True):

    '''Read settings from one file of the standard settings files.'''

    trace = False and not g.unitTesting
    verbose = verbose or trace
    giveMessage = (verbose and not g.app.unitTesting and
        not self.silent and not g.app.batchMode)
    def message(s):
        # This occurs early in startup, so use the following.
        if not g.isPython3:
            s = g.toEncodedString(s,'ascii')
        g.es_print(s,color='blue')
    self.write_recent_files_as_needed = False # Will be set later.
    localConfigFile = self.getLocalConfigFile(fileName)
    if trace: g.trace(fileName,localConfigFile)
    table = self.defineSettingsTable(fileName,localConfigFile)
    for path,localFlag in table:
        assert path and g.os_path_exists(path)
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or path.endswith('.leo')
        if isLeo:
            c = self.openSettingsFile(path)
            if c:
                if giveMessage:
                    message('reading settings in %s' % path)
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool(
                    'write_recent_files_as_needed')
            else:
                if giveMessage:
                    message('error reading settings in %s' % path)

    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20101021041958.6008: *6* getLocalConfigFile
# This can't be done in initSettingsFiles because
# the local directory does not yet exist.

def getLocalConfigFile (self,fileName):

    if not fileName:
        return None

    theDir = g.os_path_dirname(fileName)
    path = g.os_path_join(theDir,'leoSettings.leo')

    if g.os_path_exists(path):
        return path
    else:
        return None
#@+node:ekr.20101021041958.6004: *6* defineSettingsTable
def defineSettingsTable (self,fileName,localConfigFile):

    trace = False and not g.unitTesting

    global_table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        # (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        # (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
    )

    if fileName:
        if fileName.lower().endswith('leosettings.leo'):
            # 2011/02/28: don't read leoSettings.leo or myLeoSetings.leo twice.
            # This allows myLeoSettings.leo to take precedence.
            table1 = []
        else:
            path = g.os_path_finalize(fileName)
            theDir = g.os_path_dirname(fileName)
            myLocalConfigFile = g.os_path_join(theDir,'myLeoSettings.leo')
            local_table = (
                (localConfigFile,False),
                (myLocalConfigFile,False),
            )
            if trace:
                g.trace('localConfigFile:  ',localConfigFile)
                g.trace('myLocalConfigFile:',myLocalConfigFile)
    
            table1 = [z for z in local_table if z not in global_table]
            table1.append((path,True),)
    else:
        table1 = global_table

    seen = [] ; table = []
    for path,localFlag in table1:
        if trace: g.trace('exists',g.os_path_exists(path),path)
        if path and g.os_path_exists(path):
            # Make sure we mark files seen no matter how they are specified.
            path = g.os_path_realpath(g.os_path_finalize(path))
            if path.lower() not in seen:
                seen.append(path.lower())
                table.append((path,localFlag),)
    if trace: g.trace(repr(fileName),table)
    return table
#@+node:ekr.20041117085625: *6* openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@+node:ekr.20051013161232: *6* updateSettings
def updateSettings (self,c,localFlag):

    # g.trace(localFlag,c)

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and list(d.keys()))
#@+node:ekr.20110125142807.17268: *4* Added save-all command
@nocolor-node

Saves all changed windows. 
#@+node:ekr.20031218072017.2834: *5* c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll(w)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll(c.frame.body.bodyCtrl)
    else:
        c.treeWantsFocus()
#@+node:ekr.20110228162720.13980: *5* c.saveAll
def saveAll (self,event=None):
    
    '''Save all open tabs windows/tabs.'''
    
    for f in g.app.windowList:
        c = f.c
        if c.isChanged():
            c.save()
            
    # Restore the present tab.
    c = self
    dw = c.frame.top # A DynamicWindow
    dw.select(c)
#@+node:ekr.20031218072017.1720: *5* save (fileCommands)
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)

    if ok is None:
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        c.cacher.save(fileName,changeName=True)
        ok = c.checkFileTimeStamp(fileName)
        if ok:
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            self.putSavedMessage(fileName)
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@+node:ekr.20031218072017.2989: *5* c.setChanged
def setChanged (self,changedFlag):

    trace = False and not g.unitTesting
    c = self
    if not c.frame: return
    c.changed = changedFlag
    if c.loading: return # don't update while loading.

    if trace: g.trace(changedFlag,g.callers())

    # Clear all dirty bits _before_ setting the caption.
    if not changedFlag:
        for v in c.all_unique_nodes():
            if v.isDirty():
                v.clearDirty()

    if g.app.qt_use_tabs and hasattr(c.frame,'top'):
        c.frame.top.master.setChanged(c,changedFlag)

    s = c.frame.getTitle()
    if len(s) > 2:
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@+node:ekr.20110202094848.12571: *3* Vim...
#@+node:ekr.20060927173836.6: *4* Give warning when unbound key ends a mode
#@+node:ekr.20091230094319.6244: *5* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20110210115239.15392: *4* Improved redefining messages
#@+node:ekr.20061031131434.102: *5* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *6* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@+node:ekr.20061031131434.89: *5* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *6* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *6* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20110209083917.15999: ** Simple vim bindings
@language python
#@+node:ekr.20110209093958.15408: *3* To do
@nocolor-node

- Test with tk.  One test fails:  @test leoTree is a subset of leoTkTree.

- (not needed) @shortcuts node that kills all bindings.

- (done) Show source of bindings in print-bindings.

- (done) Improve conflict messages.
#@+node:ekr.20090629183608.8445: *3* Cursors
@nocolor-node

Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
#@+node:ekr.20061031131434.123: *4* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.133: *4* setInputState
def setInputState (self,state):

    k = self
    k.unboundKeyAction = state



#@+node:ekr.20061031131434.192: *4* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20110202111105.15439: *4* showStateCursor
def showStateCursor (self,state,w):
    
    # g.trace(state,w)
    
    pass
    
    
#@+node:ekr.20061031131434.146: *3* masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
            
    # if stroke == 'Tab': g.pdb()

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,keysym,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke)
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147: *4* << define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
stroke = event.stroke ### 2010/10/18
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@+node:ekr.20061031131434.108: *4* callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@+node:ekr.20091230094319.6244: *4* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode(event)
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
#@+node:ekr.20091230094319.6240: *4* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s key: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                    return b
#@+node:ekr.20061031131434.152: *4* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@+node:ekr.20110209083917.16004: *4* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    return True
    return False
#@+node:ekr.20080510095819.1: *4* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace and verbose: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1:
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke)
        return 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@+node:ekr.20110208115654.15911: *3* Body pane background colors
These settings are no longer used:
    
    @string selected-background-color
    @string selected-command-background-color
#@+node:ekr.20061031131434.192: *4* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *4* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg) ### Was body.
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20110209093958.15409: *3* Enter insert mode after ctrl-h
#@+node:ekr.20031218072017.2886: *4* c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    e,wrapper = tree.editLabel(c.p)

    if k:
        # k.setDefaultInputState()
        k.setEditingState()
        k.showStateAndMode(w=wrapper)

    #### tree.editLabel(c.p)
#@+node:ekr.20110209093958.15411: *4* setEditingState
def setEditingState (self):

    k = self ; state = k.defaultEditingAction
    
    # g.trace(state)
    
    k.setInputState(state)
#@+node:ekr.20110209093958.15413: *4* setDefaultEditingKeyAction (New)
def setDefaultEditingAction (self):

    k = self ; c = k.c

    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()

    if action not in ('command','insert','overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'

    self.defaultEditingAction = action
#@+node:ekr.20110212012742.15416: *3* Colorize headline text depending on state
#@+node:ekr.20031218072017.2886: *4* c.editHeadline
def editHeadline (self,event=None):

    '''Begin editing the headline of the selected node.'''

    c = self ; k = c.k ; tree = c.frame.tree

    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    e,wrapper = tree.editLabel(c.p)

    if k:
        # k.setDefaultInputState()
        k.setEditingState()
        k.showStateAndMode(w=wrapper)

    #### tree.editLabel(c.p)
#@+node:ekr.20061031131434.192: *4* showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
        
    isText = g.app.gui.isTextWidget(w)

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()
    
    # 2011/02/12: get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.

    if trace: g.trace('state: %s text?: %s w: %s' % (
        state,isText,w))

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and isText:
        k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
#@+node:ekr.20080512115455.1: *4* showStateColors
def showStateColors (self,inOutline,w):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; state = k.unboundKeyAction

    # body = c.frame.body ; bodyCtrl = body.bodyCtrl
    w_name = g.app.gui.widget_name(w)

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    if trace: g.trace('%9s' % (state),w_name)
    
    if w_name.startswith('body'):
        w = c.frame.body
    elif w_name.startswith('head'):
        pass
    else:
        # Don't recolor the minibuffer, log panes, etc.
        if trace: g.trace('not body or head')
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    if hasattr(w,'setEditorColors'):
        # Note: fg color has no effect on Qt at present.
        w.setEditorColors(bg=bg,fg=fg) ### Was body.
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            pass # g.es_exception()
#@+node:ekr.20110211024010.15393: *3* colon destroys alt-x binding
# This project reorganizes makeBindingFromCommandsDict
#@+node:ekr.20061031131434.76: *4*  ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.widget = c.frame.miniBufferWidget
    self.new_bindings = True
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
#@+node:ekr.20061031131434.78: *5* << define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@+node:ekr.20061031131434.79: *5* << define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@+node:ekr.20041117062717.14: *4* getShortcut (g.app.config) (changed)
def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.
    
    if c.k.new_bindings:
        bunchList = self.getShortcutHelper(c,key) # 2011/02/11
    else:
        bunchList = self.get(c,key,'shortcut')
    # g.trace(c.k.new_bindings) # 'bunchList',bunchList)
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@+node:ekr.20110211041914.15415: *5* getShortcutHelper(g.app.config) (NEW)
def getShortcutHelper (self,c,key):
    
    '''Like get, but return *all* the found bunchLists's.'''

    trace = False and not g.unitTesting
    kind = 'shortcut'
    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')
    result = []

    if c and not isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            bunchList,junk = self.getValFromDict(d,key,kind)
            if bunchList: self.mergeShortcuts(result,bunchList,key)

    for d in self.localOptionsList:
        bunchList,junk = self.getValFromDict(d,key,kind)
        if bunchList: self.mergeShortcuts(result,bunchList,key)

    for d in self.dictList:
        bunchList,junk = self.getValFromDict(d,key,kind)
        if bunchList: self.mergeShortcuts(result,bunchList,key)

    # Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            bunchList,junk = self.getValFromDict(d,key,kind)
            if bunchList: self.mergeShortcuts(result,bunchList,key)

    return result
#@+node:ekr.20110211041914.15418: *5* mergeShortcuts (NEW)
def mergeShortcuts (self,result,aList,key):
        # key is for debugging.
        # key is a conical command name, *not* a keystroke.
    
    '''Append all non-conflicting entries of aList to result.'''
    
    trace = False and not g.unitTesting
    # If there is a real override, **earlier** entries take precedence.
    # Don't add a bunch if it conflicts with a previous val, **regardless** of pane.
    
    vals = [z.val for z in result]
    aList = [z for z in aList if z.val not in vals]
    result.extend(aList)

    if trace and len(result) > 1:
        g.trace(key,['%s %s' % (z.val,z.pane) for z in result])
#@+node:ekr.20061031131434.89: *4* bindKey
def bindKey (self,pane,shortcut,callback,commandName,_hash=None,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.
    
    _hash gives the source of the binding.
    
    '''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %30s %s' % (pane,shortcut,commandName,_hash))
        g.trace(g.callers())
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName,_hash=_hash)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90: *5* << give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@+node:ekr.20061031131434.92: *5* << remove previous conflicting definitions from bunchList >>
# b is the bunch for the new binding.

### This warning should never happen with the new code in makeBindingsFromCommandsDict.

if not modeFlag and self.warn_about_redefined_shortcuts:
    
    redefs = [b2 for b2 in bunchList
        if b2.commandName != commandName and
            # pane != b2.pane and # 2011/02/11: don't give warning for straight substitution.
            pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]

    if redefs:
        def pr(commandName,pane,theHash):
            g.es_print('%30s in %5s from %s' % (commandName,pane,theHash))
    
        g.warning('shortcut conflict for %s' % c.k.prettyPrintKey(shortcut))
        pr(commandName,pane,_hash)
        for z in redefs:
            pr(z.commandName,z.pane,z._hash)

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@+node:ekr.20061031131434.102: *4* makeBindingsFromCommandsDict & helper
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bunches b with b.val equal to the stroke.
    d = c.commandsDict ; d2 = {} 
    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'move-outline-down': g.trace(bunchList)
        for b in bunchList:
            # Important: regularize the binding value here.
            val = k.shortcutFromSetting(b.val)
            b.commandName = commandName
            aList = d2.get(val,[])
            aList.append(b)
            d2[val] = aList

    # g.trace(list(d2.keys()))
    
    # Step 2: Remove overridden entries from the bunchlist for each stroke.
    if self.new_bindings:
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            aList = self.mergeShortcutList(aList,stroke)
            d2 [stroke] = aList

    # Step 3: make the bindings.
    if 1: # New code
        for stroke in sorted(d2):
            aList = d2.get(stroke)
            # if stroke == 'Ctrl+q': g.trace('***',stroke,aList)
            for bunch in aList:
                commandName = bunch.commandName
                command = c.commandsDict.get(commandName)
                _hash = bunch.get('_hash') # 2011/02/10
                pane = bunch.pane
                if trace and not _hash:
                    g.trace('**** no hash for',commandName)
                if stroke and not pane.endswith('-mode'):
                    k.bindKey(pane,stroke,command,commandName,_hash=_hash)
    else: ### old code
        d = c.commandsDict
        for commandName in sorted(d):
            command = d.get(commandName)
            key, bunchList = c.config.getShortcut(commandName)
            # if commandName in ('full-command'): g.trace(key,bunchList)
            for bunch in bunchList:
                accel = bunch.val ; pane = bunch.pane
                _hash = bunch.get('_hash') # 2011/02/10
                if trace and not _hash: g.trace('**** no hash for',commandName)
                # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
                if accel and not pane.endswith('-mode'):
                    shortcut = k.shortcutFromSetting(accel)
                    k.bindKey(pane,shortcut,command,commandName,_hash=_hash)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@+node:ekr.20110211094454.15414: *5* mergeShortcutList
def mergeShortcutList (self,aList,stroke): # stroke is for debugging.

    '''aList is a list of binding bunches for stroke.
    
    Return a new list consisting only of bindings from the highest priority .leo file.'''
    
    # Find the higest priority hash.
    trace = False and not g.unitTesting
    verbose = False
    k = self.c.k
    sList,mList,fList = [],[],[]
    # if stroke == 'Alt-F4': g.pdb()
    for b in aList:
        _hash = b.get('_hash','<no hash>')
        if _hash.endswith('myleosettings.leo'):
            mList.append(b)
        elif _hash.endswith('leosettings.leo'):
            sList.append(b)
        elif _hash.endswith('.leo'):
            fList.append(b)

    result = fList or mList or sList or aList
            
    if trace:
        def pr(stroke,message,aList):
            print('mergeShortcutList: %15s %s %s' % (stroke,message,
                '...\n'.join(['%15s %5s %s' % (k.shortcutFromSetting(z.val),z.pane,z.commandName) for z in aList])))
        if fList and mList:
            pr(stroke,'ignoring  mList',mList)
            pr(stroke,'retaining fList',fList)
        if fList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining fList',fList)
        elif mList and sList:
            pr(stroke,'ignoring  sList',sList)
            pr(stroke,'retaining mList',mList)

    if trace and verbose and len(result) > 1: g.trace(stroke,result)
    return result
#@-all
#@-leo
