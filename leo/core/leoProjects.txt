#@+leo-ver=5-thin
#@+node:ekr.20100120072650.6089: * @thin leoProjects.txt
#@+all
#@+node:ekr.20100709113505.6257: ** Leo 4.7.1 projects
#@+node:ekr.20100709113505.6258: *3* Auto-convert thin-like external files
@
The fix involves disabling caching when a file has file-like sentinels,
regardless of whether the root node is spelled @file or @thin.

In addition, Leo's read code now issues a red warning message in the
console when converting files.
#@+node:ekr.20100709113505.6259: *4* Testing
#@+node:ekr.20100709113505.6260: *5* at-File test code (leoTest.py)
def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in (
        "@auto","@edit","@file","@thin","@nosent",
        "@asis",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@auto":
        at.writeOneAtAutoNode(child1,toString=True,force=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput)
        assert(result == expected)
    except AssertionError:
        << dump result and expected >>
        raise
#@+node:ekr.20100709113505.6261: *6* << dump result and expected >>
print('\n','-' * 20)
print("result...")
for line in g.splitLines(result):
    print("%3d" % len(line),repr(line))
print('-' * 20)
print("expected...")
for line in g.splitLines(expected):
    print("%3d" % len(line),repr(line))
print('-' * 20)
#@+node:ekr.20100709113505.6291: ** Leo 4.8 a1
#@+node:ekr.20100709113505.6292: *3* Bugs
#@+node:ekr.20100709113505.6293: *4* Fixed save scrolling bug
@nocolor-node

- Open a node with long (multipage) body text
- Move cursor towards the end of the node
- Save (ctrl+s)
- Observe how window is scrolled, cursor is moved
#@+node:ekr.20100709113505.6321: *4* Fixed recent save-to bug
#@+node:ekr.20100709113505.6322: *4* Fixed at-auto-rst crash
#@+node:ekr.20100709113505.6324: *5* Original traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2644, in writeOneAtAutoNode
    ok2 = c.rstCommands.writeAtAutoFile(root,fileName,self.outputFile)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 683, in writeAtAutoFile
    self.writeNode(p) # side effect: advances p
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1509, in writeNode
    self.writeHeadline(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1438, in writeHeadline
    self.writeHeadlineHelper(p)
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1477, in writeHeadlineHelper
    self.write(self.underline(h,p)) # Used by @auto-rst.
  File "c:\leo.repo\trunk\leo\core\leoRst.py", line 1364, in write
    self.outputFile.write(s)
TypeError: must be bytes or buffer, not str
#@+node:ekr.20100709113505.6325: *5* Second traceback
@nocolor-node

exception writing external files
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoFileCommands.py", line 2114, in writeAllAtFileNodesHelper
    c.atFileCommands.writeAll()
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2491, in writeAll
    self.writeAllHelper(p,force,toString,writeAtFileNodesFlag,writtenFiles)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2540, in writeAllHelper
    at.writeOneAtAutoNode(p,toString=toString,force=force)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 2652, in writeOneAtAutoNode
    at.replaceTargetFileIfDifferent(root,ignoreBlankLines=isAtAutoRst)
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4547, in replaceTargetFileIfDifferent
    ignoreBlankLines=ignoreBlankLines):
  File "c:\leo.repo\trunk\leo\core\leoAtFile.py", line 4040, in compareFiles
    s1 = g.removeBlankLines(s1)
  File "c:\leo.repo\trunk\leo\core\leoGlobals.py", line 5992, in removeBlankLines
    return ''.join(lines)
TypeError: sequence item 0: expected str instance, bytes found
saved: test.leo
#@+node:ekr.20100709113505.6335: *4* Investigated at-auto-rst bug
@nocolor-node
https://bugs.launchpad.net/leo-editor/+bug/532085

auto-rst isn't switching to a new title underline char. going from level 2 to 3
in the outline.

Changing to regular @rst and using the rst3 command to export works.

Tree:

Foo
    Bar
        This
        That
    Etc

Output:

Foo
===

Bar
+++

This
++++ <- still using '+' one level down

--------------------------------------------------


Another test and this seems as bad or worse,

A-+
    |
   C-+
       |
      D

is using '=' to underline all three levels.
#@+node:ekr.20100709113505.6341: *4* Don't put &nbsp; in redirected log
@nocolor-node
@

https://bugs.launchpad.net/leo-editor/+bug/549319

Leo 4.7.1 final, build 3005, February 26, 2010
Python 2.6.2, qt version 4.5.2
Windows 5, 1, 2600, 2, Service Pack 3

When redirecting the output to the Log pane using g.redirectStderr() and
g.redirectStdout(), the output displays non-breaking space characters (&nbsp;)
everywhere there is supposed to be a space.

For example, if I run print 'Hello World' I get Hello&nbsp;World in the Log
pane. This is really hard to read when you have 50 or 100 lines of numbers from
the output of a program.
#@+node:ekr.20100709113505.6357: *4* Fixed tangle bug
#@+node:ekr.20100709113505.6360: *4* Fixed crash in log pane
Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 366, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 284, in autoComplete
    k.masterCommand(event,func=None,stroke=None,commandName=None)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2606, in masterCommand
    val = k.handleDefaultChar(event,stroke)
  File "c:\leo.repo\trunk\leo\core\leoKeys.py", line 2664, in handleDefaultChar
    if stroke.lower() == 'return': stroke = '\n'
AttributeError: 'NoneType' object has no attribute 'lower'
#@+node:ekr.20100709113505.6363: *4* Patch for 64-bit aspell
#@+node:ekr.20100709113505.6367: *4* Fixed at-auto-rst bug
#@+node:ekr.20100709113505.6370: *4* Fixed erroneous error message in at-auto-rst read logic
#@+node:ekr.20100709113505.6375: *4* Fixed crasher in openFileForReading
#@+node:ekr.20100707124440.5869: *4* Fixed Java import problem
@nocolor-node

On Windows, using Leo trunk from a few days ago, I get "error: class
class does not end in a newline; one will be added [nl]" on what seems
to be every imported java chunk.

This issue seems to be line-ending related and I duplicated it with a
simple test.  When I run the following code from within a Leo node, I
get the same error as when I tried to import the file.
#@+node:ekr.20100707124440.5871: *5* test
# Java code from org.apache.commons.lang.immutable
s = '''
public class MutableBoolean implements Mutable, Serializable, Comparable {

   /**
    * Required for serialization support.
    *
    * @see java.io.Serializable
    */
   private static final long serialVersionUID = -4830728138360036487L;

}

'''
# If the string has DOS line endings then I see warnings like:
# 'class class does not end in a newline; one will be added [nl]'
# Without the DOS line endings (i.e. comment out this line), no warning seen

if 1: # Dos line endings creates the error.
    s = s.replace("\n", "\r\n")

# Import the code to a child of the current one
p.insertAsLastChild()
p.moveToLastChild()
c.importCommands.scanJavaText (s,p,atAuto=True)
c.redraw()
#@+node:ekr.20100707124440.5872: *6* newHeadline
@language java
@tabwidth -4
@others


@ignore
#@+node:ekr.20100707124440.5873: *7* class Mutable

public class MutableBoolean implements Mutable, Serializable, Comparable {

   /**
    * Required for serialization support.
    *
    * @see java.io.Serializable
    */
   private static final long serialVersionUID = -4830728138360036487L;

}
#@+node:ekr.20100728074713.5839: *4* Fixed gloto-global-line
#@+node:ekr.20100729045510.5825: *4* Fixed hard crash in delete_aspell_config
#@+node:ekr.20100731134533.5797: *4* Fixed rst3 bug with docutils on py3k
#@+node:ekr.20100801112314.11721: *4* Made sure that all @auto nodes end with a newline
@nocolor-node

The fix was to the "if not trailingNewlineFlag:" code at the end of at.putBody.
#@+node:ekr.20100121050224.6140: *4* Fixed vampire nodes and created p.deletePositionsInList
# Also, created a "Resurrected Nodes" node to handle such nodes cleanly and safely.
#@+node:ekr.20100802121531.5802: *5* Post re vampire nodes
@language rest

Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle
consequence of how Leo writes outlines and reads derived files.  This
is a big bug in Leo, not cvs.  The effect of the bug is that nodes can
appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the
following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such
files.  Maybe all @thin derived files should be -kb files, but Leo's
users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is
concerned.  Other .txt files, like leoScripts.txt, should also be
binary files.  As we shall see, the fact that leoProjects.txt is now a
-kb file means that we can not possibly blame the cvs merge algorithm
for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I
added a node called 'changed in the main line'.  In sandbox 2 I added
a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the
following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/
leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.
1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not**
been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge
surprise: the outline contains **both** the node 'changed in main-
line' and the node 'changed2'!

How did this happen?  Well, obviously the 'changed in main-line' node
came from the cvs update.  I expected that.  The 'changed2' line must
have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had
happened.  The 'changed2' is a descendant of a cloned node called '4.4
projects'.

- One clone of '4.4 projects' node is a descendant of the @thin
leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but
outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was
reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node
**already existed in the outline** before Leo read leoProjects.txt,
and the present atFile read logic only **adds** nodes, it never
deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read
logic.  The 'changed2' node became a 'vampire' node that couldn't be
killed.

The problem is far from benign.  Because of clones, the vampire node
became an orphan node in **another** file, namely leoKeys.py.  I tried
two or three times to remove the vampire/orphan node before realizing
what had happened.

The fix (there is *always* a fix) will require some care.  The present
atFile.read logic is robust because it *doesn't* delete nodes.  It is
essential that the read logic remain robust.  I suspect the solutions
will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes
initially, because it doesn't know whether there will be read errors
later.  If there are read errors absolutely nothing must change.  This
ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not
actually read from the derived file.  I think (but haven't proven)
that all descendents of vampire nodes are also vampire nodes.  If that
is so the post-pass will simply delete vampire nodes without worrying
about whether they have descendents.

Warning: the new scheme will mean that cvs update can destroy
information that previously existed in the outline.  I believe this is
correct: we assume that derived files are the 'truly meaningful'
files.  Hey, if we are wrong we can always get the old info from
cvs :-)
QQQ

At present, atFile.read contains code to warn of "resurrected" nodes,
and I did indeed get such a warning when the recent problem arose.

After a quick look at atFile.read, I strongly suspect that the problem
remains today pretty much exactly as it was in 2003.  The only
difference is that the caching code (the call to
root.v.createOutlineFromCacheList(c,aList)) doesn't do the check:
\<\< advise user to delete all unvisited nodes \>\>
that is done later in read(). That probably should be fixed.

Finding a better solution to vampire nodes has been on the list since
2003.  It's not easy because it involves the dreaded "multiple delete"
problem.

Hmm.  The present read code *does* delete the tree before reading thin
external files.  So it appears that vampire nodes could only be
expected in external files derived from @file nodes.  It may be that
part of the problem is that somehow Leo thinks that it is reading an
@file node?? That's pretty weird, but messages about resurrected nodes
and missing tnode lists did happen.  It's quite a puzzle.

Edward
#@+node:ekr.20071105164407: *5* at.deleteUnvisitedNodes & helpers
def deleteUnvisitedNodes (self,root):

    '''Delete unvisited nodes in root's subtree, not including root.

    Actually, instead of deleting the nodes, we move them to be children of the
    'Resurrected Nodes' r.
    '''

    at = self

    if not root.hasChildren():
        return

    # Carefully set up the arguments.
    aList = [z.copy() for z in root.subtree() if not z.isVisited()]
    if not aList: return

    r = at.createResurrectedNodesNode()
    assert r not in aList
    callback=at.defineResurrectedNodeCallback(r,root)

    # Now move the nodes.
    root.firstChild().deletePositionsInList(aList,callback)
#@+node:ekr.20100803073751.5817: *6* createResurrectedNodesNode
def createResurrectedNodesNode(self):

    '''Create a 'Resurrected Nodes' node as the last top-level node.'''

    at = self ; c = at.c ; tag = 'Resurrected Nodes'

    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()

    if last.h == tag:
        # The 'Resurrected Nodes' node already exists.
        p = last
    else:
        # Create the 'Resurrected Nodes' node after 'last'.
        p = last.insertAfter()
        p.setHeadString(tag)

    p.expand()
    return p
#@+node:ekr.20100803073751.5818: *6* defineResurrectedNodeCallback
def defineResurrectedNodeCallback (self,r,root):

    '''Define a callback that moves node p as r's last child.'''

    def callback(p,r=r.copy(),root=root):

        '''The resurrected nodes callback.'''

        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        p.moveToLastChildOf(child)

        if g.unitTesting:
            # g.trace(p.h,r.h)
            pass 
        else:
            g.es('resurrected node:',p.h,color='red')
            g.es('in file:',root.h,color='blue')

    return callback


#@+node:ekr.20100802121531.5804: *5* p.deletePositionsInList
def deletePositionsInList (self,aList,callback=None):

    '''Traverse the tree starting from self until all nodes in aList have been
    found.

    This method calls the callback for any position in aList found in the range,
    excluding any node whose ancestor has already been passed to the callback.

    The callback takes one explicit argument, p. As usual, the callback can bind
    values using keyword arguments. The callback may delete p or move p out of
    the range. The callback **must not** move p within range of the traversal.
    If no callback is given, this method deletes all found nodes.
    '''

    if callback is None:
        def callback(p):
            p.doDelete(newNode=None)

    p = self.copy()
    while p and aList:
        # g.trace(repr(p))
        if p in aList:
            aList.remove(p)
            for z in aList:
                if p.isAncestorOf(z):
                    aList.remove(z)
            next = p.nodeAfterTree()
            callback(p.copy())
            p = next
        else:
            p.moveToThreadNext()
#@+node:ekr.20100827095120.5871: *4* fixed bug 618474: show_leo_directives
@language python
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/618474

in core/leoRst the method removeLeoDirectives seems not to remove the leo directives.
which results in @leo directives inside generated rst code.

The problematic code line is the statement "g.match_word(s, 0,key)" in the following block:

                for key in self.leoDirectivesList:
                    if g.match_word(s, 0,key):
                        #g.trace('removing %s' % s)
                        break

As far as I understand the function match_word, it returns 1 if s contains key at index 0,
The self.leoDirectivesList contains all directive like color, language, ... (without @) but
s is a complete body line that looks like:
@language rest

That means language starts at index 1 not at 0.
changing the line to
  g.match_word(s, 1,key)

let it work correctly in my installation (4.7.1)
#@+node:ekr.20090502071837.80: *5* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
#@+node:ekr.20100827095120.5869: *4* fixed bug 618482: code-mode line feeds
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/618482

in leoRst.py:

the method "handleCodeMode" does not preserve line linefeeds of the original code. While this is only annoying for code
parts it is fatal for doc parts, because rst directives does not work anymore.

The problem is in the line "elif not z.rstrip(): pass" of the following code block at the end of the method
        for z in result:
            if z == '': result2.append('\n\n')
            elif not z.rstrip(): pass
            elif z.endswith('\n\n'): result2.append(z) # Leave alone.
            else: result2.append('%s\n' % z.rstrip())

Commenting this line out, preserves the linefeeds in the doc part but doubles them in the code part.

The method "rstripList" is responsible for the doubling linefeeds:
   The lines arguments is a list of lines with (!) trainling linefeeds (\n),

   The statement s = '\n'.join(theList).rstrip() doubles therefore the linefeeds
    replacing the line with s = ''.join(theList).rstrip() works.
#@+node:ekr.20090502071837.72: *5* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
#@+node:ekr.20090502071837.73: *6* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
#@+node:ekr.20090502071837.74: *6* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
#@+node:ekr.20090502071837.75: *6* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
#@+node:ekr.20100826110728.5843: *4* Fixed weave (and many similar) commands
#@+node:ekr.20100827114047.8412: *5* Found: .write
#@+node:ekr.20031218072017.1982: *6* << attempt to create leoID.txt >> (changed)
for theDir in (homeLeoDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            s = g.app.leoID
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,encoding='utf-8',reportErrors=True)
            f.write(s)
            f.close()
            if g.os_path_exists(fn):
                g.es_print('',tag,'created in',theDir,color='red')
                return
        except IOError:
            pass

        g.es('can not create',tag,'in',theDir,color='red')
#@+node:ekr.20031218072017.1149: *6* << Write s into newFileName >> (remove-sentinels) (changed)
# Remove sentinels command.

try:
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    # theFile = open(newFileName,mode)
    theFile = open(newFileName,'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    if not g.unitTesting:
        g.es("created:",newFileName)
except Exception:
    g.es("exception creating:",newFileName)
    g.es_exception()
#@+node:ekr.20051025071455.37: *6* add (spellTab) (changed)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                s = '%s\n' % word
                if not g.isPython3: # 2010/08/27
                    s = g.toEncodedString(s,reportErrors=True)
                f.write(s)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("adding ", color= "blue", newline= False) 
                g.es('','%s' % self.currentWord)
        except IOError:
            g.es("can not add",self.currentWord,"to dictionary",color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
#@+node:ekr.20100813041139.5912: *6* createIntermediateFile (changed)
def createIntermediateFile(self,fn,s):

    '''Write s to to the file whose name is fn.'''

    ext = self.getOption('write_intermediate_extension')
    ext = ext or '.txt' # .txt by default.
    if not ext.startswith('.'): ext = '.' + ext

    fn = fn + ext

    # g.trace('intermediate file',fn)
    if g.isPython3:
        f = open(fn,'w',encoding=self.encoding)
    else:
        f = open(fn,'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
    f.write(s)
    f.close()
    self.report(fn)
#@+node:ekr.20031218072017.1462: *6* exportHeadlines (changed)
def exportHeadlines (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.p
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return
    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel,useVerticalBar=True)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
    theFile.close()
#@+node:ekr.20031218072017.1147: *6* flattenOutline (changed)
def flattenOutline (self,fileName):

    c = self.c ; nl = g.u(self.output_newline)
    p = c.currentVnode()
    if not p: return
    self.setEncoding()
    firstLevel = p.level()

    # 10/14/02: support for output_newline setting.
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    for p in p.self_and_subtree():
        head = p.moreHead(firstLevel)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
        theFile.write(s)
        body = p.moreBody() # Inserts escapes.
        if len(body) > 0:
            s = g.toEncodedString(body + nl,self.encoding,reportErrors=True)
            theFile.write(s)
    theFile.close()
#@+node:ekr.20031218072017.1148: *6* outlineToWeb (changed)
def outlineToWeb (self,fileName,webType):

    c = self.c ; nl = self.output_newline
    current = c.p
    if not current: return
    self.setEncoding()
    self.webType = webType
    # 10/14/02: support for output_newline setting.
    # mode = c.config.output_newline
    # mode = g.choose(mode=="platform",'w','wb')
    try:
        # theFile = open(fileName,mode)
        theFile = open(fileName,'w')
    except IOError:
        g.es("can not open",fileName,color="blue")
        leoTest.fail()
        return

    self.treeType = "@file"
    # Set self.treeType to @root if p or an ancestor is an @root node.
    for p in current.parents():
        flag,junk = g.is_special(p.b,0,"@root")
        if flag:
            self.treeType = "@root"
            break
    for p in current.self_and_subtree():
        s = self.convertVnodeToWeb(p)
        if len(s) > 0:
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
            theFile.write(s)
            if s[-1] != '\n': theFile.write(nl)
    theFile.close()
#@+node:ekr.20050920084036.170: *6* saveFile (changed)
def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        s = w.getAllText()
        if not g.isPython3: # 2010/08/27
             s = g.toEncodedString(s,self.encoding,reportErrors=True)
        f.write(s)
        f.close()
    except IOError:
        g.es('can not create',fileName)
#@+node:ekr.20031218072017.3650: *6* show (leoCompare) (not changed)
def show (self,s):

    # g.pr(s)
    if self.outputFile:
        # self.outputFile is opened in 'wb' mode.
        s = g.toEncodedString(s + '\n')
        self.outputFile.write(s)
    elif self.c:
        g.es(s)
    else:
        g.pr(s)
        g.pr('')
#@+node:ekr.20080822065427.4: *6* show_error_lines (changed)
def show_error_lines (self,lines,fileName):

    for line in lines:
        g.es_print(line)

    if False: # Only for major debugging.
        try:
            f1 = open(fileName, "w")
            for s in lines:
                if not g.isPython3: # 2010/08/27
                    s = g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
                f1.write(s)
            f1.close()
        except IOError:
            g.es_exception()
            g.es_print('can not open',fileName)
#@+node:ekr.20031218072017.1464: *6* weave (changed)
def weave (self,filename):

    c = self.c ; nl = self.output_newline
    p = c.p
    if not p: return
    self.setEncoding()
    << open filename to f, or return >>
    for p in p.self_and_subtree():
        s = p.b
        s2 = s.strip()
        if s2 and len(s2) > 0:
            f.write("-" * 60) ; f.write(nl)
            << write the context of p to f >>
            f.write("-" * 60) ; f.write(nl)
            if not g.isPython3:
                s = g.toEncodedString(s,self.encoding,reportErrors=True)
            f.write(s.rstrip() + nl)
    f.flush()
    f.close()
#@+node:ekr.20031218072017.1150: *7* << open filename to f, or return >> (weave)
try:
    # 10/14/02: support for output_newline setting.
        # mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        # f = open(filename,mode)
        # if not f: return

    # 2010/08/27.
    if g.isPython3:
        f = open(filename,'w',encoding=self.encoding)
    else:
        f = open(filename,'w')

except Exception:
    g.es("exception opening:",filename)
    g.es_exception()
    return
#@+node:ekr.20031218072017.1465: *7* << write the context of p to f >> (weave)
# write the headlines of p, p's parent and p's grandparent.
context = [] ; p2 = p.copy() ; i = 0
while i < 3:
    i += 1
    if not p2: break
    context.append(p2.h)
    p2.moveToParent()

context.reverse()
indent = ""
for line in context:
    f.write(indent)
    indent += '\t'
    if not g.isPython3: # 2010/08/27.
        line = g.toEncodedString(line,self.encoding,reportErrors=True)
    f.write(line)
    f.write(nl)
#@+node:ekr.20050920084036.24: *6* writeAbbreviation
def writeAbbreviations (self,event):

    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            val = self.abbrevs.get(x).replace('\n','\\n')  # 2010/09/01.
            s = '%s=%s\n' % (x,val)
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,reportErrors=True)
            f.write(s)
        f.close()
    except IOError:
        g.es('can not create',fileName)
#@+node:ekr.20070915142635: *6* writeFileFromNode (changed)
def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.p
    c.endEditing()

    h = p.h.rstrip()
    s = p.b
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
            g.chdir(fileName)
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s,reportErrors=True)
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote:',fileName,color='blue')
            theFile.close()
        else:
            g.es('can not write %s',fileName,color='red')
#@+node:ekr.20070115135502: *6* writeScriptFile (changed)
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir,'scriptFile.py')                    

    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path,encoding='utf-8',mode='w')
        else:
            f = open(path,'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script_file_path'))
        path = None

    return path
#@+node:ekr.20080713091247.1: *6* x.replaceFileWithString (@shadow) (not changed)
def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    trace = False and not g.unitTesting
    x = self
    exists = g.os_path_exists(fn)

    if exists:
        # Read the file.  Return if it is the same.
        s2,e = g.readFileIntoString(fn)
        if s2 is None:
            return False
        if s == s2:
            if not g.unitTesting: g.es('unchanged:',fn)
            return False

    # Issue warning if directory does not exist.
    theDir = g.os_path_dirname(fn)
    if theDir and not g.os_path_exists(theDir):
        if not g.unitTesting:
            x.error('not written: %s directory not found' % fn)
        return False

    # Replace the file.
    try:
        f = open(fn,'wb')
        f.write(g.toEncodedString(s))
        if trace: g.trace('fn',fn,
            '\nlines...\n%s' %(g.listToString(g.splitLines(s))),
            '\ncallers',g.callers(4))
        f.close()
        if not g.unitTesting:
            # g.trace('created:',fn,g.callers())
            if exists:  g.es('wrote:',fn)
            else:       g.es('created:',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
#@+node:ekr.20100831090251.5839: *4* Take more care with inititing gui
#@+node:ekr.20031218072017.1416: *5* app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.atPathInBodyWarning = None # Set by get_directives_dict
        # The headline of the @<file> node containing
        # an @path directive in the body.
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.db = None # Set to a leoCacher later.
    self.debug = False
        # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.enableUnitTest = True
    self.extensionsDir = None
    self.globalConfigDir = None
        # The directory assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.guiArgName = None # The gui name given in --gui option.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.homeLeoDir = None
        # The '.leo' subdirectory of the user's home directory.
    self.homeSettingsPrefix = '.'
        # prepend to "myLeoSettings.leo" and <machineName>LeoSettings.leo
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100
        # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False
        # True: the global idleTimeHookHandler will reshedule itself.
    self.inBridge = False # True: running from leoBridge module.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logInited = False # False: all log message go to logWaiting list.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.oneConfigFilename = ''
        # If non-empty, the name of a single configuration file.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0
        # Used to generate temp file names for Open With command.
    self.openWithTable = None
        # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.printWaiting = [] # Queue of messages to be sent to the printer.
    self.qt_use_tabs = False # True: allow tabbed main window.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {}
        # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {}
        # For communication between Execute Script command and scripts.
    self.silentMode = False # True if signon is more silent.
    self.statsDict = {}
        # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.translateToUpperCase = False
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.useIpython = False
    self.use_psyco = False
        # Can't be a config param because it is used
        # before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = []
        # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None

    << Define global constants >>
    << Define global data structures >>
#@+node:ekr.20031218072017.1417: *6* << define global constants >>
# self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"
self.prolog_namespace_string = \
    'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
#@+node:ekr.20031218072017.368: *6* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
#@+node:ekr.20100831090251.5838: *5* app.createXGui
#@+node:ekr.20100831090251.5840: *6* app.createCursesGui
def createCursesGui (self,fileName='',verbose=False):

    app = self

    leoPlugins.loadOnePlugin('leo.plugins.cursesGui',verbose=verbose)
#@+node:ekr.20090619065122.8593: *6* app.createDefaultGui
def createDefaultGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to create the default gui class."""

    app = self ; argName = app.guiArgName

    # This method can be called twice if we had to get .leoID.txt.
    if app.gui: return

    if argName == 'qt':
        app.createQtGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Qt gui: trying Tk gui')
            app.createTkGui(fileName,verbose=verbose)  
    elif argName == 'tk':
        app.createTkGui(fileName,verbose=verbose)
        if not app.gui:
            print('Can not create Tk gui: trying Qt gui')
            app.createQtGui(fileName,verbose=verbose)
    elif argName == 'null':
        app.createNullGui()
    elif argName == 'curses':
        app.createCursesGui()

    if not app.gui:
        print('Leo requires either Tk or Qt to be installed.')
#@+node:ekr.20090202191501.5: *6* app.createNullGui
def createNullGui (self):

    # Don't import this at the top level:
    # it might interfere with Leo's startup logic.

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.gui = leoGui.nullGui("nullGui")
#@+node:ekr.20031218072017.1938: *6* app.createNullGuiWithScript
def createNullGuiWithScript (self,script=None):

    app = self

    try:
        import leo.core.leoGui as leoGui
    except ImportError:
        leoGui = None

    if leoGui:
        app.batchMode = True
        app.gui = leoGui.nullGui("nullGui")
        app.gui.setScript(script)
#@+node:ekr.20090202191501.1: *6* app.createQtGui
def createQtGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the Qt gui class."""

    app = self

    try:
        # Take care to try the same imports as in qtGui.py.
        import PyQt4.QtCore
        import PyQt4.QtGui            
        import leo.plugins.qtGui as qtGui
    except ImportError:
        qtGui = None

    if qtGui:
        qtGui.init()
        if app.gui and fileName and verbose:
            print('qtGui created in %s' % fileName)
#@+node:ekr.20031218072017.2610: *6* app.createTkGui
def createTkGui (self,fileName='',verbose=False):

    """A convenience routines for plugins to 
    create the default Tk gui class."""

    app = self

    try:
        import tkinter as Tk
    except ImportError:
        try:
            import Tkinter as Tk
        except ImportError:
            Tk = None

    Pmw = g.importExtension('Pmw',pluginName='startup',verbose=False)

    if Tk and Pmw:
        leoPlugins.loadOnePlugin('leo.plugins.tkGui',verbose=verbose)
        if app.gui and fileName and verbose:
            print('tkGui created in %s' % fileName)
#@+node:ekr.20090126063121.3: *6* app.createWxGui
def createWxGui (self,fileName='',verbose=False):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the wx gui class."""

    leoPlugins.loadOnePlugin ('leo.plugins.wxGui',verbose=verbose)

    if fileName and verbose:

        print('wxGui created in %s' % fileName)
#@+node:ekr.20031218072017.1934: *5* run & helpers
def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    trace = False and not g.unitTesting
    if trace: print('runLeo.run: sys.argv %s' % sys.argv)

    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    if not isValidPython(): return
    fn,relFn,script,versionFlag = doPrePluginsInit(fileName,pymacs)

    # We can't print the signon until we know the gui.
    g.app.computeSignon() # Set app.signon/signon2 for commanders.
    if versionFlag:
        print(g.app.signon) ; return
    if not g.app.gui: return

    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed: return

    # Phase 3: after loading plugins. Create a frame.
    ok = doPostPluginsInit(args,fn,relFn,script,versionFlag)
    if ok and not versionFlag: g.app.gui.runMainLoop()
#@+node:ekr.20090519143741.5915: *6* doPrePluginsInit & helpers
def doPrePluginsInit(fileName,pymacs):

    '''
    Scan options, set directories and read settings.'''

    trace = False
    g.computeStandardDirectories()
    adjustSysPath()
    fileName2,gui,script,versionFlag,windowFlag = scanOptions()
    if fileName2: fileName = fileName2
    if trace:
        print('runLeo.doPrePluginsInit: sys.argv %s' % sys.argv)
        print('runLeo.doPrePluginsInit: fileName %s' % fileName)
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    # New in Leo 4.7: the default encoding is always 'utf-8'.
    # g.app.setEncoding()
    g.app.setGlobalDb()
    if g.app.gui:
        pass # initApp (setLeoID) created the gui.
    elif gui is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        createSpecialGui(gui,pymacs,script,windowFlag)

    return fileName,relativeFileName,script,versionFlag
#@+node:ekr.20080921060401.4: *7* createSpecialGui
def createSpecialGui(gui,pymacs,script,windowFlag):

    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        assert g.app.guiArgName
        g.app.createDefaultGui() 
#@+node:ekr.20070306085724: *7* adjustSysPath
def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:

    1. g.importModule will import from the
       'external' or 'extensions' folders as needed
       without altering sys.path.

    2  Plugins now do fully qualified imports.
    '''
#@+node:ekr.20071117060958: *7* getFileName & helper
def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if not fileName and not script:
        if sys.platform.startswith('win'):
            if len(sys.argv) > 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) > 1 and sys.argv[-1]

    return completeFileName(fileName)
#@+node:ekr.20041124083125: *8* completeFileName
def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    fileName = g.toUnicode(fileName)

    relativeFileName = fileName
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName,relativeFileName
#@+node:ekr.20080921091311.2: *7* initApp
def initApp (verbose):

    assert g.app.guiArgName

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.config = leoConfig.configClass()
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
#@+node:ekr.20041130093254: *7* reportDirectories
def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
#@+node:ekr.20091007103358.6061: *7* scanOptions
def scanOptions():

    '''Handle all options and remove them from sys.argv.'''
    trace = False

    # Note: this automatically implements the --help option.
    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('--debug',        action="store_true",dest="debug")
    parser.add_option('-f', '--file',   dest="fileName")
    parser.add_option('--gui',
        dest="gui",help = 'gui to use (qt/tk/qttabs)')
    #parser.add_option('--help',
        # action="store_true",dest="help_option")
    parser.add_option('--ipython',      action="store_true",dest="use_ipython")
    parser.add_option('--no-cache',     action="store_true",dest='no_cache')
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")
    parser.add_option('--version',      action="store_true",dest="version")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    if trace: print('scanOptions',sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # --debug
    if options.debug:
        g.debug = True
        g.trace('*** debug mode on')

    # -f or --file
    fileName = options.fileName

    # --gui
    gui = options.gui
    g.app.qt_use_tabs = False

    if gui:
        gui = gui.lower()
        if gui == 'qttabs':
            gui = g.app.guiArgName = 'qt'
            g.app.qt_use_tabs = True
        elif gui in ('curses','tk','qt','null'): # 'wx',
            g.app.guiArgName = gui
        else:
            g.trace('unknown gui: %s' % gui)
            g.app.guiArgName = gui = 'qt'
    else:
        gui = g.app.guiArgName = 'qt'

    assert gui == g.app.guiArgName

    # --ipython
    g.app.useIpython = options.use_ipython

    # --no-cache
    if options.no_cache:
        g.trace('disabling caching')
        g.enableDB = False

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        script,e = g.readFileIntoString(script_name,kind='script:')
    else:
        script = None
        # if trace: print('scanOptions: no script')

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # --version: print the version and exit.
    versionFlag = options.version

    # Compute the return values.
    windowFlag = script and script_path_w
    if trace:
        print('scanOptions: fileName',fileName)
        print('scanOptions: argv',sys.argv)
    return fileName,gui,script,versionFlag,windowFlag
#@+node:ekr.20090519143741.5917: *6* doPostPluginsInit & helpers
def doPostPluginsInit(args,fileName,relativeFileName,script,versionFlag):

    '''Return True if the frame was created properly.'''

    # if g.app.gui == None:
        # g.app.createQtGui(fileName='core')

    # # We can't print the signon until we know the gui.
    # g.app.computeSignon() # Set app.signon/signon2 for commanders.

    # if versionFlag:
        # print(g.app.signon)
        # return

    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()

    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.

    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return False

    # Do the final inits.
    finishInitApp(c)
    p = c.p

    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    return True
#@+node:ekr.20031218072017.1624: *7* createFrame (runLeo.py)
def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # New in Leo 4.6: support for 'default_leo_file' setting.
    defaultFileName = None
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')
            defaultFileName = fileName

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    if not fileName: fileName = defaultFileName

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)

    g.app.writeWaitingLog(c) # 2009/12/22: fixes bug 448886

    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False)
            # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    g.createMenu(c,fileName)
    g.finishOpen(c) # Calls c.redraw.

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    return c,frame
#@+node:ekr.20080921060401.5: *7* finishInitApp (runLeo.py)
def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    if g.app.disableSave:
        g.es("disabling save commands",color="red")

#@+node:ekr.20080921060401.6: *7* initFocusAndDraw
def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
#@+node:ekr.20040411081633: *7* startPsyco
def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
#@+node:ekr.20031218072017.1936: *6* isValidPython
def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                << define emergency dialog class >>
                d = emergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20080822065427.8: *7* << define emergency dialog class >>
class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20080822065427.9: *8* __init__ (emergencyDialog)
def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True},
        # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@+node:ekr.20080822065427.12: *8* createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,
            underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@+node:ekr.20080822065427.14: *8* createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
#@+node:ekr.20080822065427.10: *8* okButton
def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

#@+node:ekr.20080822065427.21: *8* onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
#@+node:ekr.20080822065427.16: *8* run
def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@+node:ekr.20100831090251.5841: *4* Shorter warnings about incompatible gui type
#@+node:ekr.20031218072017.2278: *5* g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):

    trace = False and not g.unitTesting
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path)
    module = sys.modules.get(moduleName)
    if module:
        if trace: g.trace('already loaded',moduleName,module)
        return module

    try:
        theFile = None
        import imp
        try:
            data = imp.find_module(moduleName,[path]) # This can open the file.
            theFile,pathname,description = data
            module = imp.load_module(moduleName,theFile,pathname,description)
        except ImportError:
            if trace: # or verbose:
                g.es_print("exception in g.importFromPath",color='blue')
                g.es_exception()
        except UiTypeException:
            if not g.unitTesting and not g.app.batchMode:
                g.es_print('Plugin %s does not support %s gui' % (
                    name,g.app.gui.guiName()))          
        except Exception:
            g.es_print("unexpected exception in g.importFromPath(%s)" %
                (name),color='blue')
            g.es_exception()
    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()

    if module:
        if trace: g.trace('loaded',moduleName)
    else:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@+node:ekr.20041113113140: *5* loadOnePlugin
def loadOnePlugin (moduleOrFileName,tag='open0',verbose=False):

    trace = False # and not g.unitTesting

    global loadedModules,loadingModuleNameStack

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
        print ('No g.app.config, making stub...')
        class StubConfig(g.nullObject):
            pass
        g.app.config = StubConfig()

    # Fixed reversion: do this after possibly creating stub config class.
    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = 'leo.plugins.' + moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    #moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if trace or verbose:
            g.trace('plugin',moduleName,'already loaded',color="blue")
        return module

    assert g.app.loadDir

    #plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    #result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    #print "imp", moduleName
    try:
        toplevel = __import__(moduleName)
        # need to look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]

    except g.UiTypeException:
        if not g.unitTesting and not g.app.batchMode:
            g.es_print('Plugin %s does not support %s gui' % (
                moduleName,g.app.gui.guiName()))
        result = None  

    except Exception as e:
        g.es_print('exception importing plugin ' + moduleName,color='red')
        g.es_exception()
        result = None

    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)

        if tag == 'unit-test-load':
            pass # Keep the result, but do no more.
        elif hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es_print('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.

            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                g.trace('no init()',moduleName)
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.app.batchMode or g.app.inBridge: # or g.unitTesting
        pass
    elif result:
        if trace or verbose:
            g.trace('loaded plugin:',moduleName,color="blue")
    else:
        if trace or warn_on_failure or (verbose and not g.app.initing):
            if trace or tag == 'open0':
                g.trace('can not load enabled plugin:',moduleName,color="red")

    return result
#@+node:ekr.20100709113505.6383: *3* Features
#@+node:ekr.20100517130356.5809: *4* New sentinels
#@+node:ekr.20100709113505.6384: *4* Fixed the @test logic
#@+node:ekr.20100709113505.6386: *5* patch
# Begin patch

=== modified file 'leo/core/leoTest.py'
@@ -697,9 +696,10 @@

     # 2010/03/05: set the current directory so that importing leo.core.whatever works.
     leoDir = g.os_path_finalize_join(g.app.loadDir,'..','..')
-    os.chdir(leoDir)
-
-    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)

+    #os.chdir(leoDir)
+    env = dict(os.environ)
+    env['PYTHONPATH'] = env.get('PYTHONPATH', '')+';'+leoDir
+    os.spawnve(os.P_NOWAIT,sys.executable,args,env)
#@+node:ekr.20100709113505.6387: *4* Allow changing minibuffer colors
@nocolor-node

Added the following options with the indicated defaults.

\@color minibuffer_background_color = lightblue
\@color minibuffer_warning_color = lightgrey
#@+node:ekr.20100709113505.6405: *4* Added legend for print-settings command
#@+node:ekr.20100709113505.6407: *4* Added support for @string qt-toolbar-location
Valid values are top,bottom,left,right
#@+node:ekr.20100709113505.6408: *4* Added g.app.config.config_iter
This simplifies the print-settings command.
#@+node:ekr.20100709113505.6412: *4* Don't create @chapter node for new file
@nocolor-node

I think @chapters node shouldn't be in a new leo file, but it should
be created when the first chapter is created.

Ditto for the chapter selector toolbar button.
#@+node:ekr.20100728074713.5838: *4* Remember whether @asis/@nosent existed at read time
@nocolor-node
@

Removed all traces of the "significant change" logic. The read code remembers
whether a node existed when Leo loaded the outline.

Leo will warn when writing a node that didn't previously exist. This is a nice
simplification of the code.
#@+node:ekr.20100731091712.5828: *4* Can we put up the LeoID dialog later?
@nocolor-node

It is needed to set g.app.nodeIndices, which is used in the read logic for outlines,
so it *must* be set before we load any Leo file!  Thus, alas, it is not possible.
#@+node:ekr.20100731091712.5829: *4* Be more clever in putting up the Leo id dialog
@nocolor-node

g.app.setLeoID now calls createDefaultGui instead of createTkGui.
#@+node:ekr.20100731114918.5843: *4* Improved install instructions & logic
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/a5a47afa65af9a37

The following changes are on the trunk, and also on Leo's web site:

- In home page, added link to Install page, just above the Beginner's Guide.

- Added more explicit instructions for installing Tk and Qt.

- In step 6 of the Windows install steps, the "assoc .leo=LeoFile"
  is on a line by itself.

- Updated home page to indicate that Leo requires Python and PyQt.
  I also revised and simplified the introduction in other ways.
  Ditto for description of Leo on SourceForge.

- Changed "%1" to "%*" throughout the installation instructions.

- Made batch files given in Installing Leo and Running Leo the same.

- The dialogs that ask for the Leo ID now tells why Leo needs it.

- Just before raising the dialog that asks for the Leo ID, Leo attempts
  to create the Qt Qui first, and then the Tk Gui if Qt does not exist.
  This should make it much less likely that a prompt for the id
  will be sent to the console.


2. The readme.txt file for 4.7.1-final does not mention that Python and PyQt is
   required.

readme.txt does say it has a new Windows installer. This
led me to believe -- erroneously -- that the Windows installer is all
I would need to download and install, since it's typical for most open
source programs I've used to have everything needed for the install
(for example. .NET) in the single Windows download.

2b. And perhaps the readme.txt file as well?

Can the [install] page be updated to make this clearer?

4. When I first went to the Install page, I clicked on the link for
"Installing Leo on Windows", got to the end of the steps and saw the
next section was "Tracking the development version" which I wasn't
interested in doing so I didn't read any further.

Clicking on the installer-created Windows link for Leo on the Start
Menu did nothing. Eventually I found the Windows section under
"Running Leo" and learned it was required to run Leo the first time
from a console window and not by launching it from Windows.
#@+node:ekr.20100801112314.11718: *4* Improved handling of history
@nocolor-node

nav_qt.py just uses these:

    c.goPrevVisitedNode()
    c.goNextVisitedNode()

and these subsequently use leoCommand.py / class nodeHistory.

The fix would have to happen in leoFrame.py / selectHelper() which does this:

    c.nodeHistory.update(p) # Remember this position.

It shouldn't call update() there. Rather, the call should be moved to
wherever body focus code is.

The fix was to leoTree.selectHelper and qtBody.onFocusIn.

#@+node:ekr.20100803231223.5806: *4* Added ini importer
#@+node:ekr.20100803231223.5807: *5* class iniScanner
class iniScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        baseScannerClass.__init__(self,
            importCommands,atAuto=atAuto,language='ini')

        # Override defaults defined in the base class.
        self.classTags = []
        self.functionTags = []
        self.hasClasses = False
        self.hasFunctions = True
        self.lineCommentDelim = ';'

    def startsString(self,s,i):
        return False

    @others
#@+node:ekr.20100803231223.5810: *6* startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts section.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    sigStart = i
    ok,sigId,i = self.isSectionLine(s,i)
    if not sigId or not ok:
        # if trace: g.trace('fail',repr(g.getLine(s,i)))
        return False

    i = sigEnd = g.skip_line(s,i)

    # Skip everything until the next section.
    while i < len(s):
        progress = i
        ok,junk,junk = self.isSectionLine(s,i)
        if ok: break # don't change i.
        i = g.skip_line(s,i)
        assert progress < i

    # Success: set the ivars.
    self.sigStart = sigStart
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = None

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    if trace: g.trace(sigId,'returns\n'+s[self.sigStart:i]+'\nEND')
    return True
#@+node:ekr.20100803231223.5815: *6* isSectionLine
def isSectionLine(self,s,i):

    i = g.skip_ws(s,i)
    if not g.match(s,i,'['):
        return False,None,i
    k = s.find('\n',i+1)
    if k == -1: k = len(s)
    j = s.find(']',i+1)
    if -1 < j < k:
        return True,s[i:j+1],i
    else:
        return False,None,i
#@+node:ekr.20100812082517.5943: *4* Added code-to-rst command
# And deprecated code mode.
#@+node:ekr.20100813041139.5917: *4* Added g.findTestScript
The typical usage::

    g.findTestScript(c,'@common code for tests of x')
#@+node:ekr.20100827114047.5891: *4* Removed mark-clones command
It is useless in the one-node world.
#@+node:ekr.20100830095308.5828: *4* Can we write all top-level tnodes?
#@+node:ekr.20031218072017.1863: *5* putVnode
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()

    if   isIgnore: forceWrite = True      # Always write full @ignore trees.
    elif isAuto:   forceWrite = False     # Never write non-ignored @auto trees.
    elif isEdit:   forceWrite = False     # Never write non-ignored @edit trees.
    elif isShadow: forceWrite = False     # Never write non-ignored @shadow trees.
    elif isThin:   forceWrite = isOrphan  # Only write orphan @thin trees.
    else:          forceWrite = True      # Write all other @<file> trees.

    << Set gnx = vnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s>' % (gnx,attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head+'</v>\n')
    else:
        fc.vnodesDict[gnx]=True
        v_head += '<vh>%s</vh>' % (xml.sax.saxutils.escape(p.v.headString()or''))
        # The string catentation is faster than repeated calls to fc.put.
        if not self.usingClipboard:
            << issue informational messages >>
        # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p,isIgnore)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent() # Restore p in the caller.
            fc.put('</v>\n')
        else:
            fc.put('%s</v>\n' % v_head) # Call put only once.
#@+node:ekr.20031218072017.1864: *6* << Set gnx = vnode index >>
gnx = g.app.nodeIndices.toString(v.fileIndex)

if forceWrite or self.usingClipboard:
    v.setWriteBit() # 4.2: Indicate we wrote the body text.
#@+node:ekr.20031218072017.1865: *6* << Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
# New in Leo 4.5: support fixed .leo files.
if not c.fixed:
    if v.isExpanded() and v.hasChildren(): attr += "E"
    if v.isMarked():   attr += "M"
    if v.isOrphan():   attr += "O"
    if attr:
        attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if p == self.rootPosition:
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    str_pos = ','.join(aList)
    if d.get('str_leo_pos'):
        del d['str_leo_pos']
    # Don't write the current position if we can cache it. 
    if g.enableDB and c.mFileName:
        c.cacher.setCachedStringPosition(str_pos)
    elif c.fixed:
        pass
    else:
        d['str_leo_pos'] = str_pos
    # g.trace(aList,d)
    v.unknownAttributes = d
elif hasattr(v,"unknownAttributes"):
    d = v.unknownAttributes
    if d and not c.fixed and d.get('str_leo_pos'):
        # g.trace("clearing str_leo_pos",v)
        del d['str_leo_pos']
        v.unknownAttributes = d
#@+node:ekr.20040324082713: *6* << Append unKnownAttributes to attrs>> fc.put
# v.unknownAttributes are now put in <t> elements.

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    if not isAuto: # Bug fix: 2008/8/7.
        attrs.append(self.putDescendentVnodeUas(p)) # New in Leo 4.5.
        attrs.append(self.putDescendentAttributes(p))
#@+node:ekr.20040702085529: *6* << issue informational messages >>
if isOrphan and isThin:
    g.es("writing erroneous:",p.h,color="blue")
    p.clearOrphan()
#@+node:ekr.20060919110638.5: *5* fc.createSaxChildren & helpers
def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') > -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
#@+node:ekr.20060919110638.7: *6* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
#@+node:ekr.20060919110638.8: *7* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = d.get(key)
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
#@+node:ekr.20061004053644: *7* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes
    # if trace and d: g.trace(d)

    s = d.get('a')
    if s:
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
#@+node:ekr.20041005105605.72: *5* at.createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new *vnode* whose parent (also a vnode)
    is at.lastThinNode. This is called only for @thin trees."""

    trace = False and not g.unitTesting
    verbose = False
    at = self ; c = at.c ; indices = g.app.nodeIndices
    parent = last = at.lastThinNode # A vnode.
    lastIndex = last.fileIndex
    gnx = indices.scanGnx(gnxString,0)

    if trace and verbose: g.trace("last %s, gnx %s %s" % (
        last,gnxString,headline))

    children = parent.children
    for child in children:
        if gnx == child.fileIndex:
            break
    else:
        child = None

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(parent,child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        if trace: g.trace(copies,headline)
    else:
        if gnx == lastIndex:
            last.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace:g.trace('found last',last)
            return last
        if child:
            child.setVisited()
                # Supress warning/deletion of unvisited nodes.
            if trace: g.trace('found child',child)
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the vnode only if it does not already exist.
        gnxDict = c.fileCommands.gnxDict
        v = gnxDict.get(gnxString)
        if v:
            if gnx != v.fileIndex:
                g.trace('can not happen: v.fileIndex: %s gnx: %s' % (
                    v.fileIndex,gnx))
        else:
            v = leoNodes.vnode(context=c)
            v._headString = headline # Allowed use of v._headString.
            v.fileIndex = gnx
            gnxDict[gnxString] = v

        child = v
        child._linkAsNthChild(parent,parent.numberOfChildren())

    if trace: g.trace('new node: %s' % child)
    child.setVisited() # Supress warning/deletion of unvisited nodes.
    return child
#@+node:ekr.20070806111212: *5* readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    message = g.choose(found,'finished','no @auto nodes in the selected tree')
    g.es(message,color='blue')
    c.redraw()

#@+node:ekr.20070807084545: *6* readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # 2010/01/15: Remember that we have read this file.
    # http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
    # Important: createOutline usually sets the bit in the wrong node.
    p.v.at_read = True # Create the attribute

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
#@-all
#@-leo
