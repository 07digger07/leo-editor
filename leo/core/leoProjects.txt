#@+leo-ver=4-thin
#@+node:ekr.20100120072650.6089:@thin leoProjects.txt
#@+at
# This part of the tree shows views of the outline related to specific 
# projects or
# tasks. I put such headlines in parentheses, and that is just my convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the
# cloned headlines under the task headline. This greatly increases my focus. 
# Any
# changes made in a task view to clone headlines affect the other clones 
# scattered
# throughout the outline. In particular, all @file nodes containing changed 
# clones
# become marked as dirty, so they will be written when the entire outline is
# saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20100212095952.5727:4.7 final projects
#@+node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@+node:ekr.20100212095952.5729:changed...
#@+node:ekr.20050415134809.1:c.sortSiblings
# New in Leo 4.7 final: this method no longer supports
# the 'cmp' keyword arg.

def sortSiblings (self,event=None,key=None,p=None,sortChildren=False):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer
    if p is None: p = c.p
    if not p: return

    c.endEditing()

    undoType = g.choose(sortChildren,'Sort Children','Sort Siblings')
    parent_v = p._parentVnode()
    parent = p.parent()
    oldChildren = parent_v.children[:]
    newChildren = parent_v.children[:]

    if key == None:
        def lowerKey (self):
            return (self.h.lower())
        key = lowerKey

    newChildren.sort(key=key)

    if oldChildren == newChildren:
        return

    # 2010/01/20. Fix bug 510148.
    c.setChanged(True)

    # g.trace(g.listToString(newChildren))

    bunch = u.beforeSort(p,undoType,oldChildren,newChildren,sortChildren)
    parent_v.children = newChildren
    if parent:
        dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
    else:
        dirtyVnodeList = []
    u.afterSort(p,bunch,dirtyVnodeList)

    # Sorting destroys position p, and possibly the root position.
    p = c.setPositionAfterSort(sortChildren)
    c.redraw(p)
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
    return result # for unit test.
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20060202161935:printGcAll
def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    if not g.unitTesting:
        g.pr('-' * 30)
        g.pr('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except Exception: pass
        # if type(obj) == type(()):
            # g.pr(id(obj),repr(obj))
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = list(d.items())
        items.sort(key=lambda x: x[1])
            # key is a function that extracts args.
        if not g.unitTesting:
            for z in items:
                g.pr('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        for t in sorted(d):
            g.pr('%40s %7d' % (t,d.get(t)))
#@-node:ekr.20060202161935:printGcAll
#@+node:ekr.20050920084036.118:sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):

    '''Sort lines of the selected text by comparing the entire text of a line.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = g.choose(reverse,'reverse-sort-lines','sort-lines')
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines commands
#@+node:tbrown.20080509212202.8:sortRecentFiles
def sortRecentFiles(self,event=None):

    c = self

    orig = c.recentFiles[:]
    c.clearRecentFiles()

    def key(s):
        return g.os_path_basename(s).lower()
    orig.sort(key=key) # 2010/01/12
    orig.reverse() # 2010/01/12
    for i in orig:
        c.updateRecentFiles(i)

    # code below copied from clearRecentFiles
    g.app.config.recentFiles = [] # New in Leo 4.3.
    g.app.config.appendToRecentFiles(c.recentFiles)
    g.app.config.recentFileMessageWritten = False # Force the write message.
    g.app.config.writeRecentFilesFile(c)
#@-node:tbrown.20080509212202.8:sortRecentFiles
#@-node:ekr.20100212095952.5729:changed...
#@-node:ekr.20100212095952.5726:Fixed calls to sort in 6 places
#@+node:ekr.20100215121737.5600:Fixed possible segfault in c.save/As/To
@nocolor-node

The segfault happens on Linux at the (now removed) call
to c.widgetWantsFocusNow(w) at the end of c.save, c.saveAs and c.saveTo
when w no longer exists in the tree.
#@-node:ekr.20100215121737.5600:Fixed possible segfault in c.save/As/To
#@+node:ekr.20100204052559.5792:Made goto-global-line work with @auto files
@nocolor-node

Fix bug 363406: goto global line doesn't seem to be working in @auto files
#@+node:ekr.20100216141722.5620:class gotoLineNumber and helpers (commands)
class goToLineNumber:

    '''A class implementing goto-global-line.'''

    @others
#@+node:ekr.20100216141722.5621: __init__ (gotoLineNumber)
def __init__ (self,c):

    # g.trace('(c.gotoLineNumber)')
    self.c = c
    self.p = c.p.copy()
#@-node:ekr.20100216141722.5621: __init__ (gotoLineNumber)
#@+node:ekr.20100216141722.5622:go
def go (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self.c
    if n < 0: return

    if scriptData:
        fileName,lines,p,root = self.setup_script(scriptData)
    else:
        if not p: p = c.p
        fileName,lines,n,root = self.setup_file(n,p)

    isRaw = not root or (
        root.isAtEditNode() or root.isAtAsisFileNode() or
        root.isAtAutoNode() or root.isAtNoSentFileNode())
    ignoreSentinels = root and root.isAtNoSentFileNode()
    if not root:
        if scriptData:  root = p.copy()
        else:           root = c.p

    if isRaw:
        p,n2,found = self.countLines(root,n)
        n2 += 1 # Convert to one-based.
    # elif n<=1
        # p,n2,found = root,1,True
    # elif n > len(lines):
        # p,n2,found = root,root.b.count('\n'),False
    else:
        # if n == 0: n = 1
        vnodeName,gnx,n2,delim = self.findVnode(root,lines,n,ignoreSentinels)
        p,found = self.findGnx(delim,root,gnx,vnodeName)

    self.showResults(found,p or root,n,n2,lines)
    return found
#@-node:ekr.20100216141722.5622:go
#@+node:ekr.20100216141722.5623:countLines & helpers
def countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,i,found)
    p is the found node.
    i is the offset of the line within the node.
    found is True if the line was found.'''

    trace = False # and not g.unitTesting
    c = self.c

    # Start the recursion.
    n = max(0,n-1)# Convert to zero based internally.
    if trace: g.trace('%s %s (zero-based) %s' % ('*' * 20,n,root.h))
    p,i,junk,found = self.countLinesHelper(root,n,trace)
    return p,i,found # The index is zero-based.
#@+node:ekr.20100216141722.5624:countLinesHelper
def countLinesHelper (self,p,n,trace):

    '''Scan p's body text, looking for line n,
    ao is the index of the line containing @others or None.

    Return (p,i,n,effective_lines,found)
    found: True if the line was found.
    if found:
        p:              The found node.
        i:              The offset of the line within the node.
        effective_lines:-1 (not used)
    if not found:
        p:              The original node.
        i:              -1 (not used)
        effective_lines:The number of lines in this node and
                        all descendant nodes.
    '''
    if trace: g.trace('='*10,n,p.h)
    c = self.c ; ao = None
    lines = g.splitLines(p.b)
    i = 0 ; n1 = n
    effective_lines = 0 ; skipped_lines = 0
    # Invariant 1: n never changes in this method(!)
    # Invariant 2: n + skipped_lines is the target line number.
    while i < len(lines):
        progress = i
        line = lines[i]
        if trace: g.trace('i %s effective %s skipped %s %s' % (
            i,effective_lines,skipped_lines,line.rstrip()))
        if line.strip().startswith('@'):
            skipped_lines += 1
            if line.strip().startswith('@others'):
                if ao is None and p.hasChildren():
                    ao = i
                    # Count lines in inner nodes.
                    # Pass n-effective_lines as the targe line number.
                    new_n = n-effective_lines
                    p2,i2,effective_lines2,found = \
                        self.countLinesInChildren(new_n,p,trace)
                    if found:
                        return p2,i2,-1,True # effective_lines doesn't matter.
                    else:
                        # Assert that the line has not been found.
                        assert effective_lines2 <= new_n
                        effective_lines += effective_lines2
                        # Do *not* change i: it will be bumped below.
                        # Invariant: n never changes!
                else:
                    pass # silently ignore erroneous @others.
            else:
                pass # A regular directive: don't change n or i here.
        elif i == n + skipped_lines: # Found the line.
            if trace:
                g.trace('Found! n: %s i: %s %s' % (n,i,lines[i]))
            return p,i,-1,True # effective_lines doesn't matter.
        else:
            effective_lines += 1
        # This is the one and only place we update i in this loop.
        i += 1
        assert i > progress

    if trace:
        g.trace('Not found. n: %s effective_lines: %s %s' % (
            n,effective_lines,p.h))
    return p,-1,effective_lines,False # i doesn't matter.
#@-node:ekr.20100216141722.5624:countLinesHelper
#@+node:ekr.20100216141722.5625:countLinesInChildren
def countLinesInChildren(self,n,p,trace):

    if trace: g.trace('-'*5,n,p.h)
    effective_lines = 0
    for child in p.children():
        if trace:g.trace('child %s' % child.h)
        # Recursively scan the children.
        # Pass n-effective_lines as the targe line number for each child.
        new_n = n-effective_lines
        p2,i2,effective_lines2,found = \
            self.countLinesHelper(child,new_n,trace)
        if found:
            return p2,i2,-1,True # effective_lines doesn't matter.
        else:
            # Assert that the line has not been found.
            assert effective_lines2 <= new_n
            # i2 is not used
            effective_lines += effective_lines2
            if trace:
                g.trace('Not found. effective_lines2: %s %s' % (
                    effective_lines2,child.h))
    else:
        return p,-1,effective_lines,False # i does not matter.
#@-node:ekr.20100216141722.5625:countLinesInChildren
#@-node:ekr.20100216141722.5623:countLines & helpers
#@+node:ekr.20100216141722.5626:findGnx
def findGnx (self,delim,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    if delim and gnx:
        gnx = g.app.nodeIndices.scanGnx(gnx,0)
        for p in root.self_and_subtree():
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(),True
        return None,False
    else:
        return root,False
#@-node:ekr.20100216141722.5626:findGnx
#@+node:ekr.20100216141722.5627:findRoot
def findRoot (self,p):

    '''Find the closest ancestor @<file> node, except @all nodes.

    return root, fileName.'''

    c = self.c ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions():
        if p.v == p1.v and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
#@-node:ekr.20100216141722.5627:findRoot
#@+node:ekr.20100216141722.5628:findVnode & helpers
def findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self.c
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    delim,thinFile = self.setDelimFromLines(lines)
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    nodeLine,offset = self.findNodeSentinel(delim,lines,n)
    if nodeLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeLine]
    gnx,vnodeName = self.getNodeLineInfo(s,thinFile)
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
#@+node:ekr.20100216141722.5629:findNodeSentinel & helper
def findNodeSentinel(self,delim,lines,n):

    '''
    Scan backwards from the line n, looking for an @-body line. When found,
    get the vnode's name from that line and set p to the indicated vnode. This
    will fail if vnode names have been changed, and that can't be helped.

    We compute the offset of the requested line **within the found node**.
    '''

    c = self.c
    offset = 0 # This is essentially the Tk line number.
    nodeSentinelLine = -1
    line = n - 1 # Start with the requested line.
    while line >= 0 and nodeSentinelLine == -1:
        progress = line
        s = lines[line]
        i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            line,nodeSentinelLine,offset = self.handleDelim(
                delim,s,i,line,lines,n,offset)
        else:
            # offset += 1
                # Assume the line is real.
                # A dubious assumption.
            line -= 1
        assert nodeSentinelLine > -1 or line < progress
    return nodeSentinelLine,offset
#@+node:ekr.20100216141722.5630:handleDelim
def handleDelim (self,delim,s,i,line,lines,n,offset):

    '''Handle the delim while scanning backward.'''

    c = self.c
    if line == n:
        g.es("line",str(n),"is a sentinel line")
    i += len(delim)
    nodeSentinelLine = -1

    if g.match(s,i,"-node"):
        # The end of a nested section.
        old_line = line
        line = self.skipToMatchingNodeSentinel(lines,line,delim)
        assert line < old_line
        # g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"+node"):
        # g.trace('found',repr(lines[line]))
        nodeSentinelLine = line
        offset = n-line
    elif g.match(s,i,"<<") or g.match(s,i,"@first"):
        # if not ignoreSentinels:
            # offset += 1 # Count these as a "real" lines.
        line -= 1
    else:
        line -= 1
        nodeSentinelLine = -1
    return line,nodeSentinelLine,offset
#@-node:ekr.20100216141722.5630:handleDelim
#@-node:ekr.20100216141722.5629:findNodeSentinel & helper
#@+node:ekr.20100216141722.5631:getNodeLineInfo
def getNodeLineInfo (self,s,thinFile):

    i = 0 ; gnx = None ; vnodeName = None

    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:   gnx = s[i:j]
            else:       i = len(s) # Force an error.
        else:
            i = len(s) # Force an error.

    # vnode name is everything following the first or second':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    else:
        vnodeName = None
        g.es_print("bad @+node sentinel",color='red')

    return gnx,vnodeName
#@-node:ekr.20100216141722.5631:getNodeLineInfo
#@+node:ekr.20100216141722.5632:setDelimFromLines
def setDelimFromLines (self,lines):

    # Find the @+leo line.
    c = self.c ; at = c.atFileCommands
    i = 0 
    while i < len(lines) and lines[i].find("@+leo")==-1:
        i += 1
    leoLine = i # Index of the line containing the leo sentinel

    # Set delim and thinFile from the @+leo line.
    delim,thinFile = None,False

    if leoLine < len(lines):
        s = lines[leoLine]
        valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
        # New in Leo 4.5.1: only support 4.x files.
        if valid and newDerivedFile:
            delim = start + '@'

    return delim,thinFile
#@-node:ekr.20100216141722.5632:setDelimFromLines
#@+node:ekr.20100216141722.5633:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
#@-node:ekr.20100216141722.5633:skipToMatchingNodeSentinel
#@-node:ekr.20100216141722.5628:findVnode & helpers
#@+node:ekr.20100216141722.5634:getFileLines
def getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self.c
    isAtEdit = root.isAtEditNode()
    isAtNoSent = root.isAtNoSentFileNode()

    if isAtNoSent or isAtEdit:
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        kind = g.choose(isAtNoSent,'@nosent','@edit')
        at.write(root,kind=kind,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = self.openFile(fileName)

    return lines
#@-node:ekr.20100216141722.5634:getFileLines
#@+node:ekr.20100216141722.5635:openFile (gotoLineNumber)
def openFile (self,filename):
    """
    Open a file and check if a shadow file exists.
    Construct a line mapping. This ivar is empty if no shadow file exists.
    Otherwise it contains a mapping, shadow file number -> real file number.
    """

    c = self.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines,
                x.markerFromFileLines(lines,shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
#@-node:ekr.20100216141722.5635:openFile (gotoLineNumber)
#@+node:ekr.20100216141722.5636:setup_file
def setup_file (self,n,p):

    '''Return (lines,n) where:

    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    '''

    c = self.c ; x = c.shadowController

    root,fileName = self.findRoot(p)

    if root and fileName:
        c.shadowController.line_mapping = [] # Set by open.
        lines = self.getFileLines(root,fileName)
            # This will set x.line_mapping for @shadow files.
        if len(x.line_mapping) > n:
            n = x.line_mapping[n]
    else:
        if not g.unitTesting:
            g.es("no ancestor @<file node>: using script line numbers",
                color="blue")
        lines = g.getScript(c,p,useSelectedText=False)
        lines = g.splitLines(lines)

    return fileName,lines,n,root
#@-node:ekr.20100216141722.5636:setup_file
#@+node:ekr.20100216141722.5637:setup_script
def setup_script (self,scriptData):

    c = self.c

    p = scriptData.get('p')
    root,fileName = self.findRoot(p)
    lines = scriptData.get('lines')

    return fileName,lines,p,root
#@-node:ekr.20100216141722.5637:setup_script
#@+node:ekr.20100216141722.5638:showResults
def showResults(self,found,p,n,n2,lines):

    trace = False
    c = self.c ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) < n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    if trace and g.unitTesting:
        i,j = g.getLine(s,ins)
        g.trace('%2s %2s %15s %s' % (n,n2,p.h,repr(s[i:j])))

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()
#@-node:ekr.20100216141722.5638:showResults
#@-node:ekr.20100216141722.5620:class gotoLineNumber and helpers (commands)
#@-node:ekr.20100204052559.5792:Made goto-global-line work with @auto files
#@+node:ekr.20100219045859.5650:Put focus in a standard place after save commands
@nocolor-node

After modifying the content of a node body and hitting Ctrl-S to save
the outline, the edit pane loses focus. This is inconvenient, because
I have a habit of pressing Ctrl-S very often.

I see this in r2968, only for the qt GUI.
Python 2.6.2, qt version 4.5.0, Slackware Linux 13.0
#@+node:ekr.20070226121510: treeFocusHelper
def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20070226121510: treeFocusHelper
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:c.new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    g.doHook("new",old_c=self,c=c,new_c=c)
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    g.createMenu(c)
    g.finishOpen(c)
    g.app.writeWaitingLog(c,forceLog=True) # Force a new signon message.
    c.redraw()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:c.new
#@+node:ekr.20031218072017.2821:c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@+node:ekr.20090212054250.9:c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@nonl
#@-node:ekr.20090212054250.9:c.createNodeFromExternalFile
#@-node:ekr.20031218072017.2821:c.open & helper
#@+node:ekr.20031218072017.2823:c.openWith and helpers
def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''

    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return 'break'
#@+node:ekr.20031218072017.2824:c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
#@-node:ekr.20031218072017.2824:c.getOpenWithExt
#@+node:ekr.20031218072017.2829:c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '<no command>'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
#@-node:ekr.20031218072017.2829:c.openTempFileInExternalEditor
#@+node:ekr.20100203050306.5797:c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
#@+node:ekr.20031218072017.2827:c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
#@-node:ekr.20031218072017.2827:c.createOrRecreateTempFileAsNeeded
#@+node:ekr.20100203050306.5937:c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if g.os_path_exists(fn):
            g.es('recreating:  ',g.shortFileName(fn),color='red')
        else:
            g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time: g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
#@-node:ekr.20100203050306.5937:c.createOpenWithTempFile
#@-node:ekr.20100203050306.5797:c.openWithHelper
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

     This is overridden in mod_tempfname plugin
     '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath (may be over-ridden)
#@-node:ekr.20031218072017.2823:c.openWith and helpers
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:c.save
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.currentPosition()
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame,'top'):
                c.frame.top.master.setTabName(c,c.mFileName)
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using w directly.
    if inBody:
        c.bodyWantsFocusNow()
    else:
        c.treeWantsFocusNow()
#@nonl
#@-node:ekr.20031218072017.2834:c.save
#@+node:ekr.20031218072017.2835:c.saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        if g.app.qt_use_tabs and hasattr(c.frame,'top'):
            c.frame.top.master.setTabName(c,c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)

    # Done in fileCommands.saveAs.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using w directly.
    if inBody:
        c.bodyWantsFocusNow()
    else:
        c.treeWantsFocusNow()
#@-node:ekr.20031218072017.2835:c.saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:c.saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
        g.chdir(fileName)

    # Does not change icons status.
    # c.redraw_after_icons_changed()

    # *Safely* restore focus, without using w directly.
    if inBody:
        c.bodyWantsFocusNow()
    else:
        c.treeWantsFocusNow()
#@nonl
#@-node:ekr.20031218072017.2836:c.saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20100219045859.5650:Put focus in a standard place after save commands
#@+node:ekr.20100219050413.8107:Fixed internal Leo error
@nocolor-node

I got this after changing @auto to @thin and doing read @<file> nodes.

Internal Leo error in writeFile
empty fileKey
Called from readAtFileNodes,readAtFileNodes,readAll,read

The bug is that fileKey is needed even if force is True.
#@nonl
#@+node:ekr.20041005105605.21:read (atFile) & helpers
def read(self,root,importFileName=None,
    fromString=None,atShadow=False,force=False
):

    """Read an @thin or @file tree."""

    # g.trace(root.h,len(root.b))
    at = self ; c = at.c
    fileName = at.initFileName(fromString,importFileName,root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.initReadIvars(root,fileName,
        importFileName=importFileName,atShadow=atShadow)
    if at.errors:
        return False
    fileName = at.openFileForReading(fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    root.v.at_read = True # Remember that we have read this file.

    # Get the file from the cache if possible.
    loaded,fileKey = c.cacher.readFile(fileName,root)
    if loaded and not force:
        at.inputFile.close()
        root.clearDirty()
        return True
    if not g.unitTesting:
        g.es("reading:",root.h)
    root.clearVisitedInTree()
    d = at.scanAllDirectives(root,importing=at.importing,reading=True)
    thinFile = at.readOpenFile(root,at.inputFile,fileName,deleteNodes=True)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        at.warnAboutUnvisitedNodes(root)
        at.deleteTnodeList(root)
    if at.errors == 0 and not at.importing:
        # Used by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)
    at.deleteAllTempBodyStrings()
    if at.errors == 0:
        c.cacher.writeFile(root,fileKey)

    return at.errors == 0
#@+node:ekr.20041005105605.25:deleteAllTempBodyStrings
def deleteAllTempBodyStrings(self):

    for v in self.c.all_unique_nodes():
        if hasattr(v,"tempBodyString"):
            delattr(v,"tempBodyString")
#@-node:ekr.20041005105605.25:deleteAllTempBodyStrings
#@+node:ekr.20100122130101.6174:deleteTnodeList
def deleteTnodeList (self,p): # atFile method.

    '''Remove p's tnodeList.'''

    v = p.v

    if hasattr(v,"tnodeList"):

        if False: # Not an error, but a useful trace.
            s = "deleting tnodeList for " + repr(v)
            g.es_print(s,color="blue")

        delattr(v,"tnodeList")
        v._p_changed = True
#@-node:ekr.20100122130101.6174:deleteTnodeList
#@+node:ekr.20041005105605.22:initFileName
def initFileName (self,fromString,importFileName,root):

    if fromString:
        fileName = "<string-file>"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None

    return fileName

    # isAtFile = (
        # not thinFile and
        # not importFileName and
        # not atShadow and
        # not fromString and
        # root.h.startswith('@file'))
#@-node:ekr.20041005105605.22:initFileName
#@+node:ekr.20071105164407:warnAboutUnvisitedNodes
def warnAboutUnvisitedNodes (self,root):

    resurrected = 0

    for p in root.self_and_subtree():
        if not p.v.isVisited():
            g.trace('**** not visited',p.v,p.h)
            g.es('resurrected node:',p.h,color='blue')
            g.es('in file:',root.h,color='blue')
            resurrected += 1

    if resurrected:
        g.es('you may want to delete ressurected nodes')
#@-node:ekr.20071105164407:warnAboutUnvisitedNodes
#@-node:ekr.20041005105605.21:read (atFile) & helpers
#@-node:ekr.20100219050413.8107:Fixed internal Leo error
#@+node:ekr.20100219075946.5680:Fixed wish-list bug 508108: No methods sub-nodes in PHP class import
@nocolor-node

EKR: this is a wish-list item

https://bugs.launchpad.net/leo-editor/+bug/508108

When importing a PHP class file, I get two nodes: the first is just some Leo
definitions (@language, @tab, @others), while the second is the whole class. I
expect Leo to create a node for each method in the class as it does for
"classless" file of functions (not sure how it is done in other languages). This
kind of change would also make @auto a lot more useful for PHP.
#@nonl
#@+node:ekr.20100219075946.5742:class phpScanner
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20100219075946.5743: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'

    self.hasClasses = True # 2010/02/19
    self.hasFunctions = True

    self.functionTags = ['function']

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in range(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20100219075946.5743: __init__
#@+node:ekr.20100219075946.5744:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php and ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20100219075946.5744:isPurePHP
#@+node:ekr.20100219075946.5745:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20100219075946.5746:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return g.skip_string(s,i)
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20100219075946.5746:startsString skipString
#@+node:ekr.20100219075946.5747:getSigId
def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.

    For Php, the first id is better.'''

    return ids and ids[1]
#@-node:ekr.20100219075946.5747:getSigId
#@-node:ekr.20100219075946.5745:Overrides
#@-node:ekr.20100219075946.5742:class phpScanner
#@-node:ekr.20100219075946.5680:Fixed wish-list bug 508108: No methods sub-nodes in PHP class import
#@+node:ekr.20100219083711.5614:Fixed qt colorizer bug
@nocolor-node

Default fonts were not being properly restored after being overridden in another language.

For example, after colorizing php, python keywords looked like php keywords.
#@nonl
#@-node:ekr.20100219083711.5614:Fixed qt colorizer bug
#@+node:ekr.20100221113505.5619:Fixed ancient minibuffer bug
@nocolor-node

The bug: Find/change prompts were not fully protected after home

The fix was to k.getArg: it must test for '\b' as well as 'BackSpace'.

I would like to clean up this mess in Leo 4.8.
#@nonl
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@-node:ekr.20100221113505.5619:Fixed ancient minibuffer bug
#@+node:ekr.20100221143740.5633:Improved support for wrapping in the log pane
# And reformatted the apropos commands.
#@nonl
#@+node:ekr.20060205164707:helpCommandsClass
class helpCommandsClass (baseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
#@+node:ekr.20060205165501:getPublicCommands (helpCommands)
def getPublicCommands (self):

    return {
        'help-for-minibuffer':      self.helpForMinibuffer,
        'help-for-command':         self.helpForCommand,
        'apropos-autocompletion':   self.aproposAutocompletion,
        'apropos-bindings':         self.aproposBindings,
        'apropos-debugging-commands': self.aproposDebuggingCommands,
        'apropos-find-commands':    self.aproposFindCommands,
        'print-settings':           self.printSettings,
        'python-help':              self.pythonHelp,
    }
#@-node:ekr.20060205165501:getPublicCommands (helpCommands)
#@+node:ekr.20051014170754:helpForMinibuffer
def helpForMinibuffer (self,event=None):

    '''Print a messages telling you how to get started with Leo.'''

    # A bug in Leo: triple quotes puts indentation before each line.
    c = self.c
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
full command name, then hit <Return> to execute the command. Tab completion
works, but not yet for file names.

quick-command-mode (default shortcut: Alt-x). Like Emacs Control-C. This mode is
defined in leoSettings.leo. It is useful for commonly-used commands.

universal-argument (default shortcut: Alt-u). Like Emacs Ctrl-u. Adds a repeat
count for later command. Ctrl-u 999 a adds 999 a's. Many features remain
unfinished.

keyboard-quit (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
the focus in the body pane.

Use the help-for-command command to see documentation for a particular command.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    # s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])

    if not g.app.unitTesting:
        g.es_print('',s)
#@-node:ekr.20051014170754:helpForMinibuffer
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):

    '''Prompts for a command name and prints the help message for that command.'''

    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)

def helpForCommandFinisher (self,commandName):

    c = self.c
    bindings = self.getBindingsForCommand(commandName)
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
    else:
        s = 'no docstring'
    g.es('','%s:%s\n%s\n' % (commandName,bindings,s),color='blue')

def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k ; d = k.bindingsDict
    data = [] ; n1 = 4 ; n2 = 20
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            if b.commandName == commandName:
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key,brief=True)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
        # key is a function that extracts args.

    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data])
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20060226131603.1:aproposAutocompletion
# @pagewidth 40

def aproposAutocompletion (self,event=None):

    '''Prints a discussion of autocompletion.'''

    c = self.c ; s = '''

This documentation describes both
autocompletion and calltips.

Typing a period when @language python is
in effect starts autocompletion. Typing
'(' during autocompletion shows the
calltip. Typing Return or Control-g
(keyboard-quit) exits autocompletion or
calltips.

=== Autocompletion

Autocompletion shows what may follow a
period in code. For example, after
typing g. Leo will show a list of all
the global functions in leoGlobals.py.
Autocompletion works much like tab
completion in the minibuffer. Unlike the
minibuffer, the presently selected
completion appears directly in the body
pane.

A leading period brings up 'Autocomplete
Modules'. (The period goes away.) You
can also get any module by typing its
name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only
the valid starting characters. At this
point, typing an exclamation mark shows
the complete list. Thereafter, typing
further exclamation marks toggles
between full and abbreviated modes.

If x is a list 'x.!' shows all its
elements, and if x is a Python
dictionary, 'x.!' shows list(x.keys()).
For example, 'sys.modules.!' Again,
further exclamation marks toggles
between full and abbreviated modes.

During autocompletion, typing a question
mark shows the docstring for the object.
For example: 'g.app?' shows the
docstring for g.app. This doesn't work
(yet) directly for Python globals, but
'__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring
for pow.

Autocompletion works in the Find tab;
you can use <Tab> to cycle through the
choices. The 'Completion' tab appears
while you are doing this; the Find tab
reappears once the completion is
finished.

=== Calltips

Calltips appear after you type an open
parenthesis in code. Calltips shows the
expected arguments to a function or
method. Calltips work for any Python
function or method, including Python's
global function. Examples:

a) g.toUnicode(
   gives:
   g.toUnicode(s,encoding, reportErrors=False

b) c.widgetWantsFocusNow
   gives:
   c.widgetWantsFocusNow(w

c) reduce(
   gives:
   reduce(function, sequence[,initial]) -> value

The calltips appear directly in the text
and the argument list is highlighted so
you can just type to replace it. The
calltips appear also in the status line
for reference after you have started to
replace the args.

Options

Both autocompletion and calltips are
initially enabled or disabled by the
enable_autocompleter_initially and
enable_calltips_initially settings in
leoSettings.leo. You may enable or
disable these features at any time with
these commands: enable-autocompleter,
enable-calltips, disable-autocompleter
and disable-calltips. '''

    if not g.app.unitTesting:
        # Remove indentation from indentation of this function.
        s = g.adjustTripleString(s,c.tab_width)
        g.es('',s)
#@-node:ekr.20060226131603.1:aproposAutocompletion
#@+node:ekr.20060205170335:aproposBindings
# @pagewidth 40

def aproposBindings (self,event=None):

    '''Prints a discussion of keyboard bindings.'''

    c = self.c
    s = '''

A shortcut specification has the form:

command-name = shortcutSpecifier

or

command-name ! pane = shortcutSpecifier

The first form creates a binding for all
panes except the minibuffer. The second
form creates a binding for one or more
panes. The possible values for 'pane'
are:

pane    bound panes
----    -----------
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree

You may use None as the specifier.
Otherwise, a shortcut specifier consists
of a head followed by a tail. The head
may be empty, or may be a concatenation
of the following: (All entries in each
row are equivalent).

Shift+ Shift-
Alt+ or Alt-
Control+, Control-, Ctrl+ or Ctrl-

Notes:

1. The case of plain letters is significant:
   a is not A.

2. The Shift- (or Shift+) prefix can be
   applied *only* to letters or
   multi-letter tails. Leo will ignore
   (with a warning) the shift prefix
   applied to other single letters,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by
   Ctrl-, Alt-, Key- or Shift- is *not*
   significant.

The following table illustrates these
rules. In each row, the first entry is
the key (for k.bindingsDict) and the
other entries are equivalents that the
user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.

    if not g.app.unitTesting:
        g.es('',s)
#@-node:ekr.20060205170335:aproposBindings
#@+node:ekr.20070501092655:aproposDebuggingCommands
def aproposDebuggingCommands (self,event=None):

    '''Prints a discussion of of Leo's debugging commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es('',s)
#@+node:ekr.20070501092655.1:<< define s >>
# @pagewidth 40

s = '''
The following commands are useful for debugging:

collect-garbage:   Invoke the garbage collector.
debug:             Start an external debugger in another process.
disable-gc-trace:  Disable tracing of the garbage collector.
dump-all-objects:  Print a summary of all existing Python objects.
dump-new-objects:  Print a summary of all newly-created Python objects.
enable-gc-trace:   Enable tracing of the garbage collector.
free-tree-widgets: Free all widgets used in Leo's outline pane.
print-focus:       Print information about the requested focus.
print-stats:       Print statistics about existing Python objects.
print-gc-summary:  Print a brief summary of all Python objects.
run-unit-tests:    Run unit tests in the presently selected tree.
verbose-dump-objects: Print a more verbose listing of all existing Python objects.

Leo also has many debugging settings that enable and disable traces.
For details, see the node: @settings-->Debugging in leoSettings.leo.
'''
#@-node:ekr.20070501092655.1:<< define s >>
#@-node:ekr.20070501092655:aproposDebuggingCommands
#@+node:ekr.20060205170335.1:aproposFindCommands
def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    c = self.c

    << define s >>

    # Remove indentation from s: a workaround of a Leo bug.
    s = g.adjustTripleString(s,c.tab_width)

    if not g.app.unitTesting:
        g.es('',s)
#@+node:ekr.20060209082023.1:<< define s >>
@pagewidth 40

s = '''
Note: all bindings shown are the default
bindings for these commands. You may
change any of these bindings using
@shortcuts nodes in leoSettings.leo.

=== Settings

leoSettings.leo now contains several
settings related to the Find tab:

@bool show_only_find_tab_options = True

  When True (recommended), the Find tab
  does not show the 'Find', 'Change',
  'Change, Then Find', 'Find All' and
  'Change All' buttons.

@bool minibufferSearchesShowFindTab = True

  When True, Leo shows the Find tab when
  executing most of the commands
  discussed below.

=== Basic find commands

open-find-tab

  Makes the Find tab visible. The Find
  tab does **not** need to be visible to
  execute any search command discussed
  below.

hide-find-tab

  Hides the Find tab, but retains all
  the present settings.

search-with-present-options (Ctrl-F)

  Prompts for a search string. Typing
  the <Return> key puts the search
  string in the Find tab and executes a
  search based on all the settings in
  the Find tab. This is a recommended
  default search command.

show-search-options

  Shows the present search options in
  the status line. This command also
  makes the Find tab visible.

find-next (F3)

  Like search-with-present-options,
  except that it uses the search string
  in the find-tab. Recommended as the
  default 'search again' command.

find-previous (F2)

  Repeats the command specified by the
  Find tab, but in reverse.

find-again

  Like find-next if a search pattern is
  not '<find pattern here>'. Otherwise,
  like search-with-present-options.

=== Setting find options

Several minibuffer commands toggle the
checkboxes and radio buttons in the Find
tab, and thus affect the operation of
the search-with-present-options command.
You may bind these commands to keys or
toggle these options in a mode.

These commands toggle checkboxes:

toggle-find-ignore-case-option
toggle-find-in-body-option
toggle-find-in-headline-option
toggle-find-mark-changes-option
toggle-find-mark-finds-option
toggle-find-regex-option
toggle-find-reverse-option
toggle-find-word-option
toggle-find-wrap-around-option

These commands set radio buttons:

set-find-everywhere,
set-find-node-only, and
set-find-suboutline-only.

enter-find-options-mode (Ctrl-Shift-F)

enters a mode in which you may change
all checkboxes and radio buttons in the
Find tab with plain keys. As always, you
can use the mode-help (Tab) command to
see a list of key bindings in effect for
the mode.

=== Search commands with side effects

The following commands set an option in
the Find tab, then work exactly like the
search-with-present-options command.

- search-backward and search-forward set
  the 'Whole Word' checkbox to False.

- word-search-backward and
  word-search-forward set the 'Whole
  Word' checkbox to True.

- re-search-forward and re-search-backward
  set the 'Regexp' checkbox to True.

=== Find all commands

find-all

  Prints all matches in the log pane.

clone-find-all

  Replaces the previous 'Clone Find'
  checkbox. It prints all matches in the
  log pane, and creates a node at the
  beginning of the outline containing
  clones of all nodes containing the
  'find' string. Only one clone is made
  of each node, regardless of how many
  clones the node has, or of how many
  matches are found in each node.

Note: the radio buttons in the Find tab
(Entire Outline, Suboutline Only and
Node only) control how much of the
outline is affected by the find-all and
clone-find-all commands.

=== Search and replace commands

replace-string

  Prompts for a search string. Type
  <Return> to end the search string. The
  command will then prompt for the
  replacement string. Typing a second
  <Return> key will place both strings
  in the Find tab and executes a
  **find** command, that is,
  search-with-present-options.

So the only difference between
replace-string and
search-with-present-options is that
replace-string has the side effect of
setting 'change' string in the Find tab.
However, this is an extremely useful
side effect, because of the following
commands...

change (Ctrl-=)

  Replaces the selected text with the
  'change' text in the Find tab.

change-then-find (Ctrl--)

  Replaces the selected text with the
  'change' text in the Find tab, then
  executes the find command again.

find-next, change and change-then-find
can simulate any kind of query-replace
command.

change-all

  Changes all occurrences of the 'find'
  text with the 'change' text.
  Important: the radio buttons in the
  Find tab (Entire Outline, Suboutline
  Only and Node only) control how much
  of the outline is affected by this
  command.

=== Incremental search commands

Here are Leo's incremental find commands:

isearch-backward (Alt-R)
isearch-backward-regexp
isearch-forward (Alt-S)
isearch-forward-regexp

You may use backspace to backtrack. To
repeat an incremental search, type the
shortcut for that command again.'''
#@-node:ekr.20060209082023.1:<< define s >>
#@-node:ekr.20060205170335.1:aproposFindCommands
#@+node:ekr.20060602154458:pythonHelp
def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.frame.minibufferWantsFocus()
        k.setLabelBlue('Python help: ',protect=True)
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            g.redirectStderr()
            g.redirectStdout()
            try: help(str(s))
            except Exception: pass
            g.restoreStderr()
            g.restoreStdout()
#@-node:ekr.20060602154458:pythonHelp
#@+node:ekr.20070418074444:printSettings
def printSettings (self,event=None):

    g.app.config.printSettings(self.c)
#@-node:ekr.20070418074444:printSettings
#@-node:ekr.20060205164707:helpCommandsClass
#@-node:ekr.20100221143740.5633:Improved support for wrapping in the log pane
#@-node:ekr.20100212095952.5727:4.7 final projects
#@-all
#@-node:ekr.20100120072650.6089:@thin leoProjects.txt
#@-leo
