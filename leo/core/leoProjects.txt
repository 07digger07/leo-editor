#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20080917153158.11:4.6 b2
#@+node:ekr.20090410090554.1:Proof of @shadow theorems
#@+node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
#@+node:ekr.20080712080505.1:importAtShadowNode
def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
#@-node:ekr.20080712080505.1:importAtShadowNode
#@-node:ekr.20080711093251.7:readOneAtShadowNode (atFile) & helper
#@+node:ekr.20080708094444.38:x.propagate_changed_lines (calls diff)
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    x = self ; trace = False ; verbose = True
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old:',old_i,prev_old_j)
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new:',new_i,prev_new_j)

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,new_private_lines_wtr,
        marker, limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40:<< init vars >>
new_private_lines_wtr = sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@nonl
#@-node:ekr.20080708094444.40:<< init vars >>
#@+node:ekr.20080708094444.39:<< define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@-node:ekr.20080708094444.39:<< define print_tags >>
#@+node:ekr.20080708192807.2:<< about this loop >>
@

This loop writes all output lines using a single writer: new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips (deletes)
all previously unwritten non-sentinel lines in old_private_lines_rdr whose index
is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from the
old_private_lines_rdr explicitly. This explains why opcode handlers for the
'insert' and 'delete' opcodes are identical.
#@-node:ekr.20080708192807.2:<< about this loop >>
#@+node:ekr.20080708192807.5:<< Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace(tag,'old_i',old_i,'limit',limit)

if tag == 'insert' and limit >= old_private_lines_rdr.size():
    pass
else:
    # Ignore (delete) all unwritten lines of old_private_lines_rdr up to limit.
    # Because of this, nothing has to be explicitly deleted below.
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

if tag == 'equal':
    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index()
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag in ('insert','replace'):
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index()
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if x.is_sentinel(line,marker):
            new_private_lines_wtr.put('%sverbatim\n' % (marker),tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Leave new_public_lines_rdr unchanged.
    pass

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@nonl
#@-node:ekr.20080708192807.5:<< Handle the opcode >>
#@+node:ekr.20080708094444.45:<< do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@-node:ekr.20080708094444.45:<< do final correctness check >>
#@-node:ekr.20080708094444.38:x.propagate_changed_lines (calls diff)
#@-node:ekr.20090410090554.1:Proof of @shadow theorems
#@+node:ekr.20090401105902.2:Bugs
#@+node:ekr.20090401093731.1:Fixed elisp importer problem
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level <= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070711060113:class elispScanner
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,unused_s,unused_i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False

    end = self.skipBlock(s,i)
    # g.trace('%3s %15s block: %s' % (i,repr(s[i:i+10]),repr(s[i:end])))
    if not g.match(s,end-1,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len('defun')
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner
#@-node:ekr.20090401093731.1:Fixed elisp importer problem
#@+node:ekr.20090427103358.1:Fixed back-to-home so it works as expected
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/367462

The expected/customary behaviour (one you get used to in almost every editor) is:

End: always move to end of line
Home: Move to first visible chararacter on the line. When pressing home again, move to column zero. If Home is pressed one more time, move to first visible character again.

This is also the way emacs behaves, though ctrl+a always moves to column zero.
#@nonl
#@+node:ekr.20081123102100.1:backToHome
def backToHome (self,event):

    '''Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.''',

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins == 0 or not(s): return

    # Toggle back and forth between start of line and first-non-blank character.
    i,j = g.getLine(s,ins)
    i1 = i
    while i < j and s[i] in (' \t'):
        i += 1
    if i == ins:
        i = i1

    self.moveToHelper(event,i,extend=False)
#@-node:ekr.20081123102100.1:backToHome
#@-node:ekr.20090427103358.1:Fixed back-to-home so it works as expected
#@+node:ekr.20090428075532.1:Added patch for startup logic
@nocolor-node

Insert at beginning of the loadOnePlugin::

   if g.app.config is None:
       print "No g.app.config, making stub..."
       class StubConfig:
           def getBool(self, c, setting):
               return False
       g.app.config = StubConfig()

This hack prevents leo from crashing and allows the gui prompt for a
leoID to come up.  I think this is a better solution than asking users
to manually create the .leoID.txt file and figure out where it goes.
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
       print ('No g.app.config, making stub...')
       class StubConfig:
           def __init__(self):
               self.enabledPluginsFileName = ''
           def getBool(self, c, setting):
               return False
       g.app.config = StubConfig()

    global loadedModules,loadingModuleNameStack

    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            g.es_print('plugin',moduleName,'already loaded',color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.unitTesting or g.app.batchMode or g.app.inBridge:
        pass
    elif result is None:
        if warn_on_failure or (verbose and not g.app.initing): # or not g.app.unitTesting:
            g.es_print('can not load enabled plugin:',moduleName,color="red")
    elif verbose:
        g.es_print('loaded plugin:',moduleName,color="blue")

    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20090428075532.1:Added patch for startup logic
#@+node:ekr.20090428075532.2:Fixed rst3 problem
@nocolor-node

http://mail.google.com/mail/#inbox/11ef0076a3f4d866

today I've updated my leo installation and downloaded leo from trunk.
When trying to generate a pdf document with the rst3 plugin the
following error appears in the log pane:

Traceback (most recent call last):

 File "/usr/local/src/leo-editor/leo/plugins/rst3.py", line 1244, in
writeSpecialTree
   output = self.writeToDocutils(self.source)

 File "/usr/local/src/leo-editor/leo/plugins/rst3.py", line 1344, in
writeToDocutils
   overrides.update(args)     # MWC add args to settings

ValueError: dictionary update sequence element #0 has length 13; 2 is
required

It seems that the problem comes from the node containing my
@rst_options:

@nocolor

@ @rst-options
default_path=./latex
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--use-latex-toc,--
output-encoding=utf-8,--stylesheet=/home/vmas/.leo/custom_style.sty
@c

In rst3.py, inserting a g.es_print line just before the
overrides.update(args) one can see that the arguments passed to option
publish_argv_for_missing_stylesheets are passed to the overrides
dictionary as a list:

[u'--language=ca', u'--use-latex-toc', u'--output-encoding=utf-8', u'--
stylesheet=/home/vmas/.leo/custom_style.sty']

which is neither a dictionary nor an iterable of key/value pairs so
the error is raised. Hope it helps to fix the problem.

Vicent
#@nonl
#@-node:ekr.20090428075532.2:Fixed rst3 problem
#@+node:ekr.20090507065104.1:Allocate gnx's when nodes are created
# This is reasonable now that old-style file indices are extremely rare.
#@nonl
#@+node:ekr.20031218072017.3344:v.__init__
def __init__ (self,context,t=None):

    if g.unified_nodes:
        assert t is None
    elif t is None:
        t = tnode()

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.context = context # The context containing context.hiddenRootNode.
        # Required for trees, so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.

    self.iconVal = 0
    self.parents = [] # List of all parents of this node.
        # This list will have 1 member unless the parent node is a clone.
        # In particular, cloned nodes do *not* share parents.
    self.statusBits = 0 # status bits

    if g.unified_nodes: # vnodes contain all tnode info.
        self.t = self 
        self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
        self.fileIndex = None # The immutable file index for this tnode.
        self.insertSpot = None # Location of previous insert point.
        self.scrollBarSpot = None # Previous value of scrollbar position.
        self.selectionLength = 0 # The length of the selected body text.
        self.selectionStart = 0 # The start of the selected body text.

        # Convert everything to unicode...
        if g.isPython3:
            self._headString = ''
            self._bodyString = ''
        else:
            self._headString = unicode('')
            self._bodyString = unicode('')

        self.children = [] # List of all children of this node.
        self.vnodeList = []
            # List of all vnodes pointing to this tnode.
            # v is a clone iff len(v.vnodeList) > 1.

        # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
        self.fileIndex = g.app.nodeIndices.getNewIndex()
    else:
        self.t = t # The tnode.
#@nonl
#@-node:ekr.20031218072017.3344:v.__init__
#@+node:ekr.20031218072017.2006:t.__init__
def __init__ (self,bodyString=None,headString='NewHeadline'):

    # To support ZODB the code must set t._p_changed = 1 whenever
    # t.vnodeList, t.unknownAttributes or any mutable tnode attribute changes.

    self.cloneIndex = 0 # For Pre-3.12 files.  Zero for @file nodes
    self.fileIndex = None # The immutable file index for this tnode.
    self.insertSpot = None # Location of previous insert point.
    self.scrollBarSpot = None # Previous value of scrollbar position.
    self.selectionLength = 0 # The length of the selected body text.
    self.selectionStart = 0 # The start of the selected body text.
    self.statusBits = 0 # status bits

    # Convert everything to unicode...
    self._headString = g.toUnicode(headString,g.app.tkEncoding)
    self._bodyString = g.toUnicode(bodyString,g.app.tkEncoding)

    self.children = [] # List of all children of this node.
    self.vnodeList = []
        # List of all vnodes pointing to this tnode.
        # v is a clone iff len(v.t.vnodeList) > 1.

    # New in Leo 4.6 b2: allocate gnx (fileIndex) immediately.
    self.fileIndex = g.app.nodeIndices.getNewIndex()
#@nonl
#@-node:ekr.20031218072017.2006:t.__init__
#@+node:ekr.20070325101652:cc.createChaptersNode
def createChaptersNode (self):

    cc = self ; c = cc.c ; root = c.rootPosition()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    # g.trace('root',root)
    p = root.insertAsLastChild()
    p.initHeadString('@chapters')
    p.moveToRoot(oldRoot=root)
    c.setRootPosition(p)
    cc.chaptersNode = p.copy()
    t = p.v.t

    ### t.fileIndex is now allocated immedately.
    if t.fileIndex:
        pass
        ### self.error('***** t.fileIndex already exists')
    else:
        t.setFileIndex(g.app.nodeIndices.getNewIndex())

    c.setChanged(True)
#@-node:ekr.20070325101652:cc.createChaptersNode
#@-node:ekr.20090507065104.1:Allocate gnx's when nodes are created
#@+node:ekr.20090513153807.5743:Fixed crasher when creating .leoID.txt
exception loading plugin
Traceback (most recent call last):

  File "C:\leo.repo\trunk\leo\core\leoPlugins.py", line 429, in loadOnePlugin
    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName

AttributeError: StubConfig instance has no attribute 'enabledPluginsFileName'

leoID='ekr'
.leoID.txt created in C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo
load 
#@nonl
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):

    # Prevent Leo from crashing if .leoID.txt does not exist.
    if g.app.config is None:
       print ('No g.app.config, making stub...')
       class StubConfig:
           def __init__(self):
               self.enabledPluginsFileName = ''
           def getBool(self, c, setting):
               return False
       g.app.config = StubConfig()

    global loadedModules,loadingModuleNameStack

    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            g.es_print('plugin',moduleName,'already loaded',color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.unitTesting or g.app.batchMode or g.app.inBridge:
        pass
    elif result is None:
        if warn_on_failure or (verbose and not g.app.initing): # or not g.app.unitTesting:
            g.es_print('can not load enabled plugin:',moduleName,color="red")
    elif verbose:
        g.es_print('loaded plugin:',moduleName,color="blue")

    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20090513153807.5743:Fixed crasher when creating .leoID.txt
#@+node:ekr.20090517132234.5903:Investigated speed of external unit tests
@nocolor-node

- The g.Timing functions are weak.

- The problem is imports in the Commands ctor. When executed the first time from
  the bridge the imports take about 3/4 sec. on my machine. There is nothing
  that can or should be done. Ctrl-5 is still hugely faster than opening
  unitTest.leo!
#@nonl
#@+node:ekr.20031218072017.3137:Timing
def getTime():
    return time.clock()

def esDiffTime(message, start):
    delta = time.clock()-start
    g.es('',"%s %6.3f sec." % (message,delta))
    return time.clock()

def printDiffTime(message, start):
    delta = time.clock()-start
    g.pr("%s %6.3f sec." % (message,delta))
    return time.clock()

def timeSince(start):
    return "%6.3f sec." % (time.clock()-start)
#@-node:ekr.20031218072017.3137:Timing
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing

    - all children of any @mark-for-unit-tests node anywhere in the outline.
    - all @test and @suite nodes in p's outline.'''

    trace = False
    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>

    self.copyRoot.expand()
    for p,limit,lookForMark,lookForNodes in (
        (p1,limit1,lookForMark1,lookForNodes1),
        (p2,limit2,lookForMark2,lookForNodes2),
    ):
        if trace: g.trace('look for: mark %s nodes %s\nroot %s\nlimit %s' % (
            lookForMark,lookForNodes,p.h,limit and limit.h or '<none>'))
        while p and p != limit:
            h = p.h
            if p.v.t in self.seen:
                p.moveToNodeAfterTree()
            elif lookForMark and h.startswith(markTag):
                self.addMarkTree(p)
                p.moveToNodeAfterTree()
            elif lookForNodes and self.isUnitTestNode(p):
                self.addNode(p)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.p
    if p.h.startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # Add the entire @mark-for-unit-tests tree.
    self.addNode(p)

    # for p in p.subtree_iter():
        # # if self.isUnitTestNode(p) and not p.v.t in self.seen:
        # if not p.v.t in self.seen: # Add *all* nodes.
            # self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-tests tree as the last child of self.copyRoot.
    '''

    # g.trace(p.h)

    p2 = p.copyTreeAfter()
    p2.moveToLastChildOf(self.copyRoot)

    for p2 in p.self_and_subtree_iter():
        self.seen.append(p2.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.h
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    plugins_path = g.os_path_finalize_join(g.app.loadDir,"..","plugins")
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_finalize(theFile) for theFile in files]

    s = g.app.config.getEnabledPlugins()
    if not s: return

    if not g.app.silentMode and not g.app.batchMode:
        pr('@enabled-plugins found in %s' % (
            g.app.config.enabledPluginsFileName),color='blue')

    enabled_files = getEnabledFiles(s,plugins_path)

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    '''Return a list of plugins mentioned in non-comment lines of s.'''

    enabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s and not s.startswith('#'):
            path = g.os_path_finalize_join(plugins_path,s)
            enabled_files.append(path)

    return enabled_files
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@+node:ekr.20070227093629.6:createFrame (leoBridge)
def createFrame (self,fileName):

    '''Create a commander and frame for the given file.
    Create a new frame if the fileName is empty or non-exisent.'''

    g = self.g

    trace = False

    if fileName.strip():
        if g.os_path_exists(fileName):
            if trace:
                import time ; t1 = time.time()
            # This takes a long time due to imports in c.__init__
            ok, frame = g.openWithFileName(fileName,None)
            if trace:
                t2 = time.time()
                g.trace('g.openWithFileName: %0.2fsec' % (t2-t1))
            if ok: return frame.c
        else:
            g.es_print('file not found', fileName,'creating new window')
    # Create a new frame. Unlike leo.run, this is not a startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)
    return c
#@-node:ekr.20070227093629.6:createFrame (leoBridge)
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leo.core.leoCommands as leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName,relativeFileName=None):

    trace = False
    c = self ; tag = 'Commands.__init__'

    self.requestedFocusWidget = None
    self.requestRedrawFlag = False
    self.requestedIconify = '' # 'iconify','deiconify'
    self.requestRecolorFlag = False

    if trace:
        print(tag)
        import time ; t1 = time.clock()
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep pylint happy
    self.chapterController = None
    self.frame = frame

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('<hidden root vnode>')
    self.hiddenRootNode.t.vnodeList = [self.hiddenRootNode]
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    self.initIvars()
    self.nodeHistory = nodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo

    if trace: t2 = g.printDiffTime('%s: after imports' % (tag),t1)

    self.shadowController = leoShadow.shadowController(c)
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.rstCommands    = leoRst.rstCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)
    self.rstCommands = leoRst.rstCommands(c)

    if trace: t3 = g.printDiffTime('%s: after controllers created' % (tag),t2)

    if 0:
        g.pr("\n*** using Null undoer ***\n")
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@-node:ekr.20031218072017.2812:c.__init__
#@-node:ekr.20090517132234.5903:Investigated speed of external unit tests
#@+node:ekr.20090518072506.8312:Fixed undo bug
@nocolor-node

onTextChanged in the qt gui was calling setUndoTypingParams, in many case
redundently and with bad params.

It remains to be seen whether onTextChanged is ever needed. If it is, it may be
difficult to set the old selection properly.
#@nonl
#@+node:ekr.20031218072017.3679:  leoFrame.__init__
def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.gui = gui
    self.iconBarClass = nullIconBarClass
    self.statusLineClass = nullStatusLineClass
    self.title = None # Must be created by subclasses.

    # Objects attached to this frame.
    self.body = None
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.log = None
    self.menu = None
    self.miniBufferWidget = None
    self.outerFrame = None
    self.prefsPanel = None
    self.statusLine = None
    self.tree = None
    self.useMiniBufferWidget = False

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of <?xml-stylesheet...?> line.
    self.tab_width = 0 # The tab width in effect in this pane.
#@nonl
#@+node:ekr.20080429051644.1:leoFrame.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
#@nonl
#@-node:ekr.20080429051644.1:leoFrame.mustBeDefined
#@+node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
#@nonl
#@-node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
#@nonl
#@-node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):

    f = self ; c = f.c

    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
#@-node:ekr.20051009045404:createFirstTreeNode
#@-node:ekr.20031218072017.3679:  leoFrame.__init__
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False and not g.unitTesting # Can cause unit tests to fail.
    verbose = False
    << return if there is nothing to do >>
    if trace: g.trace(undo_type,oldSel,newSel,g.callers(5))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace and verbose:
    g.pr("lead,trail",leading,trailing)
    g.pr("old mid,nls:",len(old_middle_lines),old_newlines,oldText)
    g.pr("new mid,nls:",len(new_middle_lines),new_newlines,newText)
    #g.pr("lead,trail:",leading,trailing)
    #g.pr("old mid:",old_middle_lines)
    #g.pr("new mid:",new_middle_lines)
    g.pr("---------------------")
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.b.
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = '\n'.join(old_middle_lines)
    s2 = '\n'.join(new_middle_lines)
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
# Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()

# Bug fix: Leo 4.4.6: always add p to the list.
bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('exception in','setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.1329:onBodyChanged (leoBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    trace = False and not g.unitTesting
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.p
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.b ; changed = True
    else:
        changed = oldText != newText
    if trace: g.trace(repr(ch),'changed:',changed,'newText:',len(newText),'w',w)
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setBodyString(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    << recolor the body >>
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    << update icons if necessary >>
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< update icons if necessary >>

redraw_flag = False
# Update dirty bits.
# p.setDirty() sets all cloned and @file dirty bits.
if not p.isDirty() and p.setDirty():
    redraw_flag = True

# Update icons. p.v.iconVal may not exist during unit tests.
val = p.computeIcon()
# g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '<None>')
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

if redraw_flag:
    c.redraw_after_icons_changed()
#@-node:ekr.20051026083733.7:<< update icons if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (leoBody)
#@+node:ekr.20031218072017.1493:undoRedoText
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    # newNewlines is unused, but it has symmetry.

    trace = False and not g.unitTesting

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setBodyString(result)
    w.setAllText(result)
    sel = g.choose(tag=='undo',u.oldSel,u.newSel)
    if trace: g.trace(sel)
    i,j = sel
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.b
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = '\n'.join(s)
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    g.pr("body:  ",body)
    g.pr("result:",result)
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = False
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20090213065933.14:doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@-node:ekr.20090213065933.14:doPlainTab
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@-node:ekr.20090518072506.8312:Fixed undo bug
#@+node:ekr.20090518072506.8493:Fixed F10/11/12 key bug
# Added call to isFKey in k.handleUnboundKeys.
#@+node:ekr.20051125080855:selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = False
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20090213065933.14:doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@-node:ekr.20090213065933.14:doPlainTab
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:updateAutoIndent (leoEditCommands)
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand, helpers
#@+node:ekr.20061031131434.74:class keyHandlerClass
class keyHandlerClass:

    '''A class to support emacs-style commands.'''

    # Gui-independent class vars.

    global_killbuffer = []
        # Used only if useGlobalKillbuffer arg to Emacs ctor is True.
        # Otherwise, each Emacs instance has its own local kill buffer.

    global_registers = {}
        # Used only if useGlobalRegisters arg to Emacs ctor is True.
        # Otherwise each Emacs instance has its own set of registers.

    lossage = []
        # A case could be made for per-instance lossage, but this is not supported.

    @others
#@nonl
#@+node:ekr.20061031131434.75: Birth (keyHandler)
#@+node:ekr.20061031131434.76: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.inited = False # Set at end of finishCreate.
    self.widget = c.frame.miniBufferWidget
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter_initially')
    self.enable_calltips                = c.config.getBool('enable_calltips_initially')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = c.config.getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = c.config.getBool('trace_masterClickHandler')
    self.traceMasterCommand             = c.config.getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = c.config.getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = c.config.getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = c.config.getBool('warn_about_redefined_shortcuts')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
#@+node:ekr.20061031131434.78:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
#@-node:ekr.20061031131434.78:<< define externally visible ivars >>
#@+node:ekr.20061031131434.79:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
#@-node:ekr.20061031131434.79:<< define internal ivars >>
#@-node:ekr.20061031131434.76: ctor (keyHandler)
#@+node:ekr.20061031131434.80:k.finishCreate & helpers
def finishCreate (self):

    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''

    k = self ; c = k.c
    # g.trace('keyHandler')
    k.createInverseCommandsDict()

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    k.command_mode_bg_color = c.config.getColor('command_mode_bg_color') or bg
    k.command_mode_fg_color = c.config.getColor('command_mode_fg_color') or fg
    k.insert_mode_bg_color = c.config.getColor('insert_mode_bg_color') or bg
    k.insert_mode_fg_color = c.config.getColor('insert_mode_fg_color') or fg
    k.overwrite_mode_bg_color = c.config.getColor('overwrite_mode_bg_color') or bg
    k.overwrite_mode_fg_color = c.config.getColor('overwrite_mode_fg_color') or fg
    k.unselected_body_bg_color = c.config.getColor('unselected_body_bg_color') or bg
    k.unselected_body_fg_color = c.config.getColor('unselected_body_fg_color') or bg    

    # g.trace(k.insert_mode_bg_color,k.insert_mode_fg_color)

    self.inited = True

    k.setDefaultInputState()
    k.resetLabel()
#@+node:ekr.20061031131434.81:createInverseCommandsDict
def createInverseCommandsDict (self):

    '''Add entries to k.inverseCommandsDict using c.commandDict.

    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))

        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@-node:ekr.20061031131434.81:createInverseCommandsDict
#@-node:ekr.20061031131434.80:k.finishCreate & helpers
#@+node:ekr.20061031131434.82:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    # g.trace(self.unboundKeyAction)

    self.defaultUnboundKeyAction = self.unboundKeyAction

    k.setInputState(self.defaultUnboundKeyAction)
#@-node:ekr.20061031131434.82:setDefaultUnboundKeyAction
#@+node:ekr.20070123143428:k.defineTkNames
def defineTkNames (self):

    k = self

    # These names are used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        'BackSpace','Begin','Break',
        'Caps_Lock','Clear',
        'Delete','Down',
        'End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'Home',
        'Left','Linefeed',
        'Next','Num_Lock',
        'Prior',
        'Return','Right',
        'Tab',
        'Up',
        # 'space',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace',
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s


@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.
Note: the Tk documentation states that not all of these may be available on all platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20070123143428:k.defineTkNames
#@+node:ekr.20080509064108.6:k.defineSingleLineCommands
def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # editCommandsClass
        'back-to-indentation',
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # keyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # killBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # macroCommandsClass
        'call-last-keyboard-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # registerCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
#@-node:ekr.20080509064108.6:k.defineSingleLineCommands
#@+node:ekr.20080509064108.7:k.defineMultiLineCommands
def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # editCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down',
        'scroll-down-extend-selection',
        'scroll-outline-down-line',
        'scroll-outline-down-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # keyHandlerCommandsClass
        'repeat-complex-command',
        # killBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # queryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # rectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # registerCommandsClass
        'jump-to-register',
        'point-to-register',
        # searchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
#@-node:ekr.20080509064108.7:k.defineMultiLineCommands
#@+node:ekr.20070123085931:k.defineSpecialKeys
def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

#@-node:ekr.20070123085931:k.defineSpecialKeys
#@+node:ekr.20061101071425:oops
def oops (self):

    g.trace('Should be defined in subclass:',g.callers(4))
#@-node:ekr.20061101071425:oops
#@-node:ekr.20061031131434.75: Birth (keyHandler)
#@+node:ekr.20061031131434.88:Binding (keyHandler)
#@+node:ekr.20061031131434.89:bindKey
def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.'''

    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << trace bindings >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        b = g.bunch(pane=pane,func=callback,commandName=commandName)
        << remove previous conflicting definitions from bunchList >>
        bunchList.append(b)
        shortcut = g.stripBrackets(shortcut.strip())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
#@+node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut),color='blue')
            return
#@-node:ekr.20061031131434.90:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20061031131434.91:<< trace bindings >>
if c.config.getBool('trace_bindings_verbose'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@-node:ekr.20061031131434.91:<< trace bindings >>
#@+node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
if not modeFlag and self.warn_about_redefined_shortcuts:
    redefs = [str(b2.commandName) for b2 in bunchList
        if b2.commandName != commandName and pane in ('button','all',b2.pane)
            and not b2.pane.endswith('-mode')]
    for z in redefs:
        g.es_print ('redefining shortcut %30s from %s to %s in %s' % (
            shortcut,z,commandName,pane),color='red')
        # g.es_print('redefining','shortcut %20s' % (shortcut),
            # 'from',z,'(%s)' % (pane),
            # 'to',commandName,'(%s)' % (pane),color='red')

if not modeFlag:
    bunchList = [b2 for b2 in bunchList if pane not in ('button','all',b2.pane)]
#@-node:ekr.20061031131434.92:<< remove previous conflicting definitions from bunchList >>
#@-node:ekr.20061031131434.89:bindKey
#@+node:ekr.20061031131434.93:bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):

    k = self
    d =  k.masterBindingsDict.get(pane,{})

    stroke = g.stripBrackets(stroke)

    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__))

    # New in Leo 4.4.1: Allow redefintions.
    d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
    k.masterBindingsDict [pane] = d
#@-node:ekr.20061031131434.93:bindKeyToDict
#@+node:ekr.20061031131434.94:bindOpenWith
def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
#@-node:ekr.20061031131434.94:bindOpenWith
#@+node:ekr.20061031131434.95:checkBindings
def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@-node:ekr.20061031131434.95:checkBindings
#@+node:ekr.20070218130238:dumpMasterBindingsDict
def dumpMasterBindingsDict (self):

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            b = d2.get(key2)
            g.pr('%20s %s' % (key2,b.commandName))
#@-node:ekr.20070218130238:dumpMasterBindingsDict
#@+node:ekr.20061031131434.96:k.completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,'Alt+Key-4' in d)

    for stroke in d:
        k.makeMasterGuiBinding(stroke,w=w)
#@-node:ekr.20061031131434.96:k.completeAllBindingsForWidget
#@+node:ekr.20061031131434.97:k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
#@-node:ekr.20061031131434.97:k.completeAllBindings
#@+node:ekr.20061031131434.98:k.makeAllBindings
def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    if c.frame.statusLine: c.frame.statusLine.setBindings()
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@-node:ekr.20061031131434.98:k.makeAllBindings
#@+node:ekr.20061031131434.99:k.initAbbrev
def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev:',key,'unknown command name:',commandName,color='blue')
#@-node:ekr.20061031131434.99:k.initAbbrev
#@+node:ekr.20061031131434.100:addModeCommands (enterModeCallback)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d:

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))
#@-node:ekr.20061031131434.100:addModeCommands (enterModeCallback)
#@+node:ekr.20061031131434.101:initSpecialIvars
def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@-node:ekr.20061031131434.101:initSpecialIvars
#@+node:ekr.20061031131434.102:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c ; d = c.commandsDict

    for commandName in sorted(d):
        command = d.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        # if commandName == 'keyboard-quit': g.trace(key,bunchList)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            # if pane.endswith('-mode'): g.trace('skipping',shortcut,commandName)
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)

    # g.trace(g.listToString(sorted(k.bindingsDict))
    # g.trace('Ctrl+g',k.bindingsDict.get('Ctrl+g'))
#@-node:ekr.20061031131434.102:makeBindingsFromCommandsDict
#@+node:ekr.20061031131434.103:k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    # if stroke.lower()=='ctrl+v':
        # g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),'w',repr(w),'\n',g.callers())

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
#@-node:ekr.20061031131434.103:k.makeMasterGuiBinding
#@-node:ekr.20061031131434.88:Binding (keyHandler)
#@+node:ekr.20061031131434.104:Dispatching (keyHandler)
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand ; verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if stroke and (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:k.handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20061031131434.111:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20061031131434.111:fullCommand (alt-x) & helper
#@+node:ekr.20061031131434.113:k.endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            k.commandName = None

            # Do the import here to break a circular dependency at the top level.
            import leo.core.leoEditCommands as leoEditCommands
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
#@-node:ekr.20061031131434.113:k.endCommand
#@-node:ekr.20061031131434.104:Dispatching (keyHandler)
#@+node:ekr.20061031131434.114:Externally visible commands
#@+node:ekr.20061031131434.115:digitArgument & universalArgument
def universalArgument (self,event):

    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)

def digitArgument (self,event):

    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)
#@-node:ekr.20061031131434.115:digitArgument & universalArgument
#@+node:ekr.20061031131434.116:k.show/hide/toggleMinibuffer
def hideMinibuffer (self,event):
    '''Hide the minibuffer.'''
    k = self ; c = k.c
    c.frame.hideMinibuffer()
    g.es('minibuffer hidden',color='red')
    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('',commandName,'is bound to:',shortcut)

def showMinibuffer (self,event):
    '''Show the minibuffer.'''
    k = self ; c = k.c
    c.frame.showMinibuffer()

def toggleMinibuffer (self,event):
    '''Show or hide the minibuffer.'''
    k = self ; c = k.c
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)
#@-node:ekr.20061031131434.116:k.show/hide/toggleMinibuffer
#@+node:ekr.20070613133500:k.menuCommandKey
def menuCommandKey (self,event=None):

    # This method must exist, but it never gets called.
    pass 
#@-node:ekr.20070613133500:k.menuCommandKey
#@+node:ekr.20070613190936:k.propagateKeyEvent
def propagateKeyEvent (self,event):

    self.oops() # Should be overridden.
#@nonl
#@-node:ekr.20070613190936:k.propagateKeyEvent
#@+node:ekr.20061031131434.117:negativeArgument (redo?)
def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'
#@-node:ekr.20061031131434.117:negativeArgument (redo?)
#@+node:ekr.20061031131434.118:numberCommand
def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget
    k.universalDispatcher(event)
    g.app.gui.event_generate(w,'<Key>',keysym=number)
    return 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
#@-node:ekr.20061031131434.118:numberCommand
#@+node:ekr.20061031131434.119:printBindings & helper
def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    if not d: return g.es('no bindings')
    for key in sorted(d):
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # Print keys by type:
    result = []
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
        'Meta+Ctrl+Shift', 'Meta+Shift', 'Meta+Ctrl', 'Meta+Key','Meta',
        # Meta support
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        # g.es('','%s %s' % (sep, prefix),tabName=tabName)
        result.append('%s %s\n' % (sep, prefix))
        self.printBindingsHelper(result,data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('%s %s\n' % (sep, 'Plain Keys'))
    self.printBindingsHelper(result,data,n1,n2,prefix=None)
    g.es('',''.join(result),tabName=tabName)
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@+node:ekr.20061031131434.120:printBindingsHelper
def printBindingsHelper (self,result,data,n1,n2,prefix):

    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.

    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.

    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            # g.es('','%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
            result.append('%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3))
#@-node:ekr.20061031131434.120:printBindingsHelper
#@-node:ekr.20061031131434.119:printBindings & helper
#@+node:ekr.20061031131434.121:printCommands
def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()

    data = [] ; n1 = 4 ; n2 = 20
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %*s %s\n' % (-n1,s1,-(min(12,n2)),s2,s3) for s1,s2,s3 in data]
    g.es('',''.join(lines),tabName=tabName)
#@-node:ekr.20061031131434.121:printCommands
#@+node:ekr.20061031131434.122:repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        g.trace('oops')
        return k.keyboardQuit(event)
#@-node:ekr.20061031131434.122:repeatComplexCommand & helper
#@+node:ekr.20061031131434.123:set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocusNow()
    k.showStateAndMode()
#@-node:ekr.20061031131434.123:set-xxx-State
#@+node:ekr.20061031131434.124:toggle-input-state
def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = g.choose(state=='insert','command','insert')
    elif default == 'overwrite':
        state = g.choose(state=='overwrite','command','overwrite')
    else:
        state = g.choose(state=='command','insert','command') # prefer insert to overwrite.

    k.setInputState(state)
    k.showStateAndMode()
#@-node:ekr.20061031131434.124:toggle-input-state
#@-node:ekr.20061031131434.114:Externally visible commands
#@+node:ekr.20061031131434.125:Externally visible helpers
#@+node:ekr.20061031131434.126:manufactureKeyPressForCommandName
def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    # g.trace('stroke',repr(stroke),'commandName',commandName,'w',w,g.callers())

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(w,stroke)
    else:
        g.trace('no shortcut for %s' % (commandName),color='red')
#@-node:ekr.20061031131434.126:manufactureKeyPressForCommandName
#@+node:ekr.20061031131434.127:simulateCommand
def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return


    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.bunch(c=c,keysym='',char='',widget=None)
        k.masterCommand(event,func,stroke)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
#@-node:ekr.20061031131434.127:simulateCommand
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20061031131434.130:keyboardQuit
def keyboardQuit (self,event,hideTabs=True,setDefaultStatus=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    c.endEditing()
    c.bodyWantsFocus()

    if setDefaultStatus:
        # At present, only the auto-completer suppresses this.
        k.setDefaultInputState()
        k.showStateAndMode()
#@-node:ekr.20061031131434.130:keyboardQuit
#@+node:ekr.20061031131434.131:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''

    # g.trace(commandName,g.callers())

    k = self ; c = k.c

    if wrap:
        func = c.universalCallback(func)

    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('redefining',commandName, color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        # g.trace('stroke',stroke,'pane',pane,commandName,g.callers())
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok and not g.app.silentMode:
            # g.trace(g.callers())
            g.es_print('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose and not g.app.silentMode:
        g.trace(g.callers())
        g.es_print('','@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@-node:ekr.20061031131434.131:k.registerCommand
#@+node:ekr.20071212104050:k.overrideCommand
def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            b = d2.get(key2)
            if b.commandName == commandName:
                b.func=func
                d2[key2] = b
#@-node:ekr.20071212104050:k.overrideCommand
#@-node:ekr.20061031131434.125:Externally visible helpers
#@+node:ekr.20061031131434.145:Master event handlers (keyHandler)
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
# g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

# g.trace('w_name',w_name,'stroke',stroke,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(d.keys(),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20061031131434.153:masterClickHandler
def masterClickHandler (self,event,func=None):

    g.app.gui.killPopupMenu()

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i <= x <= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@-node:ekr.20061031131434.153:masterClickHandler
#@+node:ekr.20061031131434.154:masterDoubleClickHandler
def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
#@-node:ekr.20061031131434.154:masterDoubleClickHandler
#@+node:ekr.20061031131434.155:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@-node:ekr.20061031131434.155:masterMenuHandler
#@-node:ekr.20061031131434.145:Master event handlers (keyHandler)
#@+node:ekr.20061031170011.3:Minibuffer (keyHandler)
# These may be overridden, but this code is now gui-independent.
#@nonl
#@+node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
def minibufferWantsFocus(self):

    c = self.c
    c.widgetWantsFocus(c.miniBufferWidget)


def minibufferWantsFocusNow(self):

    c = self.c
    c.widgetWantsFocusNow(c.miniBufferWidget)
#@-node:ekr.20061031131434.135:k.minibufferWantsFocus/Now
#@+node:ekr.20061031170011.5:getLabel
def getLabel (self,ignorePrompt=False):

    k = self ; w = self.widget
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@-node:ekr.20061031170011.5:getLabel
#@+node:ekr.20080408060320.791:k.killLine
def killLine (self,protect=True):

    k = self ; c = self.c
    w = self.widget
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20080408060320.791:k.killLine
#@+node:ekr.20061031170011.6:protectLabel
def protectLabel (self):

    k = self ; w = self.widget
    if not w: return

    k.mb_prefix = w.getAllText()

#@-node:ekr.20061031170011.6:protectLabel
#@+node:ekr.20061031170011.7:resetLabel
def resetLabel (self):

    k = self ; w = self.widget
    k.setLabelGrey('')
    k.mb_prefix = ''

    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        k.setLabelBlue(label='%s State' % (state.capitalize()),protect=True)
#@-node:ekr.20061031170011.7:resetLabel
#@+node:ekr.20061031170011.8:setLabel
def setLabel (self,s,protect=False):

    trace = (False or self.trace_minibuffer) and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if trace: g.trace(repr(s),g.callers(4))

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
#@-node:ekr.20061031170011.8:setLabel
#@+node:ekr.20061031170011.9:extendLabel
def extendLabel(self,s,select=False,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('len(s)',len(s))
    if not s: return

    c.widgetWantsFocusNow(w)
    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
#@-node:ekr.20061031170011.9:extendLabel
#@+node:ekr.20080408060320.790:selectAll
def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.widget
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


#@-node:ekr.20080408060320.790:selectAll
#@+node:ekr.20061031170011.10:setLabelBlue
def setLabelBlue (self,label=None,protect=False):

    k = self ; w = k.widget
    if not w: return

    w.setBackgroundColor('lightblue')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20061031170011.10:setLabelBlue
#@+node:ekr.20061031170011.11:setLabelGrey
def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return

    w.setBackgroundColor('lightgrey')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@-node:ekr.20061031170011.11:setLabelGrey
#@+node:ekr.20080510153327.2:setLabelRed
def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.widget
    if not w: return

    w.setForegroundColor('red')

    if label is not None:
        k.setLabel(label,protect)
#@-node:ekr.20080510153327.2:setLabelRed
#@+node:ekr.20061031170011.12:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
#@nonl
#@-node:ekr.20061031170011.12:updateLabel
#@+node:ekr.20061031170011.13:getEditableTextRange
def getEditableTextRange (self):

    k = self ; w = self.widget
    trace = self.trace_minibuffer and not g.app.unitTesting

    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)

    trace and g.trace(i,j)
    return i,j
#@-node:ekr.20061031170011.13:getEditableTextRange
#@-node:ekr.20061031170011.3:Minibuffer (keyHandler)
#@+node:ekr.20061031131434.156:Modes
#@+node:ekr.20061031131434.157:badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
#@-node:ekr.20061031131434.157:badMode
#@+node:ekr.20061031131434.158:createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    k = self ; c = k.c

    for commandName in d:
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
#@-node:ekr.20061031131434.158:createModeBindings
#@+node:ekr.20061031131434.159:endMode
def endMode(self,event):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
#@-node:ekr.20061031131434.159:endMode
#@+node:ekr.20061031131434.160:enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
#@-node:ekr.20061031131434.160:enterNamedMode
#@+node:ekr.20061031131434.161:exitNamedMode
def exitNamedMode (self,event):

    k = self

    if k.inState():
        k.endMode(event)

    k.showStateAndMode()
#@-node:ekr.20061031131434.161:exitNamedMode
#@+node:ekr.20061031131434.162:generalModeHandler
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = False or c.config.getBool('trace_modes')

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode(event)
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.widget = k.modeWidget
            else:
                event = g.Bunch(widget = k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return 'break'

    return 'break'
#@-node:ekr.20061031131434.162:generalModeHandler
#@+node:ekr.20061031131434.163:initMode
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = c.config.getBool('trace_modes')

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        prompt = d.get('*command-prompt*') or modeName
        if trace: g.trace('modeName',modeName,prompt,'d.keys()',d.keys())

    k.inputModeName = modeName
    k.silentMode = False

    entryCommands = d.get('*entry-commands*',[])
    if entryCommands:
        for commandName in entryCommands:
            if trace: g.trace('entry command:',commandName)
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                if trace: g.trace('redirect to mode',commandName)
                return

    # Create bindings after we know whether we are in silent mode.
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)
    k.showStateAndMode(prompt=prompt)
#@-node:ekr.20061031131434.163:initMode
#@+node:ekr.20061031131434.164:reinitMode
def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.widget)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)

#@-node:ekr.20061031131434.164:reinitMode
#@+node:ekr.20061031131434.165:modeHelp & helper
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    g.trace(k.inputModeName)

    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if not k.silentMode:
        c.minibufferWantsFocus()

    return 'break'
#@+node:ekr.20061031131434.166:modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data = [] ; n = 20
    for key in sorted(d):
        if key not in ( '*entry-commands*','*command-prompt*'):
            bunchList = d.get(key)
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut not in (None,'None'):
                    s1 = key ; s2 = k.prettyPrintKey(shortcut,brief=True)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()

    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'): modeName = modeName[:-4].strip()

    g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
#@-node:ekr.20061031131434.166:modeHelpHelper
#@-node:ekr.20061031131434.165:modeHelp & helper
#@-node:ekr.20061031131434.156:Modes
#@+node:ekr.20061031131434.167:Shared helpers
#@+node:ekr.20061031131434.175:k.computeCompletionList
# Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        aList = '\n'.join(
            ['%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3)
                for s1,s2,s3 in data])
        g.es('',aList,tabName=tabName)
    c.bodyWantsFocus()
#@-node:ekr.20061031131434.175:k.computeCompletionList
#@+node:ekr.20061031131434.176:computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict:
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                #pane = g.choose(b.pane=='all','','%s:' % (b.pane))
                pane = '%s:' % (b.pane)
                data = (pane,shortcut)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [b.commandName] = shortcutList

    return d
#@-node:ekr.20061031131434.176:computeInverseBindingDict
#@+node:ekr.20061031131434.168:getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    keysym = gui.eventKeysym(event)
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocusNow()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return 'break'
#@+node:ekr.20061031131434.169:<< init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
#@-node:ekr.20061031131434.169:<< init altX vars >>
#@+node:ekr.20061031131434.170:k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
#@-node:ekr.20061031131434.170:k.doFileNameBackSpace
#@+node:ekr.20061031131434.171:k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
#@-node:ekr.20061031131434.171:k.doFileNameChar
#@+node:ekr.20061031131434.172:k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
#@-node:ekr.20061031131434.172:k.doFileNameTab
#@+node:ekr.20061031131434.173:k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
#@-node:ekr.20061031131434.173:k.computeFileNameCompletionList
#@+node:ekr.20061031131434.174:k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
#@-node:ekr.20061031131434.174:k.showFileNameTabList
#@-node:ekr.20061031131434.168:getFileName & helpers
#@+node:ekr.20061031131434.179:getShortcutForCommand/Name (should return lists)
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return k.tkbindingFromStroke(key)
    return ''

def getShortcutForCommand (self,command):

    k = self ; c = k.c

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                     return k.tkbindingFromStroke(key)
    return ''
#@-node:ekr.20061031131434.179:getShortcutForCommand/Name (should return lists)
#@+node:ekr.20061031131434.177:k.doBackSpace
# Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c ; w = self.widget

    if 0:
        g.trace('(keyHandler)',g.callers(4))
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    # Step 1: actually delete the character.
    ins = w.getInsertPoint()
    s = w.getAllText()
    # g.trace('ins',ins,'prefix',k.mb_prefix)
    if ins <= len(k.mb_prefix):
        # g.trace('at start')
        return
    i,j = w.getSelectionRange()
    if i == j:
        ins -= 1
        w.delete(ins)
        w.setSelectionRange(ins,ins,insert=ins)
    else:
        ins = i
        w.delete(i,j)
        w.setSelectionRange(i,i,insert=ins)

    # Step 2: compute completions.
    if not completion: return
    k.mb_tabListPrefix = w.getAllText()
    k.computeCompletionList(defaultCompletionList,backspace=True)
#@-node:ekr.20061031131434.177:k.doBackSpace
#@+node:ekr.20061031131434.178:k.doTabCompletion
# Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):

    '''Handle tab completion when the user hits a tab.'''

    k = self ; c = k.c ; s = k.getLabel().strip()

    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex >= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.minibufferWantsFocusNow()
#@-node:ekr.20061031131434.178:k.doTabCompletion
#@+node:ekr.20061031131434.180:traceBinding
def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui

    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')

    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,shortcut,bunch.commandName,gui.widget_name(w))
#@-node:ekr.20061031131434.180:traceBinding
#@-node:ekr.20061031131434.167:Shared helpers
#@+node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20090518072506.8494:isFKey
def isFKey (self,shortcut):


    if not shortcut: return False

    s = shortcut.lower()

    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
#@-node:ekr.20090518072506.8494:isFKey
#@+node:ekr.20061031131434.182:isPlainKey
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
#@-node:ekr.20061031131434.182:isPlainKey
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting
    if not setting:return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    if trace: g.trace('%20s %s' % (setting,shortcut))
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", s)
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@+node:ekr.20061031131434.190:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):

    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''

    stroke = g.stripBrackets(stroke)

    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl-','Control-'),
        ('Ctrl+','Control-'), # New in Leo 4.5.
        ('Meta+','Meta-'), # New in Leo 4.6
        ('Shift+','Shift-'),
        ('Command+','Command-'),
        ('DnArrow','Down'), # New in Leo 4.5.
        ('LtArrow','Left'), # New in Leo 4.5.
        ('RtArrow','Right'),# New in Leo 4.5.
        ('UpArrow','Up'),   # New in Leo 4.5.
    ):
        stroke = stroke.replace(a,b)

    # g.trace('<%s>' % stroke)
    return '<%s>' % stroke
#@-node:ekr.20061031131434.190:k.tkbindingFromStroke
#@+node:ekr.20061031131434.191:k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    # g.trace(stroke,s)
    return g.choose(brief,s,'<%s>' % s)
#@-node:ekr.20061031131434.191:k.prettyPrintKey
#@-node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20061031131434.193:States
#@+node:ekr.20061031131434.194:clearState
def clearState (self):

    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@-node:ekr.20061031131434.194:clearState
#@+node:ekr.20061031131434.196:getState
def getState (self,kind):

    k = self
    val = g.choose(k.state.kind == kind,k.state.n,0)
    # g.trace(state,'returns',val)
    return val
#@-node:ekr.20061031131434.196:getState
#@+node:ekr.20061031131434.195:getStateHandler
def getStateHandler (self):

    return self.state.handler
#@-node:ekr.20061031131434.195:getStateHandler
#@+node:ekr.20061031131434.197:getStateKind
def getStateKind (self):

    return self.state.kind
#@-node:ekr.20061031131434.197:getStateKind
#@+node:ekr.20061031131434.198:inState
def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
#@-node:ekr.20061031131434.198:inState
#@+node:ekr.20080511122507.4:setDefaultInputState
def setDefaultInputState (self):

    k = self
    k.setInputState(k.defaultUnboundKeyAction)
#@nonl
#@-node:ekr.20080511122507.4:setDefaultInputState
#@+node:ekr.20061031131434.133:setInputState
def setInputState (self,state):

    k = self
    k.unboundKeyAction = state



#@-node:ekr.20061031131434.133:setInputState
#@+node:ekr.20061031131434.199:setState
def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
#@-node:ekr.20061031131434.199:setState
#@+node:ekr.20061031131434.192:showStateAndMode
def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
#@-node:ekr.20061031131434.192:showStateAndMode
#@+node:ekr.20080512115455.1:showStateColors
def showStateColors (self,inOutline,w):

    k = self ; c = k.c ; state = k.unboundKeyAction

    body = c.frame.body ; bodyCtrl = body.bodyCtrl

    if state not in ('insert','command','overwrite'):
        g.trace('bad input state',state)

    # g.trace(state,w,g.app.gui.widget_name(w),g.callers(4))

    # if inOutline and w == bodyCtrl:
        # return # Don't recolor the body.
    if w != bodyCtrl and not g.app.gui.widget_name(w).startswith('head'):
        # Don't recolor the minibuffer, log panes, etc.
        return

    if state == 'insert':
        bg = k.insert_mode_bg_color
        fg = k.insert_mode_fg_color
    elif state == 'command':
        bg = k.command_mode_bg_color
        fg = k.command_mode_fg_color
    elif state == 'overwrite':
        bg = k.overwrite_mode_bg_color
        fg = k.overwrite_mode_fg_color
    else:
        bg = fg = 'red'

    # g.trace(id(w),bg,fg,self)

    if w == bodyCtrl:
        body.setEditorColors(bg=bg,fg=fg)
    else:
        try:
            w.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
#@-node:ekr.20080512115455.1:showStateColors
#@-node:ekr.20061031131434.193:States
#@+node:ekr.20061031131434.200:universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>

    k = self ; gui = g.app.gui
    state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = gui.eventKeysym(event)
            # Stroke is <Key> for plain keys, <Control-u> (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '<Key>' and (keysym.isdigit() or keysym == '-'):
            k.updateLabel(event)
        elif stroke == '<Key>' and keysym in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
#@+node:ekr.20061031131434.201:<< about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@-node:ekr.20061031131434.201:<< about repeat counts >>
#@+node:ekr.20061031131434.202:executeNTimes
def executeNTimes (self,event,n):

    k = self ; stroke = k.stroke ; w = event.widget
    # g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in range(n):
                if 1: # No need to do this: commands never alter events.
                    # ev = Tk.Event()
                    event = g.Bunch(
                        c = self.c,
                        widget = event.widget,
                        keysym = event.keysym,
                        keycode = event.keycode,
                        char = event.char,
                    )
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in range(n):
                g.app.gui.event_generate(w,'<Key>',keycode=event.keycode,keysym=event.keysym)

#@-node:ekr.20061031131434.202:executeNTimes
#@+node:ekr.20061031131434.203:doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c
    ch = g.app.gui.eventChar(event)

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@-node:ekr.20061031131434.203:doControlU
#@-node:ekr.20061031131434.200:universalDispatcher & helpers
#@-node:ekr.20061031131434.74:class keyHandlerClass
#@+node:ekr.20061031131434.146:masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    << define vars >>
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        << handle special cases for plain keys >>

    << handle per-pane bindings >>

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20080510153327.4:<< handle special cases for plain keys >>
# g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'
#@nonl
#@-node:ekr.20080510153327.4:<< handle special cases for plain keys >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
keyStatesTuple = ('command','insert','overwrite')

# g.trace('w_name',w_name,'stroke',stroke,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(d.keys(),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@-node:ekr.20061031131434.146:masterKeyHandler & helpers
#@+node:ekr.20080510095819.1:k.handleUnboudKeys
def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')

    if trace: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif k.isFKey(stroke):
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20080510095819.1:k.handleUnboudKeys
#@+node:ekr.20090518072506.8494:isFKey
def isFKey (self,shortcut):


    if not shortcut: return False

    s = shortcut.lower()

    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
#@-node:ekr.20090518072506.8494:isFKey
#@+node:ekr.20061031131434.182:isPlainKey
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
#@-node:ekr.20061031131434.182:isPlainKey
#@-node:ekr.20090518072506.8493:Fixed F10/11/12 key bug
#@-node:ekr.20090401105902.2:Bugs
#@+node:ekr.20090401105902.3:Features
#@+node:ekr.20090307063422.2:find-clone-all as synonym for clone-find-all
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-clone-all':                       self.cloneFindAll, # Synonym.

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses_nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@-node:ekr.20090307063422.2:find-clone-all as synonym for clone-find-all
#@+node:ekr.20090514072254.5744:Improved unit testing .leo files
@nocolor-node

What I did:

- leoDynamicTest.py now supports a --path argument giving the .leo file.
  Duh!  This is so useful!

- leoDynamicTest.py now honors the --silent argument.

- leoTest.runUnitTestLeoFile runs all unit tests in a given .leo file
  in a separate process.

- leoTest.runTestsExternally calls runUnitTestLeoFile after creating
  dynamicUnitTest.leo.

- When reporting that no unit tests were found, all unit tests commands tell
  whether the entire outline or just the selected outline was searched.
  This fixes sometimes-misleading error messages.

- test.leo contains a 'run-test.leo-tests' button.

- leoPy.leo contains a 'run-all-core-tests' button.
#@nonl
#@+node:ekr.20090514093345.6052:An example script
'''
Run all the unit tests in the .leo file given by the path.
The path is relative to the leo\test directory.
'''

import leo.core.leoTest as leoTest

leoTest.runUnitTestLeoFile(gui='nullGui',path='../core/leoPy.leo')

g.es_print('unit tests done',color='blue')
#@nonl
#@-node:ekr.20090514093345.6052:An example script
#@+node:ekr.20090514072254.5746:runUnitTestLeoFile
def runUnitTestLeoFile (gui='qt',path='unitTest.leo',silent=True):

    '''Run all unit tests in path (a .leo file) in a pristine environment.'''

    # New in Leo 4.5: leoDynamicTest.py is in the leo/core folder.
    path = g.os_path_finalize_join(g.app.loadDir,'..','test',path)
    leo  = g.os_path_finalize_join(g.app.loadDir,'..','core','leoDynamicTest.py')

    if sys.platform.startswith('win'): 
        if ' ' in leo: leo = '"' + leo + '"'
        if ' ' in path: path = '"' + path + '"'

    guiArg = '--gui=%s' % gui
    pathArg = '--path=%s' % path
    args = [sys.executable,leo,path,guiArg,pathArg]
    if silent: args.append('--silent')

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20090514072254.5746:runUnitTestLeoFile
#@+node:ekr.20060328121145:runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline
    Tests are run in an external process, so tests *cannot* change the outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
#@-node:ekr.20060328121145:runUnitTest commands
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all=None,p=None,verbosity=1):

    if p:
        pass
    elif all:
        p = c.rootPosition()
    else:
        p = c.p
    p1 = p.copy()

    try:
        found = False
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)

        # New in Leo 4.4.8: ignore everything in @ignore trees.
        if all: last = None
        else:   last = p.nodeAfterTree()
        while p and p != last:
            h = p.h
            if g.match_word(h,0,'@ignore'):
                p.moveToNodeAfterTree()
            elif isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test:
                    suite.addTest(test) ; found = True
                p.moveToThreadNext()
            elif isSuiteNode(p): # @suite
                # g.trace(p.h)
                test = makeTestSuite(c,p)
                if test:
                    suite.addTest(test) ; found = True
                p.moveToThreadNext()
            else:
                p.moveToThreadNext()

        # Verbosity: 1: print just dots.
        if found:
            res = unittest.TextTestRunner(verbosity=verbosity).run(suite)
            # put info to db as well
            key = 'unittest/cur/fail'
            archive = [(t.p.gnx, trace) for (t, trace) in res.errors]
            c.db[key] = archive
        else:
            g.es_print('no @test or @suite nodes in %s outline' % (
                g.choose(all,'entire','selected')),color='red')
    finally:
        c.setChanged(changed) # Restore changed state.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.redraw(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()
#@nonl
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    # print ('p',p,'len(script)',len(script))
    self.assert_(script)
    writeScriptFile = c.config.getBool('write_script_file')

    # import leo.core.leoGlobals as g

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p,'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    # g.trace(type(script),script)

    # Execute the script. Let unit test handle any errors!

    if writeScriptFile:
        scriptFile = c.writeScriptFile(script)
        execfile(scriptFile,d)
    else:
        exec(script,d)

    # if 0: # debug
        # import pdb
        # pdb.run(script+'\n',d)
    # else:
        # exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    # import leo.core.leoGlobals as g
    p = p.copy()

    h = p.h
    script = g.getScript(c,p).strip()
    if not script:
        g.pr("no script in %s" % h)
        return None

    try:
        exec(script + '\n',{'c':c,'g':g,'p':p})
        suite = g.app.scriptDict.get("suite")
        if not suite:
            g.pr("%s script did not set g.app.scriptDict" % h)
        return suite
    except Exception:
        g.trace('Exception creating test cases for %s' % p.h)
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.b.strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_finalize_join(g.app.loadDir,'..','test', self.fileName)

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing

    - all children of any @mark-for-unit-tests node anywhere in the outline.
    - all @test and @suite nodes in p's outline.'''

    trace = False
    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>

    self.copyRoot.expand()
    for p,limit,lookForMark,lookForNodes in (
        (p1,limit1,lookForMark1,lookForNodes1),
        (p2,limit2,lookForMark2,lookForNodes2),
    ):
        if trace: g.trace('look for: mark %s nodes %s\nroot %s\nlimit %s' % (
            lookForMark,lookForNodes,p.h,limit and limit.h or '<none>'))
        while p and p != limit:
            h = p.h
            if p.v.t in self.seen:
                p.moveToNodeAfterTree()
            elif lookForMark and h.startswith(markTag):
                self.addMarkTree(p)
                p.moveToNodeAfterTree()
            elif lookForNodes and self.isUnitTestNode(p):
                self.addNode(p)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.p
    if p.h.startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # Add the entire @mark-for-unit-tests tree.
    self.addNode(p)

    # for p in p.subtree_iter():
        # # if self.isUnitTestNode(p) and not p.v.t in self.seen:
        # if not p.v.t in self.seen: # Add *all* nodes.
            # self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-tests tree as the last child of self.copyRoot.
    '''

    # g.trace(p.h)

    p2 = p.copyTreeAfter()
    p2.moveToLastChildOf(self.copyRoot)

    for p2 in p.self_and_subtree_iter():
        self.seen.append(p2.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.h
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self,gui='nullGui',trace=False):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo
    in a separate process.
    '''

    trace = False or trace
    import time
    kind = g.choose(self.all,'all ','selected')
    c = self.c ; p = c.p
    t1 = time.time()
    found = self.searchOutline(p.copy())
    if found:
        theGui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=theGui)
        found = self.createOutline(c2)
        self.createFileFromOutline(c2)
        t2 = time.time()
        print('created %s unit tests in %0.2fsec in %s' % (
            kind,t2-t1,self.fileName))
        g.es('created %s unit tests' % (kind),color='blue')
        runUnitTestLeoFile(gui=gui,path='dynamicUnitTest.leo',silent=True)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in %s outline' % (
            g.choose(self.all,'entire','selected')),color='red')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.p
    iter = g.choose(self.all,c.all_positions_with_unique_tnodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.h
        for s in self.tags:
            if h.startswith(s):
                self.root = c.p
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.p.parents_iter():
            h = p.h
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.all_positions_with_unique_tnodes_iter():
        if p.h.startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20090514072254.5744:Improved unit testing .leo files
#@+node:ekr.20090514111518.5659:test .py files when saving them
# To do: check syntax for @nosent and @shadow files.
#@nonl
#@+node:EKR.20040614071102.1:g.getScript & test
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    # New in Leo 4.6 b2: use a pristine atFile handler
    # so there can be no conflict with c.atFileCommands.
    # at = c.atFileCommands
    import leo.core.leoAtFile as leoAtFile
    at = leoAtFile.atFile(c)

    w = c.frame.body.bodyCtrl
    p1 = p and p.copy()
    if not p:
        p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif p1:
            s = p.b # Bug fix: Leo 8.8.4.
        elif p == c.p:
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            # Important: converts unicode to utf-8 encoded strings.
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20090517020744.5878:@test g.getScript strips crlf
if g.unitTesting:

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20090517020744.5878:@test g.getScript strips crlf
#@-node:EKR.20040614071102.1:g.getScript & test
#@+node:ekr.20090514111518.5661:checkPythonCode (leoAtFile) & helpers
def checkPythonCode (self,root,s=None,targetFn=None):

    c = self.c

    if not targetFn: targetFn = self.targetFileName

    if targetFn and targetFn.endswith('.py') and self.checkPythonCodeOnWrite:
        try:
            if not s: s = open(self.outputFileName).read()
        except IOError:
            g.trace('can not happen',g.callers(4))
            return

        # It's too slow to check each node separately.
        ok = self.checkPythonSyntax(root,s)

        # Syntax checking catches most indentation problems.
        if False:
            if ok: self.tabNannyNode(root,s)
#@nonl
#@+node:ekr.20090514111518.5663:checkPythonSyntax (leoAtFile)
def checkPythonSyntax (self,p,body):

    try:
        import compiler,parser
        ok = True
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        self.syntaxError(p)
        p.setMarked()
        ok = False
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        ok = False

    return ok
#@nonl
#@+node:ekr.20090514111518.5666:syntaxError
def syntaxError(self,p):

    import traceback

    g.es_print("Syntax error in: %s" % (p.h),color="red")

    # Similar to g.es_exception(full=False)
    typ,val,tb = sys.exc_info()
    lines = traceback.format_exception_only(typ,val)
    for line in lines[1:]:
        g.es_print(line)
#@-node:ekr.20090514111518.5666:syntaxError
#@-node:ekr.20090514111518.5663:checkPythonSyntax (leoAtFile)
#@+node:ekr.20090514111518.5665:tabNannyNode (leoAtFile)
def tabNannyNode (self,p,body):

    try:
        import parser,tabnanny,tokenize
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        g.es("ParserError in",p.h,color="red")
        g.es('',str(msg))
        p.setMarked()
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        g.es("TokenError in",headline,color="red")
        g.es('',str(msg))
        p.setMarked()
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()
        g.es("indentation error in",headline,"line",badline,color="red")
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n",line2)
        p.setMarked()
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
#@nonl
#@-node:ekr.20090514111518.5665:tabNannyNode (leoAtFile)
#@-node:ekr.20090514111518.5661:checkPythonCode (leoAtFile) & helpers
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self,root):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    c = self.c

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            g.es('unchanged:',self.shortFileName)
            if not ok:
                # self.remove gives the error.
                if root: root.setDirty() # New in 4.4.8.
            self.fileChangedFlag = False
            return False
        else:
            self.checkPythonCode(root)
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:    ',self.shortFileName)
            else:
                # self.rename gives the error.
                g.es('unchanged:',self.shortFileName)
                if root: root.setDirty() # New in 4.4.8.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:  ',self.targetFileName)
        else:
            # self.rename gives the error.
            if root: root.setDirty() # New in 4.4.8.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20080711093251.5:writeOneAtShadowNode & helpers
def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.es_print('can not happen: not an @shadow node',p.h,color='red')
        return False

    # A hack to support unknown extensions.
    self.adjustTargetLanguage(fn) # May set c.target_language.

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = c.os_path_finalize_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force,fn):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None, # Not used.
        atShadow=True,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        forcePythonSentinels=True) # A hack to suppress an error message.
            # The actual sentinels will be set below.

    # Bug fix: Leo 4.5.1: use x.markerFromExtension to force the delim to match
    #                     what is used in x.propegate changes.
    # Note: x.marker_from_extension takes the file name as the argument,
    # not the extension itself
    marker = x.marker_from_extension(fn,addAtSign=False)
    # g.trace('write marker',marker)
    at.startSentinelComment = marker
    at.endSentinelComment = None

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,
            nosentinels=not sentinels,toString=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        # by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        # x.isSentinel logic is used consistently by the @shadow read/write logic.
        # OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    self.checkPythonCode(root,s=at.private_s,targetFn=fn)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName,color='red')
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
#@+node:ekr.20080711093251.6:shouldWriteAtShadowNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force,fn):

    '''Return True if we should write the @shadow node at p.'''

    at = self ; x = at.c.shadowController

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
#@-node:ekr.20080711093251.6:shouldWriteAtShadowNode
#@+node:ekr.20080819075811.13:adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
#@-node:ekr.20080819075811.13:adjustTargetLanguage
#@-node:ekr.20080711093251.5:writeOneAtShadowNode & helpers
#@-node:ekr.20090514111518.5659:test .py files when saving them
#@+node:ville.20090311193011.2:test select_h, select_b, find_h, find_b
@color
@language python

pl = c.find_h('@thin.*py').select_h('class.*')
print "Direct classes in thin nodes:",[e.h for e in pl]
pl = pl.select_b(r"\(object\)")
print "Subclass object",[e.h for e in pl]


print "\n\nAll classes"
pl = c.find_b(r'^class\s+(\w+).*:')
#print pl
for p in pl:
    print "Node:",p.h
    for match in p.matchiter:
        print match.group(1)

# find this node

pl = c.find_h('@thin.*leoNotes')
pl2 = pl.select_h('test select.*')

print pl2
#@nonl
#@-node:ville.20090311193011.2:test select_h, select_b, find_h, find_b
#@+node:ekr.20090520055433.5880:Refactored openWithFileName
#@+node:ekr.20070412082527:g.openLeoOrZipFile
# This is used in several places besides g.openWithFileName.

def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False
#@nonl
#@-node:ekr.20070412082527:g.openLeoOrZipFile
#@+node:ekr.20090520055433.5945:g.openWithFileName & helpers
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    trace = False and not g.unitTesting

    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)

    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    g.app.writeWaitingLog()
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.createMenu(c,fn,relFn)
    g.finishOpen(c)
    return True,c.frame
#@+node:ekr.20090520055433.5951:createMenu
def createMenu(c,fileName,relativeFileName,):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
#@-node:ekr.20090520055433.5951:createMenu
#@+node:ekr.20090520055433.5948:findOpenFile
def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if munge(fileName) == munge(c.mFileName):
            frame.bringToFront()
            c.setLog()
            c.outerUpdate()
            return c
    return None
#@-node:ekr.20090520055433.5948:findOpenFile
#@+node:ekr.20090520055433.5952:finishOpen
def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
#@-node:ekr.20090520055433.5952:finishOpen
#@+node:ekr.20090520055433.5950:handleOpenHooks
def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if theFile:
            app.lockLog()
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True
#@nonl
#@-node:ekr.20090520055433.5950:handleOpenHooks
#@+node:ekr.20090520055433.5954:mungeFileName
def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
#@-node:ekr.20090520055433.5954:mungeFileName
#@+node:ekr.20090520055433.5946:openWithFileNameHelper
def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(old_c)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
#@+node:ekr.20090520055433.5949:preRead
def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
#@-node:ekr.20090520055433.5949:preRead
#@-node:ekr.20090520055433.5946:openWithFileNameHelper
#@+node:ekr.20080921154026.1:openWrapperLeoFile
def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if True: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.p
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.p
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.p
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Unlike new, we the outline should be marked changed.

    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()

    # c.redraw() # Only needed by menu commands.
    return c
#@-node:ekr.20080921154026.1:openWrapperLeoFile
#@-node:ekr.20090520055433.5945:g.openWithFileName & helpers
#@-node:ekr.20090520055433.5880:Refactored openWithFileName
#@-node:ekr.20090401105902.3:Features
#@-node:ekr.20080917153158.11:4.6 b2
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
