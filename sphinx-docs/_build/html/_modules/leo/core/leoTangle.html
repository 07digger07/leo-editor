<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>leo.core.leoTangle &mdash; Leo API 4.11dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '4.11dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Leo API 4.11dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Leo API 4.11dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for leo.core.leoTangle</h1><div class="highlight"><pre>
<span class="c">#@+leo-ver=5-thin</span>
<span class="c">#@+node:ekr.20031218072017.3446: * @file leoTangle.py</span>
<span class="c">#@@language python</span>
<span class="c">#@@tabwidth -4</span>
<span class="c">#@@pagewidth 70</span>

<span class="c"># Tangle and Untangle.</span>
<span class="kn">import</span> <span class="nn">leo.core.leoGlobals</span> <span class="kn">as</span> <span class="nn">g</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c">#@+&lt;&lt; about Tangle and Untangle &gt;&gt;</span>
<span class="c">#@+node:ekr.20031218072017.2411: ** &lt;&lt; About Tangle and Untangle &gt;&gt;</span>
<span class="c">#@@root directive. The stack never becomes empty because of the entry</span>
<span class="c">#@+at</span>
<span class="c"># The Tangle command translates the selected @root tree into one or more</span>
<span class="c"># well-formatted source files. The outline should contain directives,</span>
<span class="c"># sections references and section definitions, as described in Chapter</span>
<span class="c"># 4. The Untangle command is essentially the reverse of the Tangle</span>
<span class="c"># command. The Tangle command creates a derived file from an @root tree;</span>
<span class="c"># the Untangle command incorporates changes made to derived files back</span>
<span class="c"># into the @root tree.</span>
<span class="c"># </span>
<span class="c"># The Tangle command operates in two passes. The first pass discovers</span>
<span class="c"># the complete definitions of all sections and places these definitions</span>
<span class="c"># in a Tangle Symbol Table. The first pass also makes a list of root</span>
<span class="c"># sections. Definitions can appear in any order, so we must scan the</span>
<span class="c"># entire input file to know whether any particular definition has been</span>
<span class="c"># completed.</span>
<span class="c"># </span>
<span class="c"># Tangle&#39;s second pass creates one file for each @root node. Tangle</span>
<span class="c"># rescans each section in the list of roots, copying the root text to</span>
<span class="c"># the output and replacing each section reference by the section&#39;s</span>
<span class="c"># definition. This is a recursive process because any definition may</span>
<span class="c"># contain other references. We can not allow a section to be defined in</span>
<span class="c"># terms of itself, either directly or indirectly. We check for such</span>
<span class="c"># illegally recursive definitions in pass 2 using the section stack</span>
<span class="c"># class. Tangle indicates where sections begin and end using comment</span>
<span class="c"># lines called sentinel lines. The sentinels used predate the formats</span>
<span class="c"># described in the &quot;Format of external files&quot; appendix.</span>
<span class="c"># </span>
<span class="c"># The key design principle of the Tangle command is this: Tangle must</span>
<span class="c"># output newlines in a context-free manner. That is, Tangle must never</span>
<span class="c"># output conditional newlines, either directly or indirectly. Without</span>
<span class="c"># this rule Untangle could not determine whether to skip or copy</span>
<span class="c"># newlines.</span>
<span class="c"># </span>
<span class="c"># The Tangle command increases the indentation level of a section</span>
<span class="c"># expansion the minimum necessary to align the section expansion with</span>
<span class="c"># the surrounding code. In essence, this scheme aligns all section</span>
<span class="c"># expansions with the line of code in which the reference to the section</span>
<span class="c"># occurs. In some cases, several nested sections expansions will have</span>
<span class="c"># the same indentation level. This can occur, for example, when a</span>
<span class="c"># section reference in an outline occurs at the left margin of the</span>
<span class="c"># outline.</span>
<span class="c"># </span>
<span class="c"># This scheme is probably better than more obvious schemes that indent</span>
<span class="c"># more &quot;consistently.&quot; Such schemes would produce too much indentation</span>
<span class="c"># for deeply nested outlines. The present scheme is clear enough and</span>
<span class="c"># avoids indentation wherever possible, yet indents sections adequately.</span>
<span class="c"># End sentinel lines make this scheme work by making clear where the</span>
<span class="c"># expansion of one section ends and the expansion of a containing</span>
<span class="c"># section resumes.</span>
<span class="c"># </span>
<span class="c"># Tangle increases indentation if the section reference does not start a</span>
<span class="c"># line. Untangle is aware of this hack and adjusts accordingly. This</span>
<span class="c"># extra indentation handles several common code idioms, which otherwise</span>
<span class="c"># would create under-indented code. In short, Tangle produces highly</span>
<span class="c"># readable, given the necessity of preserving newlines for Untangle.</span>
<span class="c"># </span>
<span class="c"># Untangle is inherently complex. It must do a perfect job of updating</span>
<span class="c"># the outline, especially whitespace, from expansions of section</span>
<span class="c"># definitions created by the Tangle command. Such expansions need not be</span>
<span class="c"># identical because they may have been generated at different levels of</span>
<span class="c"># indentation. The Untangle command can not assume that all expansions</span>
<span class="c"># of a section will be identical in the derived file; within the derived</span>
<span class="c"># file, the programmer may have made incompatible changes to two</span>
<span class="c"># different expansions of the same section. Untangle must check to see</span>
<span class="c"># that all expansions of a section are &quot;equivalent&quot;. As an added</span>
<span class="c"># complication, derived files do not contain all the information found</span>
<span class="c"># in @root trees. @root trees may contain headlines that generate no</span>
<span class="c"># code at all. Also, an outline may define a section in several ways:</span>
<span class="c"># with an @c or @code directive or with a section definition line. To be</span>
<span class="c"># useful, Untangle must handle all these complications flawlessly.</span>
<span class="c"># </span>
<span class="c"># Untangle operates in three passes. The first pass builds a symbol</span>
<span class="c"># table in the same way that Tangle does. The key information there</span>
<span class="c"># informs how the second pass finds definitions in the derived file: to</span>
<span class="c"># support multi-language files (e.g., javascript embedded in html) the</span>
<span class="c"># second pass needs to know what comment delimiters to look for as it</span>
<span class="c"># discovers sentinels in the derived file. Using comment delimiters as</span>
<span class="c"># suggested by the first pass, it uses the sentinels to find section</span>
<span class="c"># parts and enters them into the Untangle Symbol Table, or UST.</span>
<span class="c"># Definitions often include references to other sections, so definitions</span>
<span class="c"># often include nested definitions of referenced sections. The second</span>
<span class="c"># pass of Untangle uses a definition stack to keep track of nested</span>
<span class="c"># definitions. The top of the stack represents the definition following</span>
<span class="c"># the latest reference, except for the very first entry pushed on the</span>
<span class="c"># stack, which represents the code in the outline that contains the</span>
<span class="c"># for the @root section. All definitions of a section should</span>
<span class="c"># match--otherwise there is an inconsistent definition. This pass uses a</span>
<span class="c"># forgiving compare routine that ignores differences that do not affect</span>
<span class="c"># the meaning of a program.</span>
<span class="c"># </span>
<span class="c"># Untangle&#39;s third pass enters definitions from the outline into a</span>
<span class="c"># second Tangle Symbol Table, or TST. The third pass simultaneously</span>
<span class="c"># updates all sections in the outline whose definition in the new TST</span>
<span class="c"># does not match the definition in the UST. The central coding insight</span>
<span class="c"># of the Untangle command is that the second pass of Untangle is almost</span>
<span class="c"># identical to the first pass of Tangle! That is, Tangle and Untangle</span>
<span class="c"># share key parts of code, namely the skip_body() method and its allies.</span>
<span class="c"># Just when skip_body() enters a definition into the symbol table, all</span>
<span class="c"># the information is present that Untangle needs to update that</span>
<span class="c"># definition.</span>
<span class="c">#@-&lt;&lt; about Tangle and Untangle &gt;&gt;</span>
<span class="c">#@+&lt;&lt; constants &gt;&gt;</span>
<span class="c">#@+node:ekr.20031218072017.3447: ** &lt;&lt; constants &gt;&gt;</span>
<span class="n">max_errors</span> <span class="o">=</span> <span class="mi">20</span>

<span class="c"># All these must be defined together, because they form a single enumeration.</span>
<span class="c"># Some of these are used by utility functions.</span>

<span class="c"># Used by token_type().</span>
<span class="n">plain_line</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># all other lines</span>
<span class="n">at_at</span>      <span class="o">=</span> <span class="mi">2</span> <span class="c"># double-at sign.</span>
<span class="n">at_chapter</span> <span class="o">=</span> <span class="mi">3</span> <span class="c"># @chapter</span>
<span class="c"># at_c     = 4 # @c in noweb mode</span>
<span class="n">at_code</span>    <span class="o">=</span> <span class="mi">5</span> <span class="c"># @code, or @c or @p in CWEB mode.</span>
<span class="n">at_doc</span>     <span class="o">=</span> <span class="mi">6</span> <span class="c"># @doc</span>
<span class="n">at_other</span>   <span class="o">=</span> <span class="mi">7</span> <span class="c"># all other @directives</span>
<span class="n">at_root</span>    <span class="o">=</span> <span class="mi">8</span> <span class="c"># @root or noweb * sections</span>
<span class="n">at_section</span> <span class="o">=</span> <span class="mi">9</span> <span class="c"># @section</span>
<span class="c"># at_space = 10 # @space</span>
<span class="n">at_web</span>     <span class="o">=</span> <span class="mi">11</span> <span class="c"># any CWEB control code, except at_at.</span>

<span class="c"># Returned by self.skip_section_name() and allies and used by token_type.</span>
<span class="n">bad_section_name</span> <span class="o">=</span> <span class="mi">12</span>  <span class="c"># &lt; &lt; with no matching &gt; &gt;</span>
<span class="n">section_ref</span>  <span class="o">=</span> <span class="mi">13</span>  <span class="c"># &lt; &lt; name &gt; &gt;</span>
<span class="n">section_def</span>  <span class="o">=</span> <span class="mi">14</span>  <span class="c"># &lt; &lt; name &gt; &gt; =</span>

<span class="c"># Returned by is_sentinal_line.</span>
<span class="n">non_sentinel_line</span>   <span class="o">=</span> <span class="mi">15</span>
<span class="n">start_sentinel_line</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">end_sentinel_line</span>   <span class="o">=</span> <span class="mi">17</span>

<span class="c"># Stephen P. Schaefer 9/13/2002</span>
<span class="c"># add support for @first</span>
<span class="n">at_last</span>    <span class="o">=</span> <span class="mi">18</span>
<span class="c">#@-&lt;&lt; constants &gt;&gt;</span>

<span class="c">#@+others</span>
<span class="c">#@+node:ekr.20031218072017.3448: ** node classes</span>
<span class="c">#@+node:ekr.20031218072017.3449: *3* class tst_node</span>
<div class="viewcode-block" id="tst_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.tst_node">[docs]</a><span class="k">class</span> <span class="nc">tst_node</span><span class="p">:</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:ekr.20031218072017.3450: *4* tst_node.__init__</span>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">root_flag</span><span class="p">):</span>

        <span class="c"># g.trace(&quot;tst_node.__init__&quot;,name)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="n">root_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenced</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delims</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c">#@+node:ekr.20031218072017.3451: *4* tst_node.__repr__</span>
    <span class="k">def</span> <span class="nf">__repr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="s">&quot;tst_node:&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="c">#@+node:sps.20100624231018.12083: *4* tst_node.dump</span>
<div class="viewcode-block" id="tst_node.dump"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.tst_node.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">section: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
            <span class="s">&quot;, referenced:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">referenced</span><span class="p">)</span> <span class="o">+</span>
            <span class="s">&quot;, is root:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">----- parts of &quot;</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">angleBrackets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># part list is in numeric order</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">----- Part &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">doc:  [&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">doc</span><span class="p">)</span>  <span class="o">+</span> <span class="s">&quot;]&quot;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">code: [&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">delims: &lt;</span><span class="si">%s</span><span class="s">&gt;&lt;</span><span class="si">%s</span><span class="s">&gt;&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">part</span><span class="o">.</span><span class="n">delims</span>
                <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">reflist</span><span class="p">():</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">    ref: [&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">----- end of partList</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="c">#@-others</span>
<span class="c">#@+node:ekr.20031218072017.3452: *3* class part_node</span></div></div>
<div class="viewcode-block" id="part_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.part_node">[docs]</a><span class="k">class</span> <span class="nc">part_node</span><span class="p">:</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:ekr.20031218072017.3453: *4* part_node.__init__</span>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">is_root</span><span class="p">,</span><span class="n">is_dirty</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="c"># g.trace(&quot;part_node.__init__&quot;,name)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="c"># Section or file name.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span> <span class="c"># The code text.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span> <span class="c"># The doc text.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_dirty</span> <span class="o">=</span> <span class="n">is_dirty</span> <span class="c"># True: vnode for body text is dirty.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="n">is_root</span> <span class="c"># True: name is a root name.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delims</span> <span class="o">=</span> <span class="n">delims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c">#@+node:ekr.20031218072017.3454: *4* part_node.__repr__</span>
    <span class="k">def</span> <span class="nf">__repr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="s">&quot;part_node:&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="c">#@+node:sps.20100622084732.16656: *4* part_node.reflist</span>
<div class="viewcode-block" id="part_node.reflist"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.part_node.reflist">[docs]</a>    <span class="k">def</span> <span class="nf">reflist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">refs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span>
    <span class="c">#@-others</span>
<span class="c">#@+node:ekr.20031218072017.3455: *3* class ust_node</span></div></div>
<div class="viewcode-block" id="ust_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.ust_node">[docs]</a><span class="k">class</span> <span class="nc">ust_node</span><span class="p">:</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:ekr.20031218072017.3456: *4* ust_node.__init__</span>
    <span class="c">#@+at</span>
    <span class="c"># The text has been masssaged so that 1) it contains no leading</span>
    <span class="c"># indentation and 2) all code arising from section references have been</span>
    <span class="c"># replaced by the reference line itself. Text for all copies of the same</span>
    <span class="c"># part can differ only in non-critical white space.</span>
    <span class="c">#@@c</span>

    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">,</span><span class="n">update_flag</span><span class="p">):</span>

        <span class="c"># g.trace(&quot;ust_node.__init__&quot;,name,part)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="c"># section name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># parts dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span> <span class="c"># code text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">part</span> <span class="o">=</span> <span class="n">part</span> <span class="c"># n in &quot;(part n of m)&quot; or zero.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="o">=</span> <span class="n">of</span>  <span class="c"># m in &quot;(part n of m)&quot; or zero.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nl_flag</span> <span class="o">=</span> <span class="n">nl_flag</span>  <span class="c"># True: section starts with a newline.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_flag</span> <span class="o">=</span> <span class="n">update_flag</span> <span class="c"># True: section corresponds to a section in the outline.</span>
    <span class="c">#@+node:ekr.20031218072017.3457: *4* ust_node.__repr__</span>
    <span class="k">def</span> <span class="nf">__repr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="s">&quot;ust_node:&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="c">#@+node:sps.20100624231018.12084: *4* ust_node.dump</span>
<div class="viewcode-block" id="ust_node.dump"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.ust_node.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;name: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c"># assert(part.of == self.of)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">----- part </span><span class="si">%s</span><span class="s"> of </span><span class="si">%s</span><span class="s"> -----</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">part</span><span class="p">),</span><span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">of</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">update_flag: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">update_flag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="c">#@-others</span>
<span class="c">#@+node:ekr.20031218072017.3458: *3* class def_node</span></div></div>
<div class="viewcode-block" id="def_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.def_node">[docs]</a><span class="k">class</span> <span class="nc">def_node</span><span class="p">:</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:ekr.20031218072017.3459: *4* def_node.__init__</span>
    <span class="c">#@+at</span>
    <span class="c"># The text has been masssaged so that 1) it contains no leading</span>
    <span class="c"># indentation and 2) all code arising from section references have been</span>
    <span class="c"># replaced by the reference line itself. Text for all copies of the same</span>
    <span class="c"># part can differ only in non-critical white space.</span>
    <span class="c">#@@c</span>

    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">,</span><span class="n">code</span><span class="p">):</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;def_node.__init__:&quot;</span><span class="p">,</span>
                <span class="s">&quot;name:&quot;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="s">&quot; part:&quot;</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="s">&quot; of:&quot;</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="s">&quot; indent:&quot;</span><span class="p">,</span><span class="n">indent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent</span> <span class="o">=</span> <span class="n">indent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">part</span> <span class="o">=</span> <span class="n">part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">of</span> <span class="o">=</span> <span class="n">of</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nl_flag</span> <span class="o">=</span> <span class="n">nl_flag</span>
    <span class="c">#@+node:ekr.20031218072017.3460: *4* def_node.__repr__</span>
    <span class="k">def</span> <span class="nf">__repr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="s">&quot;def_node:&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
    <span class="c">#@-others</span>
<span class="c">#@+node:ekr.20031218072017.3461: *3* class root_attributes (Stephen P. Schaefer)</span>
<span class="c">#@+at Stephen P. Schaefer, 9/2/2002</span>
<span class="c"># Collect the root node specific attributes in an</span>
<span class="c"># easy-to-use container.</span>
<span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="root_attributes"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.root_attributes">[docs]</a><span class="k">class</span> <span class="nc">root_attributes</span><span class="p">:</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:ekr.20031218072017.3462: *4* root_attributes.__init__</span>
    <span class="c">#@+at Stephen P. Schaefer, 9/2/2002</span>
    <span class="c"># Keep track of the attributes of a root node</span>
    <span class="c">#@@c</span>

    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tangle_state</span><span class="p">):</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#@+&lt;&lt; trace the state &gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3463: *5* &lt;&lt; trace the state &gt;&gt;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">path</span><span class="p">:</span> <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">tangle_state</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;def_root_attribute.__init__&quot;</span><span class="p">,</span>
                    <span class="s">&quot;language:&quot;</span> <span class="o">+</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">language</span> <span class="o">+</span>
                    <span class="s">&quot;, use_header_flag: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tangle_state</span><span class="o">.</span><span class="n">use_header_flag</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s">&quot;, print_mode: &quot;</span> <span class="o">+</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">+</span>
                    <span class="s">&quot;, path: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tangle_state</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s">&quot;, page_width: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tangle_state</span><span class="o">.</span><span class="n">page_width</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s">&quot;, tab_width: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">tangle_state</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">+</span>
                    <span class="c"># Stephen P. Schaefer 9/13/2002</span>
                    <span class="s">&quot;, first_lines: &quot;</span> <span class="o">+</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">first_lines</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt; trace the state &gt;&gt;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">language</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_header_flag</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">use_header_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">print_mode</span>

        <span class="c"># of all the state variables, this one isn&#39;t set in tangleCommands.__init__</span>
        <span class="c"># peculiar</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">page_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">tab_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span> <span class="o">=</span> <span class="n">tangle_state</span><span class="o">.</span><span class="n">first_lines</span> <span class="c"># Stephen P. Schaefer 9/13/2002</span>
    <span class="c">#@+node:ekr.20031218072017.3464: *4* root_attributes.__repr__</span>
    <span class="k">def</span> <span class="nf">__repr__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;root_attributes: language: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">+</span>
            <span class="s">&quot;, use_header_flag: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_header_flag</span><span class="p">)</span> <span class="o">+</span>
            <span class="s">&quot;, print_mode: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">+</span>
            <span class="s">&quot;, path: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span>
            <span class="s">&quot;, page_width: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">page_width</span><span class="p">)</span> <span class="o">+</span>
            <span class="s">&quot;, tab_width: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">+</span>
            <span class="c"># Stephen P. Schaefer 9/13/2002</span>
            <span class="s">&quot;, first_lines: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span><span class="p">)</span>
    <span class="c">#@-others</span>
<span class="c">#@+node:ekr.20031218072017.3465: ** class tangleCommands methods</span></div>
<div class="viewcode-block" id="baseTangleCommands"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands">[docs]</a><span class="k">class</span> <span class="nc">baseTangleCommands</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The base class for Leo&#39;s tangle and untangle commands.&quot;&quot;&quot;</span>
    <span class="c">#@+others</span>
    <span class="c">#@+node:sps.20100629094515.20943: *3* class RegexpForLanguageOrComment</span>
<div class="viewcode-block" id="baseTangleCommands.RegexpForLanguageOrComment"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.RegexpForLanguageOrComment">[docs]</a>    <span class="k">class</span> <span class="nc">RegexpForLanguageOrComment</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;&#39;&#39;</span>
<span class="s">            ^(</span>
<span class="s">                (?P&lt;language&gt;</span>
<span class="s">                    @language\s[^\n]*</span>
<span class="s">                ) |</span>
<span class="s">                (?P&lt;comment&gt;</span>
<span class="s">                    @comment\s[^\n]*</span>
<span class="s">                ) |</span>
<span class="s">                (</span>
<span class="s">                    [^\n]*\n</span>
<span class="s">                )</span>
<span class="s">            )*&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3466: *3* tangle.__init__</span></div>
    <span class="k">def</span> <span class="nf">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_ivars</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.1356: *3* tangle.init_ivars &amp; init_directive_ivars</span>
    <span class="c"># Called by __init__</span>

<div class="viewcode-block" id="baseTangleCommands.init_ivars"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.init_ivars">[docs]</a>    <span class="k">def</span> <span class="nf">init_ivars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c">#@+&lt;&lt; init tangle ivars &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.1357: *4* &lt;&lt; init tangle ivars &gt;&gt;</span>
        <span class="c"># Various flags and counts...</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># The number of errors seen.</span>
        <span class="c"># self.tangling = True # True if tangling, False if untangling.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># True: suppress duplicate warnings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Level of indentation during pass 2, in spaces.</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">mFileName</span> <span class="c"># The file name (was a bridge function)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span> <span class="o">=</span> <span class="s">&quot;&lt;unknown file name&gt;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># position being processed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># The file descriptor of the output file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_mode</span> <span class="o">=</span> <span class="s">&quot;doc&quot;</span> <span class="c"># &quot;code&quot; or &quot;doc&quot;.  Use &quot;doc&quot; for compatibility.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_output</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># For unit testing.</span>

        <span class="c">#@+at Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline.</span>
        <span class="c"># The UST (Untangle Symbol Table) contains all sections defined in the derived file.</span>
        <span class="c">#@@c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ust</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># The section stack for Tangle and the definition stack for Untangle.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c">#@+at</span>
        <span class="c"># The list of all roots. The symbol table routines add roots to self</span>
        <span class="c"># list during pass 1. Pass 2 uses self list to generate code for all</span>
        <span class="c"># roots.</span>
        <span class="c">#@@c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># The filename following @root in a headline.</span>
        <span class="c"># The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Formerly the &quot;tangle private globals&quot;</span>
        <span class="c"># These save state during tangling and untangling.</span>
        <span class="c"># It is possible that these will be removed...</span>
        <span class="k">if</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">section_name</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c">#@+at</span>
        <span class="c"># The following records whether we have seen an @code directive in a</span>
        <span class="c"># body text. If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is</span>
        <span class="c"># valid to continue a section definition.</span>
        <span class="c">#@@c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code_seen</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># True if @code seen in body text.</span>

        <span class="c"># Support of output_newline option</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_newline</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getOutputNewline</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; init tangle ivars &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; init untangle ivars &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.1358: *4* &lt;&lt; init untangle ivars &gt;&gt;</span>
        <span class="c">#@+at Untangle vars used while comparing.</span>
        <span class="c">#@@c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbatim</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># forgiving compare message.</span>
        <span class="c">#@-&lt;&lt; init untangle ivars &gt;&gt;</span>

    <span class="c"># Called by scanAllDirectives</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.init_directive_ivars"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.init_directive_ivars">[docs]</a>    <span class="k">def</span> <span class="nf">init_directive_ivars</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="c">#@+&lt;&lt; init directive ivars &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.1359: *4* &lt;&lt; init directive ivars &gt;&gt; (tangle)</span>
        <span class="c"># Global options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">page_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">tab_width</span>

        <span class="c"># New in Leo 4.5: get these from settings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_doc_flag</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getBool</span><span class="p">(</span><span class="s">&#39;output_doc_flag&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_batch_flag</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getBool</span><span class="p">(</span><span class="s">&#39;tangle_batch_flag&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">untangle_batch_flag</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getBool</span><span class="p">(</span><span class="s">&#39;untangle_batch_flag&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_header_flag</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">getBool</span><span class="p">(</span><span class="s">&#39;use_header_flag&#39;</span><span class="p">)</span>

        <span class="c"># Default tangle options.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Initialized by scanAllDirectives</span>

        <span class="c"># Default tangle language</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># debug</span>
            <span class="kn">import</span> <span class="nn">sys</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangleCommands.languague: </span><span class="si">%s</span><span class="s"> at header </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)))</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;caller: &quot;</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;caller&#39;s caller: &quot;</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>

        <span class="c"># Abbreviations for self.language.</span>
        <span class="c"># Warning: these must also be initialized in tangle.scanAllDirectives.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_cweb_flag</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;cweb&quot;</span><span class="p">)</span> <span class="c"># A new ivar.</span>

        <span class="c"># Set only from directives.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="s">&quot;verbose&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">default_derived_file_encoding</span> <span class="c"># 2/21/03</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_newline</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getOutputNewline</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span> <span class="c"># 4/24/03: initialize from config settings.</span>
        <span class="c">#@-&lt;&lt; init directive ivars &gt;&gt;</span>
    <span class="c">#@+node:ekr.20031218072017.3467: *3* top level</span>
    <span class="c">#@+at Only top-level drivers initialize ivars.</span>
    <span class="c">#@+node:ekr.20031218072017.3468: *4* cleanup</span>
    <span class="c"># This code is called from tangleTree and untangleTree.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.cleanup"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">cleanup</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c"># Reinitialize the symbol tables and lists.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ust</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#@+node:ekr.20031218072017.3470: *4* initTangleCommand</span></div>
<div class="viewcode-block" id="baseTangleCommands.initTangleCommand"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.initTangleCommand">[docs]</a>    <span class="k">def</span> <span class="nf">initTangleCommand</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">c</span><span class="o">.</span><span class="n">endEditing</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangling...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_ivars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c">#@+node:ekr.20031218072017.3471: *4* initUntangleCommand</span></div>
<div class="viewcode-block" id="baseTangleCommands.initUntangleCommand"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.initUntangleCommand">[docs]</a>    <span class="k">def</span> <span class="nf">initUntangleCommand</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">c</span><span class="o">.</span><span class="n">endEditing</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;untangling...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_ivars</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.3472: *4* tangle</span></div>
<div class="viewcode-block" id="baseTangleCommands.tangle"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tangle">[docs]</a>    <span class="k">def</span> <span class="nf">tangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initTangleCommand</span><span class="p">()</span>

        <span class="c"># Paul Paterson&#39;s patch.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;looking for a parent to tangle...&quot;</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict</span><span class="p">(</span><span class="n">p</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">])</span>
                <span class="k">if</span> <span class="s">&#39;root&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangling parent&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToParent</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangle complete&quot;</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3473: *4* tangleAll</span></div>
<div class="viewcode-block" id="baseTangleCommands.tangleAll"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tangleAll">[docs]</a>    <span class="k">def</span> <span class="nf">tangleAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initTangleCommand</span><span class="p">()</span>
        <span class="n">has_roots</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">rootPosition</span><span class="p">()</span><span class="o">.</span><span class="n">self_and_siblings</span><span class="p">():</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="n">has_roots</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span>
                <span class="k">break</span> <span class="c"># Fatal error.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_roots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- the outline contains no roots&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- tangle halted because of errors&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangle complete&quot;</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3474: *4* tangleMarked</span></div>
<div class="viewcode-block" id="baseTangleCommands.tangleMarked"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tangleMarked">[docs]</a>    <span class="k">def</span> <span class="nf">tangleMarked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">rootPosition</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">clearAllVisited</span><span class="p">()</span> <span class="c"># No roots have been tangled yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initTangleCommand</span><span class="p">()</span>
        <span class="n">any_marked</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">is_ignore</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_special</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;@ignore&quot;</span><span class="p">)</span>
            <span class="c"># Only tangle marked and unvisited nodes.</span>
            <span class="k">if</span> <span class="n">is_ignore</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">isMarked</span><span class="p">():</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="n">any_marked</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c"># Fatal error.</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">any_marked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- The outline contains no marked roots&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- Tangle halted because of errors&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;tangle complete&quot;</span><span class="p">)</span>
    <span class="c">#@+node:sps.20100618004337.20865: *4* tanglePass1</span>
    <span class="c"># Traverses the tree whose root is given, handling each headline and associated body text.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.tanglePass1"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tanglePass1">[docs]</a>    <span class="k">def</span> <span class="nf">tanglePass1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p_in</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;The main routine of tangle pass 1&quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># self.p used by update_def in untangle</span>
    <span class="c">#    g.trace(p)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromHeadline</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">theDict</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict</span><span class="p">(</span><span class="n">p</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="s">&#39;ignore&#39;</span> <span class="ow">in</span> <span class="n">theDict</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c"># calls init_directive_ivars.</span>
        <span class="c"># Scan the headline and body text.</span>
        <span class="c"># @language and @comment are not recognized in headlines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_headline</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_body</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">delims</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">&gt;=</span> <span class="n">max_errors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- Halting Tangle: too many errors&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">hasChildren</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">moveToFirstChild</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">p</span><span class="o">.</span><span class="n">hasNext</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">&lt;</span> <span class="n">max_errors</span><span class="p">):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNext</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3476: *4* tanglePass2</span>
    <span class="c"># At this point p is the root of the tree that has been tangled.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.tanglePass2"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tanglePass2">[docs]</a>    <span class="k">def</span> <span class="nf">tanglePass2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># self.p is not valid in pass 2.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- No file written because of errors&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- The outline contains no roots&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_all_roots</span><span class="p">()</span> <span class="c"># pass 2 top level function.</span>
    <span class="c">#@+node:ekr.20031218072017.3477: *4* tangleTree (calls cleanup)</span>
    <span class="c"># This function is called only from the top level, so there is no need to initialize globals.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.tangleTree"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.tangleTree">[docs]</a>    <span class="k">def</span> <span class="nf">tangleTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Tangles all nodes in the tree whose root is p.</span>

<span class="sd">        Reports on its results if report_errors is True.&quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># 9/14/04</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">any_root_flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nodeAfterTree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">while</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">next</span><span class="p">:</span>
    <span class="c">#        g.trace(p)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromHeadline</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">theDict</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict</span><span class="p">(</span><span class="n">p</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">])</span>
            <span class="n">is_ignore</span> <span class="o">=</span> <span class="s">&#39;ignore&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="n">is_root</span> <span class="o">=</span> <span class="s">&#39;root&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="n">is_unit</span> <span class="o">=</span> <span class="s">&#39;unit&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="k">if</span> <span class="n">is_ignore</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_root</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_unit</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c"># sets self.init_delims</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">init_delims</span><span class="p">)</span> <span class="c"># sets self.p</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span>
                    <span class="n">any_root_flag</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass2</span><span class="p">()</span> <span class="c"># self.p invalid in pass 2.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span> <span class="k">break</span> <span class="c"># Fatal error.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="ow">and</span> <span class="n">report_errors</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">any_root_flag</span><span class="p">:</span>
            <span class="c"># This is done by Untangle if we are untangling.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- The outline contains no roots&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">any_root_flag</span>
    <span class="c">#@+node:ekr.20031218072017.3478: *4* untangle</span></div>
<div class="viewcode-block" id="baseTangleCommands.untangle"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.untangle">[docs]</a>    <span class="k">def</span> <span class="nf">untangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initUntangleCommand</span><span class="p">()</span>
        <span class="c"># must be done at this point, since initUntangleCommand blows away tangle_output</span>
        <span class="c">#@+&lt;&lt; read fake files for unit testing &gt;&gt;</span>
        <span class="c">#@+node:sps.20100618004337.16262: *5* &lt;&lt; read fake files for unit testing &gt;&gt;</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">hasNext</span><span class="p">()):</span>
                <span class="n">p2</span><span class="o">.</span><span class="n">moveToNext</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tangle_output</span><span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">b</span>
        <span class="c">#@-&lt;&lt; read fake files for unit testing &gt;&gt;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">untangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;untangle complete&quot;</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">redraw</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.3479: *4* untangleAll</span></div>
<div class="viewcode-block" id="baseTangleCommands.untangleAll"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.untangleAll">[docs]</a>    <span class="k">def</span> <span class="nf">untangleAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initUntangleCommand</span><span class="p">()</span>
        <span class="n">has_roots</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">rootPosition</span><span class="p">()</span><span class="o">.</span><span class="n">self_and_siblings</span><span class="p">():</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="n">has_roots</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">c</span><span class="o">.</span><span class="n">redraw</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_roots</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- the outline contains no roots&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- untangle command halted because of errors&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;untangle complete&quot;</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3480: *4* untangleMarked</span></div>
<div class="viewcode-block" id="baseTangleCommands.untangleMarked"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.untangleMarked">[docs]</a>    <span class="k">def</span> <span class="nf">untangleMarked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">rootPosition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initUntangleCommand</span><span class="p">()</span>
        <span class="n">marked_flag</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">while</span> <span class="n">p</span><span class="p">:</span> <span class="c"># Don&#39;t use an iterator.</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">isMarked</span><span class="p">():</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangleTree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ok</span><span class="p">:</span> <span class="n">marked_flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">redraw</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">marked_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- the outline contains no marked roots&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- untangle command halted because of errors&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;untangle complete&quot;</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3481: *4* untangleRoot (calls cleanup)</span>
    <span class="c">#@+at</span>
    <span class="c"># This method untangles the derived files in a vnode known to contain at</span>
    <span class="c"># least one @root directive. The work is done in three passes. The first</span>
    <span class="c"># pass creates a TST from the Leo tree so that the next pass will know</span>
    <span class="c"># what comment conventions to use; that pass is performed in</span>
    <span class="c"># untangleTree. The second pass creates the UST by scanning the derived</span>
    <span class="c"># file. The third pass updates the outline using the UST and a new TST</span>
    <span class="c"># that is created during the pass.</span>
    <span class="c"># </span>
    <span class="c"># We assume that all sections from root to end are contained in the</span>
    <span class="c"># derived file, and we attempt to update all such sections. The</span>
    <span class="c"># begin/end params indicate the range of nodes to be scanned when</span>
    <span class="c"># building the TST.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.untangleRoot"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.untangleRoot">[docs]</a>    <span class="k">def</span> <span class="nf">untangleRoot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root</span><span class="p">,</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>

        <span class="c"># g.trace(&quot;root,begin,end:&quot;,root,begin,end)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="c">#@+&lt;&lt; return if @silent &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3482: *5* &lt;&lt; return if @silent &gt;&gt;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span><span class="s">&quot;silent&quot;</span><span class="p">):</span>
            <span class="n">g</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;@</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span><span class="p">),</span>
                <span class="s">&quot;inhibits untangle for&quot;</span><span class="p">,</span><span class="n">root</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c">#@-&lt;&lt; return if @silent &gt;&gt;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">b</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c"># g.trace(&quot;i: %d&quot; % i)</span>
            <span class="c">#@+&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3483: *5* &lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">code</span><span class="p">,</span> <span class="n">junk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="n">at_root</span><span class="p">:</span>
                    <span class="c"># token_type sets root_name unless there is a syntax error.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">:</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">:</span>
                <span class="c"># A bad @root command.  token_type has already given an error.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="c">#@-&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">os_path_finalize_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; fake the file access &gt;&gt;</span>
                <span class="c">#@+node:sps.20100608083657.20939: *5* &lt;&lt; fake the file access &gt;&gt;</span>
                <span class="c"># complications to handle testing of multiple @root directives together with</span>
                <span class="c"># @path directives</span>
                <span class="n">file_name_path</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">os_path_finalize_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span><span class="p">,</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">file_name_path</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">openDirectory</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">relative_path</span> <span class="o">=</span> <span class="n">file_name_path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">openDirectory</span><span class="p">):]</span>
                    <span class="c"># don&#39;t confuse /u and /usr as having common prefixes</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">relative_path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)]</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
                        <span class="n">file_name_path</span> <span class="o">=</span> <span class="n">relative_path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">):]</span>

                <span class="c"># find the node with the right title, and load self.tangle_output and file_buf</span>
                <span class="n">file_buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_output</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">file_name_path</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; fake the file access &gt;&gt;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">file_buf</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">readFileIntoString</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_buf</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">file_buf</span> <span class="o">=</span> <span class="n">file_buf</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;@root &#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># debug</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">st_dump</span><span class="p">())</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;path: &quot;</span> <span class="o">+</span> <span class="n">path</span><span class="p">)</span>
                <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">section</span>
                <span class="c"># Pass 2: Scan the derived files, creating the UST</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scan_derived_file</span><span class="p">(</span><span class="n">file_buf</span><span class="p">)</span>
                <span class="c"># g.trace(self.ust_dump())</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; Pass 3: Untangle the outline using the UST and a newly-created TST &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3485: *5* &lt;&lt; Pass 3:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</span>
                    <span class="c">#@+at</span>
                    <span class="c"># This code untangles the root and all its siblings. We don&#39;t call tangleTree here</span>
                    <span class="c"># because we must handle all siblings. tanglePass1 handles an entire tree. It also</span>
                    <span class="c"># handles @ignore.</span>
                    <span class="c">#@@c</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">begin</span>
                    <span class="k">while</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">end</span><span class="p">:</span> <span class="c"># Don&#39;t use iterator.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c"># sets self.init_delims</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_delims</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">ust_warn_about_orphans</span><span class="p">()</span>
                    <span class="c">#@-&lt;&lt; Pass 3: Untangle the outline using the UST and a newly-created TST &gt;&gt;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.3486: *4* untangleTree</span>
    <span class="c"># This funtion is called when the user selects any &quot;Untangle&quot; command.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.untangleTree"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.untangleTree">[docs]</a>    <span class="k">def</span> <span class="nf">untangleTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">report_errors</span><span class="p">):</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># 9/14/04</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">any_root_flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">afterEntireTree</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nodeAfterTree</span><span class="p">()</span>
        <span class="c"># Initialize these globals here: they can&#39;t be cleared later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span><span class="o">.</span><span class="n">clearAllVisited</span><span class="p">()</span> <span class="c"># Used by untangle code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delims_table</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">while</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">afterEntireTree</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromHeadline</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">theDict</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict</span><span class="p">(</span><span class="n">p</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">])</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="s">&#39;ignore&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="n">root</span> <span class="o">=</span> <span class="s">&#39;root&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s">&#39;unit&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
            <span class="k">if</span> <span class="n">ignore</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToNodeAfterTree</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">unit</span><span class="p">:</span>
                <span class="c"># Expand the context to the @unit directive.</span>
                <span class="n">unitNode</span> <span class="o">=</span> <span class="n">p</span>   <span class="c"># 9/27/99</span>
                <span class="n">afterUnit</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nodeAfterTree</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c"># sets self.init_delims</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">afterUnit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span><span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromHeadline</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">theDict</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict</span><span class="p">(</span><span class="n">p</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">])</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="s">&#39;root&#39;</span> <span class="ow">in</span> <span class="n">theDict</span>
                    <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
                        <span class="n">any_root_flag</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="c">#@+&lt;&lt; set end to the next root in the unit &gt;&gt;</span>
                        <span class="c">#@+node:ekr.20031218072017.3487: *5* &lt;&lt; set end to the next root in the unit &gt;&gt;</span>
                        <span class="c">#@+at</span>
                        <span class="c"># The untangle_root function will untangle an entire tree by calling</span>
                        <span class="c"># untangleTree, so the following code ensures that the next @root node</span>
                        <span class="c"># will not be an offspring of p.</span>
                        <span class="c">#@@c</span>

                        <span class="n">end</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">threadNext</span><span class="p">()</span>
                        <span class="k">while</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">!=</span> <span class="n">afterUnit</span><span class="p">:</span>
                            <span class="n">flag</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_special</span><span class="p">(</span><span class="n">end</span><span class="o">.</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;@root&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">isAncestorOf</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
                                <span class="k">break</span>
                            <span class="n">end</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>
                        <span class="c">#@-&lt;&lt; set end to the next root in the unit &gt;&gt;</span>
                        <span class="c"># g.trace(&quot;end:&quot;,end)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">init_delims</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">untangleRoot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">unitNode</span><span class="p">,</span><span class="n">afterUnit</span><span class="p">)</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">root</span><span class="p">:</span>
                <span class="c"># Limit the range of the @root to its own tree.</span>
                <span class="n">afterRoot</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nodeAfterTree</span><span class="p">()</span>
                <span class="n">any_root_flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scanAllDirectives</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="c"># get the delims table</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tanglePass1</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">init_delims</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">untangleRoot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">afterRoot</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">afterRoot</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">moveToThreadNext</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span>

        <span class="k">if</span> <span class="n">report_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">any_root_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- The outline contains no roots&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;----- Untangle command halted because of errors&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">any_root_flag</span>
    <span class="c">#@+node:ekr.20031218072017.3488: *3* tangle</span>
    <span class="c">#@+node:ekr.20031218072017.3489: *4* Pass 1</span>
    <span class="c">#@+node:sps.20100618004337.20969: *5* handle_newline</span>
    <span class="c">#@+at</span>
    <span class="c"># This method handles newline processing while skipping a code section.</span>
    <span class="c"># It sets &#39;done&#39; if the line contains an @directive or section</span>
    <span class="c"># definition that terminates the present code section. On entry: i</span>
    <span class="c"># should point to the first character of a line. This routine scans past</span>
    <span class="c"># a line only if it could not contain a section reference.</span>
    <span class="c"># </span>
    <span class="c"># Returns (i, done)</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.handle_newline"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.handle_newline">[docs]</a>    <span class="k">def</span> <span class="nf">handle_newline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">delims</span><span class="p">)</span>
        <span class="c"># g.trace(s[i:g.skip_to_end_of_line(s,i)])</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c"># token_type will not skip whitespace in noweb mode.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="c"># g.trace(kind,g.get_line(s,i))</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">plain_line</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">at_code</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_doc</span> <span class="ow">or</span>
            <span class="n">kind</span> <span class="o">==</span> <span class="n">at_root</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="p">;</span> <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># Terminate this code section and rescan.</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_ref</span><span class="p">:</span>
            <span class="c"># Enter the reference.</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_other</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s">&quot;@language&quot;</span><span class="p">):</span>
                <span class="n">lang</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_language</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">d3</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="s">&quot;@comment&quot;</span><span class="p">):</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_delims_from_string</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_chapter</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_section</span><span class="p">:</span>
            <span class="c"># We don&#39;t process chapter or section here</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_web</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_at</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="c"># Skip a CWEB control code.</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">assert</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">delims</span>
    <span class="c">#@+node:sps.20100618004337.20951: *5* skip_body</span>
    <span class="c"># This method handles all the body text.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.skip_body"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.skip_body">[docs]</a>    <span class="k">def</span> <span class="nf">skip_body</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="c"># g.trace(p)</span>
        <span class="c"># g.trace(&quot;****start****\n&quot;+self.st_dump())</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">b</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">doc</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">anyChanged</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_mode</span> <span class="o">==</span> <span class="s">&quot;code&quot;</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">new_delims</span><span class="p">,</span><span class="n">reflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">code</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Define a section for a leading code part &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20952: *6* &lt;&lt; Define a section for a leading code part &gt;&gt;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">:</span>
                    <span class="c"># Tangle code.</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">new_delims</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span>
                        <span class="c"># Untangle code.</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span><span class="p">:</span>
                            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">)</span>
                            <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reflist</span><span class="p">(</span><span class="n">refs</span><span class="o">=</span><span class="n">reflist</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">head</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                            <span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_def</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">tail</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">changed</span><span class="p">:</span> <span class="n">anyChanged</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="n">doc</span> <span class="o">=</span> <span class="bp">None</span>

                <span class="c"># leading code without a header name gets silently dropped</span>
                <span class="c">#@-&lt;&lt; Define a section for a leading code part &gt;&gt;</span>
            <span class="n">delims</span> <span class="o">=</span> <span class="n">new_delims</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">code</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_doc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span> <span class="c"># Start in doc section by default.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">doc</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Define a section containing only an @doc part &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20953: *6* &lt;&lt; Define a section containing only an @doc part &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># It&#39;s valid for an @doc directive to appear under a headline that does</span>
                <span class="c"># not contain a section name. In that case, no section is defined.</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">:</span>
                    <span class="c"># Tangle code.</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
                    <span class="c"># Untangle code.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span> 
                        <span class="c"># Untangle no longer updates doc parts.</span>
                        <span class="c"># 12/03/02: Mark the part as having been updated to suppress warning.</span>
                        <span class="n">junk</span><span class="p">,</span><span class="n">junk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust_lookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">update_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="n">doc</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="c">#@-&lt;&lt; Define a section containing only an @doc part &gt;&gt;</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">i</span> <span class="c"># progress indicator</span>
            <span class="c"># line = g.get_line(s,i) ; g.trace(line)</span>
            <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># if g.is_nl(s,i): i = g.skip_nl(s,i)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Scan and define a section definition &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20954: *6* &lt;&lt; Scan and define a section definition &gt;&gt;</span>
                <span class="c"># We enter the code part and any preceding doc part into the symbol table.</span>

                <span class="c"># Skip the section definition line.</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">junk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">section_name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

                <span class="c"># Tangle code: enter the section name even if the code part is empty.</span>
                <span class="c">#@+&lt;&lt;process normal section&gt;&gt;</span>
                <span class="c">#@+node:sps.20100716120121.12132: *7* &lt;&lt;process normal section&gt;&gt;</span>
                <span class="c"># Tangle code.</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">new_delims</span><span class="p">,</span> <span class="n">reflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#debug</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&#39;=======</span><span class="se">\n</span><span class="si">%s</span><span class="s">======&#39;</span> <span class="o">%</span> <span class="n">code</span><span class="p">)</span>
                <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">new_delims</span><span class="p">)</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="n">new_delims</span>

                <span class="c"># Untangle code</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span>
                    <span class="c"># part may be zero if there was an empty code section (doc part only)</span>
                    <span class="c"># In untangle stage1 such code produces no reference list,</span>
                    <span class="c">#    thus nothing to do.</span>
                    <span class="c"># In untangle stage2, such code cannot be updated because it</span>
                    <span class="c"># was either not emitted to the external file or emitted as a doc part only</span>
                    <span class="c">#     in either case, there is no code section to update, and we don&#39;t</span>
                    <span class="c">#     update doc parts.</span>
                    <span class="k">if</span> <span class="n">part</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span><span class="p">:</span>
                            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">section_name</span><span class="p">)</span>
                            <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reflist</span><span class="p">(</span><span class="n">refs</span><span class="o">=</span><span class="n">reflist</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">head</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                            <span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_def</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">tail</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">changed</span><span class="p">:</span> <span class="n">anyChanged</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c">#@-&lt;&lt;process normal section&gt;&gt;</span>

                <span class="n">code</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="c">#@-&lt;&lt; Scan and define a section definition &gt;&gt;</span>
                <span class="c"># g.trace(&quot;****after section def****\n&quot;+self.st_dump())</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_code</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="c">#@+&lt;&lt; Scan and define an @code defininition &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20955: *6* &lt;&lt; Scan and define an @code defininition &gt;&gt;</span>
                <span class="c"># All @c or @code directives denote &lt; &lt; headline_name &gt; &gt; =</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span><span class="p">:</span>
                    <span class="n">section_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span>
                    <span class="c">#@+&lt;&lt;process normal section&gt;&gt;</span>
                    <span class="c">#@+node:sps.20100716120121.12132: *7* &lt;&lt;process normal section&gt;&gt;</span>
                    <span class="c"># Tangle code.</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">new_delims</span><span class="p">,</span> <span class="n">reflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#debug</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&#39;=======</span><span class="se">\n</span><span class="si">%s</span><span class="s">======&#39;</span> <span class="o">%</span> <span class="n">code</span><span class="p">)</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">new_delims</span><span class="p">)</span>
                    <span class="n">delims</span> <span class="o">=</span> <span class="n">new_delims</span>

                    <span class="c"># Untangle code</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span>
                        <span class="c"># part may be zero if there was an empty code section (doc part only)</span>
                        <span class="c"># In untangle stage1 such code produces no reference list,</span>
                        <span class="c">#    thus nothing to do.</span>
                        <span class="c"># In untangle stage2, such code cannot be updated because it</span>
                        <span class="c"># was either not emitted to the external file or emitted as a doc part only</span>
                        <span class="c">#     in either case, there is no code section to update, and we don&#39;t</span>
                        <span class="c">#     update doc parts.</span>
                        <span class="k">if</span> <span class="n">part</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span><span class="p">:</span>
                                <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">section_name</span><span class="p">)</span>
                                <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reflist</span><span class="p">(</span><span class="n">refs</span><span class="o">=</span><span class="n">reflist</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">head</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                                <span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_def</span><span class="p">(</span><span class="n">section_name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">tail</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">changed</span><span class="p">:</span> <span class="n">anyChanged</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="c">#@-&lt;&lt;process normal section&gt;&gt;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;@c expects the headline: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">+</span> <span class="s">&quot; to contain a section name&quot;</span><span class="p">)</span>

                <span class="n">code</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="c">#@-&lt;&lt; Scan and define an @code defininition &gt;&gt;</span>
                <span class="c"># g.trace(&quot;****after @code****\n&quot;+self.st_dump())</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_root</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="c">#@+&lt;&lt; Scan and define a root section &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20956: *6* &lt;&lt; Scan and define a root section &gt;&gt;</span>
                <span class="c"># We save the file name in case another @root ends the code section.</span>
                <span class="n">old_root_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span>

                <span class="c"># g.trace(&quot;Scan and define a root section: %s tangle %s&quot; % (old_root_name,repr(self.tangling)))</span>

                <span class="c"># Tangle code.</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">new_delims</span><span class="p">,</span> <span class="n">reflist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_code</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>

                <span class="c"># g.trace(&quot;reflist: &quot; + repr(reflist))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_root_name</span><span class="p">(</span><span class="n">old_root_name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">new_delims</span><span class="p">)</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="n">new_delims</span>

                <span class="c"># g.trace(&quot;self.tangling: &quot;+repr(self.tangling))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span><span class="p">:</span> <span class="c"># Untangle code.</span>
                    <span class="c"># g.trace(&quot;untangle_stage1: &quot;+repr(self.untangle_stage1))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">untangle_stage1</span><span class="p">:</span>
                        <span class="n">root_section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">old_root_name</span><span class="p">)</span>
                        <span class="k">assert</span><span class="p">(</span><span class="n">root_section</span><span class="p">)</span>
                        <span class="n">root_first_part</span> <span class="o">=</span> <span class="n">root_section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">assert</span><span class="p">(</span><span class="n">root_first_part</span><span class="p">)</span>
                        <span class="n">root_first_part</span><span class="o">.</span><span class="n">reflist</span><span class="p">(</span><span class="n">refs</span> <span class="o">=</span> <span class="n">reflist</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Use 1 for root part.</span>
                        <span class="n">head</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span>
                        <span class="c"># g.trace(&quot;old_root_name &lt;%s&gt; part &lt;%d&gt; head &lt;%s&gt; code &lt;%s&gt; tail &lt;%s&gt;&quot; % (old_root_name,part,head,code,tail))</span>
                        <span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_def</span><span class="p">(</span><span class="n">old_root_name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">tail</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span> <span class="n">anyChanged</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="c"># g.trace(self.st_dump())</span>

                <span class="n">code</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="c">#@-&lt;&lt; Scan and define a root section &gt;&gt;</span>
                <span class="c"># g.trace(&quot;****after @root****\n&quot;+self.st_dump())</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">at_doc</span><span class="p">,</span> <span class="n">at_chapter</span><span class="p">,</span> <span class="n">at_section</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">more_doc</span><span class="p">,</span> <span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_doc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span> <span class="o">+</span> <span class="n">more_doc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">progress</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="c"># we must make progress!</span>
        <span class="c"># Only call trimTrailingLines if we have changed its body.</span>
        <span class="k">if</span> <span class="n">anyChanged</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">trimTrailingLines</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">delims</span>
    <span class="c">#@+node:sps.20100618004337.20957: *6* The interface between tangle and untangle</span>
    <span class="c">#@+at</span>
    <span class="c"># The following subsections contain the interface between the Tangle and</span>
    <span class="c"># Untangle commands. This interface is an important hack, and allows</span>
    <span class="c"># Untangle to avoid duplicating the logic in skip_tree and its allies.</span>
    <span class="c"># </span>
    <span class="c"># The aha is this: just at the time the Tangle command enters a</span>
    <span class="c"># definition into the symbol table, all the information is present that</span>
    <span class="c"># Untangle needs to update that definition.</span>
    <span class="c"># </span>
    <span class="c"># To get whitespace exactly right we retain the outline&#39;s leading</span>
    <span class="c"># whitespace and remove leading whitespace from the updated definition.</span>
    <span class="c">#@+node:sps.20100618004337.20965: *5* skip_code</span>
    <span class="c">#@+at</span>
    <span class="c"># This method skips an entire code section. The caller is responsible</span>
    <span class="c"># for entering the completed section into the symbol table. On entry, i</span>
    <span class="c"># points at the line following the @directive or section definition that</span>
    <span class="c"># starts a code section. We skip code until we see the end of the body</span>
    <span class="c"># text or the next @ directive or section defintion that starts a code</span>
    <span class="c"># or doc part.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.skip_code"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.skip_code">[docs]</a>    <span class="k">def</span> <span class="nf">skip_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="n">reflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># g.trace(g.get_line(s,i))</span>
        <span class="n">code1</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">nl_i</span> <span class="o">=</span> <span class="n">i</span> <span class="c"># For error messages</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># True when end of code part seen.</span>
        <span class="c">#@+&lt;&lt; skip a noweb code section &gt;&gt;</span>
        <span class="c">#@+node:sps.20100618004337.20966: *6* &lt;&lt; skip a noweb code section &gt;&gt;</span>
        <span class="c">#@+at</span>
        <span class="c"># This code handles the following escape conventions: double at-sign at</span>
        <span class="c"># the start of a line and at-&lt;&lt; and at.&gt;.</span>
        <span class="c">#@@c</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_newline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                <span class="n">nl_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_newline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="c"># must be on different lines</span>
                <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;&gt;&gt;&quot;</span><span class="p">)):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span> <span class="c"># skip the noweb escape sequence.</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; handle possible noweb section reference &gt;&gt;</span>
                <span class="c">#@+node:sps.20100618004337.20967: *7* &lt;&lt; handle possible noweb section reference &gt;&gt;</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="c"># We are in the middle of a line.</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;chunk definition not valid here</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">nl_i</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># This is not an error.  Just skip the &#39;&lt;&#39;.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">section_ref</span><span class="p">)</span>
                    <span class="c"># Enter the reference into the symbol table.</span>
                    <span class="c"># Appropriate comment delimiters get specified</span>
                    <span class="c"># at the time the section gets defined.</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">st_enter_section_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
                    <span class="n">reflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">end</span>
                <span class="c">#@-&lt;&lt; handle possible noweb section reference &gt;&gt;</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c">#@-&lt;&lt; skip a noweb code section &gt;&gt;</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">code1</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="c"># g.trace(&quot;returns:&quot;,code)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">delims</span><span class="p">,</span><span class="n">reflist</span>
    <span class="c">#@+node:ekr.20031218072017.3503: *5* skip_doc</span></div>
<div class="viewcode-block" id="baseTangleCommands.skip_doc"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.skip_doc">[docs]</a>    <span class="k">def</span> <span class="nf">skip_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="c"># g.trace(g.get_line(s,i))</span>
        <span class="c"># Skip @space, @*, @doc, @chapter and @section directives.</span>
        <span class="n">doc1</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                <span class="n">doc1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@ &quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@*&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">;</span> <span class="n">doc1</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">doc1</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@doc&quot;</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@chapter&quot;</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@section&quot;</span><span class="p">)):</span>
                <span class="n">doc1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">break</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">kind</span><span class="p">,</span> <span class="n">junk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_code</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_root</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c"># @language and @comment are honored within document parts</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_other</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@language&quot;</span><span class="p">):</span>
                    <span class="n">lang</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_language</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">delims</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">d3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@comment&quot;</span><span class="p">):</span>
                    <span class="n">delims</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_delims_from_string</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>               
            <span class="n">i</span> <span class="o">=</span> <span class="n">k</span>

        <span class="n">doc</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">doc1</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="c"># g.trace(doc)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">delims</span>
    <span class="c">#@+node:ekr.20031218072017.3504: *5* skip_headline</span>
    <span class="c">#@+at</span>
    <span class="c"># This function sets ivars that keep track of the indentation level. We</span>
    <span class="c"># also remember where the next line starts because it is assumed to be</span>
    <span class="c"># the first line of a documentation section.</span>
    <span class="c"># </span>
    <span class="c"># A headline can contain a leading section name. If it does, we</span>
    <span class="c"># substitute the section name if we see an @c directive in the body</span>
    <span class="c"># text.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.skip_headline"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.skip_headline">[docs]</a>    <span class="k">def</span> <span class="nf">skip_headline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">h</span>
        <span class="c"># Set self.header_name.</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header_name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
    <span class="c">#@+node:ekr.20031218072017.3505: *4* Pass 2</span>
    <span class="c">#@+node:ekr.20031218072017.1488: *5* oblank, oblanks, os, otab, otabs (Tangle)</span></div>
<div class="viewcode-block" id="baseTangleCommands.oblank"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.oblank">[docs]</a>    <span class="k">def</span> <span class="nf">oblank</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oblanks</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.oblanks"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.oblanks">[docs]</a>    <span class="k">def</span> <span class="nf">oblanks</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toEncodedString</span><span class="p">(</span><span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.onl"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.onl">[docs]</a>    <span class="k">def</span> <span class="nf">onl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_newline</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toEncodedString</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span><span class="n">reportErrors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.os"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.os">[docs]</a>    <span class="k">def</span> <span class="nf">os</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toEncodedString</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span><span class="n">reportErrors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.otab"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.otab">[docs]</a>    <span class="k">def</span> <span class="nf">otab</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">otabs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.otabs"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.otabs">[docs]</a>    <span class="k">def</span> <span class="nf">otabs</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toEncodedString</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span><span class="n">reportErrors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.1151: *5* tangle.put_all_roots</span>
    <span class="c">#@+at</span>
    <span class="c"># This is the top level method of the second pass. It creates a separate derived file</span>
    <span class="c"># for each @root directive in the outline. The file is actually written only if</span>
    <span class="c"># the new version of the file is different from the old version,or if the file did</span>
    <span class="c"># not exist previously. If changed_only_flag FLAG is True only changed roots are</span>
    <span class="c"># actually written.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_all_roots"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_all_roots">[docs]</a>    <span class="k">def</span> <span class="nf">put_all_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="p">;</span> <span class="n">outline_name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">mFileName</span>

        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span><span class="p">:</span>

            <span class="c"># g.trace(section.name)</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">os_path_finalize_join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span><span class="p">,</span><span class="n">section</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">output_newline</span>
            <span class="n">textMode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;platform&#39;</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">fileLikeObject</span><span class="p">()</span>
                <span class="n">temp_name</span> <span class="o">=</span> <span class="s">&#39;temp-file&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span><span class="n">temp_name</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">create_temp_file</span><span class="p">(</span><span class="n">textMode</span><span class="o">=</span><span class="n">textMode</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">temp_name</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;can not create temp file&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="c">#@+&lt;&lt;Get root specific attributes&gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.1152: *6* &lt;&lt;Get root specific attributes&gt;&gt;</span>
            <span class="c"># Stephen Schaefer, 9/2/02</span>
            <span class="c"># Retrieve the full complement of state for the root node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">language</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_header_flag</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">use_header_flag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">print_mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">page_width</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">tab_width</span>
            <span class="c"># Stephen P. Schaefer, 9/13/2002</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span><span class="o">.</span><span class="n">first_lines</span>
            <span class="c">#@-&lt;&lt;Get root specific attributes&gt;&gt;</span>
            <span class="c">#@+&lt;&lt;Put @first lines&gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.1153: *6* &lt;&lt;Put @first lines&gt;&gt;</span>
            <span class="c"># Stephen P. Schaefer 9/13/2002</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt;Put @first lines&gt;&gt;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_header_flag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">==</span> <span class="s">&quot;verbose&quot;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Write a banner at the start of the output file &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.1154: *6* &lt;&lt;Write a banner at the start of the output file&gt;&gt;</span>
                <span class="c"># a root section must have at least one part</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span>
                <span class="n">delims</span><span class="o">=</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span>
                <span class="k">if</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot; Created by Leo from: &quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">outline_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot; Created by Leo from: &quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">outline_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                <span class="c">#@-&lt;&lt; Write a banner at the start of the output file &gt;&gt;</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Initialize global.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">put_part_node</span><span class="p">(</span><span class="n">part</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span> <span class="c"># output first lws</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="c"># Make sure the file ends with a cr/lf</span>
            <span class="c">#@+&lt;&lt; unit testing fake files&gt;&gt;</span>
            <span class="c">#@+node:sps.20100608083657.20937: *6* &lt;&lt; unit testing fake files&gt;&gt;</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="c"># complications to handle testing of multiple @root directives together with</span>
                <span class="c"># @path directives</span>
                <span class="n">file_name_path</span> <span class="o">=</span> <span class="n">file_name</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">file_name_path</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">openDirectory</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">relative_path</span> <span class="o">=</span> <span class="n">file_name_path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">openDirectory</span><span class="p">):]</span>
                    <span class="c"># don&#39;t confuse /u and /usr as having common prefixes</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">relative_path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)]</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
                        <span class="n">file_name_path</span> <span class="o">=</span> <span class="n">relative_path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">):]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tangle_output</span><span class="p">[</span><span class="n">file_name_path</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="c">#@-&lt;&lt; unit testing fake files&gt;&gt;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c">#@+&lt;&lt; unit testing set result and continue &gt;&gt;</span>
            <span class="c">#@+node:sps.20100608083657.20938: *6* &lt;&lt; unit testing set result and continue &gt;&gt;</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">unitTestDict</span> <span class="p">[</span><span class="s">&#39;tangle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">unitTestDict</span> <span class="p">[</span><span class="s">&#39;tangle_directory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">unitTestDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;tangle_output_fn&#39;</span><span class="p">):</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">unitTestDict</span><span class="p">[</span><span class="s">&#39;tangle_output_fn&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">file_name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">unitTestDict</span> <span class="p">[</span><span class="s">&#39;tangle_output_fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_name</span>
                <span class="k">continue</span>
            <span class="c">#@-&lt;&lt; unit testing set result and continue &gt;&gt;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">scanErrors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">update_file_if_changed</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">file_name</span><span class="p">,</span><span class="n">temp_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;unchanged:&quot;</span><span class="p">,</span><span class="n">file_name</span><span class="p">)</span>
                <span class="c">#@+&lt;&lt; Erase the temporary file &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.1155: *6* &lt;&lt; Erase the temporary file &gt;&gt;</span>
                <span class="k">try</span><span class="p">:</span> <span class="c"># Just delete the temp file.</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_name</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
                <span class="c">#@-&lt;&lt; Erase the temporary file &gt;&gt;</span>
    <span class="c">#@+node:ekr.20031218072017.3506: *5* put_code</span>
    <span class="c">#@+at</span>
    <span class="c"># This method outputs a code section, expanding section references by</span>
    <span class="c"># their definition. We should see no @directives or section definitions</span>
    <span class="c"># that would end the code section.</span>
    <span class="c"># </span>
    <span class="c"># Most of the differences bewteen noweb mode and CWEB mode are handled</span>
    <span class="c"># by token_type(called from put_newline). Here, the only difference is</span>
    <span class="c"># that noweb handles double-@ signs only at the start of a line.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_code"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_code">[docs]</a>    <span class="k">def</span> <span class="nf">put_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">no_first_lws_flag</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="c"># g.trace(g.get_line(s,0))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">put_newline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">no_first_lws_flag</span><span class="p">)</span>
            <span class="c"># Double @ is valid in both noweb and CWEB modes here.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@@&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&#39;@&#39;</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">):</span>
                <span class="c">#@+&lt;&lt; put possible section reference &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3507: *6* &lt;&lt;put possible section reference &gt;&gt;</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">name_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">section_def</span><span class="p">:</span>
                    <span class="c"># We are in the middle of a code section</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s">&quot;Should never happen:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span>
                        <span class="s">&quot;section definition while putting a section reference: &quot;</span> <span class="o">+</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># This is not an error.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">section_ref</span><span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">name_end</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">put_section</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">name_end</span><span class="p">,</span><span class="n">delims</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                <span class="c">#@-&lt;&lt; put possible section reference &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span> <span class="c"># We are in the middle of a line.</span>
                <span class="c">#@+&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3509: *6* &lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># The user must ensure that neither @ &lt; &lt; nor @ &gt; &gt; occurs in comments</span>
                <span class="c"># or strings. However, it is valid for @ &lt; &lt; or @ &gt; &gt; to appear in the</span>
                <span class="c"># doc chunk or in a single-line comment.</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@&lt;&lt;&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;/*@*/&lt;&lt;&quot;</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span>

                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@&gt;&gt;&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;/*@*/&gt;&gt;&quot;</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span>

                <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;@&quot;</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c">#@-&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                <span class="c">#@+&lt;&lt; elide @comment or @language &gt;&gt;</span>
                <span class="c">#@+node:sps.20100624113712.16401: *6* &lt;&lt; elide @comment or @language &gt;&gt;</span>
                <span class="k">while</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@comment&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@language&quot;</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; elide @comment or @language &gt;&gt;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">put_newline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span> <span class="c"># Put full lws</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">progress</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3510: *5* put_doc</span>
    <span class="c"># This method outputs a doc section within a block comment.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_doc"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_doc">[docs]</a>    <span class="k">def</span> <span class="nf">put_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="c"># g.trace(g.get_line(s,0))</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span>
        <span class="n">words</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">word_width</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">line_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># 8/1/02: can&#39;t use choose here!</span>
        <span class="k">if</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">single_w</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">single_w</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c"># Make sure we put at least 20 characters on a line.</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">20</span>
        <span class="c"># Skip Initial white space in the doc part.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">==</span> <span class="s">&quot;verbose&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">==</span> <span class="s">&quot;quiet&quot;</span><span class="p">):</span>
            <span class="n">use_block_comment</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">use_single_comment</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">use_block_comment</span> <span class="ow">and</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># javadoc_comment = use_block_comment and delims[1] == &quot;/**&quot;</span>
            <span class="k">if</span> <span class="n">use_block_comment</span> <span class="ow">or</span> <span class="n">use_single_comment</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_block_comment</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c">#@+&lt;&lt; put the doc part &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3511: *6* &lt;&lt;put the doc part&gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># This code fills and outputs each line of a doc part. It keeps track of</span>
                <span class="c"># whether the next word will fit on a line,and starts a new line if</span>
                <span class="c"># needed.</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="n">use_single_comment</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                    <span class="n">line_width</span> <span class="o">=</span><span class="p">(</span><span class="n">single_w</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                <span class="n">line_width</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                <span class="n">words</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">word_width</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="c">#@+&lt;&lt;output or skip whitespace or newlines&gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3512: *7* &lt;&lt;output or skip whitespace or newlines&gt;&gt;</span>
                    <span class="c">#@+at</span>
                    <span class="c"># This outputs whitespace if it fits, and ignores it otherwise, and</span>
                    <span class="c"># starts a new line if a newline is seen. The effect of self code is</span>
                    <span class="c"># that we never start a line with whitespace that was originally at the</span>
                    <span class="c"># end of a line.</span>
                    <span class="c">#@@c</span>

                    <span class="k">while</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws_or_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                        <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">:</span>
                            <span class="n">pad</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">line_width</span> <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">))</span>
                            <span class="n">line_width</span> <span class="o">+=</span> <span class="n">pad</span>
                            <span class="k">if</span> <span class="n">line_width</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39; &#39;</span><span class="p">:</span>
                            <span class="n">line_width</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">line_width</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">assert</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">use_single_comment</span><span class="p">:</span>
                                <span class="c"># New code: 5/31/00</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                                <span class="n">line_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">single_w</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                                <span class="n">line_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">words</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                            <span class="c"># tangle_indent is in spaces.</span>
                            <span class="n">line_width</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt;output or skip whitespace or newlines&gt;&gt;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">word_width</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws_or_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
                        <span class="n">word_width</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">words</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">line_width</span> <span class="o">+</span> <span class="n">word_width</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">:</span>
                        <span class="n">words</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">line_width</span> <span class="o">+=</span> <span class="n">word_width</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># 11-SEP-2002 DTHEIN: Fixed linewrapping bug in</span>
                        <span class="c"># tab-then-comment sequencing</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">use_single_comment</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                            <span class="n">line_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">single_w</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">otab</span><span class="p">()</span>
                            <span class="n">line_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                        <span class="n">words</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                        <span class="c"># tangle_indent is in spaces.</span>
                        <span class="n">line_width</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; put the doc part &gt;&gt;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_block_comment</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.3515: *5* put_leading_ws</span>
    <span class="c"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_leading_ws"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_leading_ws">[docs]</a>    <span class="k">def</span> <span class="nf">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>

        <span class="c"># g.trace(&quot;tab_width,indent:&quot;,self.tab_width,indent)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span>

        <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">otabs</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">oblanks</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oblanks</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3516: *5* put_newline</span>
    <span class="c">#@+at</span>
    <span class="c"># This method handles scanning when putting the start of a new line.</span>
    <span class="c"># Unlike the corresponding method in pass one, this method doesn&#39;t need</span>
    <span class="c"># to set a done flag in the caller because the caller already knows</span>
    <span class="c"># where the code section ends.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_newline"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_newline">[docs]</a>    <span class="k">def</span> <span class="nf">put_newline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">no_first_lws_flag</span><span class="p">):</span>

        <span class="n">kind</span><span class="p">,</span> <span class="n">junk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c">#@+&lt;&lt; Output leading white space except for blank lines &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3517: *6* &lt;&lt; Output leading white space except for blank lines &gt;&gt;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            <span class="c"># Conditionally output the leading previous leading whitespace.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">no_first_lws_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
            <span class="c"># Always output the leading whitespace of _this_ line.</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws_with_indent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Output leading white space except for blank lines &gt;&gt;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_web</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_at</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="c"># Allow the line to be scanned.</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_doc</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_code</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># These should have set limit in pass 1.</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">section_def</span> <span class="ow">and</span> <span class="n">kind</span> <span class="o">!=</span> <span class="n">at_chapter</span> <span class="ow">and</span> <span class="n">kind</span> <span class="o">!=</span> <span class="n">at_section</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="c">#@+node:ekr.20031218072017.3518: *5* put_part_node</span>
    <span class="c"># This method outputs one part of a section definition.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_part_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_part_node">[docs]</a>    <span class="k">def</span> <span class="nf">put_part_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">no_first_lws_flag</span><span class="p">):</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">name</span> <span class="c"># can&#39;t use choose.</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&lt;NULL part&gt;&quot;</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">doc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_doc_flag</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_doc</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">:</span>
            <span class="c"># comment convention cannot change in the middle of a doc part</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_code</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="n">no_first_lws_flag</span><span class="p">,</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3519: *5* put_section</span>
    <span class="c">#@+at</span>
    <span class="c"># This method outputs the definition of a section and all sections</span>
    <span class="c"># referenced from the section. name is the section&#39;s name. This code</span>
    <span class="c"># checks for recursive definitions by calling section_check(). We can</span>
    <span class="c"># not allow section x to expand to code containing another call to</span>
    <span class="c"># section x, either directly or indirectly.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.put_section"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.put_section">[docs]</a>    <span class="k">def</span> <span class="nf">put_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">name_end</span><span class="p">,</span><span class="n">delims</span><span class="p">):</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="c"># g.trace(&quot;indent:&quot;,self.tangle_indent,s[i:j])</span>
        <span class="n">outer_old_indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span>
        <span class="n">trailing_ws_indent</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Set below.</span>
        <span class="n">inner_old_indent</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Set below.</span>
        <span class="n">newline_flag</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># True if the line ends with the reference.</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;@&lt;&quot;</span><span class="p">))</span>
        <span class="c">#@+&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3520: *6* &lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</span>
        <span class="c"># Find the start of the line containing the reference.</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>

        <span class="c"># Bump the indentation</span>
        <span class="n">j</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws_with_indent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">+=</span> <span class="n">width</span>
        <span class="c"># g.trace(&quot;leading ws,new indent:&quot;,width,self.tangle_indent)</span>

        <span class="c"># 4/27/01: Force no trailing whitespace in @silent mode.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">==</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span>
            <span class="n">trailing_ws_indent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trailing_ws_indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span>

        <span class="c"># Increase the indentation if the section reference does not immediately follow</span>
        <span class="c"># the leading white space.  4/3/01: Make no adjustment in @silent mode.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;&lt;&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Set &#39;newline_flag&#39; if the line ends with the reference &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3521: *6* &lt;&lt; Set &#39;newline_flag&#39; if the line ends with the reference &gt;&gt;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">name_end</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">newline_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
        <span class="c">#@-&lt;&lt; Set &#39;newline_flag&#39; if the line ends with the reference &gt;&gt;</span>
        <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">and</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
            <span class="c"># Expand the section only if we are not already expanding it.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_check</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="c">#@+&lt;&lt; put all parts of the section definition &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3522: *6* &lt;&lt;put all parts of the section definition&gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># This section outputs each part of a section definition. We first count</span>
                <span class="c"># how many parts there are so that the code can output a comment saying</span>
                <span class="c"># &#39;part x of y&#39;.</span>
                <span class="c">#@@c</span>

                <span class="c"># Output each part of the section.</span>
                <span class="n">sections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c"># In @silent mode, there is no sentinel line to &quot;use up&quot; the previously output</span>
                    <span class="c"># leading whitespace.  We set the flag to tell put_part_node and put_code</span>
                    <span class="c"># not to call put_newline at the start of the first code part of the definition.</span>
                    <span class="n">no_first_leading_ws_flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">==</span> <span class="s">&quot;silent&quot;</span><span class="p">)</span>
                    <span class="n">inner_old_indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span>
                    <span class="c"># 4/3/01: @silent inhibits newlines after section expansion.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span>
                        <span class="c">#@+&lt;&lt; Put the section name in a comment &gt;&gt;</span>
                        <span class="c">#@+node:ekr.20031218072017.3523: *7* &lt;&lt; Put the section name in a comment &gt;&gt;</span>
                        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>

                        <span class="c"># Don&#39;t print trailing whitespace</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                            <span class="c">#@+&lt;&lt; put (n of m) &gt;&gt;</span>
                            <span class="c">#@+node:ekr.20031218072017.3524: *8* &lt;&lt; put ( n of m ) &gt;&gt;</span>
                            <span class="k">if</span> <span class="n">sections</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;(</span><span class="si">%d</span><span class="s"> of </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="n">sections</span><span class="p">))</span>
                            <span class="c">#@-&lt;&lt; put (n of m) &gt;&gt;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">assert</span><span class="p">(</span>
                                <span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
                                <span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                            <span class="c">#@+&lt;&lt; put (n of m) &gt;&gt;</span>
                            <span class="c">#@+node:ekr.20031218072017.3524: *8* &lt;&lt; put ( n of m ) &gt;&gt;</span>
                            <span class="k">if</span> <span class="n">sections</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;(</span><span class="si">%d</span><span class="s"> of </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="n">sections</span><span class="p">))</span>
                            <span class="c">#@-&lt;&lt; put (n of m) &gt;&gt;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="c"># Always output a newline.</span>
                        <span class="c">#@-&lt;&lt; Put the section name in a comment &gt;&gt;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">put_part_node</span><span class="p">(</span><span class="n">part</span><span class="p">,</span><span class="n">no_first_leading_ws_flag</span><span class="p">)</span>
                    <span class="c"># 4/3/01: @silent inhibits newlines after section expansion.</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">sections</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;quiet&quot;</span><span class="p">):</span>
                        <span class="c">#@+&lt;&lt; Put the ending comment &gt;&gt;</span>
                        <span class="c">#@+node:ekr.20031218072017.3525: *7* &lt;&lt; Put the ending comment &gt;&gt;</span>
                        <span class="c">#@+at</span>
                        <span class="c"># We do not produce an ending comment unless we are ending the last part</span>
                        <span class="c"># of the section,and the comment is clearer if we don&#39;t say(n of m).</span>
                        <span class="c">#@@c</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>
                        <span class="c">#  Don&#39;t print trailing whitespace</span>
                        <span class="k">while</span> <span class="n">name_end</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">name_end</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="n">name_end</span> <span class="o">-=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;-- end -- &quot;</span><span class="p">)</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot;-- end -- &quot;</span><span class="p">)</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

                        <span class="c">#@+at The following code sets a flag for untangle.</span>
                        <span class="c"># </span>
                        <span class="c"># If something follows the section reference we must add a newline,</span>
                        <span class="c"># otherwise the &quot;something&quot; would become part of the comment. Any</span>
                        <span class="c"># whitespace following the (!newline) should follow the section</span>
                        <span class="c"># defintion when Untangled.</span>
                        <span class="c">#@@c</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">newline_flag</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot; (!newline)&quot;</span><span class="p">)</span> <span class="c"># LeoCB puts the leading blank, so we must do so too.</span>
                            <span class="c"># Put the whitespace following the reference.</span>
                            <span class="k">while</span> <span class="n">name_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">name_end</span><span class="p">]):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">name_end</span><span class="p">])</span>
                                <span class="n">name_end</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="c"># We must supply the newline!</span>
                        <span class="c">#@-&lt;&lt; Put the ending comment &gt;&gt;</span>
                    <span class="c"># Restore the old indent.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">=</span> <span class="n">inner_old_indent</span>
                <span class="c">#@-&lt;&lt; put all parts of the section definition &gt;&gt;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">section_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#@+&lt;&lt; Put a comment about the undefined section &gt;&gt;</span>
            <span class="c">#@+node:sps.20100621105534.16896: *6* &lt;&lt;Put a comment about the undefined section&gt;&gt;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot; undefined section: &quot;</span><span class="p">)</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="s">&quot; undefined section: &quot;</span><span class="p">)</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">oblank</span><span class="p">()</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">os</span><span class="p">(</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">onl</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Undefined section: &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt; Put a comment about the undefined section &gt;&gt;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newline_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">put_leading_ws</span><span class="p">(</span><span class="n">trailing_ws_indent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_indent</span> <span class="o">=</span> <span class="n">outer_old_indent</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">name_end</span>
    <span class="c">#@+node:ekr.20031218072017.3527: *5* section_check</span>
    <span class="c">#@+at</span>
    <span class="c"># We can not allow a section to be defined in terms of itself, either</span>
    <span class="c"># directly or indirectly.</span>
    <span class="c"># </span>
    <span class="c"># We push an entry on the section stack whenever beginning to expand a</span>
    <span class="c"># section and pop the section stack at the end of each section. This</span>
    <span class="c"># method checks whether the given name appears in the stack. If so, the</span>
    <span class="c"># section is defined in terms of itself.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.section_check"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.section_check">[docs]</a>    <span class="k">def</span> <span class="nf">section_check</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_stack</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Invalid recursive reference of &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">section_stack</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;called from: &quot;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="c">#@+node:ekr.20031218072017.3528: *3* tst</span>
    <span class="c">#@+node:ekr.20031218072017.3529: *4* st_check</span></div>
<div class="viewcode-block" id="baseTangleCommands.st_check"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_check">[docs]</a>    <span class="k">def</span> <span class="nf">st_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Checks the given symbol table for defined but never referenced sections.&quot;&quot;&quot;</span>

        <span class="c"># g.trace(keys)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">):</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">section</span><span class="o">.</span><span class="n">referenced</span><span class="p">:</span>
                <span class="n">lp</span> <span class="o">=</span> <span class="s">&quot;&lt;&lt; &quot;</span>
                <span class="n">rp</span> <span class="o">=</span> <span class="s">&quot; &gt;&gt;&quot;</span>
                <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span><span class="s">&#39;warning:&#39;</span><span class="p">,</span><span class="n">lp</span><span class="p">,</span><span class="n">section</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">rp</span><span class="p">,</span><span class="s">&#39;has been defined but not used.&#39;</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3530: *4* st_dump</span>
    <span class="c"># Dumps the given symbol table in a readable format.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.st_dump"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_dump">[docs]</a>    <span class="k">def</span> <span class="nf">st_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">dump of symbol table...</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">):</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose_flag</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_dump_node</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">theType</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;  &quot;</span><span class="p">,</span><span class="s">&quot;un&quot;</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">theType</span> <span class="o">+</span> <span class="s">&quot;defined:[&quot;</span> <span class="o">+</span> <span class="n">section</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">section delims: &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">delims</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="c">#@+node:ekr.20031218072017.3531: *4* st_dump_node</span>
    <span class="c"># Dumps each part of a section&#39;s definition.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.st_dump_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_dump_node">[docs]</a>    <span class="k">def</span> <span class="nf">st_dump_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">section</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">section</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>

    <span class="c">#@+node:ekr.20031218072017.3532: *4* st_enter</span>
    <span class="c"># The comment delimiters for the start sentinel are kept in the part;</span>
    <span class="c"># for the end sentinel, in the section</span></div>
<div class="viewcode-block" id="baseTangleCommands.st_enter"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_enter">[docs]</a>    <span class="k">def</span> <span class="nf">st_enter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">,</span><span class="n">delims_end</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Enters names and their associated code and doc parts into the given symbol table.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># debug</span>
            <span class="kn">import</span> <span class="nn">sys</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;name: </span><span class="si">%s</span><span class="s"> ======code</span><span class="se">\n</span><span class="si">%s</span><span class="s">======doc</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">doc</span><span class="p">))</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;caller: &quot;</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;caller&#39;s caller: &quot;</span><span class="o">+</span><span class="n">f</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>

        <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">is_root_flag</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="c"># remove trailing lines.</span>
        <span class="k">if</span> <span class="n">code</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">!=</span> <span class="s">&quot;silent&quot;</span><span class="p">:</span> <span class="c"># @silent supresses newline processing.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c"># remove leading lines.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> 
                <span class="k">if</span> <span class="n">code</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="c"># remove trailing lines.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangling</span> <span class="ow">and</span> <span class="n">code</span><span class="p">:</span>
            <span class="c">#@+&lt;&lt; check for duplicate code definitions &gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3533: *5* &lt;&lt;check for duplicate code definitions &gt;&gt;</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">code</span> <span class="o">==</span> <span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">angleBrackets</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&#39;warning: possible duplicate definition of:&#39;</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt; check for duplicate code definitions &gt;&gt;</span>
        <span class="k">if</span> <span class="n">code</span> <span class="ow">or</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">part_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">is_root_flag</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">)</span>
            <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
            <span class="n">section</span><span class="o">.</span><span class="n">delims</span> <span class="o">=</span> <span class="n">delims_end</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># A reference</span>
            <span class="n">section</span><span class="o">.</span><span class="n">referenced</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">is_root_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
            <span class="n">section</span><span class="o">.</span><span class="n">referenced</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># Mark the root as referenced.</span>
            <span class="c">#@+&lt;&lt;remember root node attributes&gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3534: *5* &lt;&lt;remember root node attributes&gt;&gt;</span>
            <span class="c"># Stephen Schaefer, 9/2/02</span>
            <span class="c"># remember the language and comment characteristics</span>
            <span class="n">section</span><span class="o">.</span><span class="n">root_attributes</span> <span class="o">=</span> <span class="n">root_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt;remember root node attributes&gt;&gt;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span> <span class="c"># part number</span>
    <span class="c">#@+node:ekr.20031218072017.3535: *4* st_enter_root_name</span>
    <span class="c"># Enters a root name into the given symbol table.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.st_enter_root_name"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_enter_root_name">[docs]</a>    <span class="k">def</span> <span class="nf">st_enter_root_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">,</span><span class="n">delims_end</span><span class="p">):</span>

        <span class="c"># assert(code)</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span> <span class="c"># User errors can result in an empty @root name.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">st_enter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">,</span><span class="n">delims_end</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3536: *4* st_enter_section_name</span></div>
<div class="viewcode-block" id="baseTangleCommands.st_enter_section_name"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_enter_section_name">[docs]</a>    <span class="k">def</span> <span class="nf">st_enter_section_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">,</span><span class="n">delims_end</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Enters a section name into the given symbol table.</span>

<span class="sd">        The code and doc pointers are None for references.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_enter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">doc</span><span class="p">,</span><span class="n">delims_begin</span><span class="p">,</span><span class="n">delims_end</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3537: *4* st_lookup</span></div>
<div class="viewcode-block" id="baseTangleCommands.st_lookup"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.st_lookup">[docs]</a>    <span class="k">def</span> <span class="nf">st_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Looks up name in the symbol table and creates a tst_node for it if it does not exist.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_root_flag</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c"># g.trace(&quot;found:&quot; + key)</span>
            <span class="k">return</span> <span class="n">section</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># g.trace(&quot;not found:&quot; + key)</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">tst_node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">is_root_flag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">section</span>
            <span class="k">return</span> <span class="n">section</span>
    <span class="c">#@+node:ekr.20031218072017.3538: *3* ust</span>
    <span class="c">#@+node:ekr.20031218072017.3539: *4* ust_dump</span></div>
<div class="viewcode-block" id="baseTangleCommands.ust_dump"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.ust_dump">[docs]</a>    <span class="k">def</span> <span class="nf">ust_dump</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">---------- Untangle Symbol Table ----------&quot;</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">):</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">section</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">--------------------&quot;</span>

        <span class="k">return</span> <span class="n">s</span>
    <span class="c">#@+node:ekr.20031218072017.3540: *4* ust_enter</span>
    <span class="c">#@+at</span>
    <span class="c"># This routine enters names and their code parts into the given table.</span>
    <span class="c"># The &#39;part&#39; and &#39;of&#39; parameters are taken from the &quot;(part n of m)&quot;</span>
    <span class="c"># portion of the line that introduces the section definition in the C</span>
    <span class="c"># code.</span>
    <span class="c"># </span>
    <span class="c"># If no part numbers are given the caller should set the &#39;part&#39; and &#39;of&#39;</span>
    <span class="c"># parameters to zero. The caller is reponsible for checking for</span>
    <span class="c"># duplicate parts.</span>
    <span class="c"># </span>
    <span class="c"># This function handles names scanned from a source file; the</span>
    <span class="c"># corresponding st_enter routine handles names scanned from outlines.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.ust_enter"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.ust_enter">[docs]</a>    <span class="k">def</span> <span class="nf">ust_enter</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_root_flag</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c">#@+&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3541: *5* &lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

        <span class="c">#@-&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">ust_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span> <span class="c"># update_flag</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="o">=</span><span class="n">u</span> <span class="c"># Parts may be defined in any order.</span>
        <span class="c"># g.trace(&quot;section [%s](part %d of %d)...&lt;code&gt;%s&lt;/code&gt;&quot; % (name,part,of,code))</span>
    <span class="c">#@+node:ekr.20031218072017.3542: *4* ust_lookup</span>
    <span class="c"># Searches the given table for a part matching the name and part number.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.ust_lookup"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.ust_lookup">[docs]</a>    <span class="k">def</span> <span class="nf">ust_lookup</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part_number</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">update_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="c"># g.trace(name,part_number,is_root_flag)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_root_flag</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">part_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">part_number</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># A hack: zero indicates the first part.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="c"># g.trace(&quot;section dump: %s&quot; % section.dump())</span>
            <span class="k">if</span> <span class="n">part_number</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part_number</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">update_flag</span><span class="p">:</span> <span class="n">part</span><span class="o">.</span><span class="n">update_flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c"># g.trace(&quot;update_flag: %s part.update_flag: %s found: %s(%d)(%s):%s...\n&quot; % (repr(update_flag),repr(part.update_flag),name,part_number,repr(part.part),part.code))</span>
                <span class="k">return</span> <span class="n">part</span><span class="p">,</span> <span class="bp">True</span>

        <span class="c"># g.trace(&quot;not found: %s(%d)...\n&quot; % (name,part_number))</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>
    <span class="c">#@+node:ekr.20031218072017.3543: *4* ust_warn_about_orphans</span></div>
<div class="viewcode-block" id="baseTangleCommands.ust_warn_about_orphans"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.ust_warn_about_orphans">[docs]</a>    <span class="k">def</span> <span class="nf">ust_warn_about_orphans</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Issues a warning about any sections in the derived file for which</span>
<span class="sd">        no corresponding section has been seen in the outline.&quot;&quot;&quot;</span>

        <span class="c"># g.trace(self.ust_dump())</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c"># g.trace(section)</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">of</span> <span class="o">==</span> <span class="n">section</span><span class="o">.</span><span class="n">of</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">part</span><span class="o">.</span><span class="n">update_flag</span><span class="p">:</span>
                    <span class="c"># lp = &quot;&lt;&lt; &quot;</span>
                    <span class="c"># rp = &quot; &gt;&gt;&quot;</span>
                    <span class="c"># g.es(&quot;warning:&quot;,&#39;%s%s(%s)%s&#39; % (lp,part.name,part.part,rp),</span>
                      <span class="c"># &quot;is not in the outline&quot;)</span>
                    <span class="k">break</span> <span class="c"># One warning per section is enough.</span>
    <span class="c">#@+node:ekr.20031218072017.3544: *3* untangle</span>
    <span class="c">#@+node:ekr.20031218072017.3545: *4* compare_comments</span>
    <span class="c">#@+at</span>
    <span class="c"># This function compares the interior of comments and returns True if</span>
    <span class="c"># they are identical except for whitespace or newlines. It is up to the</span>
    <span class="c"># caller to eliminate the opening and closing delimiters from the text</span>
    <span class="c"># to be compared.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.compare_comments"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.compare_comments">[docs]</a>    <span class="k">def</span> <span class="nf">compare_comments</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span>

        <span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span> <span class="n">tot_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">:</span> <span class="n">tot_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>

        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3546: *5* &lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># This code is used in forgiving_compare()and in compare_comments().</span>
                <span class="c"># </span>
                <span class="c"># In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.</span>
                <span class="c"># We must be careful not to run afoul of this very convention here!</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">+</span> <span class="s">&#39;@&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="n">tot_len</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">+</span> <span class="s">&#39;@&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="n">tot_len</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="c">#@-&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
            <span class="k">if</span> <span class="n">p1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">p2</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3547: *4* massage_block_comment (no longer used)</span>
    <span class="c">#@+at</span>
    <span class="c"># This function is called to massage an @doc part in the ust. We call</span>
    <span class="c"># this routine only after a mismatch in @doc parts is found between the</span>
    <span class="c"># ust and tst. On entry, the parameters point to the inside of a block C</span>
    <span class="c"># comment: the opening and closing delimiters are not part of the text</span>
    <span class="c"># handled by self routine.</span>
    <span class="c"># </span>
    <span class="c"># This code removes newlines that may have been inserted by the Tangle</span>
    <span class="c"># command in a block comment. Tangle may break lines differently in</span>
    <span class="c"># different expansions, but line breaks are ignored by</span>
    <span class="c"># forgiving_compare() and doc_compare() within block C comments.</span>
    <span class="c"># </span>
    <span class="c"># We count the leading whitespace from the first non-blank line and</span>
    <span class="c"># remove this much whitespace from all lines. We also remove singleton</span>
    <span class="c"># newlines and replace sequences of two or more newlines by a single</span>
    <span class="c"># newline.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.massage_block_comment"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.massage_block_comment">[docs]</a>    <span class="k">def</span> <span class="nf">massage_block_comment</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">newlines</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Consecutive newlines seen.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># Copy the first line and set n</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws_with_indent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
            <span class="n">newlines</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c"># Replace the first newline with a blank.</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># skip the newline.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="ow">and</span> <span class="n">newlines</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Skip blank lines.</span>
                <span class="k">while</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Skip the leading whitespace.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="c"># back track</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                <span class="n">newlines</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c"># Copy the rest of the line.</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c">#@+node:ekr.20031218072017.3548: *4* forgiving_compare</span>
    <span class="c">#@+at</span>
    <span class="c"># This is the &quot;forgiving compare&quot; function. It compares two texts and</span>
    <span class="c"># returns True if they are identical except for comments or non-critical</span>
    <span class="c"># whitespace. Whitespace inside strings or preprocessor directives must</span>
    <span class="c"># match exactly. @language and @comment in the outline version are</span>
    <span class="c"># ignored. s1 is the outline version, s2 is the external file version.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.forgiving_compare"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.forgiving_compare">[docs]</a>    <span class="k">def</span> <span class="nf">forgiving_compare</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="se">\n</span><span class="s">1:&quot;</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                <span class="s">&quot;</span><span class="se">\n</span><span class="s">2:&quot;</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toUnicode</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toUnicode</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="c">#@+&lt;&lt; Define forgiving_compare vars &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3549: *5* &lt;&lt; Define forgiving_compare vars &gt;&gt;</span>
        <span class="c"># scan_derived_file has set the ivars describing comment delims.</span>
        <span class="n">first1</span> <span class="o">=</span> <span class="n">first2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span> <span class="n">tot_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">:</span> <span class="n">tot_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Define forgiving_compare vars &gt;&gt;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> 
        <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
            <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3546: *5* &lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># This code is used in forgiving_compare()and in compare_comments().</span>
                <span class="c"># </span>
                <span class="c"># In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.</span>
                <span class="c"># We must be careful not to run afoul of this very convention here!</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">+</span> <span class="s">&#39;@&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="n">tot_len</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">+</span> <span class="s">&#39;@&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="n">tot_len</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">continue</span>
                <span class="c">#@-&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</span>
            <span class="n">ch1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span> <span class="ow">or</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Compare non-critical newlines &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3550: *5* &lt;&lt; Compare non-critical newlines &gt;&gt;</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; Compare non-critical newlines &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch1</span> <span class="o">==</span>  <span class="s">&#39; &#39;</span> <span class="ow">or</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Compare non-critical whitespace &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3551: *5* &lt;&lt; Compare non-critical whitespace &gt;&gt;</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; Compare non-critical whitespace &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\&#39;</span><span class="s">&#39;</span> <span class="ow">or</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;&quot;&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Compare possible strings &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3555: *5* &lt;&lt; Compare possible strings &gt;&gt;</span>
                <span class="c"># This code implicitly assumes that string1_len == string2_len == 1.</span>
                <span class="c"># The match test ensures that the language actually supports strings.</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">string1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">string2</span><span class="p">))</span> <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;pascal&quot;</span><span class="p">:</span>
                        <span class="c">#@+&lt;&lt; Compare Pascal strings &gt;&gt;</span>
                        <span class="c">#@+node:ekr.20031218072017.3557: *6* &lt;&lt; Compare Pascal strings &gt;&gt;</span>
                        <span class="c">#@+at</span>
                        <span class="c"># We assume the Pascal string is on a single line so the problems with</span>
                        <span class="c"># cr/lf do not concern us.</span>
                        <span class="c">#@@c</span>

                        <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_pascal_string</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_pascal_string</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">first1</span><span class="p">,</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">first2</span><span class="p">,</span><span class="n">p2</span><span class="p">]</span>
                        <span class="c">#@-&lt;&lt; Compare Pascal strings &gt;&gt;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c">#@+&lt;&lt; Compare C strings &gt;&gt;</span>
                        <span class="c">#@+node:ekr.20031218072017.3556: *6* &lt;&lt; Compare C strings &gt;&gt;</span>
                        <span class="n">delim</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">while</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">delim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_string</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">delim</span><span class="p">):</span>
                                <span class="n">result</span> <span class="o">=</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">==</span> <span class="n">delim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_string</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">delim</span><span class="p">))</span>
                                <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">break</span>
                            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
                                <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                                <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                                <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c">#@-&lt;&lt; Compare C strings &gt;&gt;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched strings&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3553: *6* &lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched single characters&quot;</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt; Compare single characters &gt;&gt;</span>
                <span class="c">#@-&lt;&lt; Compare possible strings &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;#&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Compare possible preprocessor directives &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3552: *5* &lt;&lt; Compare possible preprocessor directives &gt;&gt;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;c&quot;</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; compare preprocessor directives &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3554: *6* &lt;&lt; Compare preprocessor directives &gt;&gt;</span>
                    <span class="c"># We cannot assume that newlines are single characters.</span>

                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">result</span> <span class="ow">and</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">):</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_end_of_directive</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">):</span>
                                <span class="k">break</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                            <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                            <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched preprocessor directives&quot;</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt; compare preprocessor directives &gt;&gt;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; compare single characters &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3553: *6* &lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched single characters&quot;</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt; compare single characters &gt;&gt;</span>
                <span class="c">#@-&lt;&lt; Compare possible preprocessor directives &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
                <span class="c"># NB: support for derived noweb or CWEB file</span>
                <span class="c">#@+&lt;&lt; Compare possible section references &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3558: *5* &lt;&lt; Compare possible section references &gt;&gt;</span>
                <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>  <span class="n">start_ref</span> <span class="o">=</span> <span class="s">&quot;&lt;&lt;&quot;</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">start_ref</span> <span class="o">=</span> <span class="bp">None</span>

                <span class="c"># Tangling may insert newlines.</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="n">junk</span><span class="p">,</span> <span class="n">kind1</span><span class="p">,</span> <span class="n">junk2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_section_name</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                <span class="n">junk</span><span class="p">,</span> <span class="n">kind2</span><span class="p">,</span> <span class="n">junk2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_section_name</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">start_ref</span> <span class="ow">and</span> <span class="p">(</span><span class="n">kind1</span> <span class="o">!=</span> <span class="n">bad_section_name</span> <span class="ow">or</span> <span class="n">kind2</span> <span class="o">!=</span> <span class="n">bad_section_name</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_section_names</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">:],</span><span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">p1</span><span class="p">,</span> <span class="n">junk1</span><span class="p">,</span> <span class="n">junk2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">p2</span><span class="p">,</span> <span class="n">junk1</span><span class="p">,</span> <span class="n">junk2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched section names&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Neither p1 nor p2 points at a section name.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatch at &#39;@&#39; or &#39;&lt;&#39;&quot;</span><span class="p">)</span>
                <span class="c">#@-&lt;&lt; Compare possible section references &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">ch1</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Skip @language or @comment in outline &gt;&gt;</span>
                <span class="c">#@+node:sps.20100629094515.16518: *5* &lt;&lt; Skip @language or @comment in outline &gt;&gt;</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;language&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;comment&quot;</span><span class="p">):</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3553: *6* &lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched single characters&quot;</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt; Compare single characters &gt;&gt;</span>

                <span class="c">#@-&lt;&lt; Skip @language or @comment in outline &gt;&gt;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; Compare comments or single characters &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3559: *5* &lt;&lt; Compare comments or single characters &gt;&gt;</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">):</span>
                    <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_comments</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">first1</span><span class="p">:</span><span class="n">p1</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="n">first2</span><span class="p">:</span><span class="n">p2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched sentinel comments&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">):</span>
                    <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_comments</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">first1</span><span class="p">:</span><span class="n">p1</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="n">first2</span><span class="p">:</span><span class="n">p2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched single-line comments&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">):</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)):</span>
                        <span class="c"># ws doesn&#39;t have to match exactly either!</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span><span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]):</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span><span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]):</span>
                            <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_comments</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">first1</span><span class="p">:</span><span class="n">p1</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="n">first2</span><span class="p">:</span><span class="n">p2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched block comments&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">):</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">)):</span>
                        <span class="c"># ws doesn&#39;t have to match exactly either!</span>
                        <span class="k">if</span>  <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span><span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]):</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span><span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]):</span>
                            <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">):</span>
                        <span class="n">first1</span> <span class="o">=</span> <span class="n">p1</span> <span class="p">;</span> <span class="n">first2</span> <span class="o">=</span> <span class="n">p2</span>
                        <span class="n">p1</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">)</span>
                        <span class="n">p2</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2_end</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_comments</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">first1</span><span class="p">:</span><span class="n">p1</span><span class="p">],</span><span class="n">s2</span><span class="p">[</span><span class="n">first2</span><span class="p">:</span><span class="n">p2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched alternate block comments&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#@+&lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="c">#@+node:ekr.20031218072017.3553: *6* &lt;&lt; Compare single characters &gt;&gt;</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">p1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
                    <span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;Mismatched single characters&quot;</span><span class="p">)</span>
                    <span class="c">#@-&lt;&lt; Compare single characters &gt;&gt;</span>
                <span class="c">#@-&lt;&lt; Compare comments or single characters &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Make sure both parts have ended &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3560: *5* &lt;&lt; Make sure both parts have ended &gt;&gt;</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws_and_nl</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p2</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="c"># Show the ends of both parts.</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">(</span><span class="s">&quot;One part ends before the other.&quot;</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Make sure both parts have ended &gt;&gt;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="c">#@+&lt;&lt; trace the mismatch &gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3561: *5* &lt;&lt; Trace the mismatch &gt;&gt;</span>
            <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span>
                    <span class="s">&quot;</span><span class="se">\n</span><span class="s">Part &quot;</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="s">&quot; section &quot;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span>
                    <span class="s">&quot;</span><span class="se">\n</span><span class="s">1:&quot;</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">p1</span><span class="p">),</span>
                    <span class="s">&quot;</span><span class="se">\n</span><span class="s">2:&quot;</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">p2</span><span class="p">))</span>
            <span class="c">#@-&lt;&lt; trace the mismatch &gt;&gt;</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="c">#@+node:ekr.20031218072017.3562: *4* mismatch</span></div>
<div class="viewcode-block" id="baseTangleCommands.mismatch"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.mismatch">[docs]</a>    <span class="k">def</span> <span class="nf">mismatch</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">message</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
    <span class="c">#@+node:ekr.20031218072017.3563: *4* scan_derived_file (pass 2)</span>
    <span class="c">#@+at</span>
    <span class="c"># </span>
    <span class="c"># This function scans an entire derived file in s, discovering section or part</span>
    <span class="c"># definitions.</span>
    <span class="c"># </span>
    <span class="c"># This is the easiest place to delete leading whitespace from each line: we simply</span>
    <span class="c"># don&#39;t copy it. We also ignore leading blank lines and trailing blank lines. The</span>
    <span class="c"># resulting definition must compare equal using the &quot;forgiving&quot; compare to any</span>
    <span class="c"># other definitions of that section or part.</span>
    <span class="c"># </span>
    <span class="c"># We use a stack to handle nested expansions. The outermost level of expansion</span>
    <span class="c"># corresponds to the @root directive that created the file. When the stack is</span>
    <span class="c"># popped, the indent variable is restored.</span>
    <span class="c"># </span>
    <span class="c"># self.root_name is the name of the file mentioned in the @root directive.</span>
    <span class="c"># </span>
    <span class="c"># The caller has deleted all body_ignored_newlines from the text.</span>
    <span class="c">#@@c</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.scan_derived_file"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.scan_derived_file">[docs]</a>    <span class="k">def</span> <span class="nf">scan_derived_file</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>

        <span class="c"># g.trace(s)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#@+&lt;&lt; set the private global matching vars &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.2368: *5* &lt;&lt; set the private global matching vars &gt;&gt;</span>
        <span class="c"># Set defaults. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string1</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string2</span> <span class="o">=</span> <span class="s">&quot;&#39;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbatim</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Set special cases.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;plain&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string2</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># This is debatable.</span>

        <span class="c"># if you&#39;re not going to use { } for pascal comments, use</span>
        <span class="c"># @comment (* *)</span>
        <span class="c"># to specify the alternative</span>
        <span class="c">#if self.language == &quot;pascal&quot;:</span>
        <span class="c">#    self.comment2 = &quot;(*&quot; ; self.comment2_end = &quot;*)&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_next_sentinel</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;latex&quot;</span><span class="p">:</span> <span class="c"># 3/10/03: Joo-won Jung</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string2</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># This is debatable.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;html&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">string1</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">string2</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># 12/3/03</span>

        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;sentinel,line_comment,comment,string1,string2:&quot;</span><span class="p">,</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">),</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">),</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">),</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string1</span><span class="p">),</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string2</span><span class="p">))</span>
        <span class="c">#@-&lt;&lt; set the private global matching vars &gt;&gt;</span>
        <span class="n">line_indent</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># The indentation to use if we see a section reference.</span>
        <span class="c"># indent is the leading whitespace to be deleted.</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">indent</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws_with_indent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
        <span class="c">#@+&lt;&lt; Skip the header line output by tangle &gt;&gt;</span>
        <span class="c">#@+node:sps.20100622084732.12299: *5* &lt;&lt; Skip the header line output by tangle &gt;&gt;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; Created by Leo from&quot;</span> 
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">line</span><span class="p">):</span>
                <span class="c"># Even a block comment will end on the first line.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Skip the header line output by tangle &gt;&gt;</span>
        <span class="c"># The top level of the stack represents the root.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_new_def_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">eol</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">g</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;i: </span><span class="si">%s</span><span class="s"> sentinel: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">eol</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">))</span>        
            <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># ignore</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
                <span class="c">#@+&lt;&lt; handle the start of a new line &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3565: *5* &lt;&lt; handle the start of a new line &gt;&gt;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># This works because we have one-character newlines.</span>
                <span class="c"># g.trace(&quot;handle start of new line: &quot;+g.get_line(s,i))</span>

                <span class="c"># Set line_indent, used only if we see a section reference.</span>
                <span class="n">junk</span><span class="p">,</span> <span class="n">line_indent</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws_with_indent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_leading_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="c"># skip indent leading white space.</span>
                <span class="c">#@-&lt;&lt; handle the start of a new line &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sentinel_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                <span class="c">#@+&lt;&lt; handle a sentinel line  &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3566: *5* &lt;&lt; handle a sentinel line &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># This is the place to eliminate the proper amount of whitespace from</span>
                <span class="c"># the start of each line. We do this by setting the &#39;indent&#39; variable to</span>
                <span class="c"># the leading whitespace of the first _non-blank_ line following the</span>
                <span class="c"># opening sentinel.</span>
                <span class="c"># </span>
                <span class="c"># Tangle increases the indentation by one tab if the section reference</span>
                <span class="c"># is not the first non-whitespace item on the line,so self code must do</span>
                <span class="c"># the same.</span>
                <span class="c">#@@c</span>

                <span class="c"># g.trace(&quot;handle sentinel line: &quot;+g.get_line(s,i))</span>
                <span class="n">result</span><span class="p">,</span><span class="n">junk</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">nl_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sentinel_line_with_data</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="c"># g.trace(&quot;kind %s name %s&quot; % (repr(kind),repr(name)))</span>
                <span class="c"># g.trace(repr(self.def_stack))</span>
                <span class="c"># g.trace(repr(self.refpart_stack_dump()))</span>
                <span class="c">#@+&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3567: *6* &lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</span>
                <span class="c">#@+at</span>
                <span class="c"># We have just seen a sentinel line. Any kind of sentinel line will</span>
                <span class="c"># terminate a previous part of the present definition. For end sentinel</span>
                <span class="c"># lines, the present section name must match the name on the top of the</span>
                <span class="c"># stack.</span>
                <span class="c">#@@c</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_section_names</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                        <span class="n">dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dn</span><span class="o">.</span><span class="n">code</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">thePart</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">part</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span> <span class="c"># not root, not update</span>
                            <span class="c"># Check for incompatible previous definition.</span>
                            <span class="k">if</span> <span class="n">found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">forgiving_compare</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">part</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="n">thePart</span><span class="o">.</span><span class="n">code</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Incompatible definitions of &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">ust_enter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">part</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">of</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">nl_flag</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span> <span class="c"># not root</span>
                    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">end_sentinel_line</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Missing sentinel line for </span><span class="si">%s</span><span class="s"> found end </span><span class="si">%s</span><span class="s"> instead&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="c">#@-&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</span>

                <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">start_sentinel_line</span><span class="p">:</span>
                    <span class="n">indent</span> <span class="o">=</span> <span class="n">line_indent</span>
                    <span class="c"># Increase line_indent by one tab width if the</span>
                    <span class="c"># the section reference does not start the line.</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                            <span class="n">indent</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">)</span> <span class="p">;</span> <span class="k">break</span>
                        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="c"># copy the section reference to the _present_ section,</span>
                    <span class="c"># but only if this is the first part of the section.</span>
                    <span class="k">if</span> <span class="n">part</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="c"># Skip to the first character of the new section definition.</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="c"># Start the new section.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_new_def_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">select_next_sentinel</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">end_sentinel_line</span><span class="p">)</span>
                    <span class="c"># Skip the sentinel line.</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="c"># Skip a newline only if it was added after(!newline)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">nl_flag</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                        <span class="c"># Copy any whitespace following the (!newline)</span>
                        <span class="k">while</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
                            <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c"># Restore the old indentation level.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indent</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">select_next_sentinel</span><span class="p">(</span><span class="n">part_start_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                <span class="c"># g.trace(repr(self.def_stack))</span>
                <span class="c"># g.trace(repr(self.refpart_stack_dump()))</span>
                <span class="c">#@-&lt;&lt; handle a sentinel line  &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">verbatim</span><span class="p">):</span>
                <span class="c">#@+&lt;&lt; copy the entire line &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3568: *5* &lt;&lt; copy the entire line &gt;&gt;</span>
                <span class="c"># g.trace(&quot;copy the entire line:&quot;+g.get_line(s,i))</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="c">#@-&lt;&lt; copy the entire line &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">):</span>
                <span class="c">#@+&lt;&lt; copy a multi-line comment &gt;&gt;</span>
                <span class="c">#@+node:sps.20100622084732.12308: *5* &lt;&lt; copy a multi-line comment &gt;&gt;</span>
                <span class="c"># g.trace(&quot;copy a multiline comment:&quot;+g.get_line(s,i))</span>
                <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>

                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
                    <span class="c"># g.trace(&quot;sentinel == comment: &quot;+self.sentinel)</span>
                    <span class="c"># Scan for the ending delimiter.</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># g.trace(&quot;sentinel != comment: &lt;%s&gt; &lt;%s&gt;&quot; % (self.sentinel, self.comment))</span>
                    <span class="c"># Copy line by line, looking for a sentinel within the</span>
                    <span class="c"># comment</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">):</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sentinel_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="c">#@-&lt;&lt; copy a multi-line comment &gt;&gt;</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">string1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">string2</span><span class="p">):</span>
                <span class="c">#@+&lt;&lt; copy a string &gt;&gt;</span>
                <span class="c">#@+node:ekr.20031218072017.3569: *5* &lt;&lt; copy a string &gt;&gt;</span>
                <span class="c"># g.trace(&quot;copy a string:&quot;+g.get_line(s,i))</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">==</span> <span class="s">&quot;pascal&quot;</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_pascal_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="c">#@-&lt;&lt; copy a string &gt;&gt;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c">#@+&lt;&lt; end all open sections &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3572: *5* &lt;&lt; end all open sections &gt;&gt;</span>
        <span class="c"># g.trace(&quot;end all open sections&quot;)</span>
        <span class="n">dn</span><span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Unterminated section: &quot;</span> <span class="o">+</span> <span class="n">dn</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dn</span><span class="p">:</span>
            <span class="c"># Terminate the root setcion.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dn</span><span class="o">.</span><span class="n">code</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dn</span><span class="o">.</span><span class="n">code</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ust_enter</span><span class="p">(</span><span class="n">dn</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">part</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">of</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="n">dn</span><span class="o">.</span><span class="n">nl_flag</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Missing root part&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Missing root section&quot;</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; end all open sections &gt;&gt;</span>
    <span class="c">#@+node:sps.20100623125751.16367: *4* select_next_sentinel</span>
    <span class="c"># The next sentinel will be either</span>
    <span class="c"># (a) a section part reference, using the &quot;before&quot; comment style for that part</span>
    <span class="c"># - when there are section references yet to interpolate for this part</span>
    <span class="c"># - when we&#39;re followed by another part for this section</span>
    <span class="c"># (b) an end sentinel using the &quot;after&quot; comment style for the current part</span>
    <span class="c"># - when we&#39;ve exhausted the parts for this section</span>
    <span class="c"># or (c) end of file for the root section</span>
    <span class="c"># The above requires that the parts in the tst be aware of the section</span>
    <span class="c"># interpolations each part will make</span></div>
<div class="viewcode-block" id="baseTangleCommands.select_next_sentinel"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.select_next_sentinel">[docs]</a>    <span class="k">def</span> <span class="nf">select_next_sentinel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part_start_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c"># g.trace(self.st_dump())</span>

        <span class="c"># keep a &quot;private&quot; copy of the tst table so that it doesn&#39;t get</span>
        <span class="c"># corrupted by a subsequent tanglePass1 run</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">delims_table</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">delims_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span>
            <span class="n">restore_tst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">restore_tst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tst</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delims_table</span>

        <span class="c"># g.trace(self.refpart_stack_dump())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span> <span class="o">==</span> <span class="p">[]:</span>

            <span class="c"># beginning a new file</span>
            <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">section</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">tst_node</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="c"># references to sections within the part were noted by tanglePass1</span>
            <span class="n">root_part</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">root_part</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">part_node</span>
            <span class="n">reflist</span> <span class="o">=</span> <span class="n">root_part</span><span class="o">.</span><span class="n">reflist</span><span class="p">()</span>
            <span class="c">#@+&lt;&lt; push each part for each reference expected &gt;&gt;</span>
            <span class="c">#@+node:sps.20100623125751.16368: *5* &lt;&lt; push each part for each reference expected &gt;&gt;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflist</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reflist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c"># g.trace(&quot;section i:&quot;,i)</span>
                    <span class="c"># push each part start delims for each reference expected</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">reflist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c"># cope with undefined sections</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
                    <span class="c"># g.trace(&quot;parts in section i:&quot;,count)</span>
                    <span class="k">if</span> <span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c"># push the section for the end sentinel</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="c">#@-&lt;&lt; push each part for each reference expected &gt;&gt;</span>
            <span class="c"># set the delimiters for the root section</span>
            <span class="n">delims</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># we&#39;ve just matched a sentinel</span>
            <span class="k">if</span> <span class="n">part_start_flag</span><span class="p">:</span>
                <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">part</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">part_node</span><span class="p">,</span> <span class="s">&quot;expected type part_node, got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
                <span class="n">reflist</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">reflist</span><span class="p">()</span>
                <span class="c">#@+&lt;&lt; push each part for each reference expected &gt;&gt;</span>
                <span class="c">#@+node:sps.20100623125751.16368: *5* &lt;&lt; push each part for each reference expected &gt;&gt;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reflist</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reflist</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c"># g.trace(&quot;section i:&quot;,i)</span>
                        <span class="c"># push each part start delims for each reference expected</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">reflist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="c"># cope with undefined sections</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
                        <span class="c"># g.trace(&quot;parts in section i:&quot;,count)</span>
                        <span class="k">if</span> <span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="c"># push the section for the end sentinel</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="c">#@-&lt;&lt; push each part for each reference expected &gt;&gt;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">tst_node</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">st_lookup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_name</span><span class="p">)</span>
                <span class="n">delims</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">delims</span>

        <span class="k">if</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sentinel_end</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line_comment</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sentinel_end</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c"># g.trace(&quot;looking for %s with sentinel start %s&quot; % (repr(self.refpart_stack[-1]),self.sentinel))</span>

        <span class="c"># don&#39;t change multiline comment until after a comment convention transition is finished</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comment_end</span> <span class="o">=</span> <span class="n">delims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c"># g.trace(self.refpart_stack_dump())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tst</span> <span class="o">=</span> <span class="n">restore_tst</span>
    <span class="c">#@+node:ekr.20031218072017.3573: *4* update_def (pass 2)</span>
    <span class="c">#@+at</span>
    <span class="c"># This function handles the actual updating of section definitions in the web.</span>
    <span class="c"># Only code parts are updated, never doc parts.</span>
    <span class="c"># </span>
    <span class="c"># During pass 2 of Untangle, skip_body() calls this routine when it discovers the</span>
    <span class="c"># definition of a section in the outline. We look up the name in the ust. If an</span>
    <span class="c"># entry exists, we compare the code (the code part of an outline node) with the</span>
    <span class="c"># code part in the ust. We update the code part if necessary.</span>
    <span class="c"># </span>
    <span class="c"># We use the forgiving_compare() to compare code parts. It&#39;s not possible to</span>
    <span class="c"># change only trivial whitespace using Untangle because forgiving_compare()</span>
    <span class="c"># ignores trivial whitespace.</span>
    <span class="c">#@@c</span>

    <span class="c"># Major change: 2/23/01: Untangle never updates doc parts.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.update_def"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.update_def">[docs]</a>    <span class="k">def</span> <span class="nf">update_def</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part_number</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">tail</span><span class="p">,</span><span class="n">is_root_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span> <span class="c"># Doc parts are never updated!</span>

        <span class="c"># g.trace(name,part_number,&quot;===head===\n%s\n===code===\n%s\n===tail===\n%s\n===&quot;%(head,code,tail))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="p">;</span> <span class="n">body</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">b</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span> <span class="n">head</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tail</span><span class="p">:</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">code</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">false_ret</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">code</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="bp">False</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ust_lookup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">part_number</span><span class="p">,</span><span class="n">is_root_flag</span><span class="p">,</span><span class="n">update_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="c"># g.trace(&quot;not found: name &lt;%s&gt; part_number &lt;%s&gt; is_root_flag &lt;%s&gt;&quot; % (name, repr(part_number), repr(is_root_flag)))</span>
            <span class="k">return</span> <span class="n">false_ret</span>  <span class="c"># Not an error.</span>
        <span class="n">ucode</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">toUnicode</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">code</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="c">#@+&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3574: *5* &lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</span>
        <span class="c">#@+at</span>
        <span class="c"># We formerly assumed that any leading comments came from an @doc part, which might</span>
        <span class="c"># be the case if self.output_doc_flag were true.  For now, we treat leading comments</span>
        <span class="c"># as &quot;code&quot;.</span>
        <span class="c"># </span>
        <span class="c"># Elsewhere in the code is a comment that &quot;we never update doc parts&quot; when untangling.</span>
        <span class="c"># </span>
        <span class="c"># Needs to be dealt with.</span>
        <span class="c">#@@c</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_blank_lines</span><span class="p">(</span><span class="n">ucode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#j = g.skip_ws(ucode,i)</span>
        <span class="c"># g.trace(&quot;comment,end,single:&quot;,self.comment,self.comment_end,self.line_comment)</span>

        <span class="c">#@+at</span>
        <span class="c"># if self.comment and self.comment_end:</span>
        <span class="c">#     if ucode and g.match(ucode,j,self.comment):</span>
        <span class="c">#         # Skip to the end of the block comment.</span>
        <span class="c">#         i = j + len(self.comment)</span>
        <span class="c">#         i = ucode.find(self.comment_end,i)</span>
        <span class="c">#         if i == -1: ucode = None # An unreported problem in the user code.</span>
        <span class="c">#         else:</span>
        <span class="c">#             i += len(self.comment_end)</span>
        <span class="c">#             i = g.skip_blank_lines(ucode,i)</span>
        <span class="c"># elif self.line_comment:</span>
        <span class="c">#     while ucode and g.match(ucode,j,self.line_comment):</span>
        <span class="c">#         i = g.skip_line(ucode,i)</span>
        <span class="c">#         i = g.skip_blank_lines(ucode,i)</span>
        <span class="c">#         j = g.skip_ws(ucode,i)</span>
        <span class="c"># # Only the value of ucode matters here.</span>
        <span class="c">#@@c</span>
        <span class="k">if</span> <span class="n">ucode</span><span class="p">:</span> <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="c">#@-&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</span>
        <span class="c"># g.trace(ucode)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ucode</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">false_ret</span> <span class="c"># Not an error.</span>
        <span class="k">if</span> <span class="n">code</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">forgiving_compare</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">ucode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">false_ret</span> <span class="c"># Not an error.</span>
        <span class="c"># Update the body.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">unitTesting</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">(</span><span class="s">&quot;***Updating:&quot;</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c">#@+&lt;&lt; Add the trailing whitespace of code to ucode. &gt;&gt;</span>
        <span class="c">#@+node:sps.20100629094515.20939: *5* &lt;&lt; Add the trailing whitespace of code to ucode. &gt;&gt;</span>
        <span class="n">code2</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="n">trail_ws</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">code2</span><span class="p">):]</span>
        <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">trail_ws</span>
        <span class="c">#@-&lt;&lt; Add the trailing whitespace of code to ucode. &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Move any @language or @comment from code to ucode &gt;&gt;</span>
        <span class="c">#@+node:sps.20100629094515.20940: *5* &lt;&lt; Move any @language or @comment from code to ucode &gt;&gt;</span>
        <span class="c"># split the code into lines, collecting the @language and @comment lines specially</span>
        <span class="c"># if @language or @comment are present, they get added at the end</span>
        <span class="k">if</span> <span class="n">code</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
            <span class="n">leading_newline</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="n">trailing_newline</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leading_newline</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="n">trailing_newline</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegexpForLanguageOrComment</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
        <span class="c"># g.trace(repr(m.groupdict()))</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">):</span>
            <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">leading_newline</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)):</span>
                <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">)</span>
            <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">trailing_newline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">):</span>
                <span class="n">ucode</span> <span class="o">=</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">leading_newline</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">trailing_newline</span>
        <span class="c">#@-&lt;&lt; Move any @language or @comment from code to ucode &gt;&gt;</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="n">ucode</span> <span class="o">+</span> <span class="n">tail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_current_vnode</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="c"># g.trace(&quot;\nhead:&quot;,head,&quot;\nucode:&quot;ucode,&quot;\ntail:&quot;,tail)</span>
        <span class="k">return</span> <span class="n">body</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ucode</span><span class="p">),</span><span class="bp">True</span>
    <span class="c">#@+node:ekr.20031218072017.3575: *4* update_current_vnode</span></div>
<div class="viewcode-block" id="baseTangleCommands.update_current_vnode"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.update_current_vnode">[docs]</a>    <span class="k">def</span> <span class="nf">update_current_vnode</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Called from within the Untangle logic to update the body text of self.p.&quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">setBodyString</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

        <span class="n">c</span><span class="o">.</span><span class="n">setChanged</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">setDirty</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">setMarked</span><span class="p">()</span>

        <span class="c"># 2010/02/02: was update_after_icons_changed.</span>
        <span class="n">c</span><span class="o">.</span><span class="n">redraw_after_icons_changed</span><span class="p">()</span>
    <span class="c">#@+node:ekr.20031218072017.3576: *3* utility methods</span>
    <span class="c">#@+at These utilities deal with tangle ivars, so they should be methods.</span>
    <span class="c">#@+node:sps.20100623164631.12028: *4* refpart_stack_dump</span></div>
<div class="viewcode-block" id="baseTangleCommands.refpart_stack_dump"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.refpart_stack_dump">[docs]</a>    <span class="k">def</span> <span class="nf">refpart_stack_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;top of stack:&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">part_node</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">node: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; delims: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">tst_node</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">section: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; delims: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delims</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">INVALID ENTRY of type &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refpart_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">bottom of stack.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="c">#@+node:ekr.20031218072017.3577: *4* compare_section_names</span>
    <span class="c"># Compares section names or root names.</span>
    <span class="c"># Arbitrary text may follow the section name on the same line.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.compare_section_names"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.compare_section_names">[docs]</a>    <span class="k">def</span> <span class="nf">compare_section_names</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span>

        <span class="c"># g.trace(g.get_line(s1,0),&#39;:&#39;,g.get_line(s2,0))</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;@&lt;&quot;</span><span class="p">):</span>
            <span class="c"># Use a forgiving compare of the two section names.</span>
            <span class="n">delim</span> <span class="o">=</span> <span class="s">&quot;&gt;&gt;&quot;</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
                <span class="n">ch1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="p">;</span> <span class="n">ch2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">ch1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws</span><span class="p">(</span><span class="n">ch2</span><span class="p">):</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="n">delim</span><span class="p">)</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="n">delim</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">ch1</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">ch2</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># A root name.</span>
            <span class="k">return</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>
    <span class="c">#@+node:ekr.20031218072017.3578: *4* copy</span></div>
<div class="viewcode-block" id="baseTangleCommands.copy"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>

        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c"># dn = self.def_stack[-1] # Add the code at the top of the stack.</span>
        <span class="c"># dn.code += s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">code</span> <span class="o">+=</span> <span class="n">s</span>
            <span class="c"># Add the code at the top of the stack.</span>
            <span class="c"># pyflakes has trouble with the commented-out code.</span>
    <span class="c">#@+node:ekr.20031218072017.3579: *4* error, pathError, warning</span></div>
<div class="viewcode-block" id="baseTangleCommands.error"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es_error</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">translateString</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.pathError"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.pathError">[docs]</a>    <span class="k">def</span> <span class="nf">pathError</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_warning_given</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.warning"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.warning">[docs]</a>    <span class="k">def</span> <span class="nf">warning</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es_error</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">translateString</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="c">#@+node:ekr.20031218072017.3580: *4* is_end_of_directive</span>
    <span class="c"># This function returns True if we are at the end of preprocessor directive.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.is_end_of_directive"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_end_of_directive">[docs]</a>    <span class="k">def</span> <span class="nf">is_end_of_directive</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_escaped</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3581: *4* is_end_of_string</span></div>
<div class="viewcode-block" id="baseTangleCommands.is_end_of_string"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_end_of_string">[docs]</a>    <span class="k">def</span> <span class="nf">is_end_of_string</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delim</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">delim</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_escaped</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3582: *4* is_escaped</span>
    <span class="c"># This function returns True if the s[i] is preceded by an odd number of back slashes.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.is_escaped"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_escaped">[docs]</a>    <span class="k">def</span> <span class="nf">is_escaped</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="n">back_slashes</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">:</span>
            <span class="n">back_slashes</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">back_slashes</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="c">#@+node:ekr.20031218072017.3583: *4* is_section_name</span></div>
<div class="viewcode-block" id="baseTangleCommands.is_section_name"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_section_name">[docs]</a>    <span class="k">def</span> <span class="nf">is_section_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="n">kind</span> <span class="o">=</span> <span class="n">bad_section_name</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="c"># g.trace(kind,g.get_line(s,end))</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span>
    <span class="c">#@+node:ekr.20031218072017.3584: *4* is_sentinel_line &amp; is_sentinel_line_with_data</span>
    <span class="c">#@+at</span>
    <span class="c"># This function returns True if i points to a line a sentinel line of</span>
    <span class="c"># one of the following forms:</span>
    <span class="c"># </span>
    <span class="c"># start_sentinel &lt;&lt;section name&gt;&gt; end_sentinel</span>
    <span class="c"># start_sentinel &lt;&lt;section name&gt;&gt; (n of m) end_sentinel</span>
    <span class="c"># start_sentinel -- end -- &lt;&lt;section name&gt;&gt; end_sentinel</span>
    <span class="c"># start_sentinel -- end -- &lt;&lt;section name&gt;&gt; (n of m) end_sentinel</span>
    <span class="c"># </span>
    <span class="c"># start_sentinel: the string that signals the start of sentinel lines\</span>
    <span class="c"># end_sentinel:   the string that signals the endof sentinel lines.</span>
    <span class="c"># </span>
    <span class="c"># end_sentinel may be None,indicating that sentinel lines end with a newline.</span>
    <span class="c"># </span>
    <span class="c"># Any of these forms may end with (!newline), indicating that the</span>
    <span class="c"># section reference was not followed by a newline in the orignal text.</span>
    <span class="c"># We set nl_flag to False if such a string is seen. The name argument</span>
    <span class="c"># contains the section name.</span>
    <span class="c"># </span>
    <span class="c"># The valid values of kind param are:</span>
    <span class="c"># </span>
    <span class="c"># non_sentinel_line,   # not a sentinel line.</span>
    <span class="c"># start_sentinel_line, #   /// &lt;section name&gt; or /// &lt;section name&gt;(n of m)</span>
    <span class="c"># end_sentinel_line  //  /// -- end -- &lt;section name&gt; or /// -- end -- &lt;section name&gt;(n of m).</span>
    <span class="c">#@@c</span></div>
<div class="viewcode-block" id="baseTangleCommands.is_sentinel_line"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_sentinel_line">[docs]</a>    <span class="k">def</span> <span class="nf">is_sentinel_line</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="n">result</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">nl_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sentinel_line_with_data</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.is_sentinel_line_with_data"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.is_sentinel_line_with_data">[docs]</a>    <span class="k">def</span> <span class="nf">is_sentinel_line_with_data</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="n">start_sentinel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel</span>
        <span class="n">end_sentinel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel_end</span>
        <span class="c"># g.trace(&quot;line: %s start: &lt;%s&gt; end: &lt;%s&gt;&quot; % (s[i:g.skip_to_end_of_line(s,i)],start_sentinel,end_sentinel))</span>
        <span class="c">#@+&lt;&lt; Initialize the return values &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3585: *5* &lt;&lt; Initialize the return values  &gt;&gt;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">of</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">non_sentinel_line</span>
        <span class="n">nl_flag</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">false_data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">)</span>
        <span class="c">#@-&lt;&lt; Initialize the return values &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3586: *5* &lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="c"># 4/18/00: We now require an exact match of the sentinel.</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">start_sentinel</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_sentinel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">false_data</span>
        <span class="c">#@-&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3587: *5* &lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</span>
        <span class="c"># If i points to &quot;-- end --&quot;, this code skips it and sets end_flag.</span>

        <span class="n">end_flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;--&quot;</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;end&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">false_data</span> <span class="c"># Not a valid sentinel line.</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;--&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">false_data</span> <span class="c"># Not a valid sentinel line.</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">end_flag</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c">#@-&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Make sure we have a section reference &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3588: *5* &lt;&lt; Make sure we have a section reference &gt;&gt;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">):</span>

            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="n">section_ref</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">false_data</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">false_data</span>
        <span class="c">#@-&lt;&lt; Make sure we have a section reference &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Set part and of if they exist &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3589: *5* &lt;&lt; Set part and of if they exist &gt;&gt;</span>
        <span class="c"># This code handles (m of n), if it exists.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;(&#39;</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_short_val</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">part</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="c"># back out of the scanning for the number.</span>
                <span class="n">part</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;of&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">false_data</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">of</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_short_val</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">of</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">false_data</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># Skip the paren and do _not_ return.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">false_data</span>
        <span class="c">#@-&lt;&lt; Set part and of if they exist &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Set nl_flag to False if !newline exists &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3590: *5* &lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;(!newline)&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">line</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">nl_flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c">#@-&lt;&lt; Set nl_flag to False if !newline exists &gt;&gt;</span>
        <span class="c">#@+&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3591: *5* &lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_sentinel</span><span class="p">:</span>
            <span class="c"># Make sure the line ends with the end sentinel.</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">end_sentinel</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_sentinel</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">false_data</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="c"># Show the start of the whitespace.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">false_data</span>
        <span class="c">#@-&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">end_flag</span><span class="p">,</span><span class="n">end_sentinel_line</span><span class="p">,</span><span class="n">start_sentinel_line</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">kind</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">nl_flag</span>
    <span class="c">#@+node:sps.20100625103124.16437: *4* parent_language_comment_settings</span>
    <span class="c"># side effect: sets the values within lang_dict</span>
    <span class="c"># *might* lower case c.target_language</span></div>
<div class="viewcode-block" id="baseTangleCommands.parent_language_comment_settings"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.parent_language_comment_settings">[docs]</a>    <span class="k">def</span> <span class="nf">parent_language_comment_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">lang_dict</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">hasParent</span><span class="p">():</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">h</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RegexpForLanguageOrComment</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">):</span>
                        <span class="n">lang</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_language</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lang</span>
                        <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span><span class="o">&gt;</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">)):</span>
                            <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_delims_from_string</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">))</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">):</span>
                        <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_delims_from_string</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]:</span>
                    <span class="c"># delims are already set, only set language</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">):</span>
                        <span class="n">lang</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_language</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">lang</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lang</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent_language_comment_settings</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">lang_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">target_language</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">target_language</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="n">lang</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_language</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">target_language</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;language&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lang</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]:</span>
                        <span class="n">lang_dict</span><span class="p">[</span><span class="s">&#39;delims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3592: *4* push_new_def_node</span>
    <span class="c"># This function pushes a new def_node on the top of the section stack.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.push_new_def_node"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.push_new_def_node">[docs]</a>    <span class="k">def</span> <span class="nf">push_new_def_node</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">):</span>

        <span class="c"># g.trace(name,part)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">def_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">indent</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">of</span><span class="p">,</span><span class="n">nl_flag</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">def_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="c">#@+node:ekr.20031218072017.3593: *4* scan_short_val</span>
    <span class="c"># This function scans a positive integer.</span>
    <span class="c"># returns (i,val), where val == -1 if there is an error.</span>
</div>
<div class="viewcode-block" id="baseTangleCommands.scan_short_val"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.scan_short_val">[docs]</a>    <span class="k">def</span> <span class="nf">scan_short_val</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>


        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
        <span class="c"># g.trace(s[j:i],val)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span>
    <span class="c">#@+node:ekr.20031218072017.3594: *4* setRootFromHeadline</span></div>
<div class="viewcode-block" id="baseTangleCommands.setRootFromHeadline"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.setRootFromHeadline">[docs]</a>    <span class="k">def</span> <span class="nf">setRootFromHeadline</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">h</span>

        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;@root&quot;</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">start_mode</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">scanAtRootOptions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="c"># Non-empty file name.</span>
                <span class="c"># self.root_name must be set later by token_type().</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="c"># implement headline @root (but create unit tests first):</span>
                <span class="c"># arguments: name, is_code, is_doc</span>
                <span class="c"># st_enter_root_name(self.root, False, False)</span>
    <span class="c">#@+node:ekr.20031218072017.1259: *4* setRootFromText</span>
    <span class="c">#@+at This code skips the file name used in @root directives.</span>
    <span class="c"># </span>
    <span class="c"># File names may be enclosed in &lt; and &gt; characters, or in double quotes.</span>
    <span class="c"># If a file name is not enclosed be these delimiters it continues until</span>
    <span class="c"># the next newline.</span>
    <span class="c">#@@c</span></div>
<div class="viewcode-block" id="baseTangleCommands.setRootFromText"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.setRootFromText">[docs]</a>    <span class="k">def</span> <span class="nf">setRootFromText</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="c"># g.trace(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">start_mode</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">scanAtRootOptions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span> <span class="n">i</span>
        <span class="c"># Allow &lt;&gt; or &quot;&quot; as delimiters, or a bare file name.</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">delim</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span>
        <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">delim</span> <span class="o">=</span> <span class="s">&#39;&gt;&#39;</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">delim</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

        <span class="n">root1</span> <span class="o">=</span> <span class="n">i</span> <span class="c"># The name does not include the delimiter.</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">delim</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">root2</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">if</span> <span class="n">delim</span> <span class="o">!=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">delim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">report_errors</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">scanError</span><span class="p">(</span><span class="s">&quot;bad filename in @root &quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_name</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">root1</span><span class="p">:</span><span class="n">root2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="c">#@+node:ekr.20031218072017.3596: *4* skip_section_name</span>
    <span class="c">#@+at</span>
    <span class="c"># This function skips past a section name that starts with &lt; &lt; and might</span>
    <span class="c"># end with &gt; &gt; or &gt; &gt; =. The entire section name must appear on the same</span>
    <span class="c"># line.</span>
    <span class="c"># </span>
    <span class="c"># Note: this code no longer supports extended noweb mode.</span>
    <span class="c"># </span>
    <span class="c"># Returns (i, kind, end),</span>
    <span class="c">#     end indicates the end of the section name itself (not counting the =).</span>
    <span class="c">#     kind is one of:</span>
    <span class="c">#         bad_section_name: &quot;no matching &quot;&gt;&gt;&quot; or &quot;&gt;&gt;&quot;  This is _not_ a user error!</span>
    <span class="c">#         section_ref: &lt; &lt; name &gt; &gt;</span>
    <span class="c">#         section_def: &lt; &lt; name &gt; &gt; =</span>
    <span class="c">#         at_root:     &lt; &lt; * &gt; &gt; =</span>
    <span class="c">#@@c</span></div>
<div class="viewcode-block" id="baseTangleCommands.skip_section_name"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.skip_section_name">[docs]</a>    <span class="k">def</span> <span class="nf">skip_section_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="c"># Return this value if no section name found.</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">bad_section_name</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">empty_name</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Scan for the end of the section name.</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&gt;&gt;=&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">section_def</span> <span class="p">;</span> <span class="k">break</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&gt;&gt;&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">section_ref</span> <span class="p">;</span> <span class="k">break</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">is_ws_or_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">empty_name</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">:</span>
                <span class="n">empty_name</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># skip the &#39;*&#39;</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&gt;&gt;=&quot;</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">at_root</span> <span class="p">;</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">empty_name</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">empty_name</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">bad_section_name</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span>
    <span class="c">#@+node:ekr.20031218072017.3598: *4* standardize_name</span></div>
<div class="viewcode-block" id="baseTangleCommands.standardize_name"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.standardize_name">[docs]</a>    <span class="k">def</span> <span class="nf">standardize_name</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Removes leading and trailing brackets, converts white space to a single blank and converts to lower case.&quot;&quot;&quot;</span>

        <span class="c"># Convert to lowercase.</span>
        <span class="c"># Convert whitespace to a single space.</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="p">,</span><span class="s">&#39; &#39;</span><span class="p">)</span>

        <span class="c"># Remove leading &#39;&lt;&#39;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c"># Find the first &#39;&gt;&#39;</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">name</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;&gt;&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">name</span>
    <span class="c">#@+node:ekr.20080923124254.16: *4* tangle.scanAllDirectives</span></div>
<div class="viewcode-block" id="baseTangleCommands.scanAllDirectives"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.scanAllDirectives">[docs]</a>    <span class="k">def</span> <span class="nf">scanAllDirectives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Scan vnode p and p&#39;s ancestors looking for directives,</span>
<span class="sd">        setting corresponding tangle ivars and globals.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_directive_ivars</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">b</span>
            <span class="c">#@+&lt;&lt; Collect @first attributes &gt;&gt;</span>
            <span class="c">#@+node:ekr.20080923124254.17: *5* &lt;&lt; Collect @first attributes &gt;&gt;</span>
            <span class="c">#@+at</span>
            <span class="c"># Stephen P. Schaefer 9/13/2002: Add support for @first. Unlike other</span>
            <span class="c"># root attributes, does *NOT* inherit from parent nodes.</span>
            <span class="c">#@@c</span>

            <span class="n">tag</span> <span class="o">=</span> <span class="s">&quot;@first&quot;</span>
            <span class="n">sizeString</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c"># DTHEIN 13-OCT-2002: use to detect end-of-string</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># DTHEIN 13-OCT-2002: directives must start at beginning of a line</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">tag</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_ws</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_to_end_of_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">first_lines</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">skip_nl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">sizeString</span><span class="p">:</span>  <span class="c"># DTHEIN 13-OCT-2002: get out when end of string reached</span>
                    <span class="k">break</span>
            <span class="c">#@-&lt;&lt; Collect @first attributes &gt;&gt;</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="s">&#39;encoding&#39;</span><span class="p">,</span>    <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>  <span class="n">g</span><span class="o">.</span><span class="n">scanAtEncodingDirectives</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;lineending&#39;</span><span class="p">,</span>  <span class="bp">None</span><span class="p">,</span>           <span class="n">g</span><span class="o">.</span><span class="n">scanAtLineendingDirectives</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;pagewidth&#39;</span><span class="p">,</span>   <span class="n">c</span><span class="o">.</span><span class="n">page_width</span><span class="p">,</span>   <span class="n">g</span><span class="o">.</span><span class="n">scanAtPagewidthDirectives</span><span class="p">),</span>
            <span class="p">(</span><span class="s">&#39;path&#39;</span><span class="p">,</span>        <span class="bp">None</span><span class="p">,</span>           <span class="n">c</span><span class="o">.</span><span class="n">scanAtPathDirectives</span><span class="p">),</span> 
            <span class="p">(</span><span class="s">&#39;tabwidth&#39;</span><span class="p">,</span>    <span class="n">c</span><span class="o">.</span><span class="n">tab_width</span><span class="p">,</span>    <span class="n">g</span><span class="o">.</span><span class="n">scanAtTabwidthDirectives</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c"># Set d by scanning all directives.</span>
        <span class="n">aList</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_directives_dict_list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">default</span><span class="p">,</span><span class="n">func</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">aList</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">,</span><span class="n">default</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>

        <span class="n">lang_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;language&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">,</span><span class="s">&#39;delims&#39;</span><span class="p">:</span><span class="bp">None</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_language_comment_settings</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">lang_dict</span><span class="p">)</span>

        <span class="c"># Post process.</span>
        <span class="n">lineending</span>      <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;lineending&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lineending</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_newline</span> <span class="o">=</span> <span class="n">lineending</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span>             <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;encoding&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span>             <span class="o">=</span> <span class="n">lang_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;language&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_delims</span>          <span class="o">=</span> <span class="n">lang_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;delims&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span>           <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;pagewidth&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span>     <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;path&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span>            <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;tabwidth&#39;</span><span class="p">)</span>

        <span class="c"># Handle the print-mode directives.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aList</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">,</span><span class="s">&#39;terse&#39;</span><span class="p">,</span><span class="s">&#39;quiet&#39;</span><span class="p">,</span><span class="s">&#39;silent&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="n">key</span> <span class="p">;</span> <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_mode</span> <span class="o">=</span> <span class="s">&#39;verbose&#39;</span>

        <span class="c"># g.trace(self.tangle_directory)</span>

        <span class="c"># For unit testing.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s">&quot;encoding&quot;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">,</span>
            <span class="s">&quot;language&quot;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span>
            <span class="s">&quot;lineending&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_newline</span><span class="p">,</span>
            <span class="s">&quot;pagewidth&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">page_width</span><span class="p">,</span>
            <span class="s">&quot;path&quot;</span>      <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tangle_directory</span><span class="p">,</span>
            <span class="s">&quot;tabwidth&quot;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tab_width</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="c">#@+node:ekr.20031218072017.3599: *4* token_type</span></div>
<div class="viewcode-block" id="baseTangleCommands.token_type"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.baseTangleCommands.token_type">[docs]</a>    <span class="k">def</span> <span class="nf">token_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">report_errors</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;This method returns a code indicating the apparent kind of token at the position i.</span>

<span class="sd">        The caller must determine whether section definiton tokens are valid.</span>

<span class="sd">        returns (kind, end) and sets global root_name using setRootFromText().</span>
<span class="sd">        end is only valid for kind in (section_ref, section_def, at_root).&quot;&quot;&quot;</span>

        <span class="n">kind</span> <span class="o">=</span> <span class="n">plain_line</span> <span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c">#@+&lt;&lt; set token_type in noweb mode &gt;&gt;</span>
        <span class="c">#@+node:ekr.20031218072017.3600: *5* &lt;&lt; set token_type in noweb mode &gt;&gt;</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;&lt;&lt;&quot;</span><span class="p">):</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_section_name</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">bad_section_name</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">plain_line</span> <span class="c"># not an error.</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_root</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span> <span class="o">==</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromText</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_root</span><span class="p">,</span><span class="n">report_errors</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kind</span> <span class="o">=</span> <span class="n">bad_section_name</span> <span class="c"># The warning has been given.</span>
        <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@ &quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
            <span class="c"># 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_cweb_flag</span><span class="p">,</span><span class="n">plain_line</span><span class="p">,</span><span class="n">at_doc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@@&quot;</span><span class="p">):</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">at_at</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;@&#39;</span><span class="p">:</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">at_other</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">plain_line</span>
        <span class="c">#@-&lt;&lt; set token_type in noweb mode &gt;&gt;</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_other</span> <span class="p">:</span>
            <span class="c">#@+&lt;&lt; set kind for directive &gt;&gt;</span>
            <span class="c">#@+node:ekr.20031218072017.3602: *5* &lt;&lt; set kind for directive &gt;&gt;</span>
            <span class="c"># This code will return at_other for any directive other than those listed.</span>

            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="s">&quot;@c&quot;</span><span class="p">):</span>
                <span class="c"># 10/30/02: Only @code starts a code section in raw cweb mode.</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_cweb_flag</span><span class="p">,</span><span class="n">plain_line</span><span class="p">,</span><span class="n">at_code</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">theType</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s">&quot;@chapter&quot;</span><span class="p">,</span> <span class="n">at_chapter</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&quot;@code&quot;</span><span class="p">,</span> <span class="n">at_code</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&quot;@doc&quot;</span><span class="p">,</span> <span class="n">at_doc</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&quot;@root&quot;</span><span class="p">,</span> <span class="n">at_root</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&quot;@section&quot;</span><span class="p">,</span> <span class="n">at_section</span><span class="p">)</span> <span class="p">]:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">match_word</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
                        <span class="n">kind</span> <span class="o">=</span> <span class="n">theType</span> <span class="p">;</span> <span class="k">break</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_cweb_flag</span> <span class="ow">and</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_other</span><span class="p">:</span>
                <span class="c"># 10/30/02: Everything else is plain text in raw cweb mode.</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">plain_line</span>

            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">at_root</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setRootFromText</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span><span class="n">report_errors</span><span class="p">)</span>
            <span class="c">#@-&lt;&lt; set kind for directive &gt;&gt;</span>
        <span class="c"># g.trace(kind,g.get_line(s,i))</span>
        <span class="k">return</span> <span class="n">kind</span><span class="p">,</span> <span class="n">end</span>
    <span class="c">#@-others</span>
</div></div>
<div class="viewcode-block" id="tangleCommands"><a class="viewcode-back" href="../../../leo.core.html#leo.core.leoTangle.tangleCommands">[docs]</a><span class="k">class</span> <span class="nc">tangleCommands</span> <span class="p">(</span><span class="n">baseTangleCommands</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that implements Leo&#39; tangle and untangle commands.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
<span class="c">#@-others</span>
<span class="c">#@-leo</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Leo API 4.11dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ed K. Ream.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>