<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>leo.extensions.patch_11_01 &mdash; Leo API 4.11dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '4.11dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Leo API 4.11dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Leo API 4.11dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for leo.extensions.patch_11_01</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot; Patch utility to apply unified diffs</span>

<span class="sd">    Brute-force line-by-line non-recursive parsing </span>

<span class="sd">    Copyright (c) 2008-2011 anatoly techtonik</span>
<span class="sd">    Available under the terms of MIT license</span>

<span class="sd">    Project home: http://code.google.com/p/python-patch/</span>


<span class="sd">    $Id: patch.py 117 2011-01-09 16:38:03Z techtonik $</span>
<span class="sd">    $HeadURL: https://python-patch.googlecode.com/svn/trunk/patch.py $</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;techtonik.rainforce.org&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;11.01&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="c"># cStringIO doesn&#39;t support unicode in 2.5</span>
<span class="kn">from</span> <span class="nn">StringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">urllib2</span>

<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">exists</span><span class="p">,</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">abspath</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">unlink</span>


<span class="c">#------------------------------------------------</span>
<span class="c"># Logging is controlled by &quot;python_patch&quot; logger</span>

<span class="n">debugmode</span> <span class="o">=</span> <span class="bp">False</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s">&quot;python_patch&quot;</span><span class="p">)</span>
<span class="n">loghandler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">loghandler</span><span class="p">)</span>

<span class="n">debug</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span>
<span class="n">info</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">info</span>
<span class="n">warning</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">warning</span>

<span class="c">#: disable library logging by default</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">)</span>

<span class="c">#------------------------------------------------</span>

<span class="c"># constants for patch types</span>

<span class="n">DIFF</span> <span class="o">=</span> <span class="n">PLAIN</span> <span class="o">=</span> <span class="s">&quot;plain&quot;</span>
<span class="n">HG</span> <span class="o">=</span> <span class="n">MERCURIAL</span> <span class="o">=</span> <span class="s">&quot;mercurial&quot;</span>
<span class="n">SVN</span> <span class="o">=</span> <span class="n">SUBVERSION</span> <span class="o">=</span> <span class="s">&quot;svn&quot;</span>


<div class="viewcode-block" id="fromfile"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.fromfile">[docs]</a><span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Parse patch file and return Patch() object</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">debug</span><span class="p">(</span><span class="s">&quot;reading </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span>
  <span class="n">patch</span> <span class="o">=</span> <span class="n">Patch</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
  <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">patch</span>

</div>
<div class="viewcode-block" id="fromstring"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.fromstring">[docs]</a><span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Parse text string and return Patch() object</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">Patch</span><span class="p">(</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="fromurl"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.fromurl">[docs]</a><span class="k">def</span> <span class="nf">fromurl</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Read patch from URL</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">Patch</span><span class="p">(</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="Hunk"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Hunk">[docs]</a><span class="k">class</span> <span class="nc">Hunk</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; Parsed hunk data container (hunk starts with @@ -R +R @@) &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">startsrc</span><span class="o">=</span><span class="bp">None</span> <span class="c">#: line count starts with 1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">linessrc</span><span class="o">=</span><span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">starttgt</span><span class="o">=</span><span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">linestgt</span><span class="o">=</span><span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">invalid</span><span class="o">=</span><span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">=</span><span class="p">[]</span>

<div class="viewcode-block" id="Hunk.copy"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Hunk.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c">#  def apply(self, estream):</span>
<span class="c">#    &quot;&quot;&quot; write hunk data into enumerable stream</span>
<span class="c">#        return strings one by one until hunk is</span>
<span class="c">#        over</span>
<span class="c">#</span>
<span class="c">#        enumerable stream are tuples (lineno, line)</span>
<span class="c">#        where lineno starts with 0</span>
<span class="c">#    &quot;&quot;&quot;</span>
<span class="c">#    pass</span>


</div></div>
<div class="viewcode-block" id="Patch"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch">[docs]</a><span class="k">class</span> <span class="nc">Patch</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="c"># define Patch data members</span>
    <span class="c"># table with a row for every source file</span>

    <span class="c">#: list of source filenames</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">=</span><span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">=</span><span class="bp">None</span>
    <span class="c">#: list of lists of hunks</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="o">=</span><span class="bp">None</span>
    <span class="c">#: file endings statistics for every hunk</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="o">=</span><span class="bp">None</span>
    <span class="c">#: headers for each file</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span>

    <span class="c">#: patch type - one of constants</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">stream</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

<div class="viewcode-block" id="Patch.copy"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.copy">[docs]</a>  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Patch.parse"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.parse">[docs]</a>  <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; parse unified diff &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">lineends</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lf</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">crlf</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">nextfileno</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nexthunkno</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c">#: even if index starts with 0 user messages number hunks from 1</span>

    <span class="c"># hunkinfo variable holds parsed values, hunkactual - calculated</span>
    <span class="n">hunkinfo</span> <span class="o">=</span> <span class="n">Hunk</span><span class="p">()</span>
    <span class="n">hunkactual</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linessrc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linestgt</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>


    <span class="k">class</span> <span class="nc">wrapumerate</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;Enumerate wrapper that uses boolean end of stream status instead of</span>
<span class="sd">      StopIteration exception, and properties to access line information.</span>
<span class="sd">      &quot;&quot;&quot;</span>

      <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># we don&#39;t call parent, it is magically created by __new__ method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lineno</span> <span class="o">=</span> <span class="bp">False</span>     <span class="c"># after end of stream equal to the num of lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="bp">False</span>       <span class="c"># will be reset to False after end of stream</span>

      <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to read the next line and return True if it is available,</span>
<span class="sd">           False if end of stream is reached.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">False</span>

        <span class="k">try</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_lineno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">wrapumerate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span> <span class="o">=</span> <span class="bp">True</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

      <span class="nd">@property</span>
      <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exhausted</span>

      <span class="nd">@property</span>
      <span class="k">def</span> <span class="nf">line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line</span>

      <span class="nd">@property</span>
      <span class="k">def</span> <span class="nf">lineno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lineno</span>

    <span class="c"># define states (possible file regions) that direct parse flow</span>
    <span class="n">headscan</span>  <span class="o">=</span> <span class="bp">True</span>  <span class="c"># start with scanning header</span>
    <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># lines starting with --- and +++</span>

    <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># @@ -R +R @@ sequence</span>
    <span class="n">hunkbody</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c">#</span>
    <span class="n">hunkskip</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># skipping invalid hunk mode</span>

    <span class="n">hunkparsed</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># state after successfully parsed hunk</span>

    <span class="c"># regexp to match start of hunk, used groups - 1,3,4,6</span>
    <span class="n">re_hunk_start</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?&quot;</span><span class="p">)</span>
    

    <span class="c"># start of main cycle</span>
    <span class="c"># each parsing block already has line available in fe.line</span>
    <span class="n">fe</span> <span class="o">=</span> <span class="n">wrapumerate</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">fe</span><span class="o">.</span><span class="n">next</span><span class="p">():</span>

      <span class="c"># -- deciders: these only switch state to decide who should process</span>
      <span class="c"># --           line fetched at the start of this cycle</span>
      <span class="k">if</span> <span class="n">hunkparsed</span><span class="p">:</span>
        <span class="n">hunkparsed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">re_hunk_start</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fe</span><span class="o">.</span><span class="n">line</span><span class="p">):</span>
            <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">fe</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;--- &quot;</span><span class="p">):</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="c"># -- ------------------------------------</span>

      <span class="c"># read out header</span>
      <span class="k">if</span> <span class="n">headscan</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">fe</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fe</span><span class="o">.</span><span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;--- &quot;</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="n">fe</span><span class="o">.</span><span class="n">line</span>
            <span class="n">fe</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fe</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
              <span class="n">warning</span><span class="p">(</span><span class="s">&quot;warning: no patch data is found&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">info</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s"> unparsed bytes left at the end of stream&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
            <span class="c"># this is actually a loop exit</span>
            <span class="k">continue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

        <span class="n">headscan</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># switch to filenames state</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="bp">True</span>

      <span class="n">line</span> <span class="o">=</span> <span class="n">fe</span><span class="o">.</span><span class="n">line</span>
      <span class="n">lineno</span> <span class="o">=</span> <span class="n">fe</span><span class="o">.</span><span class="n">lineno</span>


      <span class="c"># hunkskip and hunkbody code skipped until definition of hunkhead is parsed</span>
      <span class="k">if</span> <span class="n">hunkbody</span><span class="p">:</span>
        <span class="c"># process line first</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r&quot;^[- \+</span><span class="se">\\</span><span class="s">]&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
            <span class="c"># gather stats about line endings</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">):</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;crlf&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;lf&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">):</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;cr&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
              
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">):</span>
              <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linessrc&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">):</span>
              <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linestgt&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span><span class="p">):</span>
              <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linessrc&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
              <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linestgt&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">hunkinfo</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="c"># todo: handle \ No newline cases</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;invalid hunk no.</span><span class="si">%d</span><span class="s"> at </span><span class="si">%d</span><span class="s"> for target file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nexthunkno</span><span class="p">,</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c"># add hunk status node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hunkinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">nexthunkno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;invalid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c"># switch to hunkskip state</span>
            <span class="n">hunkbody</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">hunkskip</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># check exit conditions</span>
        <span class="k">if</span> <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linessrc&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linessrc</span> <span class="ow">or</span> <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linestgt&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linestgt</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;extra lines for hunk no.</span><span class="si">%d</span><span class="s"> at </span><span class="si">%d</span><span class="s"> for target </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nexthunkno</span><span class="p">,</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c"># add hunk status node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hunkinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">nexthunkno</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;invalid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c"># switch to hunkskip state</span>
            <span class="n">hunkbody</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">hunkskip</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linessrc</span> <span class="o">==</span> <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linessrc&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linestgt</span> <span class="o">==</span> <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linestgt&quot;</span><span class="p">]:</span>
            <span class="c"># hunk parsed successfully</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hunkinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="c"># switch to hunkparsed state</span>
            <span class="n">hunkbody</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">hunkparsed</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c"># detect mixed window/unix line ends</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">ends</span><span class="p">[</span><span class="s">&quot;cr&quot;</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="s">&quot;crlf&quot;</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ends</span><span class="p">[</span><span class="s">&quot;lf&quot;</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
              <span class="n">warning</span><span class="p">(</span><span class="s">&quot;inconsistent line ends in patch hunks for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">debugmode</span><span class="p">:</span>
              <span class="n">debuglines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ends</span><span class="p">)</span>
              <span class="n">debuglines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hunk</span><span class="o">=</span><span class="n">nexthunkno</span><span class="p">)</span>
              <span class="n">debug</span><span class="p">(</span><span class="s">&quot;crlf: </span><span class="si">%(crlf)d</span><span class="s">  lf: </span><span class="si">%(lf)d</span><span class="s">  cr: </span><span class="si">%(cr)d</span><span class="se">\t</span><span class="s"> - file: </span><span class="si">%(file)s</span><span class="s"> hunk: </span><span class="si">%(hunk)d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">debuglines</span><span class="p">)</span>
            <span class="c"># fetch next line</span>
            <span class="k">continue</span>

      <span class="k">if</span> <span class="n">hunkskip</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re_hunk_start</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
          <span class="c"># switch to hunkhead state</span>
          <span class="n">hunkskip</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;--- &quot;</span><span class="p">):</span>
          <span class="c"># switch to filenames state</span>
          <span class="n">hunkskip</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="n">filenames</span> <span class="o">=</span> <span class="bp">True</span>
          <span class="k">if</span> <span class="n">debugmode</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&quot;- </span><span class="si">%2d</span><span class="s"> hunks for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

      <span class="k">if</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;--- &quot;</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">nextfileno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid patch for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">]</span>
            <span class="c"># double source filename line is encountered</span>
            <span class="c"># attempt to restart from this second line</span>
          <span class="n">re_filename</span> <span class="o">=</span> <span class="s">&quot;^--- ([^</span><span class="se">\t</span><span class="s">]+)&quot;</span>
          <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re_filename</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
          <span class="c"># todo: support spaces in filenames</span>
          <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid filename at line </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">lineno</span><span class="p">)</span>
            <span class="c"># switch back to headscan state</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;+++ &quot;</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">nextfileno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid patch with no target for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c"># this should be unreachable</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid target patch&quot;</span><span class="p">)</span>
          <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">nextfileno</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid patch - double target at line </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">lineno</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">nextfileno</span><span class="p">]</span>
            <span class="n">nextfileno</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c"># double target filename line is encountered</span>
            <span class="c"># switch back to headscan state</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">re_filename</span> <span class="o">=</span> <span class="s">&quot;^\+\+\+ ([^</span><span class="se">\t</span><span class="s">]+)&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">re_filename</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
              <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid patch - no target filename at line </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">lineno</span><span class="p">)</span>
              <span class="c"># switch back to headscan state</span>
              <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span>
              <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
              <span class="n">nextfileno</span> <span class="o">+=</span> <span class="mi">1</span>
              <span class="c"># switch to hunkhead state</span>
              <span class="n">filenames</span> <span class="o">=</span> <span class="bp">False</span>
              <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">True</span>
              <span class="n">nexthunkno</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">hunkends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lineends</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
              <span class="k">continue</span>

      <span class="k">if</span> <span class="n">hunkhead</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">:</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;skipping invalid patch with no hunks for file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c"># switch to headscan state</span>
            <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">continue</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c"># switch to headscan state</span>
            <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">headscan</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">startsrc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linessrc</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linessrc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">starttgt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linestgt</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span> <span class="n">hunkinfo</span><span class="o">.</span><span class="n">linestgt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">invalid</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="n">hunkinfo</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[]</span>

          <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linessrc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hunkactual</span><span class="p">[</span><span class="s">&quot;linestgt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

          <span class="c"># switch to hunkbody state</span>
          <span class="n">hunkhead</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="n">hunkbody</span> <span class="o">=</span> <span class="bp">True</span>
          <span class="n">nexthunkno</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">continue</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">hunkparsed</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">hunkskip</span><span class="p">:</span>
        <span class="n">warning</span><span class="p">(</span><span class="s">&quot;warning: finished with warnings, some hunks may be invalid&quot;</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">headscan</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;error: no patch data found!&quot;</span><span class="p">)</span>
          <span class="c"># ? sys.exit(-1)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># extra data at the end of file</span>
          <span class="k">pass</span> 
      <span class="k">else</span><span class="p">:</span>
        <span class="n">warning</span><span class="p">(</span><span class="s">&quot;error: patch stream is incomplete!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debugmode</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">debug</span><span class="p">(</span><span class="s">&quot;- </span><span class="si">%2d</span><span class="s"> hunks for </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">nextfileno</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">debug</span><span class="p">(</span><span class="s">&quot;total files: </span><span class="si">%d</span><span class="s">  total hunks: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hset</span><span class="p">)</span> <span class="k">for</span> <span class="n">hset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">)))</span>

</div>
<div class="viewcode-block" id="Patch.apply"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.apply">[docs]</a>  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; apply parsed patch</span>
<span class="sd">        return True on success</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">fileno</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>

      <span class="n">f2patch</span> <span class="o">=</span> <span class="n">filename</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">f2patch</span><span class="p">):</span>
        <span class="n">f2patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">fileno</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">f2patch</span><span class="p">):</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;source/target file does not exist</span><span class="se">\n</span><span class="s">--- </span><span class="si">%s</span><span class="se">\n</span><span class="s">+++ </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">f2patch</span><span class="p">))</span>
          <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">continue</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="n">f2patch</span><span class="p">):</span>
        <span class="n">warning</span><span class="p">(</span><span class="s">&quot;not a file - </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">f2patch</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">continue</span>
      <span class="n">filename</span> <span class="o">=</span> <span class="n">f2patch</span>

      <span class="n">debug</span><span class="p">(</span><span class="s">&quot;processing </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s">:</span><span class="se">\t</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fileno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>

      <span class="c"># validate before patching</span>
      <span class="n">f2fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="n">hunkno</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">hunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">][</span><span class="n">hunkno</span><span class="p">]</span>
      <span class="n">hunkfind</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">hunkreplace</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="n">validhunks</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">canpatch</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f2fp</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hunk</span><span class="o">.</span><span class="n">startsrc</span><span class="p">:</span>
          <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">hunk</span><span class="o">.</span><span class="n">startsrc</span><span class="p">:</span>
          <span class="n">hunkfind</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hunk</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s">&quot; -&quot;</span><span class="p">]</span>
          <span class="n">hunkreplace</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">hunk</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s">&quot; +&quot;</span><span class="p">]</span>
          <span class="c">#pprint(hunkreplace)</span>
          <span class="n">hunklineno</span> <span class="o">=</span> <span class="mi">0</span>

          <span class="c"># todo \ No newline at end of file</span>

        <span class="c"># check hunks in source file</span>
        <span class="k">if</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hunk</span><span class="o">.</span><span class="n">startsrc</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">hunkfind</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">hunkfind</span><span class="p">[</span><span class="n">hunklineno</span><span class="p">]:</span>
            <span class="n">hunklineno</span><span class="o">+=</span><span class="mi">1</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="s">&quot;file </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s">:</span><span class="se">\t</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fileno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">info</span><span class="p">(</span><span class="s">&quot; hunk no.</span><span class="si">%d</span><span class="s"> doesn&#39;t match source file at line </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hunkno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lineno</span><span class="p">))</span>
            <span class="n">info</span><span class="p">(</span><span class="s">&quot;  expected: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">hunkfind</span><span class="p">[</span><span class="n">hunklineno</span><span class="p">])</span>
            <span class="n">info</span><span class="p">(</span><span class="s">&quot;  actual  : </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">))</span>
            <span class="c"># not counting this as error, because file may already be patched.</span>
            <span class="c"># check if file is already patched is done after the number of</span>
            <span class="c"># invalid hunks if found</span>
            <span class="c"># TODO: check hunks against source/target file in one pass</span>
            <span class="c">#   API - check(stream, srchunks, tgthunks)</span>
            <span class="c">#           return tuple (srcerrs, tgterrs)</span>

            <span class="c"># continue to check other hunks for completeness</span>
            <span class="n">hunkno</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">hunkno</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
              <span class="n">hunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">][</span><span class="n">hunkno</span><span class="p">]</span>
              <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="k">break</span>

        <span class="c"># check if processed line is the last line</span>
        <span class="k">if</span> <span class="n">lineno</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">hunk</span><span class="o">.</span><span class="n">startsrc</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">hunkfind</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">debug</span><span class="p">(</span><span class="s">&quot; hunk no.</span><span class="si">%d</span><span class="s"> for file </span><span class="si">%s</span><span class="s">  -- is ready to be patched&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hunkno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
          <span class="n">hunkno</span><span class="o">+=</span><span class="mi">1</span>
          <span class="n">validhunks</span><span class="o">+=</span><span class="mi">1</span>
          <span class="k">if</span> <span class="n">hunkno</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
            <span class="n">hunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">][</span><span class="n">hunkno</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">validhunks</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
              <span class="c"># patch file</span>
              <span class="n">canpatch</span> <span class="o">=</span> <span class="bp">True</span>
              <span class="k">break</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hunkno</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;premature end of source file </span><span class="si">%s</span><span class="s"> at hunk </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">hunkno</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
          <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="n">f2fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

      <span class="k">if</span> <span class="n">validhunks</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_file_hunks</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;already patched  </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;source file is different - </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
          <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">canpatch</span><span class="p">:</span>
        <span class="n">backupname</span> <span class="o">=</span> <span class="n">filename</span><span class="o">+</span><span class="s">&quot;.orig&quot;</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">backupname</span><span class="p">):</span>
          <span class="n">warning</span><span class="p">(</span><span class="s">&quot;can&#39;t backup original file to </span><span class="si">%s</span><span class="s"> - aborting&quot;</span> <span class="o">%</span> <span class="n">backupname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="kn">import</span> <span class="nn">shutil</span>
          <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">backupname</span><span class="p">)</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_hunks</span><span class="p">(</span><span class="n">backupname</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">fileno</span><span class="p">]):</span>
            <span class="n">info</span><span class="p">(</span><span class="s">&quot;successfully patched </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s">:</span><span class="se">\t</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fileno</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">unlink</span><span class="p">(</span><span class="n">backupname</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">errors</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;error patching file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filename</span><span class="o">+</span><span class="s">&quot;.invalid&quot;</span><span class="p">)</span>
            <span class="n">warning</span><span class="p">(</span><span class="s">&quot;invalid version is saved to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="o">+</span><span class="s">&quot;.invalid&quot;</span><span class="p">)</span>
            <span class="c"># todo: proper rejects</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">backupname</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="c"># todo: check for premature eof</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">errors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Patch.can_patch"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.can_patch">[docs]</a>  <span class="k">def</span> <span class="nf">can_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if specified filename can be patched. Returns None if file can</span>
<span class="sd">    not be found among source filenames. False if patch can not be applied</span>
<span class="sd">    clearly. True otherwise.</span>

<span class="sd">    :returns: True, False or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_file_idx</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_file_hunks</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hunks</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    
</div>
  <span class="k">def</span> <span class="nf">_match_file_hunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">hunks</span><span class="p">):</span>
    <span class="n">matched</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">))</span>

    <span class="k">class</span> <span class="nc">NoMatch</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
      <span class="k">pass</span>

    <span class="n">lineno</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">hno</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">hno</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hunks</span><span class="p">):</span>
        <span class="c"># skip to first line of the hunk</span>
        <span class="k">while</span> <span class="n">lineno</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">.</span><span class="n">starttgt</span><span class="p">:</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span> <span class="c"># eof</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&quot;check failed - premature eof before hunk: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hno</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">NoMatch</span>
          <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
          <span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">hline</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">hline</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">):</span>
            <span class="k">continue</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&quot;check failed - premature eof on hunk: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hno</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="c"># todo: \ No newline at the end of file</span>
            <span class="k">raise</span> <span class="n">NoMatch</span>
          <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hline</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">):</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&quot;file is not patched - failed hunk: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hno</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">NoMatch</span>
          <span class="n">line</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
          <span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">except</span> <span class="n">NoMatch</span><span class="p">:</span>
      <span class="n">matched</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="c"># todo: display failed hunk, i.e. expected/found</span>

    <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">matched</span>


<div class="viewcode-block" id="Patch.patch_stream"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.patch_stream">[docs]</a>  <span class="k">def</span> <span class="nf">patch_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instream</span><span class="p">,</span> <span class="n">hunks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generator that yields stream patched with hunks iterable</span>
<span class="sd">    </span>
<span class="sd">        Converts lineends in hunk lines to the best suitable format</span>
<span class="sd">        autodetected from input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># todo: At the moment substituted lineends may not be the same</span>
    <span class="c">#       at the start and at the end of patching. Also issue a</span>
    <span class="c">#       warning/throw about mixed lineends (is it really needed?)</span>

    <span class="n">hunks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">hunks</span><span class="p">)</span>

    <span class="n">srclineno</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">lineends</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">get_line</span><span class="p">():</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      local utility function - return line from source stream</span>
<span class="sd">      collecting line end statistics on the way</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">instream</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c"># &#39;U&#39; mode works only with text files</span>
      <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="n">lineends</span><span class="p">[</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="n">lineends</span><span class="p">[</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="n">lineends</span><span class="p">[</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">line</span>

    <span class="k">for</span> <span class="n">hno</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hunks</span><span class="p">):</span>
      <span class="n">debug</span><span class="p">(</span><span class="s">&quot;hunk </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">hno</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
      <span class="c"># skip to line just before hunk starts</span>
      <span class="k">while</span> <span class="n">srclineno</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">.</span><span class="n">startsrc</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">get_line</span><span class="p">()</span>
        <span class="n">srclineno</span> <span class="o">+=</span> <span class="mi">1</span>

      <span class="k">for</span> <span class="n">hline</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
        <span class="c"># todo: check \ No newline at the end of file</span>
        <span class="k">if</span> <span class="n">hline</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">hline</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span><span class="p">):</span>
          <span class="n">get_line</span><span class="p">()</span>
          <span class="n">srclineno</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">hline</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">):</span>
            <span class="n">get_line</span><span class="p">()</span>
            <span class="n">srclineno</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="n">line2write</span> <span class="o">=</span> <span class="n">hline</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
          <span class="c"># detect if line ends are consistent in source file</span>
          <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">bool</span><span class="p">(</span><span class="n">lineends</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lineends</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newline</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lineends</span> <span class="k">if</span> <span class="n">lineends</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">line2write</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span><span class="o">+</span><span class="n">newline</span>
          <span class="k">else</span><span class="p">:</span> <span class="c"># newlines are mixed</span>
            <span class="k">yield</span> <span class="n">line2write</span>
     
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">instream</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">line</span>

</div>
<div class="viewcode-block" id="Patch.write_hunks"><a class="viewcode-back" href="../../../leo.extensions.html#leo.extensions.patch_11_01.Patch.write_hunks">[docs]</a>  <span class="k">def</span> <span class="nf">write_hunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srcname</span><span class="p">,</span> <span class="n">tgtname</span><span class="p">,</span> <span class="n">hunks</span><span class="p">):</span>
    <span class="n">src</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">srcname</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">tgt</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">tgtname</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">)</span>

    <span class="n">debug</span><span class="p">(</span><span class="s">&quot;processing target file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">tgtname</span><span class="p">)</span>

    <span class="n">tgt</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch_stream</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hunks</span><span class="p">))</span>

    <span class="n">tgt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">src</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span>
  
</div>
  <span class="k">def</span> <span class="nf">_get_file_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Detect index of given filename within patch.</span>

<span class="sd">        :param filename:</span>
<span class="sd">        :param source: search filename among sources (True),</span>
<span class="sd">                       targets (False), or both (None)</span>
<span class="sd">        :returns: int or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">fnm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="n">abspath</span><span class="p">(</span><span class="n">fnm</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">i</span>  
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="bp">False</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">fnm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="n">abspath</span><span class="p">(</span><span class="n">fnm</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">i</span>  



</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">optparse</span> <span class="kn">import</span> <span class="n">OptionParser</span>
  <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">exists</span>
  <span class="kn">import</span> <span class="nn">sys</span>

  <span class="n">opt</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">(</span><span class="n">usage</span><span class="o">=</span><span class="s">&quot;1. %prog [options] unipatch-file</span><span class="se">\n</span><span class="s">&quot;</span>
                    <span class="s">&quot;       2. %prog [options] http://host/patch&quot;</span><span class="p">,</span>
                     <span class="n">version</span><span class="o">=</span><span class="s">&quot;python-patch </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">__version__</span><span class="p">)</span>
  <span class="n">opt</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&quot;-q&quot;</span><span class="p">,</span> <span class="s">&quot;--quiet&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_const&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&quot;verbosity&quot;</span><span class="p">,</span>
                                  <span class="n">const</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;print only warnings and errors&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">opt</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&quot;-v&quot;</span><span class="p">,</span> <span class="s">&quot;--verbose&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_const&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&quot;verbosity&quot;</span><span class="p">,</span>
                                  <span class="n">const</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;be verbose&quot;</span><span class="p">)</span>
  <span class="n">opt</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&quot;--debug&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&quot;debugmode&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&quot;debug mode&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
    <span class="n">opt</span><span class="o">.</span><span class="n">print_version</span><span class="p">()</span>
    <span class="n">opt</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
  <span class="n">debugmode</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">debugmode</span>

  <span class="n">verbosity_levels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">}</span>
  <span class="n">loglevel</span> <span class="o">=</span> <span class="n">verbosity_levels</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">verbosity</span><span class="p">]</span>
  <span class="n">logformat</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%(message)s</span><span class="s">&quot;</span>
  <span class="k">if</span> <span class="n">debugmode</span><span class="p">:</span>
    <span class="n">loglevel</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span>
    <span class="n">logformat</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%(levelname)8s</span><span class="s"> </span><span class="si">%(message)s</span><span class="s">&quot;</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">loglevel</span><span class="p">)</span>
  <span class="n">loghandler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="n">logformat</span><span class="p">))</span>


  <span class="n">patchfile</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">urltest</span> <span class="o">=</span> <span class="n">patchfile</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="p">(</span><span class="s">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">patchfile</span> <span class="ow">and</span> <span class="n">urltest</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
      <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">urltest</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span> <span class="c"># one char before : is a windows drive letter</span>
    <span class="n">patch</span> <span class="o">=</span> <span class="n">fromurl</span><span class="p">(</span><span class="n">patchfile</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">patchfile</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="n">patchfile</span><span class="p">):</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s">&quot;patch file does not exist - </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">patchfile</span><span class="p">)</span>
    <span class="n">patch</span> <span class="o">=</span> <span class="n">fromfile</span><span class="p">(</span><span class="n">patchfile</span><span class="p">)</span>

  <span class="c">#pprint(patch)</span>
  <span class="n">patch</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="c"># todo: document and test line ends handling logic - patch.py detects proper line-endings</span>
  <span class="c">#       for inserted hunks and issues a warning if patched file has incosistent line ends</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">Leo API 4.11dev documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ed K. Ream.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>